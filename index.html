<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 36px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            border-bottom: 1px solid #333;
        }

        #score {
            color: #ffd700;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }

        #score .catches { color: #8cf; }
        #score .touchdowns { color: #4f4; }
        #score .label { color: #888; }

        #downDistance {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40, 40, 40, 0.9);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        #downDistance .down { color: #ffa; }
        #downDistance .distance { color: #aef; }

        #debugInfo {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: left;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
            white-space: pre-wrap;
        }
        #catchDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #catchDisplay.visible {
            opacity: 1;
        }
        #catchDisplay .catch-header {
            font-size: 11px;
            font-weight: bold;
        }
        #catchDisplay .catch-header.success { color: #4f4; }
        #catchDisplay .catch-header.fail { color: #f66; }
        #catchDisplay .catch-bar {
            position: relative;
            width: 100px;
            height: 14px;
            background: #222;
            border-radius: 2px;
            overflow: visible;
        }
        #catchDisplay .catch-bar-base {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #3a3, #4b4);
            border-radius: 2px;
        }
        #catchDisplay .catch-bar-penalty {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
            border-left: 1px solid #f55;
        }
        #catchDisplay .catch-bar-roll {
            position: absolute;
            top: -1px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            transform: translateX(-50%);
            line-height: 14px;
        }
        #catchDisplay .catch-bar-roll.success { color: #4f4; }
        #catchDisplay .catch-bar-roll.fail { color: #f44; }
        #catchDisplay .defender-info {
            font-size: 10px;
            color: #f99;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="topBar">
        <div id="downDistance">
            <span class="down">1st</span> & <span class="distance">10</span>
        </div>
        <div id="score">
            <span><span class="label">Catches</span> <span class="catches">0/0</span></span>
            <span><span class="label">TD</span> <span class="touchdowns">0</span></span>
        </div>
        <div id="catchDisplay">
            <div class="catch-header">CATCH</div>
            <div class="catch-bar">
                <div class="catch-bar-base"></div>
                <div class="catch-bar-penalty"></div>
                <div class="catch-bar-roll">âœ“</div>
            </div>
            <div class="defender-info"></div>
        </div>
    </div>
    <div id="debugInfo"></div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        // Game State
        const gameState = {
            catches: 0,
            attempts: 0,            // Total catch attempts
            touchdowns: 0,          // Touchdowns scored
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            offensiveLine: [],      // O-line players
            defensiveLine: [],      // D-line players
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0,  // Seconds between time-based clashes
            playStartTime: 0,  // When current play started (for label fading)
            ballCarrier: null,      // Receiver carrying the ball after catch
            playEnded: false,       // Track if play has ended (tackle/sack/TD)
            qbSacked: false,        // Track if QB was sacked
            qbStartZ: -6,           // QB's randomized starting position (set each play)
            // Down and distance tracking
            down: 1,                // Current down (1-4)
            yardsToGo: 10,          // Yards needed for first down
            lineOfScrimmage: -4,    // Current field position (Z coordinate)
            firstDownMarker: 6,     // Z position where first down is achieved
            startingLineOfScrimmage: -4  // Where drive started (for reset on turnover)
        };

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 2.5,           // Distance for clash detection
            SEPARATION_THRESHOLD: 3,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 3,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
        };

        // Line clash system constants
        const LINE_CLASH_CONSTANTS = {
            CLASH_RANGE: 1.5,           // Distance for line clash detection
            CLASH_INTERVAL: 0.5,        // Seconds between clash resolutions while engaged
            NEUTRAL_SPEED: 0.05,        // Near-zero speed on neutral clash
            OFFENSE_WIN_THRESHOLD: 5,   // Margin needed for O-line to win decisively
            DEFENSE_WIN_THRESHOLD: 5,   // Margin needed for D-line to win decisively
            KNOCKDOWN_DURATION: 1.0,    // Seconds knocked down
            SPEED_BURST_MULTIPLIER: 1.5,// Speed boost after D-line wins
            SPEED_BURST_DURATION: 1.5,  // Duration of speed burst
            TACKLE_RANGE: 1.2,          // Distance for QB sack
        };

        // Receiver tackling constants
        const TACKLE_CONSTANTS = {
            TACKLE_RANGE: 1.0,          // Distance for tackle attempt
            TACKLE_INTERVAL: 0.3,       // Seconds between tackle attempts
            STUMBLE_DURATION: 0.5,      // How long defender stumbles after failed tackle
            BREAK_TACKLE_BOOST: 1.3,    // Speed boost after breaking tackle
            BREAK_TACKLE_DURATION: 0.8, // Duration of break tackle speed boost
        };

        // QB pocket constants
        const POCKET_CONSTANTS = {
            POCKET_CENTER_Z: -7,        // Ideal pocket depth (3 yards behind LOS)
            POCKET_MIN_X: -3,           // Pocket left boundary
            POCKET_MAX_X: 3,            // Pocket right boundary
            POCKET_MAX_DEPTH: -10,      // Don't go deeper than this
            LINE_OF_SCRIMMAGE: -4,      // Can't cross this going forward
            THREAT_RADIUS: 4,           // Start evading when defender this close
            EVADE_SPEED: 0.06,          // Speed when evading
            SETTLE_SPEED: 0.03,         // Speed when settling into pocket
        };

        // Stat weights for clash resolution
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.20, acceleration: 0.15, release: 0.15 },
                defender: { speed: 0.20, agility: 0.20, manCoverage: 0.25, pursuit: 0.20, awareness: 0.15 }
            },
            physical: {
                attacker: { strength: 0.35, aggression: 0.25, hitPower: 0.25, balance: 0.15 },
                defender: { strength: 0.35, aggression: 0.25, tackling: 0.25, balance: 0.15 }
            },
            lineClash: {
                offense: { passBlock: 0.35, strength: 0.30, balance: 0.20, awareness: 0.15 },
                defense: { passRush: 0.35, strength: 0.30, acceleration: 0.20, speed: 0.15 }
            },
            tackle: {
                tackler: { tackling: 0.40, pursuit: 0.30, hitPower: 0.30 },
                ballCarrier: { agility: 0.35, speed: 0.30, balance: 0.35 }
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false,  // Show defender zone rings and fills
            showDebugInfo: false       // Show on-screen debug info for coverage/catch factors
        };

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 20;
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Enable camera rotation: right-click on desktop, two-finger on mobile
            camera.attachControl(canvas, true);
            camera.inputs.attached.pointers.buttons = [1, 2];  // Right and middle mouse buttons
            camera.inputs.attached.pointers.multiTouchPanAndZoom = true;  // Enable pinch zoom
            camera.panningSensibility = 0;  // Disable panning
            camera.lowerRadiusLimit = 15;   // Min zoom
            camera.upperRadiusLimit = 50;   // Max zoom
            camera.lowerBetaLimit = 0.3;    // Don't go below ground
            camera.upperBetaLimit = Math.PI / 2.2;  // Don't go too flat
            scene.activeCamera = camera;  // Store reference for later updates

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line
            const receiverConfigs = [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 80, acceleration: 72, agility: 85,
                        routeRunning: 88, release: 75, catching: 80,
                        jumping: 70, strength: 60, balance: 72,
                        aggression: 45, stamina: 80, focus: 88
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 80, acceleration: 92, agility: 78,
                        routeRunning: 65, release: 70, catching: 80,
                        jumping: 75, strength: 50, balance: 60,
                        aggression: 40, stamina: 85, focus: 68
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 80, acceleration: 78, agility: 80,
                        routeRunning: 82, release: 78, catching: 80,
                        jumping: 82, strength: 72, balance: 78,
                        aggression: 55, stamina: 82, focus: 80
                    }
                }
            ];

            // Defender configurations
            const defenderConfigs = [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 70, agility: 75,
                        manCoverage: 80, zoneCoverage: 80, press: 78,
                        tackling: 80, hitPower: 85, pursuit: 75,
                        awareness: 72, strength: 82, balance: 78,
                        aggression: 75, stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 85, agility: 82,
                        manCoverage: 80, zoneCoverage: 80, press: 60,
                        tackling: 70, hitPower: 65, pursuit: 90,
                        awareness: 75, strength: 65, balance: 72,
                        aggression: 55, stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'man',
                    assignedReceiver: 2,  // Covers Baron Wyatt
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 68, agility: 70,
                        manCoverage: 80, zoneCoverage: 80, press: 72,
                        tackling: 85, hitPower: 90, pursuit: 72,
                        awareness: 85, strength: 88, balance: 82,
                        aggression: 70, stamina: 75
                    }
                },
                {
                    name: "The Sentinel",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 6,
                    cushion: 4,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 80, acceleration: 72, agility: 78,
                        manCoverage: 80, zoneCoverage: 80, press: 65,
                        tackling: 78, hitPower: 75, pursuit: 80,
                        awareness: 88, strength: 75, balance: 80,
                        aggression: 60, stamina: 82
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            // Store references for route regeneration
            gameState.scene = scene;
            gameState.routeMaterial = routeMat;

            receiverConfigs.forEach((config, i) => {
                // Clone material so each receiver can flash independently
                const receiverMat = materials.receiverMaterial.clone(`receiverMat_${i}`);
                const receiver = createKnight(scene, receiverMat, config.start.clone());
                receiver.name = `receiver_${i}`;
                receiver.bodyMaterial = receiverMat;
                receiver.originalColor = receiverMat.diffuseColor.clone();

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;

                // Derive base speed from stats (normalized to game units)
                receiver.baseSpeed = config.stats.speed * 0.0005;  // Scale stat to movement speed
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // Legacy - kept for compatibility
                receiver.clashSpeedPenaltyUntil = 0;  // Clash loser speed penalty timer
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);  // White
                fillMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                fillMat.alpha = 0.5;  // Base visibility
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);  // Start with base visible circle

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation
                receiver.clashTiltUntil = 0;  // For grappling tilt
                receiver.clashTiltAngle = 0;
                receiver.loserFlashUntil = 0;   // Red flash when losing clash
                receiver.winnerFlashUntil = 0;  // Green flash when winning clash
                receiver.clashSpeedBoostUntil = 0;  // Speed boost timer

                // Hide the outer ring - only show proximity-based fill
                zoneRing.setEnabled(false);

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                // Clone material so each defender can flash independently
                const defenderMat = materials.defenderMaterial.clone(`defenderMat_${i}`);
                const defender = createKnight(scene, defenderMat, startPos);
                defender.name = `defender_${i}`;
                defender.bodyMaterial = defenderMat;
                defender.originalColor = defenderMat.diffuseColor.clone();

                // Store config data on defender
                defender.displayName = config.name;
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.startPos = startPos.clone();

                // Derive base speed from stats
                defender.baseSpeed = config.stats.speed * 0.0005;
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact
                defender.clashSpeedPenaltyUntil = 0;  // Speed penalty from losing clash

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation
                defender.clashTiltUntil = 0;  // For grappling tilt
                defender.clashTiltAngle = 0;
                defender.loserFlashUntil = 0;   // Red flash when losing clash
                defender.winnerFlashUntil = 0;  // Green flash when winning clash

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });

            // Offensive Line configurations (5 players)
            const LINE_OF_SCRIMMAGE_Z = RECEIVER_START_Z;  // Same as receivers start
            const oLineConfigs = [
                {
                    name: "Sir Bulwark",
                    position: 'C',
                    startX: 0,
                    stats: { passBlock: 82, strength: 80, balance: 85, awareness: 80, speed: 60, acceleration: 65 }
                },
                {
                    name: "Ironside",
                    position: 'LG',
                    startX: -1.5,
                    stats: { passBlock: 80, strength: 85, balance: 78, awareness: 75, speed: 58, acceleration: 62 }
                },
                {
                    name: "Stonewall",
                    position: 'RG',
                    startX: 1.5,
                    stats: { passBlock: 78, strength: 88, balance: 80, awareness: 72, speed: 55, acceleration: 60 }
                },
                {
                    name: "Rampart",
                    position: 'LT',
                    startX: -3.5,
                    stats: { passBlock: 85, strength: 78, balance: 82, awareness: 78, speed: 62, acceleration: 68 }
                },
                {
                    name: "Bastion",
                    position: 'RT',
                    startX: 3.5,
                    stats: { passBlock: 83, strength: 80, balance: 80, awareness: 76, speed: 60, acceleration: 65 }
                }
            ];

            // Create Offensive Line
            oLineConfigs.forEach((config, i) => {
                const oLineMat = materials.oLineMaterial.clone(`oLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z - 0.5);
                const oLineman = createLineman(scene, oLineMat, startPos, true);
                oLineman.name = `oline_${i}`;
                oLineman.displayName = config.name;
                oLineman.position_label = config.position;
                oLineman.stats = config.stats;
                oLineman.startPos = startPos.clone();
                oLineman.baseSpeed = config.stats.speed * 0.0004;
                oLineman.speed = oLineman.baseSpeed;

                // Blocking state
                oLineman.engagedWith = null;         // D-lineman currently blocking
                oLineman.lastClashTime = 0;
                oLineman.knockdownUntil = 0;
                oLineman.bodyMaterial = oLineMat;
                oLineman.originalColor = oLineMat.diffuseColor.clone();

                gameState.offensiveLine.push(oLineman);
            });

            // Defensive Line configurations (4 players)
            const dLineConfigs = [
                {
                    name: "Siege Breaker",
                    position: 'LDE',
                    startX: -3,
                    stats: { passRush: 82, strength: 80, acceleration: 78, speed: 72, awareness: 75, tackling: 80 }
                },
                {
                    name: "Crusher",
                    position: 'LDT',
                    startX: -1,
                    stats: { passRush: 78, strength: 90, acceleration: 70, speed: 65, awareness: 72, tackling: 82 }
                },
                {
                    name: "Devastator",
                    position: 'RDT',
                    startX: 1,
                    stats: { passRush: 80, strength: 88, acceleration: 72, speed: 68, awareness: 74, tackling: 80 }
                },
                {
                    name: "Ramraid",
                    position: 'RDE',
                    startX: 3,
                    stats: { passRush: 85, strength: 78, acceleration: 82, speed: 75, awareness: 78, tackling: 78 }
                }
            ];

            // Create Defensive Line
            dLineConfigs.forEach((config, i) => {
                const dLineMat = materials.dLineMaterial.clone(`dLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z + 0.5);
                const dLineman = createLineman(scene, dLineMat, startPos, false);
                dLineman.name = `dline_${i}`;
                dLineman.displayName = config.name;
                dLineman.position_label = config.position;
                dLineman.stats = config.stats;
                dLineman.startPos = startPos.clone();
                dLineman.baseSpeed = config.stats.speed * 0.0005;
                dLineman.speed = dLineman.baseSpeed;

                // Pass rush state
                dLineman.engagedWith = null;         // O-lineman currently engaged with
                dLineman.lastClashTime = 0;
                dLineman.knockdownUntil = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial = dLineMat;
                dLineman.originalColor = dLineMat.diffuseColor.clone();

                gameState.defensiveLine.push(dLineman);
            });

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Add name labels to receivers
            gameState.receivers.forEach((receiver, i) => {
                const nameLabel = new BABYLON.GUI.TextBlock();
                nameLabel.text = receiver.displayName;
                nameLabel.color = '#88bbff';
                nameLabel.fontSize = 14;
                nameLabel.fontFamily = 'Courier New';
                nameLabel.outlineWidth = 2;
                nameLabel.outlineColor = '#000000';

                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '120px';
                labelRect.height = '24px';
                labelRect.cornerRadius = 4;
                labelRect.thickness = 0;
                labelRect.background = 'rgba(0, 0, 0, 0.5)';
                labelRect.addControl(nameLabel);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -50;
                labelRect.alpha = 0;  // Names hidden for now

                receiver.nameLabel = labelRect;
            });

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark gray enemies
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            defenderMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            // Offensive line material - similar to receivers (blue)
            const oLineMaterial = new BABYLON.StandardMaterial('oLineMat', scene);
            oLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            oLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            oLineMaterial.specularPower = 32;

            // Defensive line material - similar to defenders (dark gray)
            const dLineMaterial = new BABYLON.StandardMaterial('dLineMat', scene);
            dLineMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            dLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            dLineMaterial.specularPower = 32;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial, oLineMaterial, dLineMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Main field
            const field = BABYLON.MeshBuilder.CreateGround('field', {
                width: FIELD_WIDTH + 2,
                height: FIELD_LENGTH + 4
            }, scene);
            field.material = materials.fieldMaterial;
            field.position.z = 2;

            // Yard lines
            for (let i = -8; i <= 12; i += 4) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.1
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.01, i);
            }

            // End zone
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 3
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 12.5);

            // Border walls (castle-like)
            const wallHeight = 0.8;
            const wallPositions = [
                { x: -FIELD_WIDTH/2 - 0.5, z: 2, width: 1, depth: FIELD_LENGTH + 4 },
                { x: FIELD_WIDTH/2 + 0.5, z: 2, width: 1, depth: FIELD_LENGTH + 4 }
            ];

            wallPositions.forEach((wp, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall_${i}`, {
                    width: wp.width,
                    height: wallHeight,
                    depth: wp.depth
                }, scene);
                const wallMat = new BABYLON.StandardMaterial(`wallMat_${i}`, scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.35, 0.3, 0.25);
                wall.material = wallMat;
                wall.position.set(wp.x, wallHeight/2, wp.z);

                // Battlements
                for (let j = 0; j < 10; j++) {
                    const merlon = BABYLON.MeshBuilder.CreateBox(`merlon_${i}_${j}`, {
                        width: 0.4,
                        height: 0.3,
                        depth: 0.4
                    }, scene);
                    merlon.material = wallMat;
                    merlon.position.set(wp.x, wallHeight + 0.15, -7 + j * 2.2);
                }
            });

            // Line of scrimmage marker (blue)
            const losLine = BABYLON.MeshBuilder.CreateBox('losLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const losMat = new BABYLON.StandardMaterial('losMat', scene);
            losMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.9);
            losMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
            losMat.alpha = 0.8;
            losLine.material = losMat;
            losLine.position.set(0, 0.02, gameState.lineOfScrimmage);
            scene.losLine = losLine;

            // First down marker (yellow)
            const firstDownLine = BABYLON.MeshBuilder.CreateBox('firstDownLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const fdMat = new BABYLON.StandardMaterial('fdMat', scene);
            fdMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.2);
            fdMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.1);
            fdMat.alpha = 0.8;
            firstDownLine.material = fdMat;
            firstDownLine.position.set(0, 0.02, gameState.firstDownMarker);
            scene.firstDownLine = firstDownLine;
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Lineman Figure (larger than receivers)
        const createLineman = (scene, material, position, isOffense) => {
            const lineman = new BABYLON.TransformNode('lineman', scene);
            const scale = 1.25;  // Linemen are 25% bigger than receivers

            // Body (larger than knight)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = lineman;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = lineman;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = lineman;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35 * scale,
                height: 0.45 * scale,
                depth: 0.08 * scale
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3 * scale, 0.5 * scale, 0.1 * scale);
            shield.parent = lineman;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4 * scale,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = lineman;

            lineman.position = position;
            lineman.idleTime = Math.random() * Math.PI * 2;

            return lineman;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.3,
                segments: 8
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.6, 0.6, 1);
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.05,
                height: 0.02,
                depth: 0.15
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            laces.material = laceMat;
            laces.position.y = 0.08;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Distance dragged determines throw power
            const dragDistance = Math.sqrt(dx * dx + dy * dy) * DRAG_SENSITIVITY;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), MAX_THROW_DISTANCE);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            const angle = Math.atan2(dx, -dy);

            return {
                distance: throwDistance,
                angle: angle,
                power: throwDistance / MAX_THROW_DISTANCE
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw distance
            // Short throws (power ~0.2) = low arc (1.5), long throws (power ~1.0) = high arc (6)
            const maxHeight = 1 + power * power * 5;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                return false; // Route complete
            }

            let target = receiver.route[receiver.routeIndex];
            let dx = target.x - receiver.position.x;
            let dz = target.z - receiver.position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);

            // Check if reached current waypoint
            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                if (receiver.routeIndex >= receiver.route.length) {
                    return false; // Route complete
                }
                // Continue toward new waypoint this frame (don't skip a frame)
                target = receiver.route[receiver.routeIndex];
                dx = target.x - receiver.position.x;
                dz = target.z - receiver.position.z;
                dist = Math.sqrt(dx * dx + dz * dz);
            }

            if (dist > 0.1) {
                // Move toward target
                receiver.position.x += (dx / dist) * runSpeed;
                receiver.position.z += (dz / dist) * runSpeed;
                receiver.rotation.y = Math.atan2(dx, dz);
            }
            return true;
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Zone coverage AI - patrol assigned area, react to nearby receivers
        const moveDefenderZoneCoverage = (defender, speed) => {
            // Find nearest receiver in zone
            let nearestReceiver = null;
            let nearestDist = defender.zoneRadius;

            gameState.receivers.forEach(receiver => {
                const dx = receiver.position.x - defender.zoneCenter.x;
                const dz = receiver.position.z - defender.zoneCenter.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver in zone
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;  // Stay slightly behind
            } else {
                // Patrol zone center
                targetX = defender.zoneCenter.x;
                targetZ = defender.zoneCenter.z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // ============================================
        // LINE MOVEMENT AND CLASH SYSTEM
        // ============================================

        // Move D-lineman - rush toward QB
        const moveDLineman = (dLineman) => {
            // Skip if knocked down
            if (dLineman.knockdownUntil > gameState.gameTime) {
                dLineman.position.y = 0;
                return;
            }

            // Get QB position (use current QB position for evasion tracking)
            const qbPos = gameState.scene.qb.position;

            // Calculate speed with any boosts
            let speed = dLineman.baseSpeed;
            if (dLineman.speedBoostUntil > gameState.gameTime) {
                speed *= LINE_CLASH_CONSTANTS.SPEED_BURST_MULTIPLIER;
            }

            // Apply engagement slowdown
            if (dLineman.engagedWith && !dLineman.engagedWith.knockdownUntil) {
                speed *= dLineman.currentSpeedMultiplier;
            }

            // Rush toward QB
            const dx = qbPos.x - dLineman.position.x;
            const dz = qbPos.z - dLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                dLineman.position.x += (dx / dist) * speed;
                dLineman.position.z += (dz / dist) * speed;
                dLineman.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Move O-lineman - stay between assigned D-lineman and QB
        const moveOLineman = (oLineman) => {
            // Skip if knocked down
            if (oLineman.knockdownUntil > gameState.gameTime) {
                oLineman.position.y = 0;
                return;
            }

            const qbPos = gameState.scene.qb.position;

            // Find best D-lineman to block
            const targetDLineman = findBlockingTarget(oLineman);

            if (!targetDLineman) {
                // No target - hold position
                return;
            }

            // Update engagement
            oLineman.engagedWith = targetDLineman;

            // Calculate ideal blocking position - between D-lineman and QB
            const dLinePos = targetDLineman.position;

            // Vector from D-lineman to QB
            const toQbX = qbPos.x - dLinePos.x;
            const toQbZ = qbPos.z - dLinePos.z;
            const toQbDist = Math.sqrt(toQbX * toQbX + toQbZ * toQbZ);

            if (toQbDist < 0.5) return;  // Too close, don't move

            // Position 0.8 units in front of D-lineman (toward QB)
            const blockDist = 0.8;
            const targetX = dLinePos.x + (toQbX / toQbDist) * blockDist;
            const targetZ = dLinePos.z + (toQbZ / toQbDist) * blockDist;

            const dx = targetX - oLineman.position.x;
            const dz = targetZ - oLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                const speed = oLineman.baseSpeed;
                oLineman.position.x += (dx / dist) * speed;
                oLineman.position.z += (dz / dist) * speed;
                // Face the D-lineman
                oLineman.rotation.y = Math.atan2(dLinePos.x - oLineman.position.x, dLinePos.z - oLineman.position.z);
            }
        };

        // Find the best D-lineman for an O-lineman to block
        const findBlockingTarget = (oLineman) => {
            const qbPos = gameState.scene.qb.position;
            let bestTarget = null;
            let bestScore = -Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip knocked down D-linemen
                if (dLineman.knockdownUntil > gameState.gameTime) return;

                // Calculate threat level (closer to QB = more threatening)
                const distToQb = BABYLON.Vector3.Distance(dLineman.position, qbPos);
                const distToOLine = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);

                // Check if another O-lineman is already blocking this D-lineman
                let alreadyBlocked = false;
                let blockingOLineman = null;
                gameState.offensiveLine.forEach(other => {
                    if (other !== oLineman && other.engagedWith === dLineman &&
                        other.knockdownUntil <= gameState.gameTime) {
                        alreadyBlocked = true;
                        blockingOLineman = other;
                    }
                });

                // Scoring: prioritize unblocked D-linemen, close to self, close to QB
                let score = 0;

                // Heavily prioritize unblocked rushers
                if (!alreadyBlocked) {
                    score += 100;
                }

                // Prefer D-linemen close to this O-lineman (easier to reach)
                score -= distToOLine * 5;

                // Prefer D-linemen closer to QB (more threatening)
                score -= distToQb * 2;

                // If this O-lineman was already blocking this D-lineman, prefer to stay
                if (oLineman.engagedWith === dLineman) {
                    score += 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = dLineman;
                }
            });

            return bestTarget;
        };

        // Process line clashes between O-line and D-line
        const processLineClashes = () => {
            const currentTime = gameState.gameTime;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip if knocked down
                if (dLineman.knockdownUntil > currentTime) {
                    dLineman.currentSpeedMultiplier = 0;
                    return;
                }

                // Reset speed boost if expired
                if (dLineman.speedBoostUntil <= currentTime) {
                    dLineman.speedBoostUntil = 0;
                }

                // Find closest O-lineman
                let closestOLineman = null;
                let closestDist = LINE_CLASH_CONSTANTS.CLASH_RANGE;

                gameState.offensiveLine.forEach(oLineman => {
                    if (oLineman.knockdownUntil > currentTime) return;

                    const dist = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestOLineman = oLineman;
                    }
                });

                if (closestOLineman) {
                    // Engaged with O-lineman
                    dLineman.engagedWith = closestOLineman;
                    closestOLineman.engagedWith = dLineman;

                    // Check if it's time for a clash resolution
                    const timeSinceLastClash = currentTime - dLineman.lastClashTime;
                    if (timeSinceLastClash >= LINE_CLASH_CONSTANTS.CLASH_INTERVAL) {
                        resolveLineClash(closestOLineman, dLineman);
                    }
                } else {
                    // Not engaged - full speed
                    dLineman.engagedWith = null;
                    dLineman.currentSpeedMultiplier = 1.0;
                }
            });
        };

        // Resolve a clash between O-lineman and D-lineman
        const resolveLineClash = (oLineman, dLineman) => {
            const currentTime = gameState.gameTime;

            // Update clash timing
            oLineman.lastClashTime = currentTime;
            dLineman.lastClashTime = currentTime;

            // Roll for clash
            const oLineRoll = weightedRoll(oLineman.stats, CLASH_WEIGHTS.lineClash.offense);
            const dLineRoll = weightedRoll(dLineman.stats, CLASH_WEIGHTS.lineClash.defense);

            const margin = oLineRoll - dLineRoll;

            if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD) {
                // O-line wins decisively - knock down D-lineman
                dLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                dLineman.currentSpeedMultiplier = 0;
                dLineman.engagedWith = null;

                // O-lineman is free to help another
                oLineman.engagedWith = null;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD) {
                // D-line wins decisively - knock O-lineman aside, speed burst
                oLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                oLineman.engagedWith = null;

                // D-lineman gets speed burst
                dLineman.speedBoostUntil = currentTime + LINE_CLASH_CONSTANTS.SPEED_BURST_DURATION;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.engagedWith = null;

                // Knock O-lineman to the side
                const sideDir = Math.random() > 0.5 ? 1 : -1;
                oLineman.position.x += sideDir * 1.5;

            } else if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD / 2) {
                // O-line winning but not decisive - D-lineman very slow
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD / 2) {
                // D-line winning but not decisive - breaking through slowly
                dLineman.currentSpeedMultiplier = 0.5;

            } else {
                // Neutral - D-lineman nearly stopped
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;
            }
        };

        // Reset offensive line to starting positions
        const resetOffensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.offensiveLine.forEach((oLineman, i) => {
                oLineman.position.x = oLineman.startPos.x;
                oLineman.position.z = lineZ - 0.5;
                oLineman.position.y = 0;
                oLineman.rotation.y = 0;
                oLineman.rotation.x = 0;
                oLineman.knockdownUntil = 0;
                oLineman.engagedWith = null;
                oLineman.lastClashTime = 0;
                oLineman.bodyMaterial.diffuseColor = oLineman.originalColor;
                oLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // Reset defensive line to starting positions
        const resetDefensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.defensiveLine.forEach((dLineman, i) => {
                dLineman.position.x = dLineman.startPos.x;
                dLineman.position.z = lineZ + 0.5;
                dLineman.position.y = 0;
                dLineman.rotation.y = Math.PI;  // Face the offense
                dLineman.rotation.x = 0;
                dLineman.knockdownUntil = 0;
                dLineman.engagedWith = null;
                dLineman.lastClashTime = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial.diffuseColor = dLineman.originalColor;
                dLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // ============================================
        // QB MOVEMENT AND SACK SYSTEM
        // ============================================

        // Move QB based on pocket behavior and threats
        const moveQB = (scene) => {
            const qb = scene.qb;
            const currentTime = gameState.gameTime;

            // Don't move if play has ended or ball is being thrown
            if (gameState.playEnded || gameState.ballInFlight) return;

            // Find closest threat (D-lineman)
            let closestThreat = null;
            let closestThreatDist = Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                if (dLineman.knockdownUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(dLineman.position, qb.position);
                if (dist < closestThreatDist) {
                    closestThreatDist = dist;
                    closestThreat = dLineman;
                }
            });

            // Check for sack
            if (closestThreatDist < LINE_CLASH_CONSTANTS.TACKLE_RANGE) {
                handleSack(scene, closestThreat);
                return;
            }

            // Calculate pocket position relative to line of scrimmage
            const losZ = gameState.lineOfScrimmage;
            const pocketCenterZ = losZ - 3;  // 3 yards behind LOS
            const maxDepthZ = losZ - 6;       // 6 yards behind LOS max

            let targetX = qb.position.x;
            let targetZ = pocketCenterZ;
            let speed = POCKET_CONSTANTS.SETTLE_SPEED;

            // If threat is close, evade
            if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                speed = POCKET_CONSTANTS.EVADE_SPEED;

                // Calculate evasion direction (away from threat)
                const threatDx = qb.position.x - closestThreat.position.x;
                const threatDz = qb.position.z - closestThreat.position.z;
                const threatDist = Math.sqrt(threatDx * threatDx + threatDz * threatDz);

                if (threatDist > 0.1) {
                    // Move away from threat
                    targetX = qb.position.x + (threatDx / threatDist) * 2;
                    targetZ = qb.position.z + (threatDz / threatDist) * 2;
                }
            }

            // Apply constraints
            // Don't cross line of scrimmage
            targetZ = Math.min(targetZ, losZ);

            // Don't go too deep
            targetZ = Math.max(targetZ, maxDepthZ);

            // Stay within pocket width (with some flexibility when evading)
            const maxX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MAX_X + 2 : POCKET_CONSTANTS.POCKET_MAX_X;
            const minX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MIN_X - 2 : POCKET_CONSTANTS.POCKET_MIN_X;
            targetX = Math.max(minX, Math.min(maxX, targetX));

            // Move toward target
            const dx = targetX - qb.position.x;
            const dz = targetZ - qb.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                qb.position.x += (dx / dist) * speed;
                qb.position.z += (dz / dist) * speed;

                // Face the threat or downfield
                if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                    const faceDx = closestThreat.position.x - qb.position.x;
                    const faceDz = closestThreat.position.z - qb.position.z;
                    qb.rotation.y = Math.atan2(faceDx, faceDz);
                }
            }
        };

        // Handle QB sack
        const handleSack = (scene, tackler) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.qbSacked = true;
            gameState.canThrow = false;

            // Move line of scrimmage back to sack location
            handleSackFieldPosition(scene.qb.position.z);

            updateMessage(`SACK by ${tackler.displayName}!`);

            // QB falls down animation
            const qb = scene.qb;
            qb.rotation.x = Math.PI / 3;  // Fall forward

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // ============================================
        // RECEIVER TACKLING SYSTEM
        // ============================================

        // Move ball carrier (receiver with the ball) toward end zone
        const moveBallCarrier = (receiver) => {
            if (!receiver || receiver.knockdownUntil > gameState.gameTime) return;

            // Calculate effective speed with any boosts
            let speed = receiver.baseSpeed;
            if (receiver.breakTackleBoostUntil > gameState.gameTime) {
                speed *= TACKLE_CONSTANTS.BREAK_TACKLE_BOOST;
            }

            // Run toward end zone (positive Z direction)
            const targetZ = 14;  // End zone
            const targetX = receiver.position.x;  // Maintain lane for now

            const dz = targetZ - receiver.position.z;
            const dx = targetX - receiver.position.x;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                receiver.position.z += (dz / dist) * speed;
                receiver.position.x += (dx / dist) * speed * 0.3;  // Slight drift
                receiver.rotation.y = Math.atan2(dx, dz);
            }

            // Check for touchdown
            if (receiver.position.z >= 12) {
                handleTouchdown(receiver);
                return;
            }

            // Check for out of bounds
            if (Math.abs(receiver.position.x) > 8) {
                handleOutOfBounds(receiver);
                return;
            }
        };

        // Process tackle attempts by defenders on ball carrier
        const processTackles = () => {
            const receiver = gameState.ballCarrier;
            if (!receiver || gameState.playEnded) return;

            const currentTime = gameState.gameTime;

            // Check all defenders for tackle attempts
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > currentTime) return;
                if (defender.tackleStumbleUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(defender.position, receiver.position);

                if (dist < TACKLE_CONSTANTS.TACKLE_RANGE) {
                    // Check tackle cooldown
                    const timeSinceLastTackle = currentTime - (defender.lastTackleTime || 0);
                    if (timeSinceLastTackle < TACKLE_CONSTANTS.TACKLE_INTERVAL) return;

                    // Attempt tackle
                    resolveTackle(receiver, defender);
                }
            });
        };

        // Resolve a tackle attempt
        const resolveTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;
            defender.lastTackleTime = currentTime;

            // Roll for tackle
            const tackleRoll = weightedRoll(defender.stats, CLASH_WEIGHTS.tackle.tackler);
            const evasionRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier);

            const margin = tackleRoll - evasionRoll;

            // Tackling is meant to be fairly easy on equal stats
            // So a small positive margin should result in a tackle
            if (margin > -5) {
                // Tackle successful!
                handleTackle(receiver, defender);
            } else {
                // Broken tackle!
                handleBrokenTackle(receiver, defender);
            }
        };

        // Handle successful tackle
        const handleTackle = (receiver, defender) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Advance ball to tackle location
            advanceBall(receiver.position.z);

            updateMessage(`TACKLED by ${defender.displayName}!`);

            // Receiver falls down
            receiver.rotation.x = Math.PI / 3;
            receiver.position.y = 0;

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Flash effects
            defender.bodyMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.5, 0.1);
            setTimeout(() => {
                defender.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 500);

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // Handle broken tackle
        const handleBrokenTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            updateMessage(`BROKEN TACKLE!`);

            // Defender stumbles
            defender.tackleStumbleUntil = currentTime + TACKLE_CONSTANTS.STUMBLE_DURATION;
            defender.rotation.x = Math.PI / 6;  // Lean forward stumbling

            // Receiver gets speed boost
            receiver.breakTackleBoostUntil = currentTime + TACKLE_CONSTANTS.BREAK_TACKLE_DURATION;

            // Flash receiver green
            receiver.bodyMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.1);
            setTimeout(() => {
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 300);

            // Reset defender stumble rotation
            setTimeout(() => {
                defender.rotation.x = 0;
            }, TACKLE_CONSTANTS.STUMBLE_DURATION * 1000);
        };

        // Reset the drive to starting position (after TD or turnover on downs)
        const resetDrive = () => {
            gameState.down = 1;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.lineOfScrimmage + 10;
            gameState.yardsToGo = 10;
        };

        // Advance the ball to a new position and handle down logic
        const advanceBall = (newPositionZ) => {
            const END_ZONE_Z = 12;  // Touchdown threshold
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = newPositionZ - oldLOS;

            // Update line of scrimmage
            gameState.lineOfScrimmage = newPositionZ;

            // Check for first down
            if (newPositionZ >= gameState.firstDownMarker) {
                // First down achieved!
                gameState.down = 1;
                gameState.firstDownMarker = newPositionZ + 10;
                gameState.yardsToGo = 10;

                // Cap first down marker at end zone
                if (gameState.firstDownMarker > END_ZONE_Z) {
                    gameState.yardsToGo = END_ZONE_Z - newPositionZ;
                    gameState.firstDownMarker = END_ZONE_Z;
                }

                updateMessage('FIRST DOWN!');
            } else {
                // No first down, advance to next down
                gameState.down++;
                gameState.yardsToGo = gameState.firstDownMarker - newPositionZ;

                if (gameState.down > 4) {
                    // Turnover on downs!
                    updateMessage('TURNOVER ON DOWNS!');
                    resetDrive();
                }
            }
        };

        // Handle incomplete pass (same line of scrimmage, next down)
        const handleIncomplete = () => {
            gameState.down++;
            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
            }
        };

        // Handle sack (move line back)
        const handleSackFieldPosition = (sackPositionZ) => {
            // Sack moves the line of scrimmage back
            const newLOS = Math.max(-8, sackPositionZ);  // Don't go too far back
            gameState.lineOfScrimmage = newLOS;
            gameState.yardsToGo = gameState.firstDownMarker - newLOS;
            gameState.down++;

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
            }
        };

        // Handle touchdown
        const handleTouchdown = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.touchdowns++;
            updateScore();

            updateMessage(`TOUCHDOWN by ${receiver.displayName}!`);

            // Celebration
            celebrateReceiver(receiver, gameState.scene);

            // Reset drive after touchdown
            resetDrive();

            // Reset after delay
            setTimeout(() => {
                resetPlay(gameState.scene);
            }, 3000);
        };

        // Handle out of bounds
        const handleOutOfBounds = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Advance ball to where receiver went out
            advanceBall(receiver.position.z);

            updateMessage(`OUT OF BOUNDS`);

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 1500);
        };

        // Move defenders to pursue ball carrier
        const moveDefenderPursuit = (defender, pursuitBoost = 1.0) => {
            const receiver = gameState.ballCarrier;
            if (!receiver || defender.knockdownUntil > gameState.gameTime) return;

            // Stumbling defenders can't move well
            if (defender.tackleStumbleUntil > gameState.gameTime) {
                return;
            }

            // Base pursuit speed with time-based boost
            const speed = defender.baseSpeed * 1.1 * pursuitBoost;

            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            const lineZ = gameState.lineOfScrimmage;
            let manDefenderIndex = 0;

            gameState.defenders.forEach((defender, i) => {
                if (defender.aiType === 'man') {
                    // Man defenders cover receivers 1-to-1
                    const receiverIndex = manDefenderIndex % gameState.receivers.length;
                    defender.assignedReceiver = receiverIndex;
                    const targetReceiver = gameState.receivers[receiverIndex];

                    // Position directly above receiver with varying depth
                    defender.cushion = 2 + Math.random() * 4;  // 2-6 yards cushion
                    defender.startPos.x = targetReceiver.startPos.x;
                    defender.startPos.z = targetReceiver.startPos.z + defender.cushion;
                    manDefenderIndex++;
                } else if (defender.aiType === 'zone') {
                    // Zone defender in middle of field with random depth
                    const zoneDepth = 6 + Math.random() * 4;  // 6-10 yards deep
                    defender.zoneCenter = new BABYLON.Vector3(0, 0, lineZ + zoneDepth);
                    defender.zoneRadius = 5 + Math.random() * 2;  // 5-7 yard radius
                    defender.startPos.x = 0;
                    defender.startPos.z = lineZ + zoneDepth - 2;
                }

                defender.position.x = defender.startPos.x;
                defender.position.z = defender.startPos.z;
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.clashTiltUntil = 0;
                defender.loserFlashUntil = 0;
                defender.winnerFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.clashSpeedPenaltyUntil = 0;
                defender.lastClashTime = 0;
                defender.rotation.x = 0;  // Reset tilt
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
                // Tackling state
                defender.tackleStumbleUntil = 0;
                defender.lastTackleTime = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            // Receivers line up at the line of scrimmage
            const receiverLineZ = gameState.lineOfScrimmage;

            // Assign spread positions: left slot, right slot, flex position
            const positions = [
                -(5 + Math.random() * 2),   // Left side: -5 to -7 (near sideline)
                (5 + Math.random() * 2),    // Right side: 5 to 7 (near sideline)
                (Math.random() - 0.5) * 4   // Middle/flex: -2 to 2
            ];
            // Shuffle positions for variety
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            gameState.receivers.forEach((receiver, i) => {
                // Assign spread position
                receiver.startPos.x = positions[i] || (Math.random() - 0.5) * 6;
                receiver.startPos.z = receiverLineZ;

                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiverLineZ;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.clashTiltUntil = 0;
                receiver.loserFlashUntil = 0;
                receiver.winnerFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.clashSpeedPenaltyUntil = 0;
                receiver.clashSpeedBoostUntil = 0;
                receiver.rotation.x = 0;  // Reset tilt
                receiver.coverageAmount = 0;
                receiver.currentCatchProb = receiver.stats.catching;
                // Size based on base catching stat (80% = 0.3 + 0.9*0.8 = 1.02 scale)
                const baseScale = 0.3 + 0.9 * (receiver.stats.catching / 100);
                receiver.zoneFill.scaling = new BABYLON.Vector3(baseScale, baseScale, baseScale);
                receiver.fillMaterial.alpha = 0.5;
                // Always white
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // Tackling state
                receiver.breakTackleBoostUntil = 0;

                // Generate new random route
                generateRandomRoute(receiver);

                // Keep name labels hidden
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });

            // Reset play start time for label fading
            gameState.playStartTime = performance.now() * 0.001;
        };

        // Generate a random route for a receiver
        const generateRandomRoute = (receiver) => {
            const startX = receiver.startPos.x;
            const startZ = receiver.startPos.z;
            const END_ZONE_Z = 12;  // End zone starts here
            const END_ZONE_BACK = 14;  // Back of end zone

            // Route types - all routes go into end zone then cut sideways
            const routes = ['go_fade', 'slant_across', 'out_corner', 'in_post', 'corner_fade', 'post_corner', 'double_move', 'comeback_fade'];
            const routeType = routes[Math.floor(Math.random() * routes.length)];

            const route = [];

            // First break point (5-8 yards from start, but not past end zone)
            const break1Depth = Math.min(startZ + 5 + Math.random() * 3, END_ZONE_Z - 2);
            // Entry point into end zone
            const endZoneEntry = END_ZONE_Z + 0.5;

            // Determine lateral movement based on field position
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = startX > 0 ? 1 : -1;

            // Sideways fade distance in end zone (3-5 yards)
            const fadeDistance = 3 + Math.random() * 2;

            switch(routeType) {
                case 'go_fade':
                    // Straight into end zone, then fade sideways
                    route.push({ z: endZoneEntry, x: startX });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + towardSideline * fadeDistance)) });
                    break;

                case 'slant_across':
                    // Slant toward middle, enter end zone, cut across
                    const slantX = startX + towardMiddle * (3 + Math.random() * 2);
                    route.push({ z: break1Depth, x: slantX });
                    route.push({ z: endZoneEntry, x: slantX });
                    route.push({ z: END_ZONE_BACK, x: slantX + towardMiddle * fadeDistance });
                    break;

                case 'out_corner':
                    // Out route, then up into end zone corner, fade along back line
                    const outX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: break1Depth, x: outX });
                    route.push({ z: endZoneEntry, x: outX });
                    route.push({ z: END_ZONE_BACK, x: outX + towardSideline * 2 });
                    break;

                case 'in_post':
                    // In route, then post into end zone, fade across
                    const inX = startX + towardMiddle * (4 + Math.random() * 2);
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: break1Depth, x: inX });
                    route.push({ z: endZoneEntry, x: inX });
                    route.push({ z: END_ZONE_BACK, x: inX + towardMiddle * fadeDistance });
                    break;

                case 'corner_fade':
                    // Straight, break to corner, enter end zone, fade along back
                    const cornerX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: endZoneEntry, x: cornerX });
                    route.push({ z: END_ZONE_BACK, x: cornerX + towardSideline * 2 });
                    break;

                case 'post_corner':
                    // Post toward middle, enter end zone, cut back toward corner
                    const postX = towardMiddle * (2 + Math.random() * 2);
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: endZoneEntry, x: postX });
                    route.push({ z: END_ZONE_BACK, x: postX + towardSideline * fadeDistance });
                    break;

                case 'double_move':
                    // Fake one way, cut back, into end zone, fade
                    const fakeDir = Math.random() > 0.5 ? towardSideline : towardMiddle;
                    const fakeX = startX + fakeDir * 2;
                    route.push({ z: break1Depth - 2, x: fakeX });
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: endZoneEntry, x: startX });
                    route.push({ z: END_ZONE_BACK, x: startX + towardSideline * fadeDistance });
                    break;

                case 'comeback_fade':
                    // Go deep, slight comeback, sprint into end zone, fade
                    route.push({ z: break1Depth, x: startX });
                    route.push({ z: break1Depth - 1, x: startX + towardMiddle * 1 });
                    route.push({ z: endZoneEntry, x: startX + towardMiddle * 2 });
                    route.push({ z: END_ZONE_BACK, x: startX + towardMiddle * 2 + towardSideline * fadeDistance });
                    break;
            }

            receiver.route = route;

            // Update route line visual
            if (receiver.routeLine) {
                receiver.routeLine.dispose();
            }

            const routePoints = [receiver.startPos.clone()];
            routePoints[0].y = 0.05;
            route.forEach(point => {
                routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
            });

            // Need to access scene - store reference on gameState
            if (gameState.scene && gameState.routeMaterial) {
                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + receiver.name, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, gameState.scene);
                routeLine.material = gameState.routeMaterial;
                receiver.routeLine = routeLine;
            }
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            const catchRadius = 1.2;

            let frameIndex = 0;
            // Shorter throws are faster: speed ranges from 2.0 (short) to 0.8 (long)
            const animationSpeed = 2.0 - (throwParams.power * 1.2);
            let accumulator = 0;
            const time = { value: 0 };

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Spin animation
                    football.rotation.z += 0.2;

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Reset speed to base when boost/penalty expires (also during ball flight)
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // Calculate effective speed (apply initial clash slowdown if no outcome yet)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;
                        }

                        // If ball is coming to them (within catch range), move toward it
                        // Moving off-route to catch slows the receiver down (allows defenders to close)
                        if (distToLanding < catchRadius * 2.5 && frameIndex > 5) {
                            if (distToLanding > 0.2) {
                                // Reduced speed when adjusting to catch (70% of normal)
                                const catchAdjustSpeed = effectiveSpeed * 0.7;
                                receiver.position.x += (dx / distToLanding) * catchAdjustSpeed;
                                receiver.position.z += (dz / distToLanding) * catchAdjustSpeed;
                                receiver.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            // Follow their route
                            moveReceiverAlongRoute(receiver, effectiveSpeed);
                        }

                        // Running animation
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                        receiver.rotation.z = Math.sin(time.value * 8 + i) * 0.05;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Defenders move at full speed during ball flight
                        moveDefender(defender, 0.016);

                        // Running animation
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time.value * 8 + i + 0.5) * 0.05;
                    });

                    // Move linemen during ball flight (battle continues!)
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            return;
                        }
                        moveOLineman(oLineman);
                        oLineman.position.y = Math.abs(Math.sin(time.value * 4 + i * 0.5)) * 0.03;
                    });

                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            return;
                        }
                        moveDLineman(dLineman);
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        dLineman.position.y = Math.abs(Math.sin(time.value * (isRushing ? 8 : 4) + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes during ball flight
                    processLineClashes();

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            const catchRadius = 1.2;
            let potentialCatcher = null;
            let closestDistance = catchRadius;

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                }
            }

            if (potentialCatcher) {
                // Calculate catch probability (returns detailed info)
                const catchInfo = calculateCatchProbability(potentialCatcher, ballPosition);
                const catchRoll = Math.random() * 100;
                const success = catchRoll < catchInfo.probability;

                // Track attempt
                gameState.attempts++;

                // Show the catch probability display
                showCatchDisplay(catchInfo, catchRoll, success);

                if (success) {
                    // Successful catch! Set up ball carrier
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}! RUN!`);

                    // Attach ball to receiver
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    // Set up ball carrier state - play continues!
                    gameState.ballCarrier = potentialCatcher;
                    potentialCatcher.breakTackleBoostUntil = 0;

                    // Start the run-after-catch phase
                    startRunAfterCatch(scene);
                } else {
                    // Dropped or defended - incomplete pass
                    handleIncomplete();
                    updateScore();
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');
                    bounceBall(scene, ballPosition);
                }
            } else {
                // No receiver nearby - incomplete pass
                handleIncomplete();
                updateMessage('Incomplete...');
                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Start the run-after-catch phase with animation loop
        const startRunAfterCatch = (scene) => {
            const timeSinceCatch = { value: 0 };

            const runAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                timeSinceCatch.value += dt;
                gameState.gameTime = performance.now() * 0.001;

                // Check if play has ended
                if (gameState.playEnded) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                const ballCarrier = gameState.ballCarrier;
                if (!ballCarrier) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                // Move ball carrier
                moveBallCarrier(ballCarrier);

                // Running animation for ball carrier
                ballCarrier.position.y = Math.abs(Math.sin(timeSinceCatch.value * 10)) * 0.1;
                ballCarrier.rotation.z = Math.sin(timeSinceCatch.value * 10) * 0.06;

                // Calculate pursuit boost based on time since catch
                // After 1 second: 10% boost, after 2 seconds: 20% boost
                let pursuitBoost = 1.0;
                if (timeSinceCatch.value >= 2.0) {
                    pursuitBoost = 1.2;  // 20% boost after 2 seconds
                } else if (timeSinceCatch.value >= 1.0) {
                    // Interpolate from 10% to 20% between 1 and 2 seconds
                    const t = timeSinceCatch.value - 1.0;  // 0 to 1
                    pursuitBoost = 1.1 + (t * 0.1);  // 1.1 to 1.2
                }

                // Move all defenders in pursuit with speed boost
                gameState.defenders.forEach((defender, i) => {
                    if (defender.knockdownUntil <= gameState.gameTime) {
                        moveDefenderPursuit(defender, pursuitBoost);

                        // Running animation (faster when boosted)
                        const animSpeed = 10 + (pursuitBoost - 1.0) * 20;
                        defender.position.y = Math.abs(Math.sin(timeSinceCatch.value * animSpeed + i)) * 0.08;
                        defender.rotation.z = Math.sin(timeSinceCatch.value * animSpeed + i) * 0.05;
                    }
                });

                // Process tackle attempts
                processTackles();
            });
        };

        // Calculate catch probability based on receiver stats and proximity to defenders
        const calculateCatchProbability = (receiver, ballPosition) => {
            // Base catch rate from receiver's catching stat
            let baseCatch = receiver.stats.catching;

            // Find defenders and apply proximity penalty
            let defenderProximityPenalty = 0;
            let defenderDetails = [];
            let hasNearbyDefender = false;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;

                    // Get defender's coverage stat based on their type
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;

                    // Proximity factor: 1.0 at distance 0, 0.0 at max range
                    const proximityFactor = 1 - (dist / coverageRange);

                    // At distance 0, if coverage equals catching, apply 80% penalty
                    // penalty = proximityFactor^3 * coverageStat * 0.8
                    // Cubed for steeper dropoff - separation is rewarded more
                    let penalty = proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;

                    // Very close defenders (0.6 or closer) have 50% more influence
                    const CLOSE_DEFENDER_THRESHOLD = 0.6;
                    if (dist <= CLOSE_DEFENDER_THRESHOLD) {
                        penalty *= 1.5;
                    }

                    // Check if ball is on opposite side from defender
                    // Only applies if defender isn't right on top of receiver (dist > 0.8)
                    const MIN_DIST_FOR_SIDE_BONUS = 0.8;
                    if (dist > MIN_DIST_FOR_SIDE_BONUS) {
                        const defenderSide = Math.sign(defender.position.x - receiver.position.x);
                        const ballSide = Math.sign(ballPosition.x - receiver.position.x);

                        // If ball and defender are on opposite sides, halve the penalty
                        if (defenderSide !== 0 && ballSide !== 0 && defenderSide !== ballSide) {
                            penalty *= 0.5;
                        }
                    }

                    defenderProximityPenalty += penalty;
                    defenderDetails.push({
                        name: defender.name,
                        dist: dist.toFixed(2),
                        penalty: penalty.toFixed(1),
                        coverageStat: coverageStat,
                        aiType: defender.aiType
                    });
                }
            });

            // Focus stat helps when defenders are nearby (higher focus = better under pressure)
            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;

            // Calculate final probability (clamped between 5% and 95%)
            const finalProbability = Math.max(5, Math.min(95,
                baseCatch + focusMod - defenderProximityPenalty
            ));

            // Store for visual display
            receiver.lastCatchProbability = finalProbability;

            // Return detailed info for UI display
            return {
                probability: finalProbability,
                baseCatch: baseCatch,
                focusMod: focusMod,
                defenderPenalty: defenderProximityPenalty,
                defenderDetails: defenderDetails
            };
        };

        // Show catch probability display
        const showCatchDisplay = (catchInfo, roll, success) => {
            const display = document.getElementById('catchDisplay');
            const header = display.querySelector('.catch-header');
            const barBase = display.querySelector('.catch-bar-base');
            const barPenalty = display.querySelector('.catch-bar-penalty');
            const barRoll = display.querySelector('.catch-bar-roll');
            const defenderInfo = display.querySelector('.defender-info');

            // Set header
            header.textContent = success ? 'CATCH!' : 'DROPPED';
            header.className = 'catch-header ' + (success ? 'success' : 'fail');

            // Calculate raw catch % (base + focus, before defender penalty)
            const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
            const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

            // Set bar: green shows raw potential, dark overlay shows defender penalty
            barBase.style.width = `${rawCatch}%`;

            // Penalty overlay starts where final probability ends
            if (penaltyWidth > 0) {
                barPenalty.style.display = 'block';
                barPenalty.style.left = `${catchInfo.probability}%`;
                barPenalty.style.width = `${penaltyWidth}%`;
            } else {
                barPenalty.style.display = 'none';
            }

            // Roll marker with tick/cross
            barRoll.textContent = success ? 'âœ“' : 'âœ—';
            barRoll.className = 'catch-bar-roll ' + (success ? 'success' : 'fail');
            barRoll.style.left = `${roll}%`;

            // Show defender distances only
            if (catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0) {
                const distances = catchInfo.defenderDetails
                    .filter(d => parseFloat(d.penalty) > 0.5)
                    .map(d => d.dist)
                    .join(', ');
                defenderInfo.textContent = distances ? distances + 'yd' : '';
            } else {
                defenderInfo.textContent = '';
            }

            // Show display
            display.classList.add('visible');

            // Hide after 2.5 seconds
            setTimeout(() => {
                display.classList.remove('visible');
            }, 2500);
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;
            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset play state flags
            gameState.ballCarrier = null;
            gameState.playEnded = false;
            gameState.qbSacked = false;

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Reset linemen
            resetOffensiveLine();
            resetDefensiveLine();

            // Reset QB position (relative to line of scrimmage, randomized depth behind it)
            const qbDepthBehindLine = 2 + Math.random() * 2;  // 2-4 yards behind LOS
            const qbZ = gameState.lineOfScrimmage - qbDepthBehindLine;
            gameState.qbStartZ = qbZ;
            scene.qb.position.x = 0;
            scene.qb.position.z = qbZ;
            scene.qb.position.y = 0;
            scene.qb.rotation.x = 0;
            scene.qb.rotation.y = 0;

            // Update field position markers
            if (scene.losLine) {
                scene.losLine.position.z = gameState.lineOfScrimmage;
            }
            if (scene.firstDownLine) {
                scene.firstDownLine.position.z = gameState.firstDownMarker;
            }

            // Move camera to follow the line of scrimmage
            if (scene.activeCamera) {
                // Target centered on the line of scrimmage
                // Clamp to reasonable field bounds (-4 to 8)
                const cameraTargetZ = Math.max(-4, Math.min(8, gameState.lineOfScrimmage));
                scene.activeCamera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);
            }

            // Update down and distance display
            updateDownDistance();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Drag from knight to throw');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            const scoreEl = document.getElementById('score');
            scoreEl.querySelector('.catches').textContent = `${gameState.catches}/${gameState.attempts}`;
            scoreEl.querySelector('.touchdowns').textContent = gameState.touchdowns;
        };

        const updateDownDistance = () => {
            const ddEl = document.getElementById('downDistance');
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const downText = downNames[gameState.down - 1] || '4th';

            // Calculate yards to go (convert Z units to approximate yards - roughly 1 unit = 1 yard)
            const yardsToGo = Math.max(1, Math.round(gameState.yardsToGo));
            const distanceText = yardsToGo >= 10 ? '10+' : yardsToGo.toString();

            ddEl.querySelector('.down').textContent = downText;
            ddEl.querySelector('.distance').textContent = distanceText;
        };

        const updateMessage = (msg) => {
            // Message display removed
        };

        // Update debug info display
        const updateDebugInfo = () => {
            if (!FEATURE_FLAGS.showDebugInfo) {
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            document.getElementById('debugInfo').style.display = 'block';

            let debugText = '=== RECEIVER STATUS ===\n';
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.receivers.forEach((receiver, i) => {
                // Find closest defender
                let closestDef = null;
                let closestDist = Infinity;
                gameState.defenders.forEach(def => {
                    if (def.knockdownUntil > gameState.gameTime) return;
                    const dx = def.position.x - receiver.position.x;
                    const dz = def.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestDef = def;
                    }
                });

                const timeSinceClash = (gameState.gameTime - receiver.lastClashTime).toFixed(1);
                const speedMod = (receiver.speed / receiver.baseSpeed * 100).toFixed(0);
                const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                const catchProb = receiver.currentCatchProb || receiver.stats.catching;

                // Determine coverage level based on catch probability
                let coverageLevel = 'OPEN';
                let levelColor = 'ðŸŸ¢';
                if (catchProb < 40) {
                    coverageLevel = 'COVERED';
                    levelColor = 'ðŸ”´';
                } else if (catchProb < 70) {
                    coverageLevel = 'CONTESTED';
                    levelColor = 'ðŸŸ¡';
                }

                debugText += `\n${receiver.displayName}:\n`;
                debugText += `  ${levelColor} Catch: ${catchProb.toFixed(0)}% (${coverageLevel})\n`;
                debugText += `  Speed: ${speedMod}%${hasSpeedPenalty ? ' (SLOWED)' : ''}\n`;

                if (closestDef) {
                    const defSpeedPenalty = closestDef.clashSpeedPenaltyUntil > gameState.gameTime;
                    const defCovStat = closestDef.aiType === 'zone' ?
                        closestDef.stats.zoneCoverage : closestDef.stats.manCoverage;
                    debugText += `  Nearest: ${closestDef.displayName}`;
                    if (defSpeedPenalty) debugText += ' (SLOWED)';
                    debugText += `\n`;
                    debugText += `  Dist: ${closestDist.toFixed(1)}/${coverageRange.toFixed(1)}`;
                    debugText += ` | ${closestDef.aiType === 'zone' ? 'ZoneCov' : 'ManCov'}: ${defCovStat}\n`;
                }
            });

            document.getElementById('debugInfo').textContent = debugText;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                // Only capture left-click (button 0) or single touch for throwing
                // Let right-click (button 2) and multi-touch pass through to camera
                if (evt.button !== 0 && evt.pointerType === 'mouse') return;
                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.activePointerId = evt.pointerId;  // Track which pointer is dragging
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
            };

            const onPointerMove = (evt) => {
                // Only track the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                // Only respond to the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.activePointerId = null;

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                if (gameState.dragStart && gameState.dragCurrent) {
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                const time = performance.now() * 0.001;

                // QB breathing/ready animation (only when not in danger)
                const qb = scene.qb;
                if (!gameState.playEnded && !gameState.qbSacked) {
                    // Only subtle breathing when not moving
                    const isEvading = gameState.defensiveLine.some(d =>
                        d.knockdownUntil <= gameState.gameTime &&
                        BABYLON.Vector3.Distance(d.position, qb.position) < POCKET_CONSTANTS.THREAT_RADIUS
                    );
                    if (!isEvading) {
                        qb.rotation.y = Math.sin(time * 2) * 0.05;
                        qb.position.y = Math.sin(time * 3) * 0.02;
                    } else {
                        qb.position.y = Math.abs(Math.sin(time * 8)) * 0.06;  // Running animation
                    }
                }

                // Track game time for clash system
                gameState.gameTime = time;

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Reset speed to base when boost/penalty expires
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate effective speed (slowdown during initial clash, unless clash outcome already applied)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash (only if no outcome yet)
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Arm swing approximation via slight rotation
                        receiver.rotation.z = Math.sin(time * bobSpeed + i) * 0.05;

                        // Clash tilt effect (lean towards opponent)
                        if (receiver.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (receiver.clashTiltUntil - gameState.gameTime) / 0.5;
                            receiver.rotation.x = Math.sin(tiltProgress * Math.PI) * 0.3;  // Lean forward
                        } else {
                            receiver.rotation.x = 0;
                        }

                        // Show green while speed boosted, red while speed penalized
                        if (receiver.clashSpeedBoostUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const green = new BABYLON.Color3(0.2, 1.0, 0.3);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, green, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = green.scale(flashRate * 0.3);
                        } else if (receiver.clashSpeedPenaltyUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const red = new BABYLON.Color3(1.0, 0.2, 0.2);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, red, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = red.scale(flashRate * 0.3);
                        } else {
                            receiver.bodyMaterial.diffuseColor = receiver.originalColor;
                            receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
                        }
                    });

                    // Reset all players when any route completes
                    if (anyRouteComplete && !gameState.playEnded) {
                        resetReceivers();
                        resetDefenders();
                        resetOffensiveLine();
                        resetDefensiveLine();
                    }

                    // Move offensive linemen
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            oLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        oLineman.rotation.x = 0;

                        moveOLineman(oLineman);

                        // Subtle stance animation
                        oLineman.position.y = Math.abs(Math.sin(time * 4 + i * 0.5)) * 0.03;
                    });

                    // Move defensive linemen
                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            dLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        dLineman.rotation.x = 0;

                        moveDLineman(dLineman);

                        // Running animation when moving fast
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        const bobSpeed = isRushing ? 8 : 4;
                        dLineman.position.y = Math.abs(Math.sin(time * bobSpeed + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes
                    processLineClashes();

                    // Move QB (pocket behavior and evasion)
                    moveQB(scene);

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdowns from clashes)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }
                        if (defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.5;  // 50% slower after losing clash
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (slower during slowdown)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time * bobSpeed + i + 0.5) * 0.05;

                        // Clash tilt effect (lean towards opponent)
                        if (defender.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (defender.clashTiltUntil - gameState.gameTime) / 0.5;
                            defender.rotation.x = Math.sin(tiltProgress * Math.PI) * 0.3;  // Lean forward
                        } else {
                            defender.rotation.x = 0;
                        }

                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();

                    // Fade out name labels after 1 second
                    const timeSinceStart = time - gameState.playStartTime;
                    if (timeSinceStart > 1.0 && timeSinceStart < 2.0) {
                        // Fade over 1 second (from t=1 to t=2)
                        const fadeProgress = timeSinceStart - 1.0;
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 1 - fadeProgress;
                            }
                        });
                    } else if (timeSinceStart >= 2.0) {
                        // Fully hidden
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 0;
                            }
                        });
                    }
                }
            });
        };

        // Get zone colors based on catch probability (0-100%)
        // High catch % = green, medium = yellow, low = red
        const getZoneColorsByCatchProb = (catchProbability) => {
            if (catchProbability >= 70) {
                // Green - high catch chance
                return {
                    diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),
                    emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                };
            } else if (catchProbability >= 40) {
                // Yellow - moderate catch chance
                return {
                    diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                };
            } else {
                // Red - low catch chance
                return {
                    diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                };
            }
        };

        // Calculate real-time catch probability for a receiver (for visual display)
        const calculateRealtimeCatchProb = (receiver) => {
            const baseCatch = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;
            let defenderPenalty = 0;
            let hasNearbyDefender = false;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / coverageRange);
                    // Match the catch calculation: cubed for steeper dropoff
                    defenderPenalty += proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;
                }
            });

            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;
            return Math.max(5, Math.min(95, baseCatch + focusMod - defenderPenalty));
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Calculate real-time catch probability
                const catchProb = calculateRealtimeCatchProb(receiver);
                receiver.currentCatchProb = catchProb;  // Store for debug display

                // Size based on catch probability (larger = higher catch %)
                const minScale = 0.3;  // Minimum size at 0% catch
                const maxScale = 1.2;  // Maximum size at 100% catch
                const catchFactor = catchProb / 100;  // 0-1
                const fillScale = minScale + (maxScale - minScale) * catchFactor;
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Keep white color, adjust alpha based on coverage for visibility
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                receiver.fillMaterial.alpha = 0.5;

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);
                    coveringDefender.fillMaterial.alpha = maxCoverage * 0.45;
                    coveringDefender.ringMaterial.alpha = 0.8;
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const tiltDuration = 0.5;   // seconds for grappling tilt
            const currentTime = gameState.gameTime;

            // Calculate tilt direction (towards each other)
            const dx = defender.position.x - receiver.position.x;
            const dz = defender.position.z - receiver.position.z;
            const angle = Math.atan2(dx, dz);

            // Both tilt towards each other during clash
            receiver.clashTiltUntil = currentTime + tiltDuration;
            receiver.clashTiltAngle = angle;  // Tilt towards defender
            defender.clashTiltUntil = currentTime + tiltDuration;
            defender.clashTiltAngle = angle + Math.PI;  // Tilt towards receiver (opposite)

            // Color is now controlled by speed effect timers (clashSpeedBoostUntil / clashSpeedPenaltyUntil)
            // No separate flash timer needed
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        const weightedRoll = (stats, weights) => {
            let weightedTotal = 0;
            for (const stat in weights) {
                const statValue = stats[stat] || 50;  // Default to 50 if stat missing
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (Â±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Cooldown - don't clash again too soon after a previous clash
            const CLASH_COOLDOWN = 2.0;  // seconds between clashes
            const timeSinceReceiverClash = currentTime - receiver.lastClashTime;
            const timeSinceDefenderClash = currentTime - defender.lastClashTime;
            if (timeSinceReceiverClash < CLASH_COOLDOWN || timeSinceDefenderClash < CLASH_COOLDOWN) {
                return { trigger: false, reason: 'cooldown' };
            }

            // Initial contact - first time zones overlap
            if (!receiver.hasHadInitialClash) {
                return { trigger: true, reason: 'initial_contact' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            if (defender.aiType === 'zone') {
                defenderWeights.zoneCoverage = defenderWeights.manCoverage;
                delete defenderWeights.manCoverage;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            // Speed effect duration for receivers only
            const CLASH_SPEED_EFFECT_DURATION = 2.0;  // seconds
            const CLASH_SPEED_PENALTY = 0.5;  // 50% slower
            const CLASH_SPEED_BOOST = 1.5;  // 50% faster

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                // Receiver wins - gets speed boost
                receiver.clashSpeedBoostUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                receiver.speed = receiver.baseSpeed * CLASH_SPEED_BOOST;
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                // Direction changes (jukes) only benefit receivers - ignore defender wins
                if (reason === 'direction_change') {
                    result.winner = 'none';
                    result.type = 'contested';
                    // Juke failed but no penalty - just maintain current speed
                } else {
                    result.winner = 'defender';
                    result.type = 'coverage';
                    // Receiver loses - gets slowed
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                    receiver.speed = receiver.baseSpeed * CLASH_SPEED_PENALTY;
                }
            } else {
                result.winner = 'none';
                result.type = 'contested';
                // Tie - receiver maintains current speed
            }

            // Physical battle check (based on aggression)
            const physicalChance = (receiver.stats.aggression + defender.stats.aggression) / 200;
            if (Math.random() < physicalChance) {
                resolvePhysicalClash(receiver, defender, result);
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Resolve physical aspect of clash (knockdowns)
        const resolvePhysicalClash = (receiver, defender, separationResult) => {
            const currentTime = gameState.gameTime;

            // Roll physical battle
            const receiverPhysical = weightedRoll(receiver.stats, CLASH_WEIGHTS.physical.attacker);
            const defenderPhysical = weightedRoll(defender.stats, CLASH_WEIGHTS.physical.defender);

            const margin = receiverPhysical - defenderPhysical;
            const loser = margin > 0 ? defender : receiver;
            const winner = margin > 0 ? receiver : defender;

            // Check for knockdown
            const knockdownChance = CLASH_CONSTANTS.KNOCKDOWN_BASE_CHANCE +
                (Math.abs(margin) / 100) * 0.1 -
                loser.knockdownResistance;

            if (Math.random() < Math.max(0, knockdownChance)) {
                // Knockdown!
                loser.knockdownUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                loser.knockdownResistance += CLASH_CONSTANTS.KNOCKDOWN_RESISTANCE_GAIN;

                // If receiver knocked down, apply heavy speed penalty
                if (loser === receiver) {
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                }
            }
        };

        // Process all clashes in the game
        const processClashes = () => {
            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // Main
        const scene = createScene();
        setupInput(scene);
        setupIdleAnimations(scene);

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
