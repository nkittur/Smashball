<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 36px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            border-bottom: 1px solid #333;
        }

        #score {
            color: #ffd700;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }

        #score .catches { color: #8cf; }
        #score .touchdowns { color: #4f4; }
        #score .label { color: #888; }

        #downDistance {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40, 40, 40, 0.9);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        #downDistance .down { color: #ffa; }
        #downDistance .distance { color: #aef; }

        #viewButtons {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        #viewButtons button {
            background: rgba(60, 60, 60, 0.9);
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 14px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        #viewButtons button:hover {
            background: rgba(80, 80, 80, 0.9);
            color: #fff;
        }
        #viewButtons button.active {
            background: rgba(70, 90, 120, 0.9);
            border-color: #68a;
            color: #fff;
        }

        #debugInfo {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: left;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
            white-space: pre-wrap;
        }
        #catchDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #catchDisplay.visible {
            opacity: 1;
        }
        #catchDisplay .catch-header {
            font-size: 11px;
            font-weight: bold;
        }
        #catchDisplay .catch-header.success { color: #4f4; }
        #catchDisplay .catch-header.fail { color: #f66; }
        #catchDisplay .catch-bar {
            position: relative;
            width: 100px;
            height: 14px;
            background: #222;
            border-radius: 2px;
            overflow: visible;
        }
        #catchDisplay .catch-bar-base {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #3a3, #4b4);
            border-radius: 2px;
        }
        #catchDisplay .catch-bar-penalty {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
            border-left: 1px solid #f55;
        }
        #catchDisplay .catch-bar-roll {
            position: absolute;
            top: -1px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            transform: translateX(-50%);
            line-height: 14px;
        }
        #catchDisplay .catch-bar-roll.success { color: #4f4; }
        #catchDisplay .catch-bar-roll.fail { color: #f44; }
        #catchDisplay .defender-info {
            font-size: 10px;
            color: #f99;
        }
        #catchDisplay .throw-rating-info {
            font-size: 10px;
            color: #9cf;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="topBar">
        <div id="downDistance">
            <span class="down">1st</span> & <span class="distance">10</span>
            <span class="field-pos" style="margin-left: 12px; color: #8cf;"></span>
        </div>
        <div id="score">
            <span><span class="label">Catches</span> <span class="catches">0/0</span></span>
            <span><span class="label">TD</span> <span class="touchdowns">0</span></span>
        </div>
        <div id="catchDisplay">
            <div class="catch-header">CATCH</div>
            <div class="catch-bar">
                <div class="catch-bar-base"></div>
                <div class="catch-bar-penalty"></div>
                <div class="catch-bar-roll">üèà</div>
            </div>
            <div class="defender-info"></div>
            <div class="throw-rating-info"></div>
        </div>
    </div>
    <div id="viewButtons">
        <button id="btnHeatMap">Heat Map: OFF</button>
    </div>
    <div id="debugInfo"></div>

    <!-- Training Mode UI -->
    <div id="trainingModeUI" style="display: none;">
        <button id="btnExitTraining" style="
            position: fixed;
            top: 46px;
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
            color: #ccc;
            border: 1px solid #444;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            z-index: 1001;
        ">‚Üê</button>
        <div id="trainingTitle" style="
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #4a4;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1001;
        ">TRAINING MODE</div>
        <div id="throwRating" style="
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.92);
            padding: 20px 28px;
            border-radius: 12px;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1000;
            display: none;
            min-width: 260px;
            cursor: pointer;
        ">
            <div id="throwGrade" style="font-size: 48px; font-weight: bold; color: #4f4;"></div>
            <div id="throwDetails" style="font-size: 13px; color: #aaa; margin-top: 5px;"></div>
            <div id="throwCatchInfo" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid #444;">
                <div id="popupCatchHeader" style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">CATCH</div>
                <div id="popupCatchBar" style="position: relative; width: 200px; height: 18px; background: #222; border-radius: 4px; margin: 0 auto 12px auto; overflow: visible;">
                    <div id="popupCatchBase" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 4px;"></div>
                    <div id="popupCatchPenalty" style="position: absolute; top: 0; height: 100%; background: rgba(0, 0, 0, 0.55); border-left: 2px solid #f55;"></div>
                    <div id="popupCatchRoll" style="position: absolute; top: -2px; font-size: 16px; font-weight: bold; transform: translateX(-50%); line-height: 18px;">üèà</div>
                </div>
                <div id="popupModifierList" style="text-align: left; font-size: 13px; margin-top: 10px;"></div>
            </div>
            <div id="popupTapToContinue" style="margin-top: 16px; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px;">tap to continue</div>
        </div>
        <!-- Settings Button -->
        <button id="btnTrainingSettings" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            font-size: 22px;
            background: rgba(0,0,0,0.7);
            color: #888;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1001;
        ">‚öô</button>
        <!-- Settings Panel -->
        <div id="trainingSettingsPanel" style="
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(0,0,0,0.92);
            padding: 16px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 1002;
            font-family: 'Courier New', monospace;
            min-width: 220px;
        ">
            <div style="color: #fff; font-size: 14px; font-weight: bold; margin-bottom: 12px; border-bottom: 1px solid #444; padding-bottom: 8px;">Training Settings</div>

            <!-- Game Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">GAME SPEED</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="btnGameSpeedDown" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">-</button>
                    <span id="gameSpeedDisplay" style="color: #4f4; font-size: 14px; min-width: 45px; text-align: center;">1.5x</span>
                    <button id="btnGameSpeedUp" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">+</button>
                </div>
            </div>

            <!-- Ball Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">BALL SPEED</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="btnBallSpeedDown" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">-</button>
                    <span id="ballSpeedDisplay" style="color: #4f4; font-size: 14px; min-width: 45px; text-align: center;">1.2x</span>
                    <button id="btnBallSpeedUp" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">+</button>
                </div>
            </div>

            <!-- Receiver Speed Preset -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">RECEIVER SPEED</div>
                <div style="display: flex; gap: 4px;">
                    <button class="rcvr-speed-btn" data-speed="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="rcvr-speed-btn" data-speed="80" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">80</button>
                    <button class="rcvr-speed-btn" data-speed="70" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="rcvr-speed-btn" data-speed="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- DB Speed Preset -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">DB SPEED</div>
                <div style="display: flex; gap: 4px;">
                    <button class="db-speed-btn" data-speed="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="db-speed-btn" data-speed="80" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">80</button>
                    <button class="db-speed-btn" data-speed="70" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="db-speed-btn" data-speed="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- Show Grade Popup Toggle -->
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #888; font-size: 11px;">SHOW GRADE POPUP</span>
                <button id="btnToggleGradePopup" style="padding: 4px 12px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">ON</button>
            </div>
        </div>
    </div>

    <!-- Game Mode Play Result Popup (outside trainingModeUI so it's visible in games) -->
    <div id="playResultPopup" style="
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.92);
        padding: 20px 28px;
        border-radius: 12px;
        color: white;
        font-family: 'Courier New', monospace;
        text-align: center;
        z-index: 1000;
        display: none;
        min-width: 220px;
        cursor: pointer;
    ">
        <div id="playResultMain" style="font-size: 42px; font-weight: bold;"></div>
        <div id="playResultDetail" style="font-size: 14px; color: #aaa; margin-top: 6px;"></div>
        <div id="playResultCatchInfo" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid #444; display: none;">
            <div id="playResultCatchHeader" style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">CATCH</div>
            <div id="playResultCatchBar" style="position: relative; width: 200px; height: 18px; background: #222; border-radius: 4px; margin: 0 auto 12px auto; overflow: visible;">
                <div id="playResultCatchBase" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 4px;"></div>
                <div id="playResultCatchPenalty" style="position: absolute; top: 0; height: 100%; background: rgba(0, 0, 0, 0.55); border-left: 2px solid #f55;"></div>
                <div id="playResultCatchRoll" style="position: absolute; top: -2px; font-size: 16px; font-weight: bold; transform: translateX(-50%); line-height: 18px;">üèà</div>
            </div>
            <div id="playResultModifierList" style="text-align: left; font-size: 13px; margin-top: 10px;"></div>
        </div>
        <div id="playResultDown" style="font-size: 14px; color: #8cf; margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;"></div>
        <div id="playResultFieldPos" style="font-size: 12px; color: #888; margin-top: 4px;"></div>
        <div id="playResultTap" style="margin-top: 14px; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px;">tap to continue</div>
    </div>

    <!-- Management UI Overlay -->
    <div id="managementOverlay">
        <!-- Main Menu -->
        <div id="mainMenuScreen" class="mgmt-screen">
            <h1>SMASHBALL</h1>
            <p class="subtitle">Medieval Football Management</p>
            <button id="btnNewGame" class="mgmt-btn">NEW GAME</button>
            <button id="btnContinue" class="mgmt-btn">CONTINUE</button>
            <button id="btnTrainingMode" class="mgmt-btn" style="margin-top: 30px; background: #2a4a2a;">TRAINING MODE</button>
        </div>

        <!-- Hub Screen -->
        <div id="hubScreen" class="mgmt-screen" style="display:none;">
            <div class="hub-status" id="hubStatus">Fame: 1,000 | Week 1</div>
            <h2>TEAM HUB</h2>
            <div class="hub-buttons">
                <button id="btnPlayGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnRoster" class="mgmt-btn">ROSTER</button>
                <button id="btnFreeAgency" class="mgmt-btn">FREE AGENCY</button>
                <button id="btnSchedule" class="mgmt-btn">SCHEDULE</button>
                <button id="btnFacilities" class="mgmt-btn">FACILITIES</button>
                <button id="btnHubTraining" class="mgmt-btn" style="background: #2a4a2a;">TRAINING</button>
            </div>
            <p id="hubRecord" class="hub-record">Record: 0-0</p>
            <p id="hubNextGame" class="hub-next"></p>
            <button id="btnHubNewGame" class="mgmt-btn danger" style="margin-top: 30px;">NEW GAME</button>
        </div>

        <!-- Roster Screen -->
        <div id="rosterScreen" class="mgmt-screen" style="display:none;">
            <button id="btnRosterBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>ROSTER</h2>
            <div id="rosterList" class="roster-list"></div>
        </div>

        <!-- Free Agency Screen -->
        <div id="freeAgencyScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFABack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FREE AGENCY</h2>
            <p id="faStatus" class="fa-status"></p>
            <div id="freeAgentList" class="roster-list"></div>
        </div>

        <!-- Schedule Screen -->
        <div id="scheduleScreen" class="mgmt-screen" style="display:none;">
            <button id="btnScheduleBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>SCHEDULE</h2>
            <div id="teamStrength" class="team-strength">
                <h3>YOUR TEAM</h3>
                <div class="strength-ratings">
                    <div class="strength-item">
                        <div class="label">OVERALL</div>
                        <div class="value" id="strengthOverall">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">OFFENSE</div>
                        <div class="value" id="strengthOffense">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">DEFENSE</div>
                        <div class="value" id="strengthDefense">--</div>
                    </div>
                </div>
            </div>
            <div id="scheduleList" class="schedule-list"></div>
        </div>

        <!-- Facilities Screen -->
        <div id="facilitiesScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFacilitiesBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FACILITIES</h2>
            <p id="facCredits" class="fac-credits"></p>
            <div class="facility-item">
                <h3>ARENA</h3>
                <p id="arenaLevel">Level 1/5</p>
                <p class="fac-desc">Increases home game revenue</p>
                <button id="btnUpgradeArena" class="mgmt-btn">UPGRADE</button>
            </div>
            <div class="facility-item">
                <h3>TRAINING GROUNDS</h3>
                <p id="trainingLevel">Level 1/5</p>
                <p class="fac-desc">Boosts player development</p>
                <button id="btnUpgradeTraining" class="mgmt-btn">UPGRADE</button>
            </div>
        </div>

        <!-- Match End Screen -->
        <div id="matchEndScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <h1 id="matchResult">VICTORY!</h1>
            <p id="matchScore" class="match-score">21 - 14</p>
            <p id="matchRevenue" class="match-revenue"></p>
            <div id="postGameStats" class="post-game-stats"></div>
            <div class="match-end-buttons">
                <button id="btnMatchContinue" class="mgmt-btn primary">CONTINUE</button>
                <button id="btnShowSimLog" class="mgmt-btn secondary" style="display:none;">VIEW LOG</button>
            </div>
            <div id="simLogContainer" style="display:none;margin-top:15px;">
                <pre id="simLogContent" style="background:#1a1a2e;padding:10px;border-radius:4px;max-height:300px;overflow:auto;font-size:11px;white-space:pre-wrap;text-align:left;"></pre>
                <button id="btnCopySimLog" class="mgmt-btn" style="margin-top:8px;">COPY TO CLIPBOARD</button>
            </div>
        </div>

        <!-- Pre-Game Matchup Screen -->
        <div id="preGameScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <button id="btnPreGameBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2 id="preGameOpponent">VS OPPONENT</h2>
            <div id="preGameTeamScores" class="pre-game-team-scores"></div>
            <div id="preGameQBScores" class="pre-game-qb-scores"></div>
            <div id="preGameMatchups" class="pre-game-matchups"></div>
            <div class="pre-game-buttons">
                <button id="btnStartGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnSimulateGame" class="mgmt-btn secondary">SIMULATE</button>
            </div>
        </div>

        <!-- Player Detail Modal -->
        <div id="playerDetailModal" class="mgmt-modal" style="display:none;">
            <div class="modal-content">
                <button id="btnCloseDetail" class="mgmt-btn back-btn">‚Üê</button>
                <h2 id="playerName">Player Name</h2>
                <div id="playerInfo" class="player-info"></div>
                <div id="playerStats" class="player-stats"></div>
                <div id="playerSeasonStats" class="player-season-stats"></div>
                <div id="playerCareerGraph" class="player-career-graph"></div>
                <div class="modal-actions">
                    <button id="btnTradePlayer" class="mgmt-btn primary">TRADE FOR FAME</button>
                    <button id="btnCutPlayer" class="mgmt-btn danger">CUT PLAYER</button>
                </div>
            </div>
        </div>

        <!-- Draft Screen -->
        <div id="draftScreen" class="mgmt-screen draft-screen" style="display:none;max-width:600px;">
            <button id="btnDraftOptions" class="mgmt-btn back-btn" style="position:absolute;top:10px;right:10px;left:auto;z-index:10;">‚öô</button>

            <!-- Last Pick Notification Bar -->
            <div id="draftLastPick" class="draft-last-pick">
                <span id="draftLastPickText">Draft starting...</span>
            </div>

            <!-- On The Clock Section -->
            <div id="draftOnClock" class="draft-on-clock computer">
                <div class="clock-row">
                    <span id="draftRoundPick">Round 1 ‚Ä¢ Pick 1</span>
                    <span id="draftPoints">1500 pts</span>
                </div>
                <div class="clock-row clock-main">
                    <span id="draftTeamName">Team Name</span>
                    <button id="btnAcquirePick" class="trade-for-btn" style="display:none;">TRADE <span class="trade-cost">0/0</span></button>
                    <button id="btnTradeInPick" class="trade-in-btn" style="display:none;">TRADE IN <span class="trade-value">+0</span></button>
                </div>
            </div>

            <!-- Toggle Buttons -->
            <div class="draft-toggle-buttons">
                <button id="btnDraftPoolView" class="mgmt-btn toggle-btn active">DRAFT POOL</button>
                <button id="btnDraftRosterView" class="mgmt-btn toggle-btn">MY ROSTER</button>
            </div>

            <!-- Player Lists -->
            <div id="draftPlayerList" class="roster-list draft-list"></div>
            <div id="draftRosterList" class="roster-list draft-list" style="display:none;"></div>

            <!-- Status -->
            <p id="draftStatus" class="draft-status"></p>
            <button id="btnSkipRound" class="mgmt-btn secondary" style="display:none;">SKIP PICK</button>
            <button id="btnFinishDraft" class="mgmt-btn primary" style="display:none;">FINISH DRAFT</button>

            <!-- Fixed Bottom Nav Buttons -->
            <div id="draftNavButtons" class="draft-nav-buttons-fixed">
                <button id="btnNextPick" class="mgmt-btn nav-btn">NEXT PICK</button>
                <button id="btnSkipToYourPick" class="mgmt-btn nav-btn skip-btn">SKIP TO YOUR PICK ‚Üí</button>
            </div>
        </div>

        <!-- Draft Options Modal -->
        <div id="draftOptionsModal" class="modal" style="display:none;">
            <div class="modal-content" style="max-width:400px;">
                <h3 style="color:#ffd700;margin-bottom:20px;">DRAFT OPTIONS</h3>
                <div class="options-row">
                    <label for="pickTradeInPenalty">Trade In Penalty (pts):</label>
                    <input type="number" id="pickTradeInPenalty" min="0" max="500" value="50" style="width:80px;">
                </div>
                <div class="options-row">
                    <label for="pickAcquirePremium">Acquire Premium (%):</label>
                    <input type="number" id="pickAcquirePremium" min="0" max="100" value="10" style="width:80px;">
                </div>
                <div class="options-info" style="color:#888;font-size:12px;margin:15px 0;">
                    <p>‚Ä¢ Trade In Penalty: Points deducted when trading your pick for draft points</p>
                    <p>‚Ä¢ Acquire Premium: Extra % cost when buying another team's pick</p>
                </div>
                <button id="btnSaveDraftOptions" class="mgmt-btn primary">SAVE</button>
                <button id="btnCloseDraftOptions" class="mgmt-btn secondary">CANCEL</button>
            </div>
        </div>
    </div>

    <style>
        #managementOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #0a0a14;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #managementOverlay.hidden { display: none; }
        .mgmt-screen {
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
            width: 100%;
            max-width: 400px;
        }
        .mgmt-screen h1 {
            color: #ffd700;
            font-size: 48px;
            margin: 0 0 10px 0;
        }
        .mgmt-screen h2 {
            color: #ffd700;
            font-size: 28px;
            margin: 50px 0 20px 0;
        }
        .mgmt-screen .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 40px;
        }
        .mgmt-btn {
            display: block;
            width: 100%;
            max-width: 280px;
            margin: 10px auto;
            padding: 16px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: #2a2a40;
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 8px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .mgmt-btn:active { background: #3a3a50; }
        .mgmt-btn:disabled { opacity: 0.5; }
        .mgmt-btn.primary { background: #3a3a60; }
        .mgmt-btn.secondary { background: #2a4a2a; }
        .pre-game-buttons, .match-end-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .pre-game-buttons .mgmt-btn, .match-end-buttons .mgmt-btn {
            flex: 1;
        }
        .mgmt-btn.back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
        }
        .hub-status {
            position: absolute;
            top: 10px;
            right: 15px;
            text-align: right;
            color: #ffd700;
            font-size: 14px;
        }
        .hub-record { font-size: 20px; margin-top: 30px; }
        .hub-next { color: #aaa; font-size: 14px; }
        .roster-list, .schedule-list {
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .roster-item, .schedule-item {
            background: #1a1a2a;
            padding: 12px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-item .name { font-size: 14px; }
        .roster-item .stats { font-size: 12px; color: #aaa; }
        .roster-item .ovr { color: #4f4; font-size: 16px; }
        .position-header {
            background: #2a2a40;
            color: #ffd700;
            padding: 8px 12px;
            margin-top: 12px;
            font-size: 14px;
        }
        .schedule-item.current { background: #2a3a2a; }
        .schedule-item.past { opacity: 0.6; }
        .schedule-item .result { font-weight: bold; }
        .schedule-item .result.win { color: #4f4; }
        .schedule-item .result.loss { color: #f44; }
        .facility-item {
            background: #1a1a2a;
            padding: 16px;
            margin: 12px 0;
            border-radius: 8px;
            text-align: left;
        }
        .facility-item h3 { color: #ffd700; margin: 0 0 8px 0; font-size: 16px; }
        .fac-desc { color: #888; font-size: 12px; margin: 8px 0; }
        .fac-credits { color: #ffd700; font-size: 18px; }
        .fa-status { color: #aaa; font-size: 14px; }
        .draft-budget { color: #4f4; font-size: 20px; font-weight: bold; margin-bottom: 5px; }
        .draft-status { color: #aaa; font-size: 14px; margin-bottom: 10px; }
        .draft-toggle-buttons { display: flex; gap: 10px; margin-bottom: 15px; justify-content: center; }
        .draft-toggle-buttons .toggle-btn { flex: 1; max-width: 150px; padding: 8px 12px; font-size: 12px; background: #2a2a3a; }
        .draft-toggle-buttons .toggle-btn.active { background: #4a4a6a; border-color: #ffd700; }
        .draft-list { max-height: 280px; overflow-y: auto; overflow-x: hidden; }
        .draft-list .roster-item { border-left: 3px solid #333; transition: border-color 0.2s; flex-wrap: nowrap; }
        .draft-list .roster-item:hover { border-left-color: #ffd700; background: #2a2a3a; }
        .draft-list .roster-item.drafted { opacity: 0.4; pointer-events: none; }
        .draft-list .roster-item.unaffordable { opacity: 0.5; border-left-color: #633; }
        .draft-list .roster-item.unaffordable:hover { border-left-color: #833; }
        .draft-cost { color: #4f4; font-size: 12px; font-weight: bold; }
        .draft-cost.expensive { color: #f84; }
        /* Draft Screen Layout */
        .draft-screen {
            padding-bottom: 70px; /* Space for fixed bottom buttons */
        }
        .draft-last-pick {
            background: #1a1a2a;
            padding: 6px 12px;
            margin: 0 -15px 10px -15px;
            font-size: 11px;
            color: #888;
            border-bottom: 1px solid #333;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .draft-last-pick .player-name { color: #fff; }
        .draft-last-pick .team-name { color: #ffd700; }
        .draft-last-pick .overall { color: #4f4; }

        .draft-on-clock {
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            transition: background 0.3s;
        }
        .draft-on-clock.computer {
            background: #1a1a2a;
            border: 1px solid #444;
        }
        .draft-on-clock.player {
            background: #0a2a0a;
            border: 1px solid #4a4;
        }
        .clock-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .clock-row.clock-main {
            margin-top: 4px;
        }
        #draftRoundPick { color: #888; font-size: 11px; }
        #draftPoints { color: #ffd700; font-size: 11px; font-weight: bold; }
        #draftTeamName {
            font-size: 16px;
            font-weight: bold;
        }
        .draft-on-clock.computer #draftTeamName { color: #aaa; }
        .draft-on-clock.player #draftTeamName { color: #4f4; }
        .trade-for-btn, .trade-in-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            border: 1px solid;
        }
        .trade-for-btn {
            background: #3a2a2a;
            border-color: #a66;
            color: #faa;
        }
        .trade-for-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .trade-for-btn .trade-cost { color: #f88; margin-left: 4px; }
        .trade-in-btn {
            background: #2a3a2a;
            border-color: #6a6;
            color: #afa;
        }
        .trade-in-btn .trade-value { color: #4f4; font-weight: bold; }

        .draft-nav-buttons-fixed {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            gap: 10px;
            padding: 12px;
            background: #0a0a14;
            border-top: 1px solid #333;
            justify-content: center;
            z-index: 100;
        }
        .draft-nav-buttons-fixed .nav-btn {
            flex: 1;
            max-width: 180px;
            padding: 12px;
            font-size: 12px;
            background: #2a2a4a;
        }
        .draft-nav-buttons-fixed .nav-btn.skip-btn {
            background: #3a3a2a;
            border-color: #aa4;
        }
        .options-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            color: #fff;
        }
        .options-row label {
            font-size: 14px;
        }
        .options-row input {
            background: #2a2a40;
            border: 1px solid #444;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .fa-btn { padding: 8px 16px; font-size: 14px; }
        .match-score { font-size: 36px; margin: 20px 0; }
        .match-revenue { color: #4f4; font-size: 18px; margin-bottom: 15px; }
        #matchResult.win { color: #4f4; }
        #matchResult.loss { color: #f44; }

        /* Post-game stats - roster-like layout */
        .post-game-stats {
            max-height: 350px;
            overflow-y: auto;
            margin: 10px 0;
            text-align: left;
        }
        .post-game-section {
            margin-bottom: 12px;
        }
        .post-game-section-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 6px;
            padding-left: 4px;
        }
        .post-game-player {
            background: #1a1a2a;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .post-game-player:hover {
            background: #252540;
        }
        .post-game-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .post-game-player-name {
            font-weight: bold;
            color: #fff;
        }
        .post-game-player-ovr {
            font-weight: bold;
            color: #ffd700;
            font-size: 16px;
        }
        .post-game-player-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 11px;
        }
        .post-game-stat {
            display: flex;
            align-items: baseline;
            gap: 3px;
        }
        .post-game-stat-value {
            color: #4af;
            font-size: 13px;
            font-weight: bold;
        }
        .post-game-stat-label {
            font-size: 10px;
            color: #888;
        }
        .post-game-no-stats {
            color: #555;
            font-size: 11px;
            font-style: italic;
        }
        .post-game-stat.fame-stat .post-game-stat-value {
            color: #ffd700;
        }
        .post-game-stat.fame-stat .post-game-stat-label {
            color: #ffd700;
        }

        /* Pre-game matchups */
        .pre-game-matchups {
            margin: 15px 0;
            text-align: left;
        }
        .matchup-section {
            margin: 12px 0;
            padding: 10px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .matchup-section-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .matchup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .matchup-row:last-child { border-bottom: none; }
        .matchup-player {
            flex: 1;
            font-size: 13px;
        }
        .matchup-player.yours { color: #4af; }
        .matchup-player.theirs { color: #f66; text-align: right; }
        .matchup-vs {
            color: #666;
            padding: 0 8px;
            font-size: 11px;
        }
        .matchup-ovr {
            font-weight: bold;
            font-size: 14px;
        }
        .matchup-ovr.advantage { color: #4f4; }
        .matchup-ovr.disadvantage { color: #f44; }
        .matchup-ovr.even { color: #ff0; }

        /* Pre-game team scores */
        .pre-game-team-scores {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .team-score-block {
            text-align: center;
        }
        .team-score-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .team-score-value {
            font-size: 28px;
            font-weight: bold;
        }
        .team-score-value.yours { color: #4af; }
        .team-score-value.theirs { color: #f66; }
        .team-score-vs {
            font-size: 18px;
            color: #666;
            align-self: center;
        }

        /* Pre-game QB scores */
        .pre-game-qb-scores {
            display: flex;
            justify-content: space-around;
            margin: 10px 0 15px 0;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .qb-stat-block {
            text-align: center;
        }
        .qb-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        .qb-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4af;
        }

        /* Player Detail Modal */
        .mgmt-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            overflow-y: auto;
        }
        .modal-content {
            background: #0a0a14;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .modal-content h2 {
            color: #ffd700;
            margin: 40px 0 10px 0;
            text-align: center;
        }
        .player-info {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .player-info .ovr-big {
            font-size: 48px;
            color: #4f4;
            font-weight: bold;
        }
        .player-info .season-change {
            font-size: 18px;
            margin-left: 10px;
        }
        .player-stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .stat-row {
            background: #1a1a2a;
            padding: 10px 12px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        .stat-row .stat-name { color: #aaa; }
        .stat-row .stat-values {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .stat-row .stat-value {
            font-weight: bold;
            min-width: 24px;
            text-align: right;
        }
        .stat-row .stat-change {
            font-size: 12px;
            min-width: 28px;
            text-align: right;
        }
        /* Stat color coding by value */
        .stat-elite { color: #4f4; }      /* 90+ green */
        .stat-good { color: #8f8; }       /* 80-89 light green */
        .stat-average { color: #ff0; }    /* 70-79 yellow */
        .stat-below { color: #f80; }      /* 60-69 orange */
        .stat-poor { color: #f44; }       /* <60 red */
        .stat-change.positive { color: #4f4; }
        .stat-change.negative { color: #f44; }

        /* Unified Stats Panel */
        .stats-panel {
            background: #1a1a2a;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        .stats-section {
            margin-bottom: 8px;
        }
        .stats-section:last-child {
            margin-bottom: 0;
        }
        .stats-section-title {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px 8px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }
        .stat-row-name {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #aaa;
            font-size: 11px;
        }
        .stat-row-value {
            font-weight: bold;
            font-size: 11px;
        }
        .stat-row.best-ability {
            background: #2a3a2a;
            border-radius: 3px;
            padding: 2px 4px;
            margin: -2px -4px;
        }
        /* Core attribute colors */
        .stat-row.str-row .stat-row-name { color: #ff6b6b; }
        .stat-row.spd-row .stat-row-name { color: #4dabf7; }
        .stat-row.agi-row .stat-row-name { color: #69db7c; }
        .stat-row.int-row .stat-row-name { color: #ffd43b; }
        /* Attribute indicator dots */
        .attr-dots {
            display: inline-flex;
            gap: 2px;
            margin-right: 2px;
        }
        .attr-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        .attr-dot.str { background: #ff6b6b; }
        .attr-dot.spd { background: #4dabf7; }
        .attr-dot.agi { background: #69db7c; }
        .attr-dot.int { background: #ffd43b; }

        /* Keep old styles for backwards compatibility but hide */
        .core-attributes-section, .abilities-section, .technique-section { display: none; }

        /* Tooltip System */
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #444;
            color: #aaa;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            flex-shrink: 0;
        }
        .tooltip-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px 12px;
            min-width: 200px;
            max-width: 280px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            font-size: 12px;
            line-height: 1.4;
            color: #ddd;
            text-align: left;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #444;
        }
        .tooltip-wrapper:hover .tooltip-content,
        .tooltip-wrapper:focus .tooltip-content,
        .tooltip-wrapper:active .tooltip-content {
            opacity: 1;
            visibility: visible;
        }
        .tooltip-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 4px;
        }
        .tooltip-desc {
            color: #bbb;
            margin-bottom: 6px;
        }
        .tooltip-formula {
            font-size: 10px;
            color: #888;
            font-style: italic;
        }
        .tooltip-counters {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #333;
            font-size: 10px;
            color: #8f8;
        }

        /* Season stats section */
        .player-season-stats {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .season-stats-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .season-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        .season-stat-item {
            text-align: center;
        }
        .season-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4f4;
        }
        .season-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        /* Career graph section */
        .player-career-graph {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .career-graph-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .career-graph-container {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 4px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .career-bar {
            flex: 1;
            min-width: 20px;
            max-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .career-bar-fill {
            width: 100%;
            background: linear-gradient(to top, #4f4, #8f8);
            border-radius: 2px 2px 0 0;
            position: relative;
        }
        .career-bar-potential {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-size: 8px;
        }
        .career-bar-label {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }
        .career-bar-ovr {
            font-size: 10px;
            color: #fff;
            margin-bottom: 2px;
        }
        .modal-actions {
            margin-top: 20px;
            text-align: center;
        }
        .mgmt-btn.danger {
            background: #4a2020;
            border-color: #f44;
            color: #f44;
        }
        .roster-item { cursor: pointer; }
        .roster-item:active { background: #2a2a3a; }
        .roster-item .season-gain {
            font-size: 12px;
            margin-left: 8px;
        }
        .season-gain.positive { color: #4f4; }
        .season-gain.negative { color: #f44; }

        /* Team Strength Display */
        .team-strength {
            background: #1a1a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .team-strength h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .strength-ratings {
            display: flex;
            justify-content: space-around;
        }
        .strength-item {
            text-align: center;
        }
        .strength-item .label { color: #888; font-size: 11px; }
        .strength-item .value { color: #4f4; font-size: 20px; font-weight: bold; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        console.log('=== SMASHBALL SCRIPT LOADING ===');
        // Game State
        const gameState = {
            catches: 0,
            attempts: 0,            // Total catch attempts
            touchdowns: 0,          // Touchdowns scored
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            activePointerId: null,  // Track which pointer is dragging
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            offensiveLine: [],      // O-line players
            defensiveLine: [],      // D-line players
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0,  // Seconds between time-based clashes
            playStartTime: 0,  // When current play started (for label fading)
            ballCarrier: null,      // Receiver carrying the ball after catch
            playEnded: false,       // Track if play has ended (tackle/sack/TD)
            waitingForPossession: false, // Pause game during possession overlay
            playFrozen: true,       // Play frozen until player holds screen
            qbSacked: false,        // Track if QB was sacked
            qbStartZ: -6,           // QB's randomized starting position (set each play)
            currentView: 'iso',     // Camera view: 'iso', 'overhead', 'shoulder'
            // Game speed control
            gameSpeedMultiplier: 1.5, // Adjustable game speed (0.5 = slow, 1.0 = normal, 1.5 = fast)
            ballSpeedMultiplier: 1.2, // Adjustable ball speed
            showGradePopup: true,     // Whether to show the grade popup after throws
            receiverSpeedPreset: 80,  // Receiver speed preset (90, 80, 70, or 'mixed')
            dbSpeedPreset: 80,        // DB speed preset (90, 80, 70, or 'mixed')
            // Down and distance tracking
            down: 1,                // Current down (1-4)
            yardsToGo: 10,          // Yards needed for first down
            lineOfScrimmage: -29,   // Current field position (Z coordinate) - opponent 40 yard line
            firstDownMarker: -19,   // Z position where first down is achieved (10 yards ahead)
            startingLineOfScrimmage: -29,  // Where drive started - opponent 40 yard line
            // Training mode
            trainingMode: false,    // Training mode: no defenders, throw ratings
            lastThrowRating: null,  // Last throw rating for display
            // Debug visualization
            showThrowHeatMap: false,
            heatMapMeshes: []
        };

        // Base speed factors - all player speeds are relative to these
        const SPEED_CONSTANTS = {
            RECEIVER_FACTOR: 0.00064,   // Base: speed stat 80 = 0.0512 units/frame
            DEFENDER_FACTOR: 0.00064,   // Same as receivers for fair matchups
            O_LINE_FACTOR: 0.0004,      // Slower for linemen
            D_LINE_FACTOR: 0.0005       // Slightly faster rush
        };

        // Per-game stats tracking (reset each match)
        const gameStats = {
            players: {},  // Keyed by playerId

            // Initialize or get player stats
            getPlayer(playerId, name) {
                if (!this.players[playerId]) {
                    this.players[playerId] = {
                        name: name || 'Unknown',
                        // Catching
                        catches: 0,
                        drops: 0,
                        catchDifficulties: [],  // Array of difficulty values
                        yardsAfterCatch: 0,
                        // Throwing (QB)
                        completions: 0,
                        incompletions: 0,
                        throwDistances: [],     // Total distance
                        airDistances: [],       // In-air distance
                        // Clashes
                        clashesWon: 0,
                        clashesLost: 0,
                        clashDifficulties: [],  // Margin of win/loss
                        // Defense
                        sacks: 0,
                        tackles: 0,
                        passesDefended: 0,
                        // Touchdowns
                        touchdowns: 0
                    };
                }
                return this.players[playerId];
            },

            // Reset all stats for new game
            reset() {
                this.players = {};
            }
        };

        // Management mode flag - when false, game input is disabled
        let gameSceneActive = false;

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 1.8,           // Distance for clash detection (reduced for more separation time)
            SEPARATION_THRESHOLD: 3,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 3,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
        };

        // Line clash system constants
        const LINE_CLASH_CONSTANTS = {
            CLASH_RANGE: 1.5,           // Distance for line clash detection
            CLASH_INTERVAL: 0.5,        // Seconds between clash resolutions while engaged
            NEUTRAL_SPEED: 0.05,        // Near-zero speed on neutral clash
            OFFENSE_WIN_THRESHOLD: 5,   // Margin needed for O-line to win decisively
            DEFENSE_WIN_THRESHOLD: 5,   // Margin needed for D-line to win decisively
            KNOCKDOWN_DURATION: 1.0,    // Seconds knocked down
            SPEED_BURST_MULTIPLIER: 1.5,// Speed boost after D-line wins
            SPEED_BURST_DURATION: 1.5,  // Duration of speed burst
            TACKLE_RANGE: 1.2,          // Distance for QB sack
            SNAP_DELAY: 1.5,            // Seconds before D-line starts rushing (QB drop-back time)
        };

        // Receiver tackling constants
        const TACKLE_CONSTANTS = {
            TACKLE_RANGE: 1.0,          // Distance for tackle attempt
            TACKLE_INTERVAL: 0.3,       // Seconds between tackle attempts
            STUMBLE_DURATION: 0.5,      // How long defender stumbles after failed tackle
            BREAK_TACKLE_BOOST: 1.3,    // Speed boost after breaking tackle
            BREAK_TACKLE_DURATION: 0.8, // Duration of break tackle speed boost
        };

        // QB pocket constants
        const POCKET_CONSTANTS = {
            POCKET_CENTER_Z: -7,        // Ideal pocket depth (3 yards behind LOS)
            POCKET_MIN_X: -3,           // Pocket left boundary
            POCKET_MAX_X: 3,            // Pocket right boundary
            POCKET_MAX_DEPTH: -10,      // Don't go deeper than this
            LINE_OF_SCRIMMAGE: -4,      // Can't cross this going forward
            THREAT_RADIUS: 4,           // Start evading when defender this close
            EVADE_SPEED: 0.06,          // Speed when evading
            SETTLE_SPEED: 0.03,         // Speed when settling into pocket
        };

        // Stat weights for clash resolution
        // Note: speed, agility, strength now come from coreAttributes (merged with old stats)
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.35, acceleration: 0.15 },
                defender: { speed: 0.20, agility: 0.20, awareness: 0.25, pursuit: 0.20, tackling: 0.15 }
            },
            lineClash: {
                offense: { passBlock: 0.35, strength: 0.30, balance: 0.20, awareness: 0.15 },
                defense: { passRush: 0.35, strength: 0.30, acceleration: 0.20, speed: 0.15 }
            },
            tackle: {
                tackler: { tackling: 0.70, pursuit: 0.30 },
                ballCarrier: { agility: 0.35, speed: 0.30, evasion: 0.35 }
            }
        };

        // ========================================
        // ABILITY SELECTION SYSTEM
        // ========================================
        // Matchup matrix: DL ability effectiveness vs OL ability (multiplier)
        // > 1.0 = DL has advantage, < 1.0 = OL has advantage
        const ABILITY_MATCHUPS = {
            linemen: {
                bullRush:   { anchor: 0.85, handFighting: 1.00, footwork: 1.15, driveBlock: 0.95 },
                blockShed:  { anchor: 1.10, handFighting: 0.90, footwork: 1.05, driveBlock: 0.95 },
                spinMove:   { anchor: 1.20, handFighting: 1.05, footwork: 0.85, driveBlock: 1.10 },
                swimMove:   { anchor: 1.15, handFighting: 0.85, footwork: 0.95, driveBlock: 1.05 }
            },
            // WR/CB matchups: WR ability effectiveness vs CB ability
            receivers: {
                releaseMove:   { pressCoverage: 0.90, manCoverage: 1.10, zoneCoverage: 1.05, ballHawk: 1.00 },
                routeSharpness: { pressCoverage: 1.05, manCoverage: 0.90, zoneCoverage: 1.15, ballHawk: 1.00 }
            }
        };

        // Select ability based on 60/30/10 rule for highest/second/third
        function selectAbility(player, abilityType) {
            const abilities = calculateAbilities(player);
            if (!abilities) return null;

            // Get abilities sorted by value (highest first)
            const sorted = Object.entries(abilities)
                .sort((a, b) => b[1] - a[1]);

            if (sorted.length === 0) return null;

            // 60% highest, 30% second, 10% third (or lower if not enough abilities)
            const roll = Math.random() * 100;
            let selectedIndex = 0;

            if (roll < 60) {
                selectedIndex = 0;  // Highest (60%)
            } else if (roll < 90 && sorted.length > 1) {
                selectedIndex = 1;  // Second highest (30%)
            } else if (sorted.length > 2) {
                selectedIndex = 2;  // Third highest (10%)
            } else if (sorted.length > 1) {
                selectedIndex = 1;  // Fallback to second if no third
            }

            return { name: sorted[selectedIndex][0], value: sorted[selectedIndex][1] };
        }

        // Check if reacting player should use a counter ability
        // Returns the counter ability if they choose to use it, otherwise null
        function selectCounterAbility(reactingPlayer, initiatingAbility, matchupTable) {
            const abilities = calculateAbilities(reactingPlayer);
            if (!abilities || !matchupTable[initiatingAbility]) return null;

            const intelligence = reactingPlayer.coreAttributes?.intelligence || 50;
            const counterChance = Math.max(0, intelligence - 20) / 100;  // (INT - 20)%

            // Only attempt counter if roll succeeds
            if (Math.random() > counterChance) return null;

            // Find the ability that gives best matchup against initiating ability
            const matchups = matchupTable[initiatingAbility];
            let bestCounter = null;
            let bestAdvantage = 0;

            for (const [abilityName, multiplier] of Object.entries(matchups)) {
                if (abilities[abilityName]) {
                    // Lower multiplier = better for defender (OL) in linemen matchups
                    // For receivers table, we flip the logic
                    const advantage = 1 - multiplier;  // Positive = good for reacting player
                    const effectiveStrength = abilities[abilityName] * (1 + advantage * 0.5);

                    if (!bestCounter || effectiveStrength > bestAdvantage) {
                        bestCounter = { name: abilityName, value: abilities[abilityName] };
                        bestAdvantage = effectiveStrength;
                    }
                }
            }

            return bestCounter;
        }

        // Resolve ability clash between two players
        // Returns { initiator: ability, reactor: ability, matchupMultiplier }
        function resolveAbilityClash(initiator, reactor, matchupTable, isInitiatorAttacker = true) {
            // Initiator selects ability (60/30/10 rule)
            const initiatorAbility = selectAbility(initiator);
            if (!initiatorAbility) {
                return { initiator: null, reactor: null, matchupMultiplier: 1.0 };
            }

            // Reactor tries to counter (INT-20)% chance, otherwise uses 60/30/10
            let reactorAbility = selectCounterAbility(reactor, initiatorAbility.name, matchupTable);
            if (!reactorAbility) {
                reactorAbility = selectAbility(reactor);
            }

            // Get matchup multiplier
            let matchupMultiplier = 1.0;
            if (initiatorAbility && reactorAbility && matchupTable[initiatorAbility.name]) {
                matchupMultiplier = matchupTable[initiatorAbility.name][reactorAbility.name] || 1.0;
            }

            return {
                initiator: initiatorAbility,
                reactor: reactorAbility,
                matchupMultiplier: matchupMultiplier
            };
        }

        // Calculate core√óability multiplicative value for a player
        // Returns value scaled to be used in clash rolls
        // The core stat contribution is based on the ability's ABILITY_CORE_MAPPING
        function getCoreAbilityRoll(player, selectedAbility) {
            if (!player.coreAttributes || !selectedAbility) return 30; // Default fallback

            const mapping = ABILITY_CORE_MAPPING[selectedAbility.name];
            if (!mapping) return 30;

            // Calculate weighted core stat based on ability's core mapping
            let weightedCoreStat = 0;
            for (const [attr, weight] of Object.entries(mapping)) {
                const coreValue = player.coreAttributes[attr] || 50;
                weightedCoreStat += coreValue * weight;
            }

            // Multiplicative: (coreStat/100) √ó (ability/100) scaled to contribute 60% of total
            // If both are 90: (0.9 √ó 0.9) = 0.81 √ó 60 = 48.6
            // If both are 70: (0.7 √ó 0.7) = 0.49 √ó 60 = 29.4
            const coreNorm = weightedCoreStat / 100;
            const abilityNorm = selectedAbility.value / 100;
            const multiplicativeValue = coreNorm * abilityNorm * 60;

            return multiplicativeValue;
        }

        // Calculate technique-only roll (40% of total clash value)
        function getTechniqueRoll(stats, weights, coreAttributes = null) {
            // Filter to only non-core stats (technique stats)
            const coreStats = ['speed', 'agility', 'strength', 'intelligence'];
            let techniqueTotal = 0;
            let techniqueWeightSum = 0;

            for (const stat in weights) {
                if (!coreStats.includes(stat)) {
                    const statValue = stats[stat] || 50;
                    techniqueTotal += statValue * weights[stat];
                    techniqueWeightSum += weights[stat];
                }
            }

            // Normalize if we have technique stats, scale to 40% contribution
            if (techniqueWeightSum > 0) {
                // Normalize to 0-100 range, then scale to 40% of total
                const normalized = techniqueTotal / techniqueWeightSum;
                return normalized * 0.4;
            }

            return 20; // Default if no technique stats
        }

        // ========================================
        // ROUTE TEMPLATES FOR SIMULATION
        // ========================================
        // Each route has per-round depth (yards from LOS) and crossing (direction change)
        // When crossing = true, receiver moves horizontally so depth stays same or gains minimally
        // breakRound is when the route "breaks" - creates separation opportunity
        const ROUTE_TEMPLATES = {
            standard: {
                go: {
                    name: 'go',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 20, crossing: false },
                        { depth: 28, crossing: false },
                        { depth: 35, crossing: false }
                    ],
                    breakRound: null
                },
                slant: {
                    name: 'slant',
                    rounds: [
                        { depth: 3, crossing: false },  // Vertical stem past LOS first
                        { depth: 6, crossing: true },   // Then diagonal cross
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false }
                    ],
                    breakRound: 2
                },
                out: {
                    name: 'out',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking out - no depth gain
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: 2
                },
                in: {
                    name: 'in',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking in - no depth gain
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 2
                },
                post: {
                    name: 'post',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking post - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                corner: {
                    name: 'corner',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking corner - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                curl: {
                    name: 'curl',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 10, crossing: true },  // Coming back - loses depth
                        { depth: 10, crossing: false },
                        { depth: 10, crossing: false }
                    ],
                    breakRound: 3
                },
                comeback: {
                    name: 'comeback',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 14, crossing: false },
                        { depth: 12, crossing: true },  // Coming back - loses depth
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 3
                },
                dig: {
                    name: 'dig',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: true },  // Crossing - no depth gain
                        { depth: 14, crossing: false },
                        { depth: 14, crossing: false }
                    ],
                    breakRound: 3
                },
                seam: {
                    name: 'seam',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 10, crossing: false },
                        { depth: 16, crossing: false },
                        { depth: 22, crossing: false },
                        { depth: 28, crossing: false }
                    ],
                    breakRound: null
                },
                flat: {
                    name: 'flat',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Then horizontal cross
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false }
                    ],
                    breakRound: 2
                },
                wheel: {
                    name: 'wheel',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Release horizontally
                        { depth: 8, crossing: false },  // Turn upfield
                        { depth: 16, crossing: false },
                        { depth: 24, crossing: false }
                    ],
                    breakRound: 2
                },
                hitch: {
                    name: 'hitch',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },  // Stop and wait
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 1
                }
            },
            redzone: {
                fade: {
                    name: 'fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 15, crossing: false },
                        { depth: 15, crossing: false }
                    ],
                    breakRound: null
                },
                back_shoulder: {
                    name: 'back_shoulder',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 8, crossing: true },   // Fading back - loses depth
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 3
                },
                corner_fade: {
                    name: 'corner_fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 5, crossing: true },   // Breaking corner - minimal gain
                        { depth: 10, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 2
                },
                quick_slant: {
                    name: 'quick_slant',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 4, crossing: true },   // Then diagonal slant
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false }
                    ],
                    breakRound: 2
                },
                out_quick: {
                    name: 'out_quick',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: true },   // Breaking out - no depth gain
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                }
            },
            goalline: {
                endzone_fade: {
                    name: 'endzone_fade',
                    rounds: [
                        { depth: 2, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: null
                },
                endzone_slant: {
                    name: 'endzone_slant',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step into endzone
                        { depth: 3, crossing: true },   // Then diagonal cross
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_out: {
                    name: 'endzone_out',
                    rounds: [
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: true },   // Breaking out - no depth gain
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_flat: {
                    name: 'endzone_flat',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step forward
                        { depth: 2, crossing: true },   // Then horizontal cross
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false }
                    ],
                    breakRound: 2
                }
            }
        };

        // QB personality traits that affect decision making
        const QB_TRAITS = {
            gunslinger: {
                name: 'Gunslinger',
                description: 'Waits for big plays, takes risks',
                openThreshold: 60,       // Needs higher catch % to throw
                pressureMultiplier: 0.7, // Less affected by pressure
                firstDownBias: -10,      // Less likely to take short gains
                aggressiveness: 1.3      // More likely to throw into coverage
            },
            game_manager: {
                name: 'Game Manager',
                description: 'Takes safe throws, avoids mistakes',
                openThreshold: 45,       // Throws to first open receiver
                pressureMultiplier: 1.3, // More affected by pressure
                firstDownBias: 20,       // Heavily favors first down throws
                aggressiveness: 0.7      // Avoids risky throws
            },
            balanced: {
                name: 'Balanced',
                description: 'Adapts to situation',
                openThreshold: 52,
                pressureMultiplier: 1.0,
                firstDownBias: 5,
                aggressiveness: 1.0
            },
            scrambler: {
                name: 'Scrambler',
                description: 'Prefers to run when pressured',
                openThreshold: 55,
                pressureMultiplier: 0.5, // Much less affected by pressure
                firstDownBias: 0,
                aggressiveness: 0.9,
                scrambleBonus: 20        // Extra likelihood to scramble
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false,  // Show defender zone rings and fills
            showDebugInfo: false       // Show on-screen debug info for coverage/catch factors
        };

        // ========================================
        // MANAGEMENT LAYER - DATA MODELS
        // ========================================

        // Management state - persisted between sessions
        const managementState = {
            team: null,
            season: null,
            freeAgents: [],
            settings: {
                difficulty: 'normal',  // easy, normal, hard
                autoSave: true,
                pickTradeInPenalty: 50,    // Penalty points when trading in your pick
                pickAcquirePremium: 10     // Premium percentage when acquiring another team's pick
            },
            initialized: false,
            currentScreen: 'main_menu',  // main_menu, hub, roster, player_detail, free_agency, facilities, schedule, game, draft
            selectedPlayerId: null,
            matchInProgress: false,
            currentPossession: 0,
            matchScore: { player: 0, opponent: 0 },
            seasonJustEnded: false  // Flag to trigger draft after match end screen
        };

        // Position definitions with stat priorities
        // primaryStats: used for overall calculation
        // techniqueStats: all technique stats used in gameplay calculations (excludes core attributes)
        const POSITIONS = {
            WR: {
                name: 'Wide Receiver',
                shortName: 'WR',
                primaryStats: ['speed', 'catching', 'routeRunning', 'agility'],
                techniqueStats: ['catching', 'routeRunning', 'acceleration', 'evasion'],
                count: 3
            },
            CB: {
                name: 'Cornerback',
                shortName: 'CB',
                primaryStats: ['speed', 'awareness', 'tackling', 'agility'],
                techniqueStats: ['tackling', 'awareness', 'pursuit'],
                count: 4
            },
            OL: {
                name: 'Offensive Lineman',
                shortName: 'OL',
                primaryStats: ['passBlock', 'strength', 'balance', 'awareness'],
                techniqueStats: ['passBlock', 'balance', 'awareness'],
                count: 5
            },
            DL: {
                name: 'Defensive Lineman',
                shortName: 'DL',
                primaryStats: ['passRush', 'strength', 'acceleration', 'tackling'],
                techniqueStats: ['passRush', 'tackling', 'pursuit', 'acceleration'],
                count: 4
            },
            QB: {
                name: 'Quarterback',
                shortName: 'QB',
                primaryStats: ['shortPassAcc', 'longPassAcc', 'awareness', 'agility'],
                techniqueStats: ['shortPassAcc', 'longPassAcc', 'awareness'],
                count: 1
            }
        };

        // Tooltip data for all stats and abilities
        const STAT_TOOLTIPS = {
            // Core Attributes
            strength: {
                name: 'Strength',
                desc: 'Raw physical power. Affects blocking, tackling, and breaking through contact.',
                influences: 'passBlock, passRush, tackling, hitPower, balance',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            speed: {
                name: 'Speed',
                desc: 'Top-end running speed and acceleration.',
                influences: 'speed, acceleration, pursuit',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            agility: {
                name: 'Agility',
                desc: 'Quickness, balance, and change of direction ability.',
                influences: 'agility, routeRunning, release, balance',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            intelligence: {
                name: 'Intelligence',
                desc: 'Mental processing, awareness, and decision-making.',
                influences: 'awareness, routeRunning, field vision',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            // DL Abilities
            bullRush: {
                name: 'Bull Rush',
                desc: 'Power through blockers with pure strength.',
                formula: 'Strength (60%) + Pass Rush (25%) + Intelligence (15%)',
                counters: 'Countered by: Anchor. Effective vs: Footwork'
            },
            blockShed: {
                name: 'Block Shed',
                desc: 'Quickly disengage from blocks.',
                formula: 'Strength (40%) + Agility (40%) + Pass Rush (20%)',
                counters: 'Countered by: Hand Fighting'
            },
            spinMove: {
                name: 'Spin Move',
                desc: 'Spin around blockers with finesse.',
                formula: 'Agility (55%) + Speed (25%) + Pass Rush (20%)',
                counters: 'Countered by: Footwork. Effective vs: Anchor, Drive Block'
            },
            swimMove: {
                name: 'Swim Move',
                desc: 'Swim over the blocker\'s arms.',
                formula: 'Agility (45%) + Speed (35%) + Pass Rush (20%)',
                counters: 'Countered by: Hand Fighting. Effective vs: Anchor'
            },
            // OL Abilities
            anchor: {
                name: 'Anchor',
                desc: 'Hold your ground against power rushes.',
                formula: 'Strength (55%) + Balance (25%) + Pass Block (20%)',
                counters: 'Counters: Bull Rush. Weak vs: Spin Move, Swim Move'
            },
            handFighting: {
                name: 'Hand Fighting',
                desc: 'Control and redirect pass rushers.',
                formula: 'Strength (40%) + Agility (35%) + Pass Block (25%)',
                counters: 'Counters: Block Shed, Swim Move'
            },
            footwork: {
                name: 'Footwork',
                desc: 'Mirror lateral moves of rushers.',
                formula: 'Agility (45%) + Intelligence (30%) + Pass Block (25%)',
                counters: 'Counters: Spin Move. Weak vs: Bull Rush'
            },
            driveBlock: {
                name: 'Drive Block',
                desc: 'Sustain blocks and create push.',
                formula: 'Strength (40%) + Intelligence (30%) + Pass Block (30%)',
                counters: 'Weak vs: Spin Move'
            },
            // CB Abilities
            pressCoverage: {
                name: 'Press Coverage',
                desc: 'Jam receivers at the line of scrimmage.',
                formula: 'Strength (45%) + Intelligence (35%) + Awareness (20%)',
                counters: 'Countered by: Release Move'
            },
            manCoverage: {
                name: 'Man Coverage',
                desc: 'Stick with receivers in man-to-man.',
                formula: 'Speed (40%) + Agility (40%) + Awareness (20%)',
                counters: 'Used vs: Route Sharpness'
            },
            zoneCoverage: {
                name: 'Zone Coverage',
                desc: 'Read routes and defend zone areas.',
                formula: 'Intelligence (45%) + Agility (35%) + Awareness (20%)',
                counters: 'Used vs: Route Sharpness'
            },
            ballHawk: {
                name: 'Ball Hawk',
                desc: 'Anticipate and intercept passes.',
                formula: 'Intelligence (40%) + Speed (35%) + Awareness (25%)',
                counters: 'Used in contested catch situations'
            },
            // WR Abilities
            releaseMove: {
                name: 'Release Move',
                desc: 'Beat press coverage at the line.',
                formula: 'Agility (45%) + Strength (35%) + Route Running (20%)',
                counters: 'Counters: Press Coverage'
            },
            routeSharpness: {
                name: 'Route Sharpness',
                desc: 'Create separation on routes.',
                formula: 'Agility (40%) + Speed (35%) + Route Running (25%)',
                counters: 'Used vs: Man/Zone Coverage'
            },
            contestedCatch: {
                name: 'Contested Catch',
                desc: 'Catch passes with defenders nearby.',
                formula: 'Strength (30%) + Intelligence (25%) + Catching (25%) + Focus (20%)',
                counters: 'Used vs: Ball Hawk'
            },
            yacAbility: {
                name: 'YAC Ability',
                desc: 'Gain yards after the catch.',
                formula: 'Speed (40%) + Agility (40%) + Balance (20%)',
                counters: 'Used for tackle evasion'
            },
            // QB Abilities
            armStrength: {
                name: 'Arm Strength',
                desc: 'Throw with power downfield.',
                formula: 'Strength (45%) + Throwing (35%) + Intelligence (20%)'
            },
            quickRelease: {
                name: 'Quick Release',
                desc: 'Fast delivery and touch passes.',
                formula: 'Agility (40%) + Throwing (35%) + Intelligence (25%)'
            },
            fieldVision: {
                name: 'Field Vision',
                desc: 'Read defenses and make decisions.',
                formula: 'Intelligence (55%) + Awareness (30%) + Throwing (15%)'
            },
            pocketPresence: {
                name: 'Pocket Presence',
                desc: 'Escape pressure and extend plays.',
                formula: 'Agility (45%) + Speed (35%) + Awareness (20%)'
            },
            // Technique Stats (trained skills)
            catching: {
                name: 'Catching',
                desc: 'Ability to secure the ball and concentrate under pressure.',
                influences: 'Base catch probability (0-100%), contested catch bonus, catch zone radius',
                growth: 'Technique - can improve through training and game reps'
            },
            routeRunning: {
                name: 'Route Running',
                desc: 'Precision in running routes and getting off the line against press coverage.',
                influences: 'Separation clash (35% weight), route sharpness ability, release move ability',
                growth: 'Technique - can improve through training and game reps'
            },
            tackling: {
                name: 'Tackling',
                desc: 'Form, technique, and hitting power in bringing down ball carriers.',
                influences: 'Tackle clash (70% weight), tackle success rate',
                growth: 'Technique - can improve through training and game reps'
            },
            awareness: {
                name: 'Awareness',
                desc: 'Field awareness and reading plays.',
                influences: 'Coverage abilities, line clash (OL), separation defense',
                growth: 'Technique - can improve through training and game reps'
            },
            pursuit: {
                name: 'Pursuit',
                desc: 'Chasing down ball carriers and closing on plays.',
                influences: 'Tackle clash (30% weight), pursuit speed boost',
                growth: 'Technique - can improve through training and game reps'
            },
            passBlock: {
                name: 'Pass Block',
                desc: 'Technique in protecting the quarterback.',
                influences: 'Line clash (35% weight), all OL abilities',
                growth: 'Technique - can improve through training and game reps'
            },
            passRush: {
                name: 'Pass Rush',
                desc: 'Technique in rushing the passer.',
                influences: 'Line clash (35% weight), all DL abilities',
                growth: 'Technique - can improve through training and game reps'
            },
            balance: {
                name: 'Balance',
                desc: 'Staying on feet during contact in the trenches.',
                influences: 'Line clash (OL 20%)',
                growth: 'Technique - can improve through training and game reps'
            },
            shortPassAcc: {
                name: 'Short Pass Acc',
                desc: 'Accuracy on short passes (under 12 yards). Combined with agility for throw accuracy.',
                influences: 'Lead bonus on short routes, catch probability',
                growth: 'Technique - can improve through training and game reps'
            },
            longPassAcc: {
                name: 'Long Pass Acc',
                desc: 'Accuracy on deep passes (12+ yards). Combined with agility for throw accuracy.',
                influences: 'Lead bonus on deep routes, catch probability',
                growth: 'Technique - can improve through training and game reps'
            },
            acceleration: {
                name: 'Acceleration',
                desc: 'Burst speed and explosiveness off the line.',
                influences: 'Separation clash (15%), line clash defense (20%), YAC (25%)',
                growth: 'Technique - can improve through training and game reps'
            },
            evasion: {
                name: 'Evasion',
                desc: 'Ability to avoid tackles and stay on feet during contact.',
                influences: 'Tackle evasion (35% weight), YAC ability',
                growth: 'Technique - can improve through training and game reps'
            }
        };

        // Helper to create tooltip HTML
        function createTooltip(key) {
            const data = STAT_TOOLTIPS[key];
            if (!data) return '';

            let html = `<div class="tooltip-wrapper" tabindex="0">
                <span class="tooltip-icon">i</span>
                <div class="tooltip-content">
                    <div class="tooltip-title">${data.name}</div>
                    <div class="tooltip-desc">${data.desc}</div>`;

            if (data.formula) {
                html += `<div class="tooltip-formula">${data.formula}</div>`;
            }
            if (data.influences) {
                html += `<div class="tooltip-formula">Influences: ${data.influences}</div>`;
            }
            if (data.growth) {
                html += `<div class="tooltip-formula">${data.growth}</div>`;
            }
            if (data.counters) {
                html += `<div class="tooltip-counters">${data.counters}</div>`;
            }

            html += '</div></div>';
            return html;
        }

        // Medieval-themed name pools
        const FIRST_NAMES = [
            'Aldric', 'Baldwin', 'Cedric', 'Duncan', 'Edmund', 'Fabian', 'Gareth', 'Harold',
            'Ivan', 'Jasper', 'Kendrick', 'Leopold', 'Magnus', 'Norbert', 'Oswald', 'Percival',
            'Quincy', 'Roderick', 'Sigmund', 'Thaddeus', 'Ulric', 'Victor', 'Wallace', 'Xavier',
            'Yorick', 'Zephyr', 'Arthur', 'Bernard', 'Conrad', 'Dorian', 'Edgar', 'Felix',
            'Geoffrey', 'Hugo', 'Ignatius', 'Julius', 'Klaus', 'Lionel', 'Marcus', 'Neville'
        ];

        const LAST_NAMES = [
            'Blackwood', 'Ironforge', 'Stoneheart', 'Thornfield', 'Winterbane', 'Ashford',
            'Brighthelm', 'Coldwell', 'Darkwater', 'Everhart', 'Foxworth', 'Grimshaw',
            'Hawthorne', 'Ironcrest', 'Jarvis', 'Kingsley', 'Lockwood', 'Montague',
            'Northwind', 'Oakenshield', 'Proudfoot', 'Queensbury', 'Ravenwood', 'Silverton',
            'Thunderstone', 'Underhill', 'Vanguard', 'Westbrook', 'Yarrow', 'Zephyrus',
            'Battleborn', 'Crossbow', 'Dragonbane', 'Eaglecrest', 'Flameheart', 'Goldmane'
        ];

        // Team name components
        const TEAM_CITIES = [
            'Ironhelm', 'Stormwall', 'Dragonfire', 'Shadowmere', 'Frostpeak', 'Sunspire',
            'Bloodstone', 'Thornwood', 'Goldcrest', 'Ravenmoor', 'Wolfhaven', 'Eaglekeep',
            'Lionhart', 'Bearhold', 'Hawkridge', 'Serpentine'
        ];

        const TEAM_NAMES = [
            'Crusaders', 'Sentinels', 'Legion', 'Knights', 'Warriors', 'Guardians',
            'Paladins', 'Champions', 'Defenders', 'Marauders', 'Vanguard', 'Templars',
            'Berserkers', 'Wardens', 'Lancers', 'Reavers'
        ];

        // Economy constants (salaries in millions)
        const ECONOMY = {
            STARTING_FAME: 1000,
            SALARY_CAP: 60,  // $60M salary cap
            MIN_SALARY: 1,   // $1M minimum salary
            MAX_SALARY: 30,  // $30M for 100 OVR player

            // Revenue
            HOME_GAME_BASE: 50,
            HOME_GAME_STADIUM_BONUS: 30,  // per level
            AWAY_GAME_REVENUE: 25,
            PLAYER_SALE_RATE: 0.5,  // get 50% of salary value

            // Facility costs by level (1->2, 2->3, etc)
            STADIUM_UPGRADE_COSTS: [200, 500, 1000, 2000, 4000],
            TRAINING_UPGRADE_COSTS: [150, 400, 800, 1500, 3000],

            // Other
            BRIBE_COST: 1000,
            BRIBE_CAP_BONUS: 3,  // $3M cap increase per bribe

            // Fame performance points
            FAME_POINTS: {
                CATCH: 5,
                TOUCHDOWN: 50,
                TACKLE: 3,
                SACK: 15,
                INTERCEPTION: 25,
                PASS_DEFENDED: 8,
                YARDS_GAINED: 0.5,
                COMPLETION: 3,
                CLASH_WON: 2
            },

            // Hype multiplier settings
            HYPE: {
                DECLINE_RATE_PER_YEAR: 0.25,  // 25% decline per year after cliff
                FLOOR: 0.1                     // Minimum multiplier
            }
        };

        // Calculate current hype multiplier for a player
        function getCurrentHypeMultiplier(player) {
            if (!player.hypeData) return 1.0;

            const cliffAge = player.peakAge - player.hypeData.yearsBeforePrimeCliff;

            // Before cliff: full multiplier
            if (player.age < cliffAge) {
                return player.hypeData.baseHypeMultiplier;
            }

            // After cliff: decline each year
            const yearsAfterCliff = player.age - cliffAge;
            const declinedMultiplier = player.hypeData.baseHypeMultiplier *
                Math.pow(1 - ECONOMY.HYPE.DECLINE_RATE_PER_YEAR, yearsAfterCliff);

            return Math.max(ECONOMY.HYPE.FLOOR, declinedMultiplier);
        }

        // Calculate fame earned from game stats for a player
        function calculateGameFame(player, pStats) {
            if (!pStats) return 0;

            const fp = ECONOMY.FAME_POINTS;
            let rawPoints = 0;

            // Receiver stats
            rawPoints += (pStats.catches || 0) * fp.CATCH;
            rawPoints += (pStats.touchdowns || 0) * fp.TOUCHDOWN;
            rawPoints += (pStats.yardsAfterCatch || 0) * fp.YARDS_GAINED;

            // QB stats
            rawPoints += (pStats.completions || 0) * fp.COMPLETION;

            // Defense stats
            rawPoints += (pStats.tackles || 0) * fp.TACKLE;
            rawPoints += (pStats.sacks || 0) * fp.SACK;
            rawPoints += (pStats.passesDefended || 0) * fp.PASS_DEFENDED;

            // Clash wins
            rawPoints += (pStats.clashesWon || 0) * fp.CLASH_WON;

            // Apply hype multiplier
            const multiplier = getCurrentHypeMultiplier(player);
            return Math.floor(rawPoints * multiplier);
        }

        // Progression constants
        const PROGRESSION = {
            // Growth is based purely on potential grade
            GROWTH_CHANCE_BASE: 0.20,           // 20% base chance per stat per week
            GROWTH_AMOUNT_MIN: 1,               // Minimum +1 when growth happens
            // Potential decay: chance for potential to drop each year
            POTENTIAL_DECAY_EARLY: 0.15,        // 15% chance years 1-3
            POTENTIAL_DECAY_LATE: 0.50,         // 50% chance after year 3
            POTENTIAL_DROP_TWO_CHANCE: 0.25,    // 25% chance to drop 2 levels instead of 1
            // Decline rates
            DECLINE_RATE: 0.3,                  // per year over peak (base)
            // Physical stats: grow less often, decline in phases
            PHYSICAL_STATS: ['speed', 'acceleration', 'agility', 'strength', 'stamina'],
            PHYSICAL_GROWTH_CHANCE_MULT: 0.50,  // 50% of normal growth chance
            PHYSICAL_DECLINE_EARLY_MULT: 0.5,   // Gentle decline years 1-3 after peak
            PHYSICAL_DECLINE_LATE_MULT: 3.0,    // Steep decline years 4+ after peak
            PHYSICAL_DECLINE_LATE_START: 4,     // When steep decline begins
            // Skill stats: decline very slowly
            SKILL_STATS: ['catching', 'routeRunning', 'blocking', 'runBlock', 'passBlock',
                          'tackling', 'manCoverage', 'zoneCoverage', 'passRush', 'awareness', 'focus'],
            SKILL_DECLINE_MULT: 0.1,            // Only 10% of normal decline
            MIN_STAT: 20,
            MIN_AVERAGE_STAT: 35,  // retire if average drops below
            MAX_AGE: 40
        };

        // Season constants
        const SEASON = {
            WEEKS: 16,
            POSSESSIONS_PER_GAME: 4  // 4 quarters, with possible 2-minute drill and overtime
        };

        // ========================================
        // MANAGEMENT LAYER - UTILITY FUNCTIONS
        // ========================================

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Random from array
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Random int between min and max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Format salary in millions (e.g., 5.5 -> "$5.5M", 10 -> "$10M")
        function formatSalary(amount) {
            if (amount % 1 === 0) {
                return `$${amount}M`;
            }
            return `$${amount.toFixed(1)}M`;
        }

        // Shuffle array (Fisher-Yates)
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // ========================================
        // MANAGEMENT LAYER - SAVE/LOAD SYSTEM
        // ========================================

        const SaveSystem = {
            SAVE_KEY: 'smashball_management_save',

            save() {
                if (!managementState.initialized) return false;

                const saveData = {
                    version: 2,
                    timestamp: Date.now(),
                    team: managementState.team,
                    season: managementState.season,
                    freeAgents: managementState.freeAgents,
                    settings: managementState.settings,
                    // Save draft state if active
                    draftState: draftState.active ? {
                        active: draftState.active,
                        round: draftState.round,
                        pick: draftState.pick,
                        picksRemaining: draftState.picksRemaining,
                        currentPickNumber: draftState.currentPickNumber,
                        isPlayersTurn: draftState.isPlayersTurn,
                        draftPool: draftState.draftPool,
                        draftedPlayers: draftState.draftedPlayers,
                        playerPicks: draftState.playerPicks,
                        isNewGame: draftState.isNewGame
                    } : null
                };

                try {
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('Game saved successfully');
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            },

            load() {
                try {
                    const data = localStorage.getItem(this.SAVE_KEY);
                    if (!data) return null;

                    const saveData = JSON.parse(data);
                    console.log('Game loaded successfully, version:', saveData.version);
                    return saveData;
                } catch (e) {
                    console.error('Failed to load game:', e);
                    return null;
                }
            },

            exists() {
                return localStorage.getItem(this.SAVE_KEY) !== null;
            },

            clear() {
                localStorage.removeItem(this.SAVE_KEY);
                console.log('Save data cleared');
            },

            applySaveData(saveData) {
                if (!saveData) return false;

                managementState.team = saveData.team;
                managementState.season = saveData.season;
                managementState.freeAgents = saveData.freeAgents || [];
                managementState.settings = saveData.settings || managementState.settings;
                managementState.initialized = true;

                // Migrate old saves: credits -> fame
                if (managementState.team && managementState.team.credits !== undefined) {
                    managementState.team.fame = Math.round(managementState.team.credits / 10);
                    delete managementState.team.credits;
                }

                // Restore draft state if saved
                if (saveData.draftState && saveData.draftState.active) {
                    draftState.active = saveData.draftState.active;
                    draftState.round = saveData.draftState.round;
                    draftState.pick = saveData.draftState.pick;
                    draftState.picksRemaining = saveData.draftState.picksRemaining;
                    draftState.currentPickNumber = saveData.draftState.currentPickNumber;
                    draftState.isPlayersTurn = saveData.draftState.isPlayersTurn;
                    draftState.draftPool = saveData.draftState.draftPool;
                    draftState.draftedPlayers = saveData.draftState.draftedPlayers;
                    draftState.playerPicks = saveData.draftState.playerPicks;
                    draftState.isNewGame = saveData.draftState.isNewGame;
                    draftState.usingExtraPick = false;
                    draftState.simulatingPicks = false;
                    draftState.lastComputerPick = null;
                    draftState.viewingRoster = false;
                    draftState.selectedDraftPlayer = null;
                }

                return true;
            }
        };

        // ========================================
        // MANAGEMENT LAYER - PLAYER GENERATION
        // ========================================

        // Generate base stats for a tier
        function getBaseStatsForTier(tier) {
            // Note: Primary stats get +10 bonus in generatePositionStats
            // So actual overall = base + 10 for primary stats
            // Tier -> approximate overall after +10 bonus:
            // rookie: 55-72 -> ~63 OVR
            // below_average: 60-78 -> ~69 OVR
            // average: 68-85 -> ~76 OVR
            // veteran: 78-92 -> ~85 OVR
            // star: 88-99 -> ~93 OVR
            // elite: 98-99 -> ~99 OVR
            const ranges = {
                rookie: { min: 45, max: 62 },        // ~63 OVR
                below_average: { min: 50, max: 68 }, // ~69 OVR
                average: { min: 58, max: 75 },       // ~76 OVR
                veteran: { min: 68, max: 82 },       // ~85 OVR
                star: { min: 78, max: 90 },          // ~93 OVR
                elite: { min: 88, max: 99 }          // ~99 OVR
            };
            const range = ranges[tier] || ranges.average;
            return { min: range.min, max: range.max };
        }

        // Get base stat range for a target overall rating
        // Accounts for the +10 primary stat bonus
        function getBaseRangeForTargetOverall(targetOverall, variance = 5) {
            // Primary stats get +10 bonus, so base should be lower
            const targetPrimaryBase = targetOverall - 10;

            // Add variance for realistic spread
            const minBase = targetPrimaryBase - variance;
            const maxBase = targetPrimaryBase + variance;

            // Clamp to valid ranges (40-89 base -> 50-99 with bonus)
            return {
                min: Math.max(40, minBase),
                max: Math.min(89, maxBase)
            };
        }

        // Roll age based on tier
        function rollAge(tier) {
            switch(tier) {
                case 'rookie': return randomInt(20, 23);
                case 'below_average': return randomInt(22, 30);
                case 'average': return randomInt(23, 28);
                case 'veteran': return randomInt(27, 33);
                case 'star': return randomInt(24, 30);
                case 'elite': return randomInt(25, 31);
                default: return randomInt(22, 28);
            }
        }

        // Roll potential grade based on age and tier (0-3 scale)
        // Distribution: max (3) 15%, average (2) 35%, low (1) 35%, very low (0) 15%
        function rollPotential(age, tier) {
            // Base weighted distribution
            const roll = Math.random() * 100;
            let potential;
            if (roll < 15) potential = 3;        // 15% max
            else if (roll < 50) potential = 2;   // 35% average
            else if (roll < 85) potential = 1;   // 35% low
            else potential = 0;                   // 15% very low

            // Age modifier: older players lose potential
            if (age > 28) potential = Math.max(0, potential - 1);
            if (age > 32) potential = Math.max(0, potential - 1);

            // Tier bonus for young elite/rookie players
            if ((tier === 'elite' || tier === 'rookie') && age <= 24) {
                potential = Math.min(3, potential + 1);
            }

            return potential;
        }

        // Core attribute ranges by tier
        const CORE_ATTRIBUTE_RANGES = {
            elite: { min: 75, max: 95 },
            star: { min: 70, max: 90 },
            veteran: { min: 65, max: 85 },
            average: { min: 50, max: 75 },
            below_average: { min: 40, max: 65 },
            rookie: { min: 45, max: 80 },
            backup: { min: 35, max: 55 }
        };

        // Generate core attributes for a player
        function generateCoreAttributes(position, tier) {
            const range = CORE_ATTRIBUTE_RANGES[tier] || CORE_ATTRIBUTE_RANGES.average;

            const generateAttr = () => {
                const base = randomInt(range.min, range.max);
                return Math.max(30, Math.min(99, base + randomInt(-3, 3)));
            };

            let strength = generateAttr();
            let speed = generateAttr();
            let agility = generateAttr();
            let intelligence = generateAttr();

            // Position-based tendencies
            switch (position) {
                case 'OL':
                case 'DL':
                    strength = Math.min(99, strength + randomInt(3, 8));
                    speed = Math.max(30, speed - randomInt(3, 8));
                    break;
                case 'WR':
                case 'CB':
                    speed = Math.min(99, speed + randomInt(3, 8));
                    agility = Math.min(99, agility + randomInt(2, 5));
                    break;
                case 'QB':
                    intelligence = Math.min(99, intelligence + randomInt(3, 8));
                    break;
            }

            return { strength, speed, agility, intelligence };
        }

        // Calculate position-specific abilities from core attributes
        function calculateAbilities(player) {
            const core = player.coreAttributes;
            if (!core) return null;

            const clamp = (val) => Math.max(0, Math.min(99, Math.round(val)));

            switch (player.position) {
                case 'DL':
                    return {
                        bullRush: clamp(core.strength * 0.60 + (player.stats.passRush || 70) * 0.25 + core.intelligence * 0.15),
                        blockShed: clamp(core.strength * 0.40 + core.agility * 0.40 + (player.stats.passRush || 70) * 0.20),
                        spinMove: clamp(core.agility * 0.55 + core.speed * 0.25 + (player.stats.passRush || 70) * 0.20),
                        swimMove: clamp(core.agility * 0.45 + core.speed * 0.35 + (player.stats.passRush || 70) * 0.20)
                    };
                case 'OL':
                    return {
                        anchor: clamp(core.strength * 0.55 + (player.stats.balance || 70) * 0.25 + (player.stats.passBlock || 70) * 0.20),
                        handFighting: clamp(core.strength * 0.40 + core.agility * 0.35 + (player.stats.passBlock || 70) * 0.25),
                        footwork: clamp(core.agility * 0.45 + core.intelligence * 0.30 + (player.stats.passBlock || 70) * 0.25),
                        driveBlock: clamp(core.strength * 0.40 + core.intelligence * 0.30 + (player.stats.passBlock || 70) * 0.30)
                    };
                case 'CB':
                    return {
                        pressCoverage: clamp(core.strength * 0.45 + core.intelligence * 0.35 + (player.stats.awareness || 70) * 0.20),
                        manCoverage: clamp(core.speed * 0.40 + core.agility * 0.40 + (player.stats.awareness || 70) * 0.20),
                        zoneCoverage: clamp(core.intelligence * 0.45 + core.agility * 0.35 + (player.stats.awareness || 70) * 0.20),
                        ballHawk: clamp(core.intelligence * 0.40 + core.speed * 0.35 + (player.stats.awareness || 70) * 0.25)
                    };
                case 'WR':
                    return {
                        releaseMove: clamp(core.agility * 0.45 + core.strength * 0.35 + (player.stats.routeRunning || 70) * 0.20),
                        routeSharpness: clamp(core.agility * 0.40 + core.speed * 0.35 + (player.stats.routeRunning || 70) * 0.25),
                        contestedCatch: clamp(core.strength * 0.30 + core.intelligence * 0.25 + (player.stats.catching || 70) * 0.45),
                        yacAbility: clamp(core.speed * 0.40 + core.agility * 0.40 + (player.stats.evasion || 70) * 0.20)
                    };
                case 'QB':
                    // Abilities are multiplicative: (core/100) √ó (skill/100) √ó 100
                    const shortAcc = player.stats.shortPassAcc || 70;
                    const longAcc = player.stats.longPassAcc || 70;
                    const qbAwareness = player.stats.awareness || 70;
                    return {
                        armStrength: clamp((core.strength / 100) * (longAcc / 100) * 100),
                        quickRelease: clamp((core.agility / 100) * (shortAcc / 100) * 100),
                        fieldVision: clamp((core.intelligence / 100) * (qbAwareness / 100) * 100),
                        pocketPresence: clamp((core.agility / 100) * (qbAwareness / 100) * 100)
                    };
                default:
                    return null;
            }
        }

        // Get best ability for a player
        function getBestAbility(player) {
            const abilities = calculateAbilities(player);
            if (!abilities) return null;

            let best = { name: '', value: 0 };
            for (const [name, value] of Object.entries(abilities)) {
                if (value > best.value) {
                    best = { name, value };
                }
            }
            return best;
        }

        // Core attribute colors for visual display
        const CORE_ATTR_COLORS = {
            strength: '#ff6b6b',     // Red
            speed: '#4dabf7',        // Blue
            agility: '#69db7c',      // Green
            intelligence: '#ffd43b'  // Gold
        };

        // Ability to core attribute mapping (core stats only, normalized to 100%)
        const ABILITY_CORE_MAPPING = {
            // DL abilities
            bullRush:       { strength: 0.80, intelligence: 0.20 },
            blockShed:      { strength: 0.50, agility: 0.50 },
            spinMove:       { agility: 0.69, speed: 0.31 },
            swimMove:       { agility: 0.56, speed: 0.44 },
            // OL abilities
            anchor:         { strength: 1.00 },
            handFighting:   { strength: 0.53, agility: 0.47 },
            footwork:       { agility: 0.60, intelligence: 0.40 },
            driveBlock:     { strength: 0.57, intelligence: 0.43 },
            // CB abilities
            pressCoverage:  { strength: 0.56, intelligence: 0.44 },
            manCoverage:    { speed: 0.50, agility: 0.50 },
            zoneCoverage:   { intelligence: 0.56, agility: 0.44 },
            ballHawk:       { intelligence: 0.53, speed: 0.47 },
            // WR abilities
            releaseMove:    { agility: 0.56, strength: 0.44 },
            routeSharpness: { agility: 0.53, speed: 0.47 },
            contestedCatch: { strength: 0.55, intelligence: 0.45 },
            yacAbility:     { speed: 0.50, agility: 0.50 },
            // QB abilities (core √ó skill, multiplicative)
            armStrength:    { strength: 1.00 },
            quickRelease:   { agility: 1.00 },
            fieldVision:    { intelligence: 1.00 },
            pocketPresence: { agility: 1.00 }
        };

        // Generate attribute indicator dots for an ability
        function getAbilityDots(abilityKey) {
            const mapping = ABILITY_CORE_MAPPING[abilityKey];
            if (!mapping) return '';

            // Map attribute names to CSS classes
            const attrToClass = {
                strength: 'str',
                speed: 'spd',
                agility: 'agi',
                intelligence: 'int'
            };

            // Sort by percentage descending and generate dots
            const sortedAttrs = Object.entries(mapping).sort((a, b) => b[1] - a[1]);
            const dots = sortedAttrs.map(([attr]) =>
                `<span class="attr-dot ${attrToClass[attr]}"></span>`
            ).join('');

            return `<span class="attr-dots">${dots}</span>`;
        }

        // Get display name for ability
        function getAbilityDisplayName(abilityKey) {
            return abilityKey.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
        }

        // Generate position-specific stats
        function generatePositionStats(position, baseRange) {
            const stats = {};
            const positionData = POSITIONS[position];

            // All possible stats
            const allStats = [
                'speed', 'acceleration', 'agility', 'strength', 'stamina', 'balance', 'evasion',
                'catching', 'shortPassAcc', 'longPassAcc', 'routeRunning', 'jumping',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'pursuit', 'awareness',
                'passBlock', 'passRush'
            ];

            // Generate all stats
            allStats.forEach(stat => {
                // Primary stats get bonus
                const isPrimary = positionData.primaryStats.includes(stat);
                const bonus = isPrimary ? 10 : 0;

                stats[stat] = Math.min(99, Math.max(1,
                    randomInt(baseRange.min, baseRange.max) + bonus
                ));
            });

            return stats;
        }

        // Calculate salary from stats
        // Calculate overall rating (average of primary stats for position)
        function calculateOverall(player) {
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;
            const total = primaryStats.reduce((sum, stat) => sum + (player.stats[stat] || 0), 0);
            return Math.round(total / primaryStats.length);
        }

        // Calculate salary based on overall rating (exponential scaling in $M)
        // 60 OVR = $1M, 80 OVR = $8M, 100 OVR = $30M
        function calculateSalary(stats, position = 'WR') {
            const positionData = POSITIONS[position];
            const primaryStats = positionData.primaryStats;
            const total = primaryStats.reduce((sum, stat) => sum + (stats[stat] || 0), 0);
            const overall = Math.round(total / primaryStats.length);

            // Exponential scaling: salary = MIN + (MAX - MIN) * ((OVR - 60) / 40)^2
            const minOvr = 60;
            const maxOvr = 100;
            const normalizedOvr = Math.max(0, Math.min(1, (overall - minOvr) / (maxOvr - minOvr)));
            const rawSalary = ECONOMY.MIN_SALARY + (ECONOMY.MAX_SALARY - ECONOMY.MIN_SALARY) * Math.pow(normalizedOvr, 2);

            // Round to nearest 0.5M for cleaner numbers
            return Math.round(rawSalary * 2) / 2;
        }

        // Calculate trade value (fame received for trading a player)
        function calculateTradeValue(player) {
            const overall = player.overall;
            if (overall < 80) return 0;
            if (overall < 90) {
                // 80-89: linear scaling, 0 to 150
                return Math.floor((overall - 80) * 15);
            }
            // 90+: exponential scaling
            // 90 = 150, 92 = 250, 95 = 775, 99 = 2175
            return Math.floor(150 + Math.pow(overall - 90, 2) * 25);
        }

        // Generate a player
        function generatePlayer(position, tier = 'average') {
            const baseRange = getBaseStatsForTier(tier);
            const age = rollAge(tier);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Years in league based on age (rookies start at 0)
            const yearsInLeague = tier === 'rookie' ? 0 : Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, tier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats, position),
                seasonStartStats: { ...stats },
                // Core attributes - foundational traits that rarely change
                coreAttributes: generateCoreAttributes(position, tier),
                // Season stats
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                // Fame/Hype system
                hypeData: {
                    baseHypeMultiplier: Math.max(0.1, 1.0 + (Math.random() - 0.5) * 0.4), // Normal-ish distribution around 1.0
                    yearsBeforePrimeCliff: randomInt(0, 5), // Secret: when decline starts
                    accumulatedFameBank: 0, // Total fame earned over career
                    seasonFameEarnings: 0   // Fame earned this season
                },
                // Career history (array of season snapshots)
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, tier)
                }]
            };

            player.overall = calculateOverall(player);

            // Assign QB trait based on stats
            if (position === 'QB') {
                // Weight trait selection based on QB's style
                // High awareness + low agility = game_manager
                // High agility + speed = scrambler
                // High pass accuracy = gunslinger
                // Otherwise balanced
                const awareness = stats.awareness || 70;
                const agility = stats.agility || 70;
                const speed = stats.speed || 70;
                const passAcc = ((stats.shortPassAcc || 70) + (stats.longPassAcc || 70)) / 2;

                if (agility > 78 && speed > 75) {
                    player.qbTrait = 'scrambler';
                } else if (awareness > 80 && passAcc < 75) {
                    player.qbTrait = 'game_manager';
                } else if (passAcc > 82) {
                    player.qbTrait = 'gunslinger';
                } else {
                    player.qbTrait = 'balanced';
                }
            }

            return player;
        }

        // Generate a player targeting a specific overall rating
        function generatePlayerWithTargetOverall(position, targetOverall, variance = 5) {
            const baseRange = getBaseRangeForTargetOverall(targetOverall, variance);
            const age = randomInt(22, 32);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Estimate tier based on target for age/potential logic
            let estimatedTier = 'average';
            if (targetOverall >= 93) estimatedTier = 'elite';
            else if (targetOverall >= 85) estimatedTier = 'star';
            else if (targetOverall >= 78) estimatedTier = 'veteran';
            else if (targetOverall >= 72) estimatedTier = 'average';
            else if (targetOverall >= 65) estimatedTier = 'below_average';
            else estimatedTier = 'rookie';

            const yearsInLeague = Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, estimatedTier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats, position),
                seasonStartStats: { ...stats },
                coreAttributes: generateCoreAttributes(position, estimatedTier),
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                hypeData: {
                    baseHypeMultiplier: Math.max(0.1, 1.0 + (Math.random() - 0.5) * 0.4),
                    yearsBeforePrimeCliff: randomInt(0, 5),
                    accumulatedFameBank: 0,
                    seasonFameEarnings: 0
                },
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, estimatedTier)
                }]
            };

            player.overall = calculateOverall(player);

            // Assign QB trait
            if (position === 'QB') {
                const awareness = stats.awareness || 70;
                const agility = stats.agility || 70;
                const speed = stats.speed || 70;
                const passAcc = ((stats.shortPassAcc || 70) + (stats.longPassAcc || 70)) / 2;

                if (agility > 78 && speed > 75) {
                    player.qbTrait = 'scrambler';
                } else if (awareness > 80 && passAcc < 75) {
                    player.qbTrait = 'game_manager';
                } else if (passAcc > 82) {
                    player.qbTrait = 'gunslinger';
                } else {
                    player.qbTrait = 'balanced';
                }
            }

            return player;
        }

        // Generate initial roster for new game
        function generateInitialRoster() {
            const roster = [];

            // WRs: 1 good, 2 average
            roster.push(generatePlayer('WR', 'veteran'));
            roster.push(generatePlayer('WR', 'average'));
            roster.push(generatePlayer('WR', 'average'));

            // CBs: 1 good, 3 average
            roster.push(generatePlayer('CB', 'veteran'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));

            // OL: 1 good, 4 average
            roster.push(generatePlayer('OL', 'veteran'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));

            // DL: 1 good, 3 average
            roster.push(generatePlayer('DL', 'veteran'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));

            // QB
            roster.push(generatePlayer('QB', 'average'));

            return roster;
        }

        // Auto-assign depth chart based on overall ratings
        function autoAssignDepthChart(team) {
            const roster = team.roster;

            // Group by position and sort by overall
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            Object.keys(byPosition).forEach(pos => {
                byPosition[pos].sort((a, b) => b.overall - a.overall);
            });

            // Assign to depth chart
            const depthChart = {
                WR1: byPosition.WR?.[0]?.id || null,
                WR2: byPosition.WR?.[1]?.id || null,
                WR3: byPosition.WR?.[2]?.id || null,
                CB1: byPosition.CB?.[0]?.id || null,
                CB2: byPosition.CB?.[1]?.id || null,
                CB3: byPosition.CB?.[2]?.id || null,
                CB4: byPosition.CB?.[3]?.id || null,
                OL: (byPosition.OL || []).slice(0, 5).map(p => p.id),
                DL: (byPosition.DL || []).slice(0, 4).map(p => p.id),
                QB: byPosition.QB?.[0]?.id || null
            };

            // Pad OL and DL if needed
            while (depthChart.OL.length < 5) depthChart.OL.push(null);
            while (depthChart.DL.length < 4) depthChart.DL.push(null);

            team.depthChart = depthChart;
        }

        // Create a new team
        function createNewTeam(name = 'Your Team') {
            // New teams get last-place draft budget (best picks available)
            const defaultRank = DRAFT.NUM_TEAMS;
            const team = {
                name,
                fame: ECONOMY.STARTING_FAME,
                salaryCap: ECONOMY.SALARY_CAP,
                salaryCapModifier: 0,
                roster: generateInitialRoster(),
                depthChart: {},
                facilities: {
                    stadium: { level: 1, maxLevel: 5 },
                    trainingCenter: { level: 1, maxLevel: 5 }
                },
                record: { wins: 0, losses: 0 },
                draftPoints: calculateDraftBudget(defaultRank)
            };

            autoAssignDepthChart(team);
            return team;
        }

        // ========================================
        // MANAGEMENT LAYER - OPPONENT GENERATION
        // ========================================

        // Generate a roster targeting a specific team overall rating
        // Creates diverse rosters: key players above average, role players below
        function generateRosterWithTargetOverall(teamOverall) {
            // Position slots with their offset from team average and importance weight
            // Key players (QB, WR1, CB1, edge) get boosted, depth players get reduced
            // This creates realistic roster diversity while hitting the target average
            const positionSlots = [
                // Offense
                { pos: 'QB', offset: +6, weight: 3.0 },   // Franchise QB, most important
                { pos: 'WR', offset: +4, weight: 2.0 },   // WR1 - primary target
                { pos: 'WR', offset: 0, weight: 1.0 },    // WR2 - solid contributor
                { pos: 'WR', offset: -4, weight: 1.0 },   // WR3 - depth
                { pos: 'OL', offset: +2, weight: 1.5 },   // LT - protects blind side
                { pos: 'OL', offset: -2, weight: 1.0 },   // LG
                { pos: 'OL', offset: -2, weight: 1.0 },   // C
                { pos: 'OL', offset: -3, weight: 1.0 },   // RG/RT
                // Defense
                { pos: 'CB', offset: +4, weight: 2.0 },   // CB1 - shutdown corner
                { pos: 'CB', offset: 0, weight: 1.0 },    // CB2
                { pos: 'CB', offset: -3, weight: 1.0 },   // CB3 - nickel
                { pos: 'CB', offset: -5, weight: 1.0 },   // CB4 - safety/zone
                { pos: 'DL', offset: +4, weight: 1.5 },   // Edge rusher
                { pos: 'DL', offset: 0, weight: 1.0 },    // DT
                { pos: 'DL', offset: -2, weight: 1.0 },   // DT
                { pos: 'DL', offset: -4, weight: 1.0 },   // Rotational
            ];

            const roster = [];
            for (const slot of positionSlots) {
                // Calculate target overall for this position
                // Clamp between 60 (minimum viable) and 99 (maximum)
                const targetOvr = Math.max(60, Math.min(99, teamOverall + slot.offset));
                // Use variance of 4 for some natural spread
                const player = generatePlayerWithTargetOverall(slot.pos, targetOvr, 4);
                roster.push(player);
            }

            return roster;
        }

        // Legacy function for backward compatibility - maps difficulty to target overall
        function generateOpponentRoster(difficulty) {
            const targetOveralls = {
                'easy': 72,    // Low 70s team
                'medium': 77,  // High 70s team
                'hard': 83,    // Low 80s team
                'elite': 91    // Elite team
            };
            const target = targetOveralls[difficulty] || 77;
            return generateRosterWithTargetOverall(target);
        }

        // Calculate team ratings from roster (weighted by key positions)
        function calculateTeamRatings(roster) {
            // Weight key positions more heavily
            const getPositionWeight = (player, index, position) => {
                if (position === 'QB') return 3.0;        // QB is most important
                if (position === 'WR' && index === 0) return 2.0;  // WR1
                if (position === 'CB' && index === 0) return 2.0;  // CB1
                if (position === 'DL' && index === 0) return 1.5;  // Pass rusher
                if (position === 'OL' && index === 0) return 1.5;  // LT
                return 1.0;  // Role players
            };

            const offense = roster.filter(p => ['QB', 'WR', 'OL'].includes(p.position));
            const defense = roster.filter(p => ['CB', 'DL'].includes(p.position));

            // Group by position for index-based weighting
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            let offenseWeightedSum = 0, offenseWeightTotal = 0;
            let defenseWeightedSum = 0, defenseWeightTotal = 0;

            Object.entries(byPosition).forEach(([pos, players]) => {
                players.sort((a, b) => b.overall - a.overall); // Best first
                players.forEach((p, i) => {
                    const weight = getPositionWeight(p, i, pos);
                    if (['QB', 'WR', 'OL'].includes(pos)) {
                        offenseWeightedSum += p.overall * weight;
                        offenseWeightTotal += weight;
                    } else {
                        defenseWeightedSum += p.overall * weight;
                        defenseWeightTotal += weight;
                    }
                });
            });

            const offenseRating = offenseWeightTotal > 0
                ? Math.round(offenseWeightedSum / offenseWeightTotal)
                : 60;
            const defenseRating = defenseWeightTotal > 0
                ? Math.round(defenseWeightedSum / defenseWeightTotal)
                : 60;

            return { offenseRating, defenseRating };
        }

        // Pre-defined opponents with varying difficulty
        function generateOpponents() {
            const opponents = [];
            const usedNames = new Set();

            // Team overall targets: 8 teams in 70s (half), rest spread across 80s and 90s
            // Distribution: 4 low-70s, 4 high-70s, 4 low-80s, 2 mid-80s, 2 elite
            const teamOveralls = [
                // Low 70s (4 teams)
                70, 71, 72, 73,
                // High 70s (4 teams)
                75, 76, 78, 79,
                // Low 80s (4 teams)
                81, 82, 83, 84,
                // Mid-high 80s (2 teams)
                86, 88,
                // Elite (2 teams)
                91, 94
            ];

            // Shuffle target overalls for variety
            const shuffledOveralls = shuffleArray([...teamOveralls]);

            // Map overall to difficulty label for display
            const getDifficulty = (ovr) => {
                if (ovr <= 74) return 'easy';
                if (ovr <= 79) return 'medium';
                if (ovr <= 85) return 'hard';
                return 'elite';
            };

            // Generate 16 unique opponents
            let overallIndex = 0;
            while (opponents.length < 16) {
                const city = randomFrom(TEAM_CITIES);
                const teamName = randomFrom(TEAM_NAMES);
                const fullName = `${city} ${teamName}`;

                if (usedNames.has(fullName)) continue;
                usedNames.add(fullName);

                const targetOverall = shuffledOveralls[overallIndex++];
                const difficulty = getDifficulty(targetOverall);

                // Generate roster targeting this overall
                const roster = generateRosterWithTargetOverall(targetOverall);
                const ratings = calculateTeamRatings(roster);

                opponents.push({
                    id: generateUUID(),
                    name: fullName,
                    difficulty,
                    targetOverall,  // Store for debugging/display
                    roster,
                    offenseRating: ratings.offenseRating,
                    defenseRating: ratings.defenseRating,
                    record: { wins: 0, losses: 0 }
                });
            }

            return shuffleArray(opponents);
        }

        // Generate season schedule
        function generateSchedule(opponents) {
            const schedule = [];
            const shuffledOpponents = shuffleArray([...opponents]);

            for (let week = 1; week <= SEASON.WEEKS; week++) {
                const opponent = shuffledOpponents[(week - 1) % shuffledOpponents.length];
                schedule.push({
                    week,
                    opponent,
                    isHome: Math.random() > 0.5,
                    result: null  // { playerScore, opponentScore, win }
                });
            }

            return schedule;
        }

        // Create a new season
        function createNewSeason() {
            const opponents = generateOpponents();
            return {
                week: 1,
                opponents,
                schedule: generateSchedule(opponents)
            };
        }

        // ========================================
        // MANAGEMENT LAYER - ECONOMY SYSTEM
        // ========================================

        // Calculate current team salary
        function calculateTeamSalary(team) {
            return team.roster.reduce((sum, p) => sum + p.salaryCost, 0);
        }

        // Check if can sign player (under cap)
        function canSignPlayer(team, player) {
            const currentSalary = calculateTeamSalary(team);
            const cap = team.salaryCap + team.salaryCapModifier;
            return currentSalary + player.salaryCost <= cap;
        }

        // Sign a free agent
        function signFreeAgent(playerId) {
            const player = managementState.freeAgents.find(p => p.id === playerId);
            if (!player) return { success: false, error: 'Player not found' };

            if (!canSignPlayer(managementState.team, player)) {
                return { success: false, error: 'Over salary cap' };
            }

            managementState.team.roster.push(player);
            managementState.freeAgents = managementState.freeAgents.filter(p => p.id !== playerId);

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true };
        }

        // Cut/release a player
        function cutPlayer(playerId) {
            const playerIndex = managementState.team.roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return { success: false, error: 'Player not found' };

            const player = managementState.team.roster[playerIndex];
            const payout = Math.floor(player.salaryCost * ECONOMY.PLAYER_SALE_RATE);

            managementState.team.fame += payout;
            managementState.team.roster.splice(playerIndex, 1);

            // Remove from depth chart
            const dc = managementState.team.depthChart;
            Object.keys(dc).forEach(slot => {
                if (Array.isArray(dc[slot])) {
                    const idx = dc[slot].indexOf(playerId);
                    if (idx !== -1) dc[slot][idx] = null;
                } else if (dc[slot] === playerId) {
                    dc[slot] = null;
                }
            });

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, payout };
        }

        // Award game revenue
        function awardGameRevenue(isHome) {
            let revenue;
            if (isHome) {
                revenue = ECONOMY.HOME_GAME_BASE +
                    (managementState.team.facilities.stadium.level * ECONOMY.HOME_GAME_STADIUM_BONUS);
            } else {
                revenue = ECONOMY.AWAY_GAME_REVENUE;
            }

            managementState.team.fame += revenue;
            return revenue;
        }

        // Upgrade facility
        function upgradeFacility(facilityType) {
            const facility = managementState.team.facilities[facilityType];
            if (!facility) return { success: false, error: 'Invalid facility' };

            if (facility.level >= facility.maxLevel) {
                return { success: false, error: 'Already at max level' };
            }

            const costs = facilityType === 'stadium'
                ? ECONOMY.STADIUM_UPGRADE_COSTS
                : ECONOMY.TRAINING_UPGRADE_COSTS;
            const cost = costs[facility.level - 1];

            if (managementState.team.fame < cost) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= cost;
            facility.level++;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newLevel: facility.level, cost };
        }

        // Bribe officials for more cap space
        function bribeOfficials() {
            if (managementState.team.fame < ECONOMY.BRIBE_COST) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= ECONOMY.BRIBE_COST;
            managementState.team.salaryCapModifier += ECONOMY.BRIBE_CAP_BONUS;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newCap: managementState.team.salaryCap + managementState.team.salaryCapModifier };
        }

        // ========================================
        // MANAGEMENT LAYER - PROGRESSION SYSTEM
        // ========================================

        // Process growth for a player (weekly)
        // Growth is based purely on current potential grade
        function processPlayerGrowth(player) {
            if (player.age >= player.peakAge) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: No growth - age ${player.age} >= peakAge ${player.peakAge}`);
                return [];
            }
            if (player.potentialGrade <= 0) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: No growth - potentialGrade ${player.potentialGrade} <= 0`);
                return []; // No growth potential left
            }

            // Potential grade affects growth chance (0-3 scale)
            const potentialMultiplier = 0.5 + (player.potentialGrade * 0.5); // 0.5x to 2.0x
            const baseGrowthChance = PROGRESSION.GROWTH_CHANCE_BASE * potentialMultiplier;

            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            const improvements = [];
            primaryStats.forEach(stat => {
                if (player.stats[stat] === undefined) return;

                // Physical stats grow very rarely
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const growthChance = isPhysical
                    ? baseGrowthChance * PROGRESSION.PHYSICAL_GROWTH_CHANCE_MULT
                    : baseGrowthChance;

                if (Math.random() < growthChance) {
                    const oldVal = player.stats[stat];
                    // Growth is always at least +1, with potential for more based on potential
                    const bonusGrowth = Math.floor(Math.random() * player.potentialGrade);
                    const growth = PROGRESSION.GROWTH_AMOUNT_MIN + bonusGrowth;
                    player.stats[stat] = Math.min(99, player.stats[stat] + growth);
                    if (player.stats[stat] > oldVal) {
                        console.log(`[GROWTH] ${player.firstName} ${player.lastName}: ${stat} +${player.stats[stat] - oldVal} (${oldVal} -> ${player.stats[stat]})`);
                        improvements.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            if (improvements.length === 0) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: Eligible but no growth this week (chance: ${(baseGrowthChance * 100).toFixed(1)}%)`);
            }

            return improvements;
        }

        // Process decline for a player (weekly)
        function processPlayerDecline(player) {
            if (player.age < player.peakAge) return [];

            const yearsOver = player.age - player.peakAge;
            const baseDeclineRate = yearsOver * PROGRESSION.DECLINE_RATE;

            const declines = [];

            // Process all stats the player has
            Object.keys(player.stats).forEach(stat => {
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const isSkill = PROGRESSION.SKILL_STATS.includes(stat);

                let declineRate;
                let minStat = PROGRESSION.MIN_STAT;

                if (isPhysical) {
                    // Physical stats: gentle decline years 1-3, steep decline years 4+
                    const isLateDecline = yearsOver >= PROGRESSION.PHYSICAL_DECLINE_LATE_START;
                    const physicalMult = isLateDecline
                        ? PROGRESSION.PHYSICAL_DECLINE_LATE_MULT
                        : PROGRESSION.PHYSICAL_DECLINE_EARLY_MULT;
                    declineRate = baseDeclineRate * physicalMult;
                } else if (isSkill) {
                    // Skill stats barely decline (10% of normal)
                    declineRate = baseDeclineRate * PROGRESSION.SKILL_DECLINE_MULT;
                    minStat = PROGRESSION.MIN_STAT + 15; // Skills floor higher
                } else {
                    // Other stats decline normally
                    declineRate = baseDeclineRate;
                }

                // Apply decline with some randomness
                if (Math.random() < 0.5 + (yearsOver * 0.1)) { // More likely to decline as years pass
                    const oldVal = player.stats[stat];
                    const actualDecline = declineRate * (0.5 + Math.random()); // 50-150% of rate
                    player.stats[stat] = Math.max(minStat, player.stats[stat] - actualDecline);
                    if (player.stats[stat] < oldVal) {
                        declines.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            return declines;
        }

        // Check if player should retire
        function checkRetirement(player) {
            if (player.age > PROGRESSION.MAX_AGE) return true;

            const statValues = Object.values(player.stats);
            const avgStat = statValues.reduce((a, b) => a + b, 0) / statValues.length;

            return avgStat < PROGRESSION.MIN_AVERAGE_STAT;
        }

        // Process weekly progression for all players
        function processWeeklyProgression() {
            console.log(`[PROGRESSION] Processing weekly progression for ${managementState.team.roster.length} players`);
            const results = {
                improvements: [],
                declines: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                // Growth or decline
                const improvements = processPlayerGrowth(player);
                const declines = processPlayerDecline(player);

                if (improvements.length > 0) {
                    results.improvements.push({ player, improvements });
                }
                if (declines.length > 0) {
                    results.declines.push({ player, declines });
                }

                // Check retirement
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Also process opponent team progressions
            processOpponentProgression();

            return results;
        }

        // Process weekly progression for all opponent teams
        function processOpponentProgression() {
            if (!managementState.season || !managementState.season.opponents) return;

            managementState.season.opponents.forEach(opponent => {
                if (!opponent.roster) return;

                const toRemove = [];
                opponent.roster.forEach(player => {
                    // Apply growth/decline (simplified - no retirement tracking for opponents)
                    processPlayerGrowth(player);
                    processPlayerDecline(player);

                    // Simple retirement check - replace with new player
                    if (checkRetirement(player)) {
                        toRemove.push(player);
                    }
                });

                // Replace retired opponents with new players
                toRemove.forEach(oldPlayer => {
                    const idx = opponent.roster.indexOf(oldPlayer);
                    if (idx !== -1) {
                        const tierMap = {
                            'easy': 'average',
                            'medium': 'average',
                            'hard': 'veteran',
                            'elite': 'star'
                        };
                        opponent.roster[idx] = generatePlayer(oldPlayer.position, tierMap[opponent.difficulty] || 'average');
                    }
                });

                // Recalculate team ratings
                const ratings = calculateTeamRatings(opponent.roster);
                opponent.offenseRating = ratings.offenseRating;
                opponent.defenseRating = ratings.defenseRating;
            });
        }

        // Process end of season (age all players)
        function processEndOfSeason() {
            const results = {
                ageUps: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                player.age++;
                player.yearsInLeague = (player.yearsInLeague || 0) + 1;
                results.ageUps.push(player);

                // Potential decay: chance for potential to drop each year
                // Much higher chance after year 3
                if (player.potentialGrade > 0 && player.age < player.peakAge) {
                    const decayChance = player.yearsInLeague <= 3
                        ? PROGRESSION.POTENTIAL_DECAY_EARLY
                        : PROGRESSION.POTENTIAL_DECAY_LATE;

                    if (Math.random() < decayChance) {
                        // Chance to drop 2 levels instead of 1
                        const dropAmount = Math.random() < PROGRESSION.POTENTIAL_DROP_TWO_CHANCE ? 2 : 1;
                        player.potentialGrade = Math.max(0, player.potentialGrade - dropAmount);
                    }
                }

                // Record career history before resetting
                if (!player.careerHistory) player.careerHistory = [];
                player.careerHistory.push({
                    season: player.careerHistory.length,
                    overall: player.overall,
                    potential: player.potentialGrade,
                    gamesPlayed: player.gamesPlayed || 0,
                    tds: player.seasonTDs || 0,
                    catches: player.seasonCatches || 0,
                    targets: player.seasonTargets || 0,
                    tackles: player.seasonTackles || 0,
                    clashesWon: player.seasonClashesWon || 0,
                    clashesLost: player.seasonClashesLost || 0,
                    sacks: player.seasonSacks || 0,
                    passesDefended: player.seasonPassesDefended || 0
                });

                // Reset season stats
                player.seasonStartStats = { ...player.stats };
                player.gamesPlayed = 0;
                player.seasonTDs = 0;
                player.seasonCatches = 0;
                player.seasonTargets = 0;
                player.seasonTackles = 0;
                player.seasonClashesWon = 0;
                player.seasonClashesLost = 0;
                player.seasonSacks = 0;
                player.seasonPassesDefended = 0;

                // Check retirement after aging
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Create new season
            managementState.season = createNewSeason();

            // Refresh free agents
            refreshFreeAgents();

            if (managementState.settings.autoSave) SaveSystem.save();

            return results;
        }

        // ========================================
        // MANAGEMENT LAYER - FREE AGENCY
        // ========================================

        // Roll tier for free agent (weighted towards average)
        function rollFreeAgentTier() {
            const roll = Math.random();
            if (roll < 0.1) return 'elite';      // 10%
            if (roll < 0.25) return 'veteran';   // 15%
            if (roll < 0.75) return 'average';   // 50%
            return 'rookie';                      // 25%
        }

        // Refresh free agent pool
        function refreshFreeAgents() {
            managementState.freeAgents = [];

            const count = randomInt(5, 8);
            const positions = ['WR', 'CB', 'OL', 'DL'];

            for (let i = 0; i < count; i++) {
                const position = randomFrom(positions);
                const tier = rollFreeAgentTier();
                managementState.freeAgents.push(generatePlayer(position, tier));
            }
        }

        // ========================================
        // MANAGEMENT LAYER - DRAFT SYSTEM
        // ========================================

        // Draft constants
        const DRAFT = {
            ROUNDS: 5,
            PLAYERS_PER_ROUND: 10,  // Players available each round (50 total)
            NUM_TEAMS: 12,          // Teams in the league for draft order calculation
            MIN_COST: 10,           // Minimum draft cost
            NEW_GAME_BUDGET: 1500,  // Starting draft points for new games
            // Exact costs for first 7 picks as specified
            EARLY_COSTS: [1000, 800, 700, 600, 520, 450, 390],
            ROUND_2_START: 13,      // First pick of round 2 (in 12-team league)
            ROUND_3_START: 25,      // First pick of round 3
            ROUND_DROP: 0.70,       // 30% drop at round boundaries
            // Pick trading defaults
            DEFAULT_TRADE_IN_PENALTY: 50,    // Penalty points when trading in your pick (like a round 5 pick cost)
            DEFAULT_ACQUIRE_PREMIUM: 0.10    // 10% premium when acquiring another team's pick
        };

        // Calculate cost of a draft pick based on position in pool
        // Picks 1-7: Exact values from EARLY_COSTS
        // Picks 8-12: Continue with decreasing drops
        // Pick 13, 25: Sharp 30% drop at round boundaries
        function calculatePickCost(pickPosition) {
            // Picks 1-7: Use exact specified values
            if (pickPosition <= DRAFT.EARLY_COSTS.length) {
                return DRAFT.EARLY_COSTS[pickPosition - 1];
            }

            // Picks 8-12: Continue with decreasing drops from pick 7's value
            // Drops: ~45, 38, 32, 27, 23 (shrinking by ~15% each)
            if (pickPosition <= 12) {
                let cost = DRAFT.EARLY_COSTS[6]; // Start from 390
                let drop = 45;
                for (let i = 8; i <= pickPosition; i++) {
                    cost -= drop;
                    drop = Math.floor(drop * 0.85);
                }
                return Math.max(DRAFT.MIN_COST, cost);
            }

            // Get pick 12's cost as baseline
            let pick12Cost = DRAFT.EARLY_COSTS[6];
            let drop = 45;
            for (let i = 8; i <= 12; i++) {
                pick12Cost -= drop;
                drop = Math.floor(drop * 0.85);
            }
            // pick12Cost is ~254

            // Pick 13: Sharp drop at round 2 start
            if (pickPosition === DRAFT.ROUND_2_START) {
                return Math.max(DRAFT.MIN_COST, Math.floor(pick12Cost * DRAFT.ROUND_DROP));
            }

            // Picks 14-24: Gradual 94% decay
            if (pickPosition < DRAFT.ROUND_3_START) {
                let cost = Math.floor(pick12Cost * DRAFT.ROUND_DROP); // Start from pick 13 value
                for (let i = 14; i <= pickPosition; i++) {
                    cost = Math.floor(cost * 0.94);
                }
                return Math.max(DRAFT.MIN_COST, cost);
            }

            // Calculate pick 24's value
            let pick24Cost = Math.floor(pick12Cost * DRAFT.ROUND_DROP);
            for (let i = 14; i <= 24; i++) {
                pick24Cost = Math.floor(pick24Cost * 0.94);
            }

            // Pick 25: Sharp drop at round 3 start
            if (pickPosition === DRAFT.ROUND_3_START) {
                return Math.max(DRAFT.MIN_COST, Math.floor(pick24Cost * DRAFT.ROUND_DROP));
            }

            // Picks 26+: Gentler 96% decay
            let cost = Math.floor(pick24Cost * DRAFT.ROUND_DROP);
            for (let i = 26; i <= pickPosition; i++) {
                cost = Math.floor(cost * 0.96);
            }

            return Math.max(DRAFT.MIN_COST, cost);
        }

        // Calculate draft budget based on team's season finish ranking
        // Worse teams get more points (higher picks in each round)
        function calculateDraftBudget(teamRank, totalTeams = DRAFT.NUM_TEAMS) {
            // teamRank: 1 = best record, totalTeams = worst record
            // Worst team picks at position 1, 13, 25, 37, 49 (every 12 picks in 5 rounds)
            // Best team picks at position 12, 24, 36, 48, 60

            let budget = 0;
            const pickPosition = totalTeams - teamRank + 1;  // Convert rank to pick order (worst=1st pick)

            for (let round = 0; round < DRAFT.ROUNDS; round++) {
                const overallPick = round * totalTeams + pickPosition;
                budget += calculatePickCost(overallPick);
            }

            return budget;
        }

        // Get team's rank based on record (1 = best, NUM_TEAMS = worst)
        function getTeamSeasonRank() {
            if (!managementState.team || !managementState.season) {
                // Default to middle ranking for new games
                return Math.ceil(DRAFT.NUM_TEAMS / 2);
            }

            const teamWins = managementState.team.record.wins;
            const teamLosses = managementState.team.record.losses;

            // Compare against other teams in schedule
            const schedule = managementState.season.schedule || [];
            let betterTeams = 0;

            const opponents = new Set();
            schedule.forEach(game => {
                if (game.opponent && !opponents.has(game.opponent.id)) {
                    opponents.add(game.opponent.id);
                    const oppWins = game.opponent.record?.wins || 0;
                    const oppLosses = game.opponent.record?.losses || 0;

                    // Higher wins = better rank (lower number)
                    if (oppWins > teamWins || (oppWins === teamWins && oppLosses < teamLosses)) {
                        betterTeams++;
                    }
                }
            });

            // Rank is 1 + number of teams with better records
            return Math.min(betterTeams + 1, DRAFT.NUM_TEAMS);
        }

        // Draft state
        const draftState = {
            active: false,
            round: 1,
            pick: 1,
            picksRemaining: 0,  // How many picks the player has left
            currentPickNumber: 1,  // Overall pick number in the draft (1-60)
            isPlayersTurn: false,  // True when it's the player's turn to pick
            usingExtraPick: false,  // True when player is using a purchased extra pick
            simulatingPicks: false,  // True when computer picks are being animated
            lastComputerPick: null,  // Last computer pick for display { team, player }
            draftPool: [],
            draftedPlayers: [],  // IDs of all drafted players (by any team)
            playerPicks: [],     // IDs of players drafted by the user
            isNewGame: false,
            viewingRoster: false,
            selectedDraftPlayer: null
        };

        // Generate draft class with realistic ratings
        // Guaranteed: 1-3 elite (90+), 6+ standouts (85-89), rest are developmental
        function generateDraftClass() {
            const draftClass = [];
            const totalPlayers = DRAFT.ROUNDS * DRAFT.PLAYERS_PER_ROUND;
            const positions = ['QB', 'WR', 'WR', 'WR', 'CB', 'CB', 'OL', 'DL'];

            // First, generate guaranteed elite players (90+)
            const numElite = randomInt(1, 3);
            for (let i = 0; i < numElite; i++) {
                const position = positions[randomInt(0, positions.length - 1)];
                const player = generatePlayer(position, 'elite');
                player.age = randomInt(21, 22);
                player.yearsInLeague = 0;

                // Ensure 90+ overall
                if (player.overall < 90) {
                    const boost = (90 + randomInt(0, 2)) / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.min(99, Math.floor(player.stats[stat] * boost));
                    });
                    if (player.coreAttributes) {
                        Object.keys(player.coreAttributes).forEach(attr => {
                            player.coreAttributes[attr] = Math.min(99, Math.floor(player.coreAttributes[attr] * boost));
                        });
                    }
                    player.overall = calculateOverall(player);
                }
                // Cap at 92
                if (player.overall > 92) {
                    const scale = 92 / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.floor(player.stats[stat] * scale);
                    });
                    player.overall = calculateOverall(player);
                }
                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Generate standout players (85-89) - at least 6
            const numStandouts = randomInt(6, 9);
            for (let i = 0; i < numStandouts; i++) {
                const position = positions[randomInt(0, positions.length - 1)];
                const player = generatePlayer(position, 'star');
                player.age = randomInt(21, 23);
                player.yearsInLeague = 0;

                // Ensure 85-89 overall
                const targetOverall = randomInt(85, 89);
                if (player.overall !== targetOverall) {
                    const scale = targetOverall / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.min(99, Math.max(40, Math.floor(player.stats[stat] * scale)));
                    });
                    if (player.coreAttributes) {
                        Object.keys(player.coreAttributes).forEach(attr => {
                            player.coreAttributes[attr] = Math.min(99, Math.max(40, Math.floor(player.coreAttributes[attr] * scale)));
                        });
                    }
                    player.overall = calculateOverall(player);
                }
                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Fill remaining slots with regular prospects
            const remainingSlots = totalPlayers - draftClass.length;
            for (let i = 0; i < remainingSlots; i++) {
                const position = positions[i % positions.length];

                // Regular tier distribution for remaining players
                const roll = Math.random();
                let tier;
                if (roll < 0.40) tier = 'rookie';        // 40% - developmental (60-73)
                else if (roll < 0.75) tier = 'average';  // 35% - solid prospect (68-78)
                else if (roll < 0.90) tier = 'below_average'; // 15% - raw talent (58-68)
                else tier = 'veteran';                    // 10% - contributor (78-84)

                const player = generatePlayer(position, tier);
                player.age = randomInt(21, 23);
                player.yearsInLeague = 0;

                // Cap regular prospects at 84 (these aren't the guaranteed standouts)
                if (player.overall > 84) {
                    const scale = randomInt(78, 84) / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.floor(player.stats[stat] * scale);
                    });
                    player.overall = calculateOverall(player);
                }

                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Sort by overall rating descending
            const sorted = draftClass.sort((a, b) => b.overall - a.overall);

            // Assign draft cost based on position in pool (best = most expensive)
            sorted.forEach((player, index) => {
                player.draftCost = calculatePickCost(index + 1);
            });

            return sorted;
        }

        // Computer team names for draft display
        const COMPUTER_TEAM_NAMES = [
            'Storm', 'Titans', 'Wolves', 'Hawks', 'Dragons', 'Knights',
            'Vipers', 'Cobras', 'Bears', 'Eagles', 'Sharks'
        ];

        // Start the draft
        function startDraft(isNewGame = false) {
            draftState.active = true;
            draftState.round = 1;
            draftState.pick = 1;
            draftState.picksRemaining = DRAFT.ROUNDS;  // Player gets one pick per round
            draftState.currentPickNumber = 1;  // Start at pick 1
            draftState.isPlayersTurn = false;  // Other teams pick first
            draftState.usingExtraPick = false;
            draftState.simulatingPicks = false;
            draftState.lastComputerPick = null;
            draftState.draftPool = generateDraftClass();
            draftState.draftedPlayers = [];
            draftState.playerPicks = [];
            draftState.isNewGame = isNewGame;
            draftState.viewingRoster = false;
            draftState.selectedDraftPlayer = null;

            // Calculate and set draft budget based on season ranking
            if (isNewGame && managementState.team) {
                // New games get fixed starting budget
                managementState.team.draftPoints = DRAFT.NEW_GAME_BUDGET;
            } else if (!isNewGame && managementState.team) {
                // Returning seasons calculate budget based on ranking
                const teamRank = getTeamSeasonRank();
                managementState.team.draftPoints = calculateDraftBudget(teamRank);
            } else if (managementState.team && !managementState.team.draftPoints) {
                // Fallback
                managementState.team.draftPoints = DRAFT.NEW_GAME_BUDGET;
            }

            showScreen('draft');
            refreshDraftScreen();

            // Save game at start of draft so progress isn't lost on reload
            if (managementState.settings.autoSave) SaveSystem.save();
        }

        // Check if it's the player's turn based on current pick number
        function isPlayersTurnNow() {
            if (!draftState.currentPickNumber || !DRAFT.NUM_TEAMS) return false;
            const pickInRound = ((draftState.currentPickNumber - 1) % DRAFT.NUM_TEAMS) + 1;
            return pickInRound === DRAFT.NUM_TEAMS;
        }

        // Simulate a single computer team pick (called when user clicks Next Pick)
        function simulateNextComputerPick() {
            const available = getAvailableDraftPlayers();

            // Check if it's player's turn
            if (isPlayersTurnNow()) {
                draftState.isPlayersTurn = true;
                draftState.lastComputerPick = null;
                refreshDraftScreen();
                return;
            }

            if (available.length === 0) {
                draftState.isPlayersTurn = true;
                refreshDraftScreen();
                return;
            }

            // Computer team picks from top available players (with some randomness)
            const pickRange = Math.min(3, available.length);
            const pickIdx = Math.floor(Math.random() * pickRange);
            const picked = available[pickIdx];

            if (picked) {
                draftState.draftedPlayers.push(picked.id);

                // Store the pick for display
                const teamIndex = (draftState.currentPickNumber - 1) % (DRAFT.NUM_TEAMS - 1);
                draftState.lastComputerPick = {
                    teamName: COMPUTER_TEAM_NAMES[teamIndex],
                    player: picked,
                    pickNumber: draftState.currentPickNumber
                };

                draftState.currentPickNumber++;

                // Update display (user will click Next Pick to continue)
                refreshDraftScreen();
            }
        }

        // Skip all computer picks and go directly to player's turn
        function skipToPlayerTurn() {
            const available = getAvailableDraftPlayers();

            while (!isPlayersTurnNow() && available.length > 0) {
                // Computer team picks from top available
                const pickRange = Math.min(3, available.length);
                const pickIdx = Math.floor(Math.random() * pickRange);
                const picked = available.splice(pickIdx, 1)[0];

                if (picked) {
                    draftState.draftedPlayers.push(picked.id);
                    draftState.currentPickNumber++;
                }
            }

            draftState.isPlayersTurn = true;
            draftState.lastComputerPick = null;
            refreshDraftScreen();
        }

        // Legacy function - no longer auto-plays, user uses Next Pick button
        function simulateOtherTeamsPicks() {
            // No-op - user navigates manually now
        }

        // Get all available (undrafted) players
        function getAvailableDraftPlayers() {
            return draftState.draftPool
                .filter(p => !draftState.draftedPlayers.includes(p.id));
        }

        // Check if team can afford a player
        function canAffordDraftPlayer(playerId) {
            const player = draftState.draftPool.find(p => p.id === playerId);
            if (!player || !managementState.team) return false;
            return (managementState.team.draftPoints || 0) >= player.draftCost;
        }

        // Draft a player
        function draftPlayer(playerId) {
            console.log('draftPlayer called with:', playerId);
            console.log('draftState:', {
                active: draftState.active,
                picksRemaining: draftState.picksRemaining,
                isPlayersTurn: draftState.isPlayersTurn,
                usingExtraPick: draftState.usingExtraPick,
                draftedPlayers: draftState.draftedPlayers
            });

            const player = draftState.draftPool.find(p => p.id === playerId);
            console.log('Found player:', player);

            if (!player) {
                console.log('FAIL: Player not found in draft pool');
                return false;
            }
            if (draftState.draftedPlayers.includes(playerId)) {
                console.log('FAIL: Player already drafted');
                return false;
            }

            // Check if it's the player's turn (or using a traded pick)
            if (!draftState.isPlayersTurn && !draftState.usingExtraPick) {
                console.log('FAIL: Not your turn to draft');
                return false;
            }

            // If using a traded pick, it works like your own pick (FREE to draft)
            if (draftState.usingExtraPick) {
                // Add to team roster (no draft cost - picks are free)
                managementState.team.roster.push(player);
                draftState.draftedPlayers.push(playerId);
                draftState.playerPicks.push(playerId);
                draftState.currentPickNumber++;
                draftState.usingExtraPick = false;  // Reset traded pick flag

                // Update depth chart
                autoAssignDepthChart(managementState.team);

                // Save progress
                if (managementState.settings.autoSave) SaveSystem.save();

                // Just refresh - modal shows feedback
                refreshDraftScreen();
                return true;
            }

            // Normal draft pick - check if player has picks remaining
            if (draftState.picksRemaining <= 0) {
                console.log('FAIL: No picks remaining');
                return false;
            }

            console.log('SUCCESS: Drafting player...');

            // Add to team roster (no draft cost - picks are free to use)
            managementState.team.roster.push(player);
            draftState.draftedPlayers.push(playerId);
            draftState.playerPicks.push(playerId);
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;
            console.log('State updated. Picks remaining:', draftState.picksRemaining, 'Round:', draftState.round);

            // Update depth chart
            autoAssignDepthChart(managementState.team);
            console.log('Depth chart updated');

            // Check if draft is complete
            if (draftState.picksRemaining <= 0) {
                console.log('Draft complete, calling finishDraft');
                finishDraft();
                return true;
            }

            // Save progress
            if (managementState.settings.autoSave) SaveSystem.save();

            // Just refresh the screen - no animation needed since modal shows feedback
            draftState.lastComputerPick = null;
            console.log('Calling refreshDraftScreen...');
            refreshDraftScreen();
            console.log('refreshDraftScreen completed');

            return true;
        }

        // Skip current pick (use pick without selecting a player)
        function skipDraftPick() {
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;
            draftState.lastComputerPick = null;

            if (draftState.picksRemaining <= 0) {
                finishDraft();
                return;
            }

            // Just refresh - user will click Next Pick to continue
            refreshDraftScreen();
        }

        // Legacy function - now just completes draft
        function advanceDraft() {
            // No longer needed - draft advances after each pick

            if (draftState.round > DRAFT.ROUNDS) {
                // Draft complete
                finishDraft();
                return;
            }

            refreshDraftScreen();
        }

        // Finish the draft
        function finishDraft() {
            draftState.active = false;

            // Save game
            if (managementState.settings.autoSave) SaveSystem.save();

            // Show hub
            showScreen('hub');
        }

        // ========================================
        // PICK TRADING SYSTEM
        // ========================================

        // Get value of the current pick based on its position in the draft order
        // This is static - pick 1 = 1000, pick 2 = 800, etc. (uses calculatePickCost)
        function getCurrentPickValue() {
            return calculatePickCost(draftState.currentPickNumber);
        }

        // Get value player receives when trading in their pick
        function getTradeInValue() {
            const pickValue = getCurrentPickValue();
            const penalty = managementState.settings.pickTradeInPenalty || DRAFT.DEFAULT_TRADE_IN_PENALTY;
            return Math.max(0, pickValue - penalty);
        }

        // Get cost to acquire the current pick from another team
        function getAcquireCost() {
            const pickValue = getCurrentPickValue();
            const premiumPercent = managementState.settings.pickAcquirePremium || (DRAFT.DEFAULT_ACQUIRE_PREMIUM * 100);
            return Math.ceil(pickValue * (1 + premiumPercent / 100));
        }

        // Check if player can afford to acquire the current pick
        function canAffordAcquirePick() {
            if (!managementState.team) return false;
            return (managementState.team.draftPoints || 0) >= getAcquireCost();
        }

        // Trade in the player's current pick for draft points
        function tradeInPick() {
            if (!draftState.active || draftState.picksRemaining <= 0) return false;

            const tradeValue = getTradeInValue();

            // Add draft points
            managementState.team.draftPoints += tradeValue;

            // Use up the pick without drafting a player
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;

            if (draftState.picksRemaining <= 0) {
                finishDraft();
                return true;
            }

            // Simulate other teams picking for next round
            simulateOtherTeamsPicks();
            refreshDraftScreen();
            return true;
        }

        // Trade for a pick by paying the premium cost
        // This gives the player the current pick without using their regular pick slot
        function acquireCurrentPick() {
            if (!draftState.active || !canAffordAcquirePick()) return false;

            const acquireCost = getAcquireCost();

            // Deduct the cost
            managementState.team.draftPoints -= acquireCost;

            // Mark that player is using an extra pick
            draftState.usingExtraPick = true;

            refreshDraftScreen();
            return true;
        }

        // Toggle draft view between pool and roster
        function toggleDraftView(showRoster) {
            draftState.viewingRoster = showRoster;
            refreshDraftScreen();
        }

        // Show player detail for draft player
        function showDraftPlayerDetail(playerId) {
            console.log('showDraftPlayerDetail called with:', playerId);
            const player = draftState.draftPool.find(p => p.id === playerId);
            console.log('Found player in pool:', player);
            if (!player) return;

            draftState.selectedDraftPlayer = player;
            console.log('Set selectedDraftPlayer:', draftState.selectedDraftPlayer);

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Player info - draft version (no cost - picks are free)
            const infoHtml = `
                <div><span class="ovr-big">${player.overall}</span></div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age} | Peak ${player.peakAge}<br>
                    Salary: ${formatSalary(player.salaryCost)} | Potential: ${'‚òÖ'.repeat(player.potentialGrade)}
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // Hide cut button, show draft button
            const tradeBtn = document.getElementById('btnTradePlayer');
            const cutBtn = document.getElementById('btnCutPlayer');
            const alreadyDrafted = draftState.draftedPlayers.includes(playerId);
            const canDraftNow = draftState.isPlayersTurn || draftState.usingExtraPick;

            if (alreadyDrafted) {
                tradeBtn.textContent = 'ALREADY DRAFTED';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            } else if (!canDraftNow) {
                tradeBtn.textContent = 'NOT YOUR TURN';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            } else {
                tradeBtn.textContent = 'DRAFT';
                tradeBtn.disabled = false;
                tradeBtn.style.opacity = '1';
            }
            cutBtn.style.display = 'none';

            const getColorClass = (val) => val >= 90 ? 'stat-elite' : val >= 80 ? 'stat-good' : val >= 70 ? 'stat-average' : val >= 60 ? 'stat-below' : 'stat-poor';

            // Build unified stats panel
            const core = player.coreAttributes;
            const abilities = calculateAbilities(player);
            const bestAbility = getBestAbility(player);
            const techniqueStats = POSITIONS[player.position].techniqueStats || [];

            let statsHtml = '<div class="stats-panel">';

            // Core Attributes section
            if (core) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Core</div>
                        <div class="stats-grid">
                            <div class="stat-row str-row"><span class="stat-row-name">STR</span><span class="stat-row-value ${getColorClass(core.strength)}">${core.strength}</span></div>
                            <div class="stat-row spd-row"><span class="stat-row-name">SPD</span><span class="stat-row-value ${getColorClass(core.speed)}">${core.speed}</span></div>
                            <div class="stat-row agi-row"><span class="stat-row-name">AGI</span><span class="stat-row-value ${getColorClass(core.agility)}">${core.agility}</span></div>
                            <div class="stat-row int-row"><span class="stat-row-name">INT</span><span class="stat-row-value ${getColorClass(core.intelligence)}">${core.intelligence}</span></div>
                        </div>
                    </div>
                `;
            }

            // Abilities section
            if (abilities) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Abilities</div>
                        <div class="stats-grid">
                            ${Object.entries(abilities).map(([key, value]) => {
                                const isBest = bestAbility && bestAbility.name === key;
                                const dots = getAbilityDots(key);
                                const name = getAbilityDisplayName(key);
                                return `<div class="stat-row ${isBest ? 'best-ability' : ''}"><span class="stat-row-name">${dots}${name}</span><span class="stat-row-value ${getColorClass(value)}">${value}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Technique section
            if (techniqueStats.length > 0) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Technique</div>
                        <div class="stats-grid">
                            ${techniqueStats.map(stat => {
                                const current = Math.floor(player.stats[stat] || 0);
                                const statName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                                return `<div class="stat-row"><span class="stat-row-name">${statName}</span><span class="stat-row-value ${getColorClass(current)}">${current}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            statsHtml += '</div>';

            // Show all stats in main area
            document.getElementById('playerStats').innerHTML = statsHtml;
            document.getElementById('playerSeasonStats').innerHTML = '';
            document.getElementById('playerCareerGraph').innerHTML = '';

            document.getElementById('playerDetailModal').style.display = 'flex';
        }

        // Refresh draft screen
        function refreshDraftScreen() {
            const lastPickEl = document.getElementById('draftLastPick');
            const lastPickTextEl = document.getElementById('draftLastPickText');
            const onClockEl = document.getElementById('draftOnClock');
            const roundPickEl = document.getElementById('draftRoundPick');
            const pointsEl = document.getElementById('draftPoints');
            const teamNameEl = document.getElementById('draftTeamName');
            const statusEl = document.getElementById('draftStatus');
            const poolListEl = document.getElementById('draftPlayerList');
            const rosterListEl = document.getElementById('draftRosterList');
            const skipBtn = document.getElementById('btnSkipRound');
            const finishBtn = document.getElementById('btnFinishDraft');
            const poolBtn = document.getElementById('btnDraftPoolView');
            const rosterBtn = document.getElementById('btnDraftRosterView');
            const tradeInBtn = document.getElementById('btnTradeInPick');
            const acquireBtn = document.getElementById('btnAcquirePick');
            const navButtonsEl = document.getElementById('draftNavButtons');

            // Safety check for missing elements
            if (!onClockEl || !statusEl || !poolListEl || !navButtonsEl) {
                console.error('Draft screen elements not found');
                return;
            }

            const draftPoints = managementState.team?.draftPoints || 0;
            const pickValue = getCurrentPickValue();
            const tradeInValue = getTradeInValue();
            const acquireCost = getAcquireCost();
            const isComputerTurn = !isPlayersTurnNow();
            const available = getAvailableDraftPlayers();

            // Update toggle button states
            poolBtn.classList.toggle('active', !draftState.viewingRoster);
            rosterBtn.classList.toggle('active', draftState.viewingRoster);

            // Show/hide appropriate list
            poolListEl.style.display = draftState.viewingRoster ? 'none' : 'block';
            rosterListEl.style.display = draftState.viewingRoster ? 'block' : 'none';

            if (!draftState.active) {
                finishBtn.style.display = 'block';
                skipBtn.style.display = 'none';
                onClockEl.style.display = 'none';
                lastPickEl.style.display = 'none';
                navButtonsEl.style.display = 'none';
                statusEl.textContent = 'Draft Complete!';
                poolListEl.innerHTML = '<p style="color:#4f4;">Your draft picks have been added to the roster.</p>';
                return;
            }

            // Update last pick notification bar
            if (draftState.lastComputerPick) {
                const pick = draftState.lastComputerPick;
                lastPickTextEl.innerHTML = `Pick #${pick.pickNumber}: <span class="team-name">${pick.teamName}</span> ‚Üí <span class="player-name">${pick.player.firstName} ${pick.player.lastName}</span> <span class="overall">${pick.player.overall}</span>`;
            } else {
                lastPickTextEl.textContent = 'Draft in progress...';
            }

            // Update round/pick info
            roundPickEl.textContent = `Round ${draftState.round} ‚Ä¢ Pick ${draftState.currentPickNumber}`;
            pointsEl.textContent = `${draftPoints} pts`;

            // Update on-the-clock section
            if (draftState.usingExtraPick) {
                onClockEl.className = 'draft-on-clock player';
                teamNameEl.textContent = 'YOUR PICK';
                navButtonsEl.style.display = 'none';
            } else if (draftState.isPlayersTurn || !isComputerTurn) {
                if (!draftState.isPlayersTurn) draftState.isPlayersTurn = true;
                onClockEl.className = 'draft-on-clock player';
                teamNameEl.textContent = 'YOUR TURN';
                navButtonsEl.style.display = 'none';
            } else {
                onClockEl.className = 'draft-on-clock computer';
                // Show actual team name on the clock
                const teamIndex = (draftState.currentPickNumber - 1) % (DRAFT.NUM_TEAMS - 1);
                teamNameEl.textContent = COMPUTER_TEAM_NAMES[teamIndex] || 'Team';
                navButtonsEl.style.display = 'flex';
            }

            // Update trade buttons
            if (draftState.viewingRoster || draftState.simulatingPicks || draftState.usingExtraPick) {
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'none';
            } else if (draftState.isPlayersTurn) {
                // Player's turn: Show TRADE IN only
                acquireBtn.style.display = 'none';
                if (draftState.picksRemaining > 0 && available.length > 0) {
                    tradeInBtn.style.display = 'inline-block';
                    tradeInBtn.innerHTML = `TRADE IN PICK <span class="trade-value">+${tradeInValue}</span>`;
                } else {
                    tradeInBtn.style.display = 'none';
                }
            } else if (isComputerTurn && available.length > 0) {
                // Computer's turn: Show TRADE FOR only
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'inline-block';
                acquireBtn.innerHTML = `TRADE <span class="trade-cost">${acquireCost}</span>`;
                acquireBtn.disabled = !canAffordAcquirePick();
            } else {
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'none';
            }

            // Update status line
            const playerDrafted = draftState.playerPicks.length;
            if (draftState.usingExtraPick) {
                statusEl.textContent = `Select a player | Drafted: ${playerDrafted}`;
                skipBtn.style.display = 'none';
            } else if (draftState.isPlayersTurn) {
                statusEl.textContent = `Picks remaining: ${draftState.picksRemaining} | Drafted: ${playerDrafted}`;
                skipBtn.style.display = draftState.viewingRoster ? 'none' : 'block';
            } else {
                statusEl.textContent = `Drafted: ${playerDrafted}`;
                skipBtn.style.display = 'none';
            }
            finishBtn.style.display = 'none';

            if (draftState.viewingRoster) {
                refreshDraftRosterView(rosterListEl);
            } else {
                refreshDraftPoolView(poolListEl);
            }
        }

        // Refresh draft pool view
        function refreshDraftPoolView(listEl) {
            const available = getAvailableDraftPlayers();
            listEl.innerHTML = '';

            if (available.length === 0) {
                listEl.innerHTML = '<p style="color:#888;">No more players available.</p>';
                return;
            }

            available.forEach(player => {
                let potentialDisplay = '';
                if (player.potentialGrade > 0) {
                    potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                }

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div style="flex:1;">
                        <div class="name">${player.firstName} ${player.lastName}</div>
                        <div class="stats">${POSITIONS[player.position].name}</div>
                    </div>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                        <span class="potential-ind" style="min-width:30px;color:#ffd700;font-size:14px;">${potentialDisplay}</span>
                    </div>
                `;
                item.addEventListener('click', () => {
                    console.log('Draft player item clicked, ID:', player.id);
                    showDraftPlayerDetail(player.id);
                });
                listEl.appendChild(item);
            });
        }

        // Refresh draft roster view
        function refreshDraftRosterView(listEl) {
            listEl.innerHTML = '';

            if (!managementState.team || managementState.team.roster.length === 0) {
                listEl.innerHTML = '<p style="color:#888;">No players on roster yet.</p>';
                return;
            }

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                listEl.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    let potentialDisplay = '';
                    if (player.potentialGrade > 0) {
                        potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                    }

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName}</div>
                            <div class="stats">Age ${player.age} | ${formatSalary(player.salaryCost)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:#ffd700;font-size:14px;">${potentialDisplay}</span>
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    listEl.appendChild(item);
                });
            });
        }

        // ========================================
        // MANAGEMENT LAYER - MATCH SIMULATION
        // ========================================

        // Calculate team defense rating
        function calculateTeamDefenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // CBs
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.manCoverage + player.stats.zoneCoverage + player.stats.tackling) / 3;
                        count++;
                    }
                }
            });

            // DL
            dc.DL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passRush + player.stats.tackling) / 2;
                        count++;
                    }
                }
            });

            return count > 0 ? total / count : 50;
        }

        // Calculate team offense rating
        function calculateTeamOffenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // WRs
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.speed + player.stats.catching + player.stats.routeRunning) / 3;
                        count++;
                    }
                }
            });

            // OL
            dc.OL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passBlock + player.stats.strength) / 2;
                        count++;
                    }
                }
            });

            // QB
            if (dc.QB) {
                const qb = roster.find(p => p.id === dc.QB);
                if (qb) {
                    const passAcc = ((qb.stats.shortPassAcc || 70) + (qb.stats.longPassAcc || 70)) / 2;
                    total += (passAcc + qb.stats.awareness) / 2;
                    count++;
                }
            }

            return count > 0 ? total / count : 50;
        }

        // ========================================
        // REALISTIC ENEMY DRIVE SIMULATION
        // ========================================

        // Weighted roll using stat weights (same formula as real game)
        // Uses coreAttributes for speed, agility, strength (merged stats)
        function weightedStatRoll(stats, weights, coreAttributes = null) {
            let weightedTotal = 0;
            const coreStats = ['speed', 'agility', 'strength'];
            for (const stat in weights) {
                let statValue;
                // Use coreAttributes for speed, agility, strength if available
                if (coreStats.includes(stat) && coreAttributes && coreAttributes[stat] !== undefined) {
                    statValue = coreAttributes[stat];
                } else {
                    statValue = stats[stat] || 50;
                }
                weightedTotal += statValue * weights[stat];
            }
            // Add ¬±20% variance
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);
            return roll;
        }

        // Get player's full name
        function getPlayerFullName(player) {
            if (!player) return 'Unknown';
            const first = player.firstName || 'Player';
            const last = player.lastName || '';
            return `${first} ${last.charAt(0) || ''}.`.trim();
        }

        // ========================================
        // HIGH-FIDELITY ROUND-BASED SIMULATION
        // ========================================

        // Select routes for receivers based on field position and situation
        function selectRoutesForPlay(receivers, yardsFromGoal, yardsToGo, down) {
            const routeAssignments = {};

            // Determine field zone
            const zone = yardsFromGoal <= 8 ? 'goalline' :
                         yardsFromGoal <= 20 ? 'redzone' : 'standard';

            const availableRoutes = Object.values(ROUTE_TEMPLATES[zone]);

            // Identify crossing/comeback routes (have crossing round or specific route types)
            const isCrossingRoute = (route) => {
                const crossingNames = ['slant', 'dig', 'comeback', 'curl', 'out', 'in', 'flat', 'quick_slant', 'endzone_slant'];
                if (crossingNames.some(name => route.name?.includes(name))) return true;
                // Or has a round with crossing: true after round 1
                return route.rounds?.some((r, i) => i > 0 && r.crossing);
            };

            const crossingRoutes = availableRoutes.filter(isCrossingRoute);

            // Categorize routes by depth
            const quickRoutes = availableRoutes.filter(r => r.rounds[1].depth <= 6);
            const mediumRoutes = availableRoutes.filter(r => r.rounds[1].depth > 6 && r.rounds[2].depth <= 12);
            const deepRoutes = availableRoutes.filter(r => r.rounds[2].depth > 12);

            // Randomly pick which receiver gets the guaranteed crossing route (usually slot/WR3)
            const crossingReceiverIndex = Math.random() < 0.6 ? 2 : (Math.random() < 0.5 ? 1 : 0);

            // Select based on situation
            receivers.forEach((wr, index) => {
                let routePool;

                // Ensure one receiver always runs a crossing/comeback route
                if (index === crossingReceiverIndex && crossingRoutes.length > 0) {
                    routePool = crossingRoutes;
                } else if (down >= 3 && yardsToGo > 7) {
                    // 3rd/4th and long - need deep routes
                    routePool = index === 0 ? deepRoutes : (index === 1 ? mediumRoutes : quickRoutes);
                } else if (down >= 3 && yardsToGo <= 3) {
                    // 3rd/4th and short - quick routes
                    routePool = index === 0 ? quickRoutes : (index === 1 ? mediumRoutes : deepRoutes);
                } else {
                    // Normal downs - mix it up
                    routePool = index === 0 ? mediumRoutes : (index === 1 ? deepRoutes : quickRoutes);
                }

                // Fallback if pool is empty
                if (routePool.length === 0) routePool = availableRoutes;

                // Pick random route from pool
                const route = routePool[Math.floor(Math.random() * routePool.length)];
                routeAssignments[wr.id || index] = route;
            });

            return routeAssignments;
        }

        // Initialize play state for round-based simulation
        function initializePlayState(offense, defense, fieldPosition) {
            const routes = selectRoutesForPlay(
                offense.receivers,
                fieldPosition.yardsFromGoal,
                fieldPosition.yardsToGo,
                fieldPosition.down
            );

            return {
                round: 0,
                maxRounds: 5,

                // Field state
                yardsFromGoal: fieldPosition.yardsFromGoal,
                yardsToGo: fieldPosition.yardsToGo,
                down: fieldPosition.down,

                // Pressure tracking
                totalPressure: 0,
                sacked: false,
                sackingPlayer: null,
                lineMatchups: [],  // Track OL/DL clashes for display

                // Receiver states
                receivers: offense.receivers.map((wr, index) => ({
                    id: wr.id || index,
                    player: wr,
                    stats: wr.stats,
                    route: routes[wr.id || index],
                    currentDepth: 0,
                    separation: 0,
                    catchProbability: 0,
                    effectiveCatchPct: 0,
                    rollMean: 79,
                    // Momentum tracking
                    lastDirection: 'vertical',  // 'vertical' or 'horizontal'
                    momentum: 0                  // Built up over consecutive same-direction rounds
                })),

                // Defender states (DBs)
                defenders: defense.dbs.map((db, index) => ({
                    id: db.id || index,
                    player: db,
                    stats: db.stats,
                    position: db.position || 'CB',
                    // Momentum tracking for defenders
                    lastDirection: 'vertical',
                    momentum: 0
                })),

                // O-Line states
                oLine: offense.oLine.map((ol, index) => ({
                    id: ol.id || index,
                    player: ol,
                    stats: ol.stats,
                    knockedDown: false
                })),

                // D-Line states
                dLine: defense.dLine.map((dl, index) => ({
                    id: dl.id || index,
                    player: dl,
                    stats: dl.stats,
                    knockedDown: false,
                    pressureContribution: 0
                })),

                // QB state
                qb: {
                    player: offense.qb,
                    stats: offense.qb.stats,
                    coreAttributes: offense.qb.coreAttributes || null,
                    trait: offense.qb.qbTrait || 'balanced',
                    hasThrown: false
                },

                // Result tracking
                result: null
            };
        }

        // Process OL/DL clashes for a single round
        function processLineClashesRound(state) {
            const roundBonus = (state.round - 1) * 3;  // DL gets +3 per round (was +5)
            let totalPressure = 0;

            // Reset pressure contributions
            state.dLine.forEach(dl => { dl.pressureContribution = 0; });

            // Clear matchups for this round (we'll keep the latest round's matchups)
            state.lineMatchups = [];

            for (let i = 0; i < state.dLine.length; i++) {
                const dl = state.dLine[i];

                if (dl.knockedDown) {
                    continue;
                }

                // Find corresponding OL (or closest available non-knocked-down)
                let ol = state.oLine[i];
                if (!ol || ol.knockedDown) {
                    ol = state.oLine.find(o => !o.knockedDown);
                }

                if (!ol) {
                    // Unblocked rusher - maximum pressure
                    dl.pressureContribution = 40;
                    totalPressure += 40;

                    // Record matchup
                    state.lineMatchups.push({
                        dl: dl.player,
                        ol: null,
                        dlRoll: 99,
                        olRoll: 0,
                        result: 'unblocked',
                        pressure: 40
                    });

                    // Sack chance for unblocked rusher (reduced from 35%)
                    if (Math.random() < 0.20) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    continue;
                }

                // Ability selection - DL initiates, OL reacts
                const abilityResult = resolveAbilityClash(dl.player, ol.player, ABILITY_MATCHUPS.linemen, true);

                // Calculate technique rolls (40% of total)
                const olTechRoll = getTechniqueRoll(ol.stats, CLASH_WEIGHTS.lineClash.offense);
                const dlTechRoll = getTechniqueRoll(dl.stats, CLASH_WEIGHTS.lineClash.defense);

                // Calculate core√óability multiplicative rolls (60% of total)
                const olCoreAbilityRoll = getCoreAbilityRoll(ol.player, abilityResult.reactor);
                const dlCoreAbilityRoll = getCoreAbilityRoll(dl.player, abilityResult.initiator);

                // Combined rolls with variance (¬±20%)
                const variance = 0.2;
                const olRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;
                const dlRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;

                const adjustedOlRoll = (olTechRoll + olCoreAbilityRoll) * olRollVariance;
                // Apply matchup multiplier and round bonus to DL
                const adjustedDlRoll = ((dlTechRoll + dlCoreAbilityRoll) * dlRollVariance + roundBonus) * abilityResult.matchupMultiplier;

                const margin = adjustedDlRoll - adjustedOlRoll;

                let result = 'held';
                // Determine outcome based on margin
                if (margin > 18) {
                    // DL dominant win - sack chance (reduced from 25%)
                    dl.pressureContribution = 35;
                    result = 'beaten badly';
                    if (Math.random() < 0.15) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    // OL might get knocked down
                    if (Math.random() < 0.3) {
                        ol.knockedDown = true;
                    }
                } else if (margin > 10) {
                    dl.pressureContribution = 25;
                    result = 'beaten';
                } else if (margin > 5) {
                    dl.pressureContribution = 15;
                    result = 'pressured';
                } else if (margin > 2) {
                    dl.pressureContribution = 10;
                    result = 'pressured';
                } else if (margin > -2) {
                    dl.pressureContribution = 3;
                    result = 'held';
                } else if (margin > -10) {
                    dl.pressureContribution = 0;
                    result = 'blocked';
                } else {
                    // OL dominant win - DL might get knocked down
                    dl.pressureContribution = 0;
                    result = 'pancaked';
                    if (Math.random() < 0.2) {
                        dl.knockedDown = true;
                    }
                }

                // Record matchup for display
                state.lineMatchups.push({
                    dl: dl.player,
                    ol: ol.player,
                    dlRoll: Math.round(dlRoll),
                    olRoll: Math.round(olRoll),
                    result: result,
                    pressure: dl.pressureContribution
                });

                totalPressure += dl.pressureContribution;
            }

            state.totalPressure = Math.min(totalPressure, 100);
        }

        // Process WR/DB separation clashes for a single round
        // Momentum mechanics - both players have same physics, but DB must REACT while WR pre-plans
        function processReceiverClashesRound(state) {
            for (let i = 0; i < state.receivers.length; i++) {
                const receiver = state.receivers[i];
                const routeRound = receiver.route.rounds[state.round - 1];
                const isCrossing = routeRound.crossing;
                const isBreakRound = receiver.route.breakRound === state.round;

                // Determine current direction
                const currentDirection = isCrossing ? 'horizontal' : 'vertical';
                const directionChanged = currentDirection !== receiver.lastDirection;

                // Update receiver depth
                receiver.currentDepth = routeRound.depth;

                // Find covering defender
                const defender = state.defenders[i] || state.defenders[0];

                if (!defender) {
                    receiver.separation = 30;  // Wide open
                    receiver.momentum = directionChanged ? 1 : Math.min(receiver.momentum + 1, 5);
                    receiver.lastDirection = currentDirection;
                    receiver.momentumAdvantage = 0;
                    continue;
                }

                // ========================================
                // MOMENTUM MECHANICS (UNIFIED PHYSICS)
                // ========================================
                // Both players have the same momentum physics when changing direction
                // The difference: WR pre-plans the cut, DB must REACT

                // Agility determines how well a player changes direction
                const wrAgility = receiver.stats.agility || 70;
                const dbAgility = defender.stats.agility || 70;

                // DB reaction time based on awareness (0-100)
                // Low awareness = slow to recognize the cut = still moving wrong way
                const dbAwareness = defender.stats.awareness || 70;
                // Reaction frames: 100 awareness = 0 frames, 50 awareness = 2.5 frames delay
                const reactionFrames = (100 - dbAwareness) / 20;

                // Momentum effect multiplier (same physics for both)
                // Higher momentum = harder to change direction
                const momentumPenaltyPerLevel = 8;  // Strong effect

                let wrMomentumEffect = 0;
                let dbMomentumEffect = 0;
                let momentumAdvantage = 0;

                if (directionChanged) {
                    // WR changes direction instantly (pre-planned)
                    // Penalty based on their momentum, reduced by agility
                    const wrAgilityFactor = wrAgility / 100;
                    wrMomentumEffect = receiver.momentum * momentumPenaltyPerLevel * (1 - wrAgilityFactor * 0.5);

                    // DB must REACT - they keep moving wrong way during reaction time
                    // Then they change direction with same physics
                    const dbAgilityFactor = dbAgility / 100;

                    // Reaction delay: DB's momentum CONTINUES building during reaction time
                    const effectiveMomentum = defender.momentum + reactionFrames;
                    dbMomentumEffect = effectiveMomentum * momentumPenaltyPerLevel * (1 - dbAgilityFactor * 0.5);

                    // Momentum advantage = how much the WR gained from the cut
                    momentumAdvantage = dbMomentumEffect - wrMomentumEffect;

                    // Store for display
                    receiver.momentumAdvantage = Math.round(momentumAdvantage);
                    receiver.dbReactionDelay = reactionFrames;
                } else {
                    receiver.momentumAdvantage = 0;
                    receiver.dbReactionDelay = 0;
                }

                // ========================================
                // BASE SEPARATION ROLL
                // ========================================
                let receiverRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver, receiver.player.coreAttributes);

                // Crossing route bonus - route running helps execute cuts cleanly
                // Reduced from 0.3 to 0.10 for better balance
                if (isCrossing) {
                    const crossingBonus = receiver.stats.routeRunning * 0.10;
                    receiverRoll += crossingBonus;
                }

                // Break round bonus (the "snap" of the route creates separation)
                // Reduced from 0.25 to 0.08 for better balance
                if (isBreakRound) {
                    const breakBonus = receiver.stats.routeRunning * 0.08;
                    receiverRoll += breakBonus;
                }

                // ========================================
                // DEFENDER ROLL
                // ========================================
                let defenderRoll = weightedStatRoll(defender.stats, CLASH_WEIGHTS.separation.defender, defender.player.coreAttributes);

                // Defender counter-bonuses to balance WR route bonuses
                // Awareness helps read the route and anticipate breaks
                const awarenessBonus = (defender.stats.awareness || 70) * 0.08;
                defenderRoll += awarenessBonus;

                // Awareness also helps track the receiver through cuts
                if (isCrossing || isBreakRound) {
                    const trackingBonus = (defender.stats.awareness || 70) * 0.06;
                    defenderRoll += trackingBonus;
                }

                // ========================================
                // APPLY MOMENTUM ADVANTAGE
                // ========================================
                // The momentum advantage goes directly to separation
                // Positive = WR gained separation from the cut
                receiverRoll += momentumAdvantage;

                // ========================================
                // UPDATE MOMENTUM FOR NEXT ROUND
                // ========================================
                if (directionChanged) {
                    // Both reset to 1 after direction change
                    receiver.momentum = 1;
                    defender.momentum = 1;
                } else {
                    // Build momentum in current direction (cap at 5 for stronger effect)
                    receiver.momentum = Math.min(receiver.momentum + 1, 5);
                    defender.momentum = Math.min(defender.momentum + 1, 5);
                }

                receiver.lastDirection = currentDirection;
                defender.lastDirection = currentDirection;

                // Calculate separation margin
                receiver.separation = receiverRoll - defenderRoll;
            }
        }

        // Calculate catch probabilities using exponential distribution
        function simCalculateCatchProbabilities(state) {
            const pressure = state.totalPressure;
            const qbAgility = state.qb.coreAttributes?.agility || state.qb.stats.agility || 70;

            for (const receiver of state.receivers) {
                // Use short or long pass accuracy based on depth (12 yards = break point)
                const isShortPass = receiver.currentDepth < 12;
                const passAccStat = isShortPass
                    ? (state.qb.stats.shortPassAcc || state.qb.stats.throwing || 70)
                    : (state.qb.stats.longPassAcc || state.qb.stats.throwing || 70);

                // Multiplicative accuracy: agility √ó passAcc
                const qbAccuracy = (qbAgility / 100) * (passAccStat / 100) * 100;

                // QB throw quality - rollMean determines accuracy distribution
                const rollMean = 79 + (75 - qbAccuracy) * 1.7 + pressure * 0.5;

                let catchProb = receiver.stats.catching;

                // Separation bonus/penalty
                if (receiver.separation >= 20) {
                    catchProb += 15;
                } else if (receiver.separation >= 10) {
                    catchProb += 8;
                } else if (receiver.separation >= 3) {
                    catchProb += 3;
                } else if (receiver.separation >= -3) {
                    catchProb += 0;
                } else if (receiver.separation >= -10) {
                    catchProb -= 15;
                } else {
                    catchProb -= 30;
                }

                // Contested catch bonus from catching skill
                if (receiver.separation < 5) {
                    const contestedBonus = (receiver.stats.catching - 70) * 0.2;
                    catchProb += contestedBonus;
                }

                // Depth penalty for longer throws (reduced by good long pass accuracy)
                const depthPenalty = Math.max(0, (receiver.currentDepth - 15) * 0.3);
                catchProb -= depthPenalty;

                // Clamp
                catchProb = Math.max(5, Math.min(95, catchProb));

                // Calculate effective catch % with exponential
                const effectiveCatchPct = (1 - Math.exp(-catchProb / rollMean)) * 100;

                receiver.catchProbability = catchProb;
                receiver.effectiveCatchPct = effectiveCatchPct;
                receiver.rollMean = rollMean;
                receiver.qbAccuracy = qbAccuracy;  // Store for display
            }
        }

        // QB decision: should throw, and to whom?
        function processQBDecision(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;
            const qbStats = state.qb.stats;

            // Step 1: Vision check - can QB see each receiver?
            const visibleReceivers = [];
            for (const receiver of state.receivers) {
                const qbInt = state.qb.coreAttributes?.intelligence || 70;
                const visionRoll = weightedStatRoll(qbStats, {
                    awareness: 0.70
                }, state.qb.coreAttributes) * 0.7 + qbInt * 0.3;

                // Easier to notice more open receivers
                const noticeThreshold = 70 - receiver.separation;
                const noticeRoll = visionRoll + (Math.random() * 20 - 10);

                if (noticeRoll >= noticeThreshold) {
                    visibleReceivers.push(receiver);
                }
            }

            // Step 2: Evaluate throw options
            let throwLikelihood = 0;
            let bestTarget = null;
            let bestScore = -999;

            for (const receiver of visibleReceivers) {
                let score = receiver.effectiveCatchPct;

                // First down consideration
                const wouldGetFirstDown = receiver.currentDepth >= state.yardsToGo;
                if (wouldGetFirstDown) {
                    score += trait.firstDownBias;
                } else {
                    score -= state.round * 3;  // Penalty for short throws late
                }

                // Down urgency
                if (state.down >= 3 && !wouldGetFirstDown) {
                    score -= 15;
                }

                // Trait threshold
                if (receiver.effectiveCatchPct < trait.openThreshold) {
                    score -= 20;
                }

                // Aggressiveness for contested
                if (receiver.separation < 5) {
                    score *= trait.aggressiveness;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = receiver;
                }
            }

            // Step 3: Calculate throw likelihood
            if (bestTarget) {
                throwLikelihood = bestScore;

                // Pressure urgency
                const pressureUrgency = state.totalPressure * trait.pressureMultiplier;
                throwLikelihood += pressureUrgency * 0.5;

                // Round urgency
                throwLikelihood += state.round * 8;

                // Very high pressure = must throw
                if (state.totalPressure > 70) {
                    throwLikelihood += 30;
                }
            } else {
                // No visible targets
                throwLikelihood = state.totalPressure * 0.5 + state.round * 10;
            }

            // Step 4: Roll to throw
            const throwRoll = Math.random() * 100;
            const shouldThrow = throwRoll < throwLikelihood;

            return {
                shouldThrow,
                target: bestTarget,
                throwLikelihood,
                visibleReceivers
            };
        }

        // Resolve a throw attempt
        function simResolveThrow(state, target) {
            if (!target) {
                return {
                    type: 'throwaway',
                    yardsGained: 0,
                    description: 'QB throws the ball away',
                    _targetReceiver: null,
                    _qbRoll: 0,
                    _catchSuccess: false
                };
            }

            // Exponential roll for throw quality
            const qbRoll = -target.rollMean * Math.log(Math.random());
            const caught = qbRoll < target.catchProbability;

            let result;
            if (caught) {
                result = simResolveCatchAndRun(state, target);
            } else {
                result = simResolveIncompletions(state, target, qbRoll);
            }

            // Attach tracking info for legacy display
            result._targetReceiver = target;
            result._qbRoll = qbRoll;
            result._catchSuccess = caught;

            return result;
        }

        // Resolve incomplete pass (check for INT)
        function simResolveIncompletions(state, receiver, qbRoll) {
            const defenderIndex = state.receivers.indexOf(receiver);
            const defender = state.defenders[defenderIndex] || state.defenders[0];

            if (defender && receiver.separation < 0) {
                const throwBadness = qbRoll - receiver.catchProbability;

                let intChance = Math.min(throwBadness * 0.4, 25);
                intChance += (defender.stats.awareness - 60) * 0.2;
                intChance += ((defender.stats.catching || 50) - 50) * 0.1;

                if (receiver.separation < -10) {
                    intChance += 5;
                }

                intChance = Math.max(5, Math.min(35, intChance));

                if (Math.random() * 100 < intChance) {
                    return {
                        type: 'interception',
                        yardsGained: 0,
                        interceptedBy: defender.player,
                        description: `Intercepted by ${getPlayerFullName(defender.player)}!`
                    };
                }
            }

            return {
                type: 'incomplete',
                yardsGained: 0,
                description: 'Pass incomplete'
            };
        }

        // Resolve catch and YAC
        function simResolveCatchAndRun(state, receiver) {
            let totalYards = receiver.currentDepth;
            const yacEvents = [];

            // Find nearest defender for tackle
            const defenderIndex = state.receivers.indexOf(receiver);
            const nearestDB = state.defenders[defenderIndex] || state.defenders[0];

            // Immediate tackle attempt if tightly covered (separation < 5)
            // Separation 5-15: chance to avoid immediate tackle based on separation
            // Separation 15+: skip immediate tackle, go straight to YAC
            const skipImmediateTackle = receiver.separation >= 15 ||
                (receiver.separation >= 5 && Math.random() * 100 < receiver.separation * 5);

            if (nearestDB && !skipImmediateTackle) {
                // Separation gives evasion bonus (less covered = harder to tackle)
                const separationBonus = Math.max(0, receiver.separation * 0.5);
                const tackleResult = simResolveTackleAttempt(receiver, nearestDB, -separationBonus);

                if (tackleResult.tackled) {
                    return {
                        type: 'complete',
                        yardsGained: totalYards,
                        caughtBy: receiver.player,
                        tackledBy: nearestDB.player,
                        yac: 0,
                        description: `Caught for ${totalYards} yards, tackled immediately`
                    };
                }
                yacEvents.push(tackleResult);
            }

            // YAC phase - up to 3 tackle attempts
            let tackled = false;
            for (let attempt = 0; attempt < 3 && !tackled; attempt++) {
                // YAC yards proportional to receiver stats
                const yacRoll = weightedStatRoll(receiver.stats, {
                    speed: 0.35,
                    acceleration: 0.25,
                    agility: 0.25,
                    evasion: 0.15
                }, receiver.player.coreAttributes);
                const segmentYards = Math.floor(2 + (yacRoll / 100) * 10);

                // Find next tackler (cycle through defenders, safety gets bonus)
                const tacklerIndex = (defenderIndex + attempt + 1) % state.defenders.length;
                const tackler = state.defenders[tacklerIndex];

                if (!tackler) {
                    totalYards += segmentYards;
                    continue;
                }

                // Safety bonus on later attempts
                const safetyBonus = (tackler.position === 'S' || attempt > 0) ? (10 + attempt * 5) : 0;
                const tackleResult = simResolveTackleAttempt(receiver, tackler, safetyBonus);

                if (tackleResult.tackled) {
                    totalYards += Math.floor(segmentYards * 0.5);
                    tackled = true;
                    yacEvents.push(tackleResult);
                } else {
                    totalYards += segmentYards;
                    yacEvents.push(tackleResult);
                }
            }

            // Check for TD
            const isTouchdown = totalYards >= state.yardsFromGoal;

            return {
                type: isTouchdown ? 'touchdown' : 'complete',
                yardsGained: isTouchdown ? state.yardsFromGoal : totalYards,
                caughtBy: receiver.player,
                tackledBy: yacEvents.find(e => e.tackled)?.tackler || null,
                yac: totalYards - receiver.currentDepth,
                description: isTouchdown ?
                    `TOUCHDOWN! ${totalYards} yard catch and run!` :
                    `Caught for ${receiver.currentDepth} yards, ${totalYards - receiver.currentDepth} YAC`
            };
        }

        // Resolve a tackle attempt
        function simResolveTackleAttempt(receiver, tackler, safetyBonus) {
            const evasionRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier, receiver.player.coreAttributes);
            let tackleRoll = weightedStatRoll(tackler.stats, CLASH_WEIGHTS.tackle.tackler, tackler.player.coreAttributes);

            // Tackler advantage: WRs have natural +7 advantage from primary stat bonuses
            // on speed/agility, while CBs don't get bonuses on tackling/pursuit/hitPower.
            // Add a base tackler bonus to compensate and make tackling realistic.
            const tacklerBonus = 10;
            tackleRoll += tacklerBonus + safetyBonus;

            const margin = tackleRoll - evasionRoll;
            const breakTackleThreshold = -12;

            if (margin > breakTackleThreshold) {
                return {
                    type: 'tackle',
                    tackled: true,
                    tackler: tackler.player,
                    margin
                };
            } else {
                return {
                    type: 'broken_tackle',
                    tackled: false,
                    tackler: tackler.player,
                    margin
                };
            }
        }

        // Resolve sack
        function simResolveSack(state) {
            const sackYards = 5 + Math.floor(Math.random() * 6);
            return {
                type: 'sack',
                yardsGained: -sackYards,
                tackler: state.sackingPlayer,
                description: `Sacked for a loss of ${sackYards} yards`
            };
        }

        // Resolve desperation play (max rounds exceeded)
        function simResolveDesperationPlay(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;

            if (state.totalPressure > 60 && Math.random() < 0.4) {
                return {
                    type: 'sack',
                    yardsGained: -Math.floor(5 + Math.random() * 5),
                    description: 'Sacked after holding the ball too long'
                };
            }

            // Scrambler might run
            if (trait.scrambleBonus && Math.random() < 0.3) {
                const scrambleYards = Math.floor(
                    (state.qb.stats.speed * 0.1) +
                    (state.qb.stats.agility * 0.05) +
                    Math.random() * 5
                );
                return {
                    type: 'scramble',
                    yardsGained: scrambleYards,
                    description: `QB scrambles for ${scrambleYards} yards`
                };
            }

            // Heave to best available
            const bestReceiver = state.receivers.reduce((best, r) =>
                r.effectiveCatchPct > (best?.effectiveCatchPct || 0) ? r : best, null
            );

            if (bestReceiver && bestReceiver.effectiveCatchPct > 20) {
                bestReceiver.catchProbability *= 0.7;
                return simResolveThrow(state, bestReceiver);
            }

            return {
                type: 'throwaway',
                yardsGained: 0,
                description: 'QB throws it away under pressure'
            };
        }

        // Main play simulation loop
        function simulatePlayRoundBased(offense, defense, fieldPosition) {
            const state = initializePlayState(offense, defense, fieldPosition);

            // Track round-by-round events for debugging display
            state.roundEvents = [];

            while (state.round < state.maxRounds && !state.result) {
                state.round++;
                const roundEvent = { round: state.round, events: [] };

                // Phase 1: OL/DL Clashes
                processLineClashesRound(state);

                // Track line clash results
                if (state.lineMatchups && state.lineMatchups.length > 0) {
                    const lastMatchup = state.lineMatchups[state.lineMatchups.length - 1];
                    if (lastMatchup && lastMatchup.result !== 'held' && lastMatchup.result !== 'stonewalled') {
                        roundEvent.events.push({
                            type: 'pressure',
                            player: lastMatchup.dl?.firstName || 'DL',
                            result: lastMatchup.result,
                            pressure: state.totalPressure
                        });
                    }
                }

                // Check for sack
                if (state.sacked) {
                    roundEvent.events.push({ type: 'sack', player: state.sackingPlayer?.firstName || 'DL' });
                    state.roundEvents.push(roundEvent);
                    state.result = simResolveSack(state);
                    break;
                }

                // Phase 2: WR/DB Separation
                processReceiverClashesRound(state);

                // Track separation changes for each receiver
                state.receivers.forEach((rec, i) => {
                    const sep = Math.round(rec.separation || 0);
                    const status = sep > 15 ? 'open' : sep > 5 ? 'space' : sep > -5 ? 'contested' : 'covered';
                    if (rec.momentumAdvantage && rec.momentumAdvantage > 5) {
                        roundEvent.events.push({
                            type: 'route_break',
                            wr: i + 1,
                            momentum: rec.momentumAdvantage,
                            status: status
                        });
                    }
                });

                // Phase 3: Calculate catch probabilities
                simCalculateCatchProbabilities(state);

                // Phase 4: QB Decision
                const decision = processQBDecision(state);

                if (decision.shouldThrow) {
                    roundEvent.events.push({
                        type: 'throw',
                        target: decision.targetIndex + 1,
                        catchProb: Math.round(decision.target?.catchProbability || 0)
                    });
                    state.roundEvents.push(roundEvent);
                    state.result = simResolveThrow(state, decision.target);
                    break;
                }

                // Only add round if something notable happened
                if (roundEvent.events.length > 0) {
                    state.roundEvents.push(roundEvent);
                }
            }

            // Desperation if no throw
            if (!state.result) {
                state.result = simResolveDesperationPlay(state);
            }

            state.result.roundsElapsed = state.round;
            state.result.finalPressure = state.totalPressure;
            state.result.roundEvents = state.roundEvents || [];

            // ========================================
            // BUILD LEGACY-COMPATIBLE DISPLAY PROPERTIES
            // ========================================

            // Attach QB
            state.result.qb = state.qb.player;

            // Attach sackingPlayer for sacks
            if (state.result.type === 'sack') {
                state.result.sackingPlayer = state.sackingPlayer;
            }

            // Build pressureInfo (legacy format)
            const pressureLevel = state.totalPressure >= 70 ? 'heavy' :
                                  state.totalPressure >= 50 ? 'moderate' :
                                  state.totalPressure >= 25 ? 'light' : 'none';

            state.result.pressureInfo = {
                totalPressure: state.totalPressure,
                pressureLevel: pressureLevel,
                matchups: state.lineMatchups,
                sackingDL: state.sackingPlayer || null
            };

            // Build catchInfo for pass plays
            const targetReceiver = state.result._targetReceiver;
            if (targetReceiver) {
                const receiverIndex = state.receivers.indexOf(targetReceiver);
                const defender = state.defenders[receiverIndex] || state.defenders[0];

                // Calculate display values
                const wrRoll = Math.round(targetReceiver.separation + 50);
                const cbRoll = Math.round(50 - targetReceiver.separation);
                const separationMargin = targetReceiver.separation;
                const coverageCloseness = Math.max(0, Math.min(1, 1 - (separationMargin + 30) / 60));
                const defenderPenalty = Math.round(Math.pow(coverageCloseness, 3) * (defender?.stats?.coverage || 70) * 0.8);
                const baseCatch = targetReceiver.player?.stats?.catching || 70;
                const focusMod = (targetReceiver.player?.stats?.focus || 70) - 60;
                const catchProb = Math.round(targetReceiver.catchProbability);
                const qbAccuracy = state.qb.player?.stats?.accuracy || 70;

                state.result.catchInfo = {
                    receiver: targetReceiver.player,
                    cb: defender?.player || null,
                    wrRoll: wrRoll,
                    cbRoll: cbRoll,
                    separationMargin: Math.round(separationMargin),
                    coverageCloseness: Math.round(coverageCloseness * 100) / 100,
                    defenderPenalty: defenderPenalty,
                    baseCatch: baseCatch,
                    focusMod: focusMod > 0 ? focusMod : 0,
                    catchProb: catchProb,
                    qbAccuracy: qbAccuracy,
                    pressure: Math.round(state.totalPressure),
                    rollMean: Math.round(targetReceiver.rollMean),
                    qbRoll: Math.round(state.result._qbRoll),
                    catchSuccess: state.result._catchSuccess,
                    throwGood: state.result._qbRoll < targetReceiver.rollMean * 1.5,
                    cbCoverage: defender?.stats?.coverage || 70,
                    effectiveCatchPct: Math.round(targetReceiver.effectiveCatchPct || catchProb),
                    // Momentum tracking for display
                    momentumAdvantage: targetReceiver.momentumAdvantage || 0,
                    dbReactionDelay: targetReceiver.dbReactionDelay || 0,
                    dbAwareness: defender?.stats?.awareness || 70
                };

                // Attach target slot
                state.result.targetSlot = ['WR1', 'WR2', 'WR3'][receiverIndex] || 'WR';
            }

            // Clean up internal tracking properties
            delete state.result._targetReceiver;
            delete state.result._qbRoll;
            delete state.result._catchSuccess;

            return state.result;
        }

        // Full drive simulation using round-based plays
        function simulateDriveRoundBased(offense, defense, startingFieldPosition) {
            let fieldPosition = { ...startingFieldPosition };
            const plays = [];
            let driveResult = null;

            const maxPlays = 15;

            while (!driveResult && plays.length < maxPlays) {
                // Store the pre-play situation
                const prePlayDown = fieldPosition.down;
                const prePlayYardsToGo = fieldPosition.yardsToGo;
                const prePlayYardsFromGoal = fieldPosition.yardsFromGoal;

                const playResult = simulatePlayRoundBased(offense, defense, fieldPosition);

                // Attach pre-play situation to the result for display
                playResult.down = prePlayDown;
                playResult.yardsToGo = prePlayYardsToGo;
                playResult.yardsFromGoal = prePlayYardsFromGoal;

                plays.push(playResult);

                // Update field position
                const newYardsFromGoal = fieldPosition.yardsFromGoal - playResult.yardsGained;
                const yardsGainedTowardFirst = playResult.yardsGained;

                // Check first down
                if (yardsGainedTowardFirst >= fieldPosition.yardsToGo) {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: 10,
                        down: 1
                    };
                } else {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: fieldPosition.yardsToGo - yardsGainedTowardFirst,
                        down: fieldPosition.down + 1
                    };
                }

                // Attach post-play situation
                playResult.newYardsFromGoal = fieldPosition.yardsFromGoal;
                playResult.newYardsToGo = fieldPosition.yardsToGo;
                playResult.newDown = fieldPosition.down;

                // Check for drive-ending results
                if (playResult.type === 'touchdown') {
                    driveResult = { points: 7, type: 'touchdown', plays };
                } else if (playResult.type === 'interception') {
                    driveResult = { points: 0, type: 'turnover', plays };
                } else if (fieldPosition.down > 4) {
                    if (fieldPosition.yardsFromGoal <= 40) {
                        const fgDistance = fieldPosition.yardsFromGoal + 17;
                        const fgSuccess = Math.random() < (0.95 - fgDistance * 0.01);

                        // Mark the last play as a field goal attempt for display
                        playResult.fieldGoalAttempt = true;
                        playResult.fieldGoalSuccess = fgSuccess;

                        driveResult = {
                            points: fgSuccess ? 3 : 0,
                            type: fgSuccess ? 'field_goal' : 'missed_fg',
                            plays
                        };
                    } else {
                        driveResult = { points: 0, type: 'punt', plays };
                    }
                }
            }

            if (!driveResult) {
                driveResult = { points: 0, type: 'punt', plays };
            }

            return driveResult;
        }

        // Simulate player's offensive drive using high-fidelity system
        // Can be used for "auto-play" or "simulate" option
        function simulatePlayerDriveHighFidelity(playerTeam, opponent) {
            // Get player offense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            let playerQB = dc.QB ? roster.find(p => p.id === dc.QB) : null;
            if (!playerQB) playerQB = generateWalkOn('QB');

            const playerWRs = [];
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerWRs.push(player);
                }
            });

            const playerOL = [];
            (dc.OL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerOL.push(player);
                }
            });

            // Get opponent defense
            const oppCBs = opponent.roster.filter(p => p.position === 'CB').sort((a, b) => b.overall - a.overall);
            const oppDL = opponent.roster.filter(p => p.position === 'DL').sort((a, b) => b.overall - a.overall);

            // Fill walk-ons if needed
            while (playerWRs.length < 3) playerWRs.push(generateWalkOn('WR'));
            while (playerOL.length < 5) playerOL.push(generateWalkOn('OL'));
            while (oppCBs.length < 4) oppCBs.push(generateWalkOn('CB'));
            while (oppDL.length < 4) oppDL.push(generateWalkOn('DL'));

            // Build offense/defense objects
            const offense = {
                qb: playerQB,
                receivers: playerWRs.slice(0, 3),
                oLine: playerOL.slice(0, 5)
            };

            const defense = {
                dbs: oppCBs.slice(0, 4),
                dLine: oppDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Record offensive stats for player's team
            if (result.plays && roster) {
                result.plays.forEach(play => {
                    // QB stats - completions/incompletions
                    if (playerQB && playerQB.id) {
                        if (play.type === 'complete' || play.type === 'touchdown') {
                            gameStats.getPlayer(playerQB.id, `${playerQB.firstName} ${playerQB.lastName}`).completions++;
                        } else if (play.type === 'incomplete' || play.type === 'interception') {
                            gameStats.getPlayer(playerQB.id, `${playerQB.firstName} ${playerQB.lastName}`).incompletions++;
                        }
                    }

                    // Receiver stats - catches, yards, TDs
                    if ((play.type === 'complete' || play.type === 'touchdown') && play.catchInfo && play.catchInfo.receiver) {
                        const receiver = play.catchInfo.receiver;
                        if (receiver.id) {
                            const rosterPlayer = roster.find(p => p.id === receiver.id);
                            if (rosterPlayer) {
                                const rStats = gameStats.getPlayer(rosterPlayer.id, `${rosterPlayer.firstName} ${rosterPlayer.lastName}`);
                                rStats.catches++;
                                rStats.yardsAfterCatch += (play.yac || 0);
                                if (play.type === 'touchdown') {
                                    rStats.touchdowns++;
                                }
                                // Update season stats
                                if (rosterPlayer.seasonCatches === undefined) rosterPlayer.seasonCatches = 0;
                                rosterPlayer.seasonCatches++;
                                if (play.type === 'touchdown') {
                                    if (rosterPlayer.seasonTDs === undefined) rosterPlayer.seasonTDs = 0;
                                    rosterPlayer.seasonTDs++;
                                }
                            }
                        }
                    }

                    // OL clash stats
                    if (play.pressureInfo && play.pressureInfo.matchups) {
                        play.pressureInfo.matchups.forEach(matchup => {
                            if (matchup.ol && matchup.ol.id) {
                                const olPlayer = roster.find(p => p.id === matchup.ol.id);
                                if (olPlayer) {
                                    const olStats = gameStats.getPlayer(olPlayer.id, `${olPlayer.firstName} ${olPlayer.lastName}`);
                                    if (matchup.margin < -2) {
                                        olStats.clashesWon++;
                                    } else if (matchup.margin > 5) {
                                        olStats.clashesLost++;
                                    }
                                }
                            }
                        });
                    }
                });
            }

            // Add team reference
            result.team = playerTeam;

            return result;
        }

        // Adapter to use new round-based simulation for enemy possessions
        function simulateEnemyDriveHighFidelity(opponent, playerTeam) {
            // Get opponent offense
            let oppQB = opponent.roster.find(p => p.position === 'QB');
            if (!oppQB) oppQB = generateWalkOn('QB');

            const oppWRs = opponent.roster.filter(p => p.position === 'WR').sort((a, b) => b.overall - a.overall);
            const oppOL = opponent.roster.filter(p => p.position === 'OL').sort((a, b) => b.overall - a.overall);

            // Get player defense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            const playerCBs = [];
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerCBs.push(player);
                }
            });

            const playerDL = [];
            (dc.DL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerDL.push(player);
                }
            });

            // Fill walk-ons if needed (4 CBs to match opponent defense setup)
            while (playerCBs.length < 4) playerCBs.push(generateWalkOn('CB'));
            while (playerDL.length < 4) playerDL.push(generateWalkOn('DL'));
            while (oppWRs.length < 3) oppWRs.push(generateWalkOn('WR'));
            while (oppOL.length < 5) oppOL.push(generateWalkOn('OL'));

            // Build offense/defense objects for new simulation
            const offense = {
                qb: oppQB,
                receivers: oppWRs.slice(0, 3),
                oLine: oppOL.slice(0, 5)
            };

            const defense = {
                dbs: playerCBs.slice(0, 4),
                dLine: playerDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the new high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Record defensive stats for player's team
            if (result.plays && roster) {
                result.plays.forEach(play => {
                    // Sack - credit DL player
                    if (play.type === 'sack' && play.sackingPlayer && play.sackingPlayer.id) {
                        const dlPlayer = roster.find(p => p.id === play.sackingPlayer.id);
                        if (dlPlayer) {
                            if (dlPlayer.seasonSacks === undefined) dlPlayer.seasonSacks = 0;
                            dlPlayer.seasonSacks++;
                            gameStats.getPlayer(dlPlayer.id, `${dlPlayer.firstName} ${dlPlayer.lastName}`).sacks++;
                        }
                    }

                    // Pass defended - credit CB
                    if (play.type === 'incomplete' && play.catchInfo && play.catchInfo.cb && play.catchInfo.cb.id) {
                        const cbPlayer = roster.find(p => p.id === play.catchInfo.cb.id);
                        if (cbPlayer) {
                            if (cbPlayer.seasonPassesDefended === undefined) cbPlayer.seasonPassesDefended = 0;
                            cbPlayer.seasonPassesDefended++;
                            gameStats.getPlayer(cbPlayer.id, `${cbPlayer.firstName} ${cbPlayer.lastName}`).passesDefended++;
                        }
                    }

                    // Tackle - credit CB when completion is not a TD
                    if (play.type === 'complete' && play.catchInfo && play.catchInfo.cb && play.catchInfo.cb.id) {
                        const cbPlayer = roster.find(p => p.id === play.catchInfo.cb.id);
                        if (cbPlayer) {
                            if (cbPlayer.seasonTackles === undefined) cbPlayer.seasonTackles = 0;
                            cbPlayer.seasonTackles++;
                            gameStats.getPlayer(cbPlayer.id, `${cbPlayer.firstName} ${cbPlayer.lastName}`).tackles++;
                        }
                    }
                });
            }

            // Add opponent reference for compatibility
            result.opponent = opponent;

            return result;
        }

        // Simulate enemy possession using high-fidelity simulation
        function simulateEnemyPossession(opponent) {
            try {
                console.log('Starting enemy drive simulation (high-fidelity) for:', opponent?.name);
                console.log('Opponent roster size:', opponent?.roster?.length);
                console.log('Player team exists:', !!managementState.team);
                console.log('Player depthChart exists:', !!managementState.team?.depthChart);

                // Generate roster if missing
                if (opponent && !opponent.roster) {
                    console.log('Generating missing roster for opponent:', opponent.name);
                    // Use targetOverall if available, otherwise fall back to difficulty-based
                    if (opponent.targetOverall) {
                        opponent.roster = generateRosterWithTargetOverall(opponent.targetOverall);
                    } else {
                        opponent.roster = generateOpponentRoster(opponent.difficulty || 'medium');
                    }
                }

                // Validate required data
                if (!opponent || !opponent.roster || !managementState.team || !managementState.team.depthChart) {
                    throw new Error('Missing required simulation data');
                }

                // Use the new high-fidelity round-based simulation
                const driveResult = simulateEnemyDriveHighFidelity(opponent, managementState.team);

                console.log('Drive result:', driveResult.type, 'with', driveResult.plays?.length, 'plays');

                // Format narrative from new play format
                const narrative = driveResult.plays.map((p, i) => {
                    const down = Math.min(4, Math.floor(i / 3) + 1);
                    if (p.type === 'sack') {
                        return `Sack! ${p.description}`;
                    } else if (p.type === 'interception') {
                        return `INTERCEPTION! ${p.description}`;
                    } else if (p.type === 'touchdown') {
                        return `TOUCHDOWN! ${p.description}`;
                    } else if (p.type === 'complete') {
                        return `Complete! ${p.yardsGained} yards${p.yac > 0 ? ` (${p.yac} YAC)` : ''}`;
                    } else if (p.type === 'incomplete') {
                        return 'Pass incomplete';
                    } else if (p.type === 'throwaway') {
                        return 'QB throws it away';
                    } else if (p.type === 'scramble') {
                        return p.description;
                    }
                    return `${p.type}: ${p.yardsGained} yards`;
                });

                return {
                    points: driveResult.points,
                    type: driveResult.type,
                    plays: driveResult.plays,
                    opponent: driveResult.opponent,
                    narrative
                };
            } catch (error) {
                console.error('Enemy drive simulation error:', error);
                console.error('Error stack:', error.stack);
                // Fallback to simple result on error
                const roll = Math.random() * 100;
                const points = roll < 50 ? 7 : roll < 70 ? 3 : 0;
                const type = points === 7 ? 'TD' : points === 3 ? 'FG' : 'STOP';
                return {
                    points,
                    type,
                    plays: [],
                    opponent,
                    narrative: [type === 'TD' ? 'Touchdown!' : type === 'FG' ? 'Field goal!' : 'Defensive stop!']
                };
            }
        }

        // Format a play into narrative text
        function formatPlayNarrative(play, opponent) {
            const teamShort = opponent.name.split(' ')[0];
            const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

            if (play.type === 'sack') {
                const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your defense';
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${dlName} breaks through! SACK for ${Math.abs(play.yardsGained)} yard loss!`;
            }

            if (play.fieldGoalAttempt) {
                const distance = play.yardsFromGoal + 17; // Add end zone
                if (play.fieldGoalSuccess) {
                    return `Field goal attempt from ${distance} yards... GOOD!`;
                } else {
                    return `Field goal attempt from ${distance} yards... NO GOOD!`;
                }
            }

            const wrName = play.catchInfo?.receiver ? getPlayerFullName(play.catchInfo.receiver) : `${teamShort} WR`;
            const cbName = play.catchInfo?.cb ? getPlayerFullName(play.catchInfo.cb) : 'Your CB';

            if (play.type === 'complete') {
                if (play.isTouchdown) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} finds ${wrName}... TOUCHDOWN ${opponent.name}!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} hits ${wrName} for ${play.yardsGained} yards.`;
            } else {
                if (!play.catchInfo?.throwGood) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} under pressure, throws it away!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: Pass to ${wrName} broken up by ${cbName}!`;
            }
        }

        function getDownString(down) {
            const ordinals = ['1st', '2nd', '3rd', '4th'];
            return ordinals[down - 1] || `${down}th`;
        }

        // Get display text for current game phase
        function getGamePhaseDisplay(result) {
            const phase = result.gamePhase || managementState.gamePhase || 'regulation';
            const possession = result.possession + 1;

            if (phase === 'overtime') {
                const otPossession = managementState.overtimePossession || 1;
                return `OVERTIME - Possession ${otPossession}`;
            } else if (phase === 'twoMinuteDrill') {
                return '2-MINUTE DRILL';
            } else {
                // Regulation - show as quarters
                const quarter = Math.min(possession, 4);
                const quarterNames = ['1st Quarter', '2nd Quarter', '3rd Quarter', '4th Quarter'];
                return quarterNames[quarter - 1] || `Quarter ${quarter}`;
            }
        }

        // Start a match
        function startMatch() {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                return { success: false, error: 'Season is over' };
            }

            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) {
                return { success: false, error: 'Game already played' };
            }

            managementState.matchInProgress = true;
            managementState.currentPossession = 0;
            managementState.matchScore = { player: 0, opponent: 0 };
            managementState.simulationLog = null;  // Clear sim log for regular games
            managementState.currentScreen = 'game';
            managementState.gamePhase = 'regulation';  // regulation, twoMinuteDrill, overtime
            managementState.overtimePossession = 0;
            managementState.fameAddedThisGame = false;  // Track if fame was already added

            // Reset per-game stats (critical: prevents stats from accumulating across games)
            Object.keys(gameStats.players).forEach(key => delete gameStats.players[key]);

            return { success: true, opponent: game.opponent, isHome: game.isHome };
        }

        // Simulate entire game without playing arcade mode
        function simulateFullGame() {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                return { success: false, error: 'Season is over' };
            }

            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) {
                return { success: false, error: 'Game already played' };
            }

            const playerTeam = managementState.team;
            const opponent = game.opponent;

            // Initialize simulation log
            managementState.simulationLog = [];
            const log = (msg) => managementState.simulationLog.push(msg);

            log(`=== GAME SIMULATION: ${playerTeam.name} vs ${opponent.name} ===`);
            log(`Player Team OVR: ${Math.round(playerTeam.roster.reduce((s,p) => s + p.overall, 0) / playerTeam.roster.length)}`);
            log(`Opponent OVR: ${opponent.offenseRating}/${opponent.defenseRating}`);

            // Log team compositions for debugging
            const getAvgOvr = (players) => players.length ? Math.round(players.reduce((s,p) => s + (p.overall || 70), 0) / players.length) : 0;
            const playerWRs = playerTeam.roster.filter(p => p.position === 'WR');
            const playerCBs = playerTeam.roster.filter(p => p.position === 'CB');
            const playerOL = playerTeam.roster.filter(p => p.position === 'OL');
            const playerDL = playerTeam.roster.filter(p => p.position === 'DL');
            const playerQB = playerTeam.roster.find(p => p.position === 'QB');
            const oppWRs = opponent.roster.filter(p => p.position === 'WR');
            const oppCBs = opponent.roster.filter(p => p.position === 'CB');
            const oppOL = opponent.roster.filter(p => p.position === 'OL');
            const oppDL = opponent.roster.filter(p => p.position === 'DL');
            const oppQB = opponent.roster.find(p => p.position === 'QB');

            log(`Player Offense: QB:${playerQB?.overall || 'walk-on'} WRs:${getAvgOvr(playerWRs)}(${playerWRs.length}) OL:${getAvgOvr(playerOL)}(${playerOL.length})`);
            log(`Player Defense: CBs:${getAvgOvr(playerCBs)}(${playerCBs.length}) DL:${getAvgOvr(playerDL)}(${playerDL.length})`);
            log(`Opp Offense: QB:${oppQB?.overall || 'walk-on'} WRs:${getAvgOvr(oppWRs)}(${oppWRs.length}) OL:${getAvgOvr(oppOL)}(${oppOL.length})`);
            log(`Opp Defense: CBs:${getAvgOvr(oppCBs)}(${oppCBs.length}) DL:${getAvgOvr(oppDL)}(${oppDL.length})`);
            log('');

            // Reset per-game stats
            Object.keys(gameStats.players).forEach(key => delete gameStats.players[key]);
            managementState.fameAddedThisGame = false;

            let playerScore = 0;
            let opponentScore = 0;
            const possessionResults = [];

            // Helper to log drive details
            const logDrive = (drive, team, driveNum) => {
                log(`--- ${team} Drive #${driveNum} ---`);
                log(`Result: ${drive.type} (${drive.points || 0} pts)`);
                if (drive.plays) {
                    drive.plays.forEach((play, idx) => {
                        const down = play.down || '?';
                        const toGo = play.yardsToGo || '?';
                        const fromGoal = play.yardsFromGoal || '?';
                        log(`  Play ${idx+1}: ${down}&${toGo} at ${fromGoal}yd - ${play.type} for ${play.yardsGained || 0} yds`);
                        if (play.description) log(`    ${play.description}`);
                        // Add catch details if available
                        if (play.catchInfo) {
                            const ci = play.catchInfo;
                            log(`    [Sep:${ci.separationMargin || 0} Catch%:${ci.effectiveCatchPct || ci.catchProb || 0}]`);
                        }
                    });
                }
                log('');
            };

            // Simulate regulation possessions
            for (let i = 0; i < SEASON.POSSESSIONS_PER_GAME; i++) {
                // Player offense
                const playerDrive = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                const playerPoints = playerDrive.type === 'touchdown' ? 7 :
                                    playerDrive.type === 'field_goal' ? 3 : 0;
                playerScore += playerPoints;
                possessionResults.push({ team: 'player', result: playerDrive, points: playerPoints });
                logDrive(playerDrive, 'PLAYER OFFENSE', i + 1);

                // Enemy offense
                const enemyDrive = simulateEnemyDriveHighFidelity(opponent, playerTeam);
                const enemyPoints = enemyDrive.type === 'touchdown' ? 7 :
                                   enemyDrive.type === 'field_goal' ? 3 : 0;
                opponentScore += enemyPoints;
                possessionResults.push({ team: 'opponent', result: enemyDrive, points: enemyPoints });
                logDrive(enemyDrive, 'OPPONENT OFFENSE', i + 1);

                log(`Score after possession ${i+1}: Player ${playerScore} - Opponent ${opponentScore}`);
                log('');
            }

            // Handle overtime if tied
            let overtime = false;
            while (playerScore === opponentScore) {
                overtime = true;
                // Player gets one possession
                const playerOT = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                const playerOTPoints = playerOT.type === 'touchdown' ? 7 :
                                       playerOT.type === 'field_goal' ? 3 : 0;
                playerScore += playerOTPoints;

                // Opponent gets one possession
                const enemyOT = simulateEnemyDriveHighFidelity(opponent, playerTeam);
                const enemyOTPoints = enemyOT.type === 'touchdown' ? 7 :
                                      enemyOT.type === 'field_goal' ? 3 : 0;
                opponentScore += enemyOTPoints;

                // Max 3 OT periods
                if (possessionResults.length > SEASON.POSSESSIONS_PER_GAME * 2 + 6) break;
            }

            // Set match state for showMatchEnd
            managementState.matchInProgress = true;
            managementState.matchScore = { player: playerScore, opponent: opponentScore };
            managementState.currentPossession = SEASON.POSSESSIONS_PER_GAME;

            log(`=== FINAL SCORE: Player ${playerScore} - Opponent ${opponentScore} ===`);
            if (overtime) log('(Overtime)');

            return {
                success: true,
                playerScore,
                opponentScore,
                overtime,
                possessionResults,
                opponent
            };
        }

        // Get simulation log as text
        function getSimulationLog() {
            return (managementState.simulationLog || []).join('\n');
        }

        // Record possession result (called after each arcade possession)
        function recordPossessionResult(points) {
            if (!managementState.matchInProgress) return;

            managementState.matchScore.player += points;

            // Enemy gets counter-possession
            const game = managementState.season.schedule[managementState.season.week - 1];
            const enemyResult = simulateEnemyPossession(game.opponent);
            managementState.matchScore.opponent += enemyResult.points;

            managementState.currentPossession++;

            const playerScore = managementState.matchScore.player;
            const oppScore = managementState.matchScore.opponent;
            const scoreDiff = playerScore - oppScore;

            // Check game state based on phase
            if (managementState.gamePhase === 'regulation') {
                if (managementState.currentPossession >= SEASON.POSSESSIONS_PER_GAME) {
                    // End of 4 quarters
                    if (scoreDiff === 0) {
                        // Tied - go to overtime
                        managementState.gamePhase = 'overtime';
                        managementState.overtimePossession = 0;
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'overtime',
                            message: 'Tied game! Heading to overtime!'
                        };
                    } else if (scoreDiff < 0 && scoreDiff >= -7) {
                        // Losing by 7 or less - 2 minute drill
                        managementState.gamePhase = 'twoMinuteDrill';
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'twoMinuteDrill',
                            message: `Down by ${Math.abs(scoreDiff)}! 2-minute drill to tie or win!`
                        };
                    } else {
                        // Game over (winning or losing by more than 7)
                        return endMatch();
                    }
                }
            } else if (managementState.gamePhase === 'twoMinuteDrill') {
                // After 2-minute drill possession
                if (scoreDiff === 0) {
                    // Tied - go to overtime
                    managementState.gamePhase = 'overtime';
                    managementState.overtimePossession = 0;
                    return {
                        ongoing: true,
                        possession: managementState.currentPossession,
                        score: managementState.matchScore,
                        enemyResult,
                        gamePhase: 'overtime',
                        message: 'Tied game! Heading to overtime!'
                    };
                } else {
                    // Game over (win or loss)
                    return endMatch();
                }
            } else if (managementState.gamePhase === 'overtime') {
                managementState.overtimePossession++;
                // In overtime, check after each possession pair
                if (scoreDiff !== 0) {
                    // Someone is ahead - game over
                    return endMatch();
                }
                // Still tied - continue overtime
                return {
                    ongoing: true,
                    possession: managementState.currentPossession,
                    score: managementState.matchScore,
                    enemyResult,
                    gamePhase: 'overtime',
                    message: `Overtime continues! Still tied ${playerScore}-${oppScore}`
                };
            }

            return {
                ongoing: true,
                possession: managementState.currentPossession,
                score: managementState.matchScore,
                enemyResult,
                gamePhase: managementState.gamePhase
            };
        }

        // End match
        function endMatch() {
            if (!managementState.matchInProgress) return null;

            const game = managementState.season.schedule[managementState.season.week - 1];
            const win = managementState.matchScore.player > managementState.matchScore.opponent;

            // Record result
            game.result = {
                playerScore: managementState.matchScore.player,
                opponentScore: managementState.matchScore.opponent,
                win
            };

            // Update records
            if (win) {
                managementState.team.record.wins++;
            } else {
                managementState.team.record.losses++;
            }

            // Award revenue
            const revenue = awardGameRevenue(game.isHome);

            // Process weekly progression
            const progressionResults = processWeeklyProgression();

            // Advance week
            managementState.season.week++;

            // Check end of season
            let seasonEnded = false;
            if (managementState.season.week > SEASON.WEEKS) {
                processEndOfSeason();
                seasonEnded = true;
                managementState.seasonJustEnded = true;  // Flag for draft trigger
            }

            managementState.matchInProgress = false;
            managementState.currentScreen = 'hub';

            if (managementState.settings.autoSave) SaveSystem.save();

            return {
                ongoing: false,
                result: game.result,
                revenue,
                progression: progressionResults,
                seasonEnded
            };
        }

        // ========================================
        // MANAGEMENT LAYER - GAME INTEGRATION
        // ========================================

        // Get player from depth chart slot
        function getDepthChartPlayer(slot) {
            if (!managementState.team || !managementState.team.depthChart) return null;

            const dc = managementState.team.depthChart;
            let playerId;

            if (Array.isArray(dc[slot])) {
                // For OL/DL arrays, slot should be like 'OL' with index
                return null;  // Handle differently
            } else {
                playerId = dc[slot];
            }

            if (!playerId) return null;
            return managementState.team.roster.find(p => p.id === playerId);
        }

        // Generate walk-on player (lower stats but not terrible) for empty slots
        function generateWalkOn(position) {
            const player = generatePlayer(position, 'average');
            // Reduce stats moderately - walk-ons should be below average but not terrible
            Object.keys(player.stats).forEach(stat => {
                player.stats[stat] = Math.max(55, player.stats[stat] - 10);
            });
            player.firstName = 'Recruit';
            player.lastName = position;
            player.salaryCost = 0;
            player.overall = calculateOverall(player);
            return player;
        }

        // Convert roster player to game receiver config
        function playerToReceiverConfig(player, index, startZ) {
            const xPositions = [-5, 0, 5];
            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                lastName: player.lastName,
                overall: player.overall || calculateOverall(player),
                playerId: player.id,
                start: new BABYLON.Vector3(xPositions[index], 0, startZ),
                route: [],  // Will be generated
                stats: { ...player.stats },
                coreAttributes: player.coreAttributes || null
            };
        }

        // Convert roster player to game defender config
        function playerToDefenderConfig(player, index, startZ, receiverIndex) {
            const aiTypes = ['man', 'man', 'man', 'zone'];
            const cushions = [2, 4, 3, 4];
            const zoneColors = [
                new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(1.0, 0.5, 0.1)   // Orange for zone
            ];

            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                playerId: player.id,
                aiType: aiTypes[index],
                assignedReceiver: receiverIndex !== undefined ? receiverIndex : index,
                cushion: cushions[index],
                zoneCenter: index === 3 ? new BABYLON.Vector3(0, 0, startZ + 8) : null,
                zoneRadius: index === 3 ? 6 : 0,
                zoneColor: zoneColors[index],
                overall: player.overall,
                stats: { ...player.stats },
                coreAttributes: player.coreAttributes || null
            };
        }

        // Get receiver configs from roster
        function getReceiverConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                let player = getDepthChartPlayer(slot);
                if (!player) {
                    player = generateWalkOn('WR');
                }
                configs.push(playerToReceiverConfig(player, index, RECEIVER_START_Z));
            });

            return configs;
        }

        // Get defender configs from opponent's roster
        function getDefenderConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            // Get opponent's CBs sorted by overall
            const oppCBs = opponent.roster
                .filter(p => p.position === 'CB')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppCBs[i];
                if (!player) {
                    player = generateWalkOn('CB');
                }
                configs.push(playerToDefenderConfig(player, i, RECEIVER_START_Z, i < 3 ? i : undefined));
            }

            return configs;
        }

        // Get OL configs from roster
        function getOLineConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;
            }

            const configs = [];
            const posLabels = ['C', 'LG', 'RG', 'LT', 'RT'];

            managementState.team.depthChart.OL.forEach((playerId, index) => {
                let player = playerId ? managementState.team.roster.find(p => p.id === playerId) : null;
                if (!player) {
                    player = generateWalkOn('OL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[index],
                    stats: { ...player.stats },
                    coreAttributes: player.coreAttributes || null
                });
            });

            return configs;
        }

        // Get DL configs from opponent's roster
        function getDLineConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;
            }

            const configs = [];
            const posLabels = ['LDE', 'LDT', 'RDT', 'RDE'];

            // Get opponent's DL sorted by overall
            const oppDL = opponent.roster
                .filter(p => p.position === 'DL')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppDL[i];
                if (!player) {
                    player = generateWalkOn('DL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[i],
                    stats: { ...player.stats },
                    coreAttributes: player.coreAttributes || null
                });
            }

            return configs;
        }

        // Record a stat for a roster player by their in-game mesh
        function recordPlayerStat(gameMesh, statName, increment = 1) {
            if (!gameMesh || !gameMesh.playerId) return;
            if (!managementState.team || !managementState.team.roster) return;

            const player = managementState.team.roster.find(p => p.id === gameMesh.playerId);
            if (!player) return;

            // Initialize stat if it doesn't exist
            if (player[statName] === undefined) player[statName] = 0;
            player[statName] += increment;
        }

        // Initialize management system
        function initializeManagement() {
            // Try to load existing save
            if (SaveSystem.exists()) {
                const saveData = SaveSystem.load();
                if (saveData && SaveSystem.applySaveData(saveData)) {
                    console.log('Loaded existing save');
                    // Resume draft if one was in progress
                    if (draftState.active) {
                        console.log('Resuming draft in progress');
                        managementState.currentScreen = 'draft';
                    } else {
                        managementState.currentScreen = 'hub';
                    }
                    return;
                }
            }

            // No save - show main menu
            managementState.currentScreen = 'main_menu';
        }

        // Start new game
        function startNewGame(teamName = 'Your Knights') {
            managementState.team = createNewTeam(teamName);
            managementState.season = createNewSeason();
            refreshFreeAgents();
            managementState.initialized = true;

            // Start with the draft
            startDraft(true);
        }

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 70;  // Extended for full 65-yard drive from own 35
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true
        });
        // Set hardware scaling for sharp rendering on high-DPI screens
        engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Camera is view-only, no user controls
            scene.activeCamera = camera;

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback - link to roster QB
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';

            // Link QB to roster player
            const rosterQB = getDepthChartPlayer('QB1');
            if (rosterQB) {
                qb.playerId = rosterQB.id;
                qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                qb.stats = { ...rosterQB.stats };
            } else {
                // Fallback stats
                qb.stats = {
                    shortPassAcc: 75, longPassAcc: 72, awareness: 70, agility: 65, speed: 60,
                    strength: 65
                };
            }

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line

            // Try to get roster configs, fall back to defaults
            const rosterReceiverConfigs = getReceiverConfigsFromRoster();
            const receiverConfigs = rosterReceiverConfigs || [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 80, acceleration: 72, agility: 85,
                        routeRunning: 88, catching: 84,
                        jumping: 70, strength: 60, evasion: 75,
                        stamina: 80
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 80, acceleration: 92, agility: 78,
                        routeRunning: 68, catching: 80,
                        jumping: 75, strength: 50, evasion: 65,
                        stamina: 85
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 80, acceleration: 78, agility: 80,
                        routeRunning: 82, catching: 82,
                        jumping: 82, strength: 72, evasion: 78,
                        stamina: 82
                    }
                }
            ];

            // Defender configurations - try roster first
            const rosterDefenderConfigs = getDefenderConfigsFromRoster();
            const defenderConfigs = rosterDefenderConfigs || [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 70, agility: 75,
                        manCoverage: 80, zoneCoverage: 80, press: 78,
                        tackling: 85, pursuit: 75,
                        awareness: 72, strength: 82,
                        stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 85, agility: 82,
                        manCoverage: 80, zoneCoverage: 80, press: 60,
                        tackling: 72, pursuit: 90,
                        awareness: 75, strength: 65,
                        stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'man',
                    assignedReceiver: 2,  // Covers Baron Wyatt
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 68, agility: 70,
                        manCoverage: 80, zoneCoverage: 80, press: 72,
                        tackling: 90, pursuit: 72,
                        awareness: 85, strength: 88,
                        stamina: 75
                    }
                },
                {
                    name: "The Sentinel",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 6,
                    cushion: 4,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 80, acceleration: 72, agility: 78,
                        manCoverage: 80, zoneCoverage: 80, press: 65,
                        tackling: 80, pursuit: 80,
                        awareness: 88, strength: 75,
                        stamina: 82
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            // Store references for route regeneration
            gameState.scene = scene;
            gameState.routeMaterial = routeMat;

            receiverConfigs.forEach((config, i) => {
                // Clone material so each receiver can flash independently
                const receiverMat = materials.receiverMaterial.clone(`receiverMat_${i}`);
                const receiver = createKnight(scene, receiverMat, config.start.clone());
                receiver.name = `receiver_${i}`;
                receiver.bodyMaterial = receiverMat;
                receiver.originalColor = receiverMat.diffuseColor.clone();

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.lastName = config.lastName || config.name.split(' ').pop();  // Extract last name from display name if not provided
                // Calculate overall from WR position stats
                const wrStats = POSITIONS.WR.primaryStats;
                receiver.overall = config.overall || Math.round(wrStats.reduce((sum, stat) => sum + (config.stats[stat] || 0), 0) / wrStats.length);
                receiver.playerId = config.playerId || null;  // Link to roster player
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;
                receiver.coreAttributes = config.coreAttributes || null;

                // Derive base speed from stats (normalized to game units)
                // Use core speed if available, otherwise fall back to stats.speed
                const baseSpeed = receiver.coreAttributes?.speed || config.stats.speed;
                receiver.baseSpeed = baseSpeed * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier;
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // Legacy - kept for compatibility
                receiver.clashSpeedPenaltyUntil = 0;  // Clash loser speed penalty timer
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;  // Track if WR/DB were apart before clashing
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);  // White
                fillMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                fillMat.alpha = 0.5;  // Base visibility
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);  // Start with base visible circle

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation
                receiver.clashTiltUntil = 0;  // For grappling tilt
                receiver.clashTiltAngle = 0;
                receiver.loserFlashUntil = 0;   // Red flash when losing clash
                receiver.winnerFlashUntil = 0;  // Green flash when winning clash
                receiver.clashSpeedBoostUntil = 0;  // Speed boost timer

                // Hide the outer ring - only show proximity-based fill
                zoneRing.setEnabled(false);

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders (skip in training mode)
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            if (!gameState.trainingMode) {
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                // Clone material so each defender can flash independently
                const defenderMat = materials.defenderMaterial.clone(`defenderMat_${i}`);
                const defender = createKnight(scene, defenderMat, startPos);
                defender.name = `defender_${i}`;
                defender.bodyMaterial = defenderMat;
                defender.originalColor = defenderMat.diffuseColor.clone();

                // Store config data on defender
                defender.displayName = config.name;
                defender.playerId = config.playerId || null;  // Link to roster player
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.coreAttributes = config.coreAttributes || null;
                // Calculate overall from CB position stats
                const cbStats = POSITIONS.CB.primaryStats;
                defender.overall = config.overall || Math.round(cbStats.reduce((sum, stat) => sum + (config.stats[stat] || 0), 0) / cbStats.length);
                defender.startPos = startPos.clone();

                // Derive base speed from stats
                // Use core speed if available, otherwise fall back to stats.speed
                const baseSpeed = defender.coreAttributes?.speed || config.stats.speed;
                defender.baseSpeed = baseSpeed * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier;
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact
                defender.clashSpeedPenaltyUntil = 0;  // Speed penalty from losing clash

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation
                defender.clashTiltUntil = 0;  // For grappling tilt
                defender.clashTiltAngle = 0;
                defender.loserFlashUntil = 0;   // Red flash when losing clash
                defender.winnerFlashUntil = 0;  // Green flash when winning clash

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });
            } // End of training mode skip for defenders

            // Offensive Line configurations (5 players) - skip in training mode
            if (!gameState.trainingMode) {
            const LINE_OF_SCRIMMAGE_Z = RECEIVER_START_Z;  // Same as receivers start
            const rosterOLineConfigs = getOLineConfigsFromRoster();
            const defaultOLineConfigs = [
                {
                    name: "Sir Bulwark",
                    position: 'C',
                    startX: 0,
                    stats: { passBlock: 82, strength: 80, balance: 85, awareness: 80, speed: 60, acceleration: 65 }
                },
                {
                    name: "Ironside",
                    position: 'LG',
                    startX: -1.5,
                    stats: { passBlock: 80, strength: 85, balance: 78, awareness: 75, speed: 58, acceleration: 62 }
                },
                {
                    name: "Stonewall",
                    position: 'RG',
                    startX: 1.5,
                    stats: { passBlock: 78, strength: 88, balance: 80, awareness: 72, speed: 55, acceleration: 60 }
                },
                {
                    name: "Rampart",
                    position: 'LT',
                    startX: -3.5,
                    stats: { passBlock: 85, strength: 78, balance: 82, awareness: 78, speed: 62, acceleration: 68 }
                },
                {
                    name: "Bastion",
                    position: 'RT',
                    startX: 3.5,
                    stats: { passBlock: 83, strength: 80, balance: 80, awareness: 76, speed: 60, acceleration: 65 }
                }
            ];
            // Merge roster configs with default positions/startX
            const oLineConfigs = rosterOLineConfigs ? rosterOLineConfigs.map((rc, i) => ({
                ...defaultOLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultOLineConfigs;

            // Create Offensive Line
            oLineConfigs.forEach((config, i) => {
                const oLineMat = materials.oLineMaterial.clone(`oLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z - 0.5);
                const oLineman = createLineman(scene, oLineMat, startPos, true);
                oLineman.name = `oline_${i}`;
                oLineman.displayName = config.name;
                oLineman.playerId = config.playerId || null;  // Link to roster player
                oLineman.position_label = config.position;
                oLineman.position = 'OL';  // For ability calculations
                oLineman.stats = config.stats;
                oLineman.coreAttributes = config.coreAttributes || null;
                oLineman.startPos = startPos.clone();
                // Use core speed if available, otherwise fall back to stats.speed
                const baseSpeed = oLineman.coreAttributes?.speed || config.stats.speed;
                oLineman.baseSpeed = baseSpeed * SPEED_CONSTANTS.O_LINE_FACTOR * gameState.gameSpeedMultiplier;
                oLineman.speed = oLineman.baseSpeed;

                // Blocking state
                oLineman.engagedWith = null;         // D-lineman currently blocking
                oLineman.lastClashTime = 0;
                oLineman.knockdownUntil = 0;
                oLineman.bodyMaterial = oLineMat;
                oLineman.originalColor = oLineMat.diffuseColor.clone();

                gameState.offensiveLine.push(oLineman);
            });

            // Defensive Line configurations (4 players) - try roster first
            const rosterDLineConfigs = getDLineConfigsFromRoster();
            const defaultDLineConfigs = [
                {
                    name: "Siege Breaker",
                    position: 'LDE',
                    startX: -3,
                    stats: { passRush: 82, strength: 80, acceleration: 78, speed: 72, awareness: 75, tackling: 80 }
                },
                {
                    name: "Crusher",
                    position: 'LDT',
                    startX: -1,
                    stats: { passRush: 78, strength: 90, acceleration: 70, speed: 65, awareness: 72, tackling: 82 }
                },
                {
                    name: "Devastator",
                    position: 'RDT',
                    startX: 1,
                    stats: { passRush: 80, strength: 88, acceleration: 72, speed: 68, awareness: 74, tackling: 80 }
                },
                {
                    name: "Ramraid",
                    position: 'RDE',
                    startX: 3,
                    stats: { passRush: 85, strength: 78, acceleration: 82, speed: 75, awareness: 78, tackling: 78 }
                }
            ];
            // Merge roster configs with default positions/startX
            const dLineConfigs = rosterDLineConfigs ? rosterDLineConfigs.map((rc, i) => ({
                ...defaultDLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultDLineConfigs;

            // Create Defensive Line
            dLineConfigs.forEach((config, i) => {
                const dLineMat = materials.dLineMaterial.clone(`dLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z + 0.5);
                const dLineman = createLineman(scene, dLineMat, startPos, false);
                dLineman.name = `dline_${i}`;
                dLineman.displayName = config.name;
                dLineman.playerId = config.playerId || null;  // Link to roster player
                dLineman.position_label = config.position;
                dLineman.position = 'DL';  // For ability calculations
                dLineman.stats = config.stats;
                dLineman.coreAttributes = config.coreAttributes || null;
                dLineman.startPos = startPos.clone();
                // Use core speed if available, otherwise fall back to stats.speed
                const baseSpeed = dLineman.coreAttributes?.speed || config.stats.speed;
                dLineman.baseSpeed = baseSpeed * SPEED_CONSTANTS.D_LINE_FACTOR * gameState.gameSpeedMultiplier;
                dLineman.speed = dLineman.baseSpeed;

                // Pass rush state
                dLineman.engagedWith = null;         // O-lineman currently engaged with
                dLineman.lastClashTime = 0;
                dLineman.knockdownUntil = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial = dLineMat;
                dLineman.originalColor = dLineMat.diffuseColor.clone();

                gameState.defensiveLine.push(dLineman);
            });
            } // End of training mode skip for OL/DL

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Get QB data from roster
            let qbPlayer = null;
            if (managementState.initialized && managementState.team && managementState.team.depthChart.QB) {
                qbPlayer = managementState.team.roster.find(p => p.id === managementState.team.depthChart.QB);
            }
            if (!qbPlayer) {
                qbPlayer = { firstName: 'Knight', lastName: 'Commander', overall: 80 };
            }
            qb.lastName = qbPlayer.lastName;
            qb.overall = qbPlayer.overall;
            qb.displayName = `${qbPlayer.firstName} ${qbPlayer.lastName.charAt(0)}.`;

            // Helper function to get rating indicator (stars) and styling for high-rated players
            const getRatingIndicator = (overall) => {
                if (overall >= 90) {
                    return { stars: '‚òÖ‚òÖ', starColor: '#ffd700', bgTint: 'rgba(80, 60, 0, 0.85)' };  // Gold double star
                } else if (overall >= 85) {
                    return { stars: '‚òÖ', starColor: '#ffd700', bgTint: 'rgba(50, 40, 0, 0.8)' };   // Gold single star
                }
                return { stars: '', starColor: '', bgTint: null };  // No indicator below 85
            };

            // Add name label to QB (stacked: name on top, OVR below bigger)
            const qbRating = getRatingIndicator(qb.overall);
            const qbLabelRect = new BABYLON.GUI.Rectangle();
            qbLabelRect.width = '140px';
            qbLabelRect.height = '70px';
            qbLabelRect.cornerRadius = 6;
            qbLabelRect.thickness = 0;
            qbLabelRect.background = qbRating.bgTint || 'rgba(0, 0, 0, 0.7)';

            const qbStack = new BABYLON.GUI.StackPanel();
            qbStack.isVertical = true;

            const qbNameText = new BABYLON.GUI.TextBlock();
            qbNameText.text = qb.lastName.toUpperCase();
            qbNameText.color = '#ffcc44';
            qbNameText.fontSize = 20;
            qbNameText.fontFamily = 'Courier New';
            qbNameText.fontWeight = 'bold';
            qbNameText.outlineWidth = 3;
            qbNameText.outlineColor = '#000000';
            qbNameText.height = '28px';

            const qbOvrText = new BABYLON.GUI.TextBlock();
            qbOvrText.text = qbRating.stars ? `${qb.overall} ${qbRating.stars}` : `${qb.overall}`;
            qbOvrText.color = '#ffffff';
            qbOvrText.fontSize = 28;
            qbOvrText.fontFamily = 'Courier New';
            qbOvrText.fontWeight = 'bold';
            qbOvrText.outlineWidth = 4;
            qbOvrText.outlineColor = '#000000';
            qbOvrText.height = '36px';

            qbStack.addControl(qbNameText);
            qbStack.addControl(qbOvrText);
            qbLabelRect.addControl(qbStack);

            advancedTexture.addControl(qbLabelRect);
            qbLabelRect.linkWithMesh(qb);
            qbLabelRect.linkOffsetY = -70;
            qbLabelRect.alpha = 1;  // Show when frozen

            qb.nameLabel = qbLabelRect;
            qb.nameTextBlock = qbNameText;
            qb.ovrTextBlock = qbOvrText;

            // Add name labels to receivers (stacked: name on top, OVR below bigger)
            gameState.receivers.forEach((receiver, i) => {
                const wrRating = getRatingIndicator(receiver.overall);
                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '130px';
                labelRect.height = '65px';
                labelRect.cornerRadius = 6;
                labelRect.thickness = 0;
                labelRect.background = wrRating.bgTint || 'rgba(0, 0, 0, 0.65)';

                const stack = new BABYLON.GUI.StackPanel();
                stack.isVertical = true;

                const nameText = new BABYLON.GUI.TextBlock();
                nameText.text = receiver.lastName.toUpperCase();
                nameText.color = '#88bbff';
                nameText.fontSize = 18;
                nameText.fontFamily = 'Courier New';
                nameText.fontWeight = 'bold';
                nameText.outlineWidth = 3;
                nameText.outlineColor = '#000000';
                nameText.height = '26px';

                const ovrText = new BABYLON.GUI.TextBlock();
                ovrText.text = wrRating.stars ? `${receiver.overall} ${wrRating.stars}` : `${receiver.overall}`;
                ovrText.color = '#ffffff';
                ovrText.fontSize = 26;
                ovrText.fontFamily = 'Courier New';
                ovrText.fontWeight = 'bold';
                ovrText.outlineWidth = 4;
                ovrText.outlineColor = '#000000';
                ovrText.height = '34px';

                stack.addControl(nameText);
                stack.addControl(ovrText);
                labelRect.addControl(stack);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -65;
                labelRect.alpha = 1;  // Show when frozen

                receiver.nameLabel = labelRect;
                receiver.nameTextBlock = nameText;
                receiver.ovrTextBlock = ovrText;
            });

            // Add name labels to defenders (DBs) - only if not in training mode
            if (!gameState.trainingMode) {
                // Defender-specific rating indicator with red theme
                const getDefenderRatingIndicator = (overall) => {
                    if (overall >= 90) {
                        return { stars: '‚òÖ‚òÖ', bgTint: 'rgba(100, 40, 40, 0.9)' };  // Elite - darker red with gold stars
                    } else if (overall >= 85) {
                        return { stars: '‚òÖ', bgTint: 'rgba(80, 35, 35, 0.85)' };   // Very good
                    }
                    return { stars: '', bgTint: 'rgba(40, 20, 20, 0.75)' };  // Default - no star below 85
                };

                gameState.defenders.forEach((defender, i) => {
                    const dbRating = getDefenderRatingIndicator(defender.overall);
                    const labelRect = new BABYLON.GUI.Rectangle();
                    labelRect.width = '130px';
                    labelRect.height = '65px';
                    labelRect.cornerRadius = 6;
                    labelRect.thickness = 0;
                    labelRect.background = dbRating.bgTint;

                    const stack = new BABYLON.GUI.StackPanel();
                    stack.isVertical = true;

                    const nameText = new BABYLON.GUI.TextBlock();
                    nameText.text = defender.displayName.toUpperCase();
                    nameText.color = '#ff6666';
                    nameText.fontSize = 16;
                    nameText.fontFamily = 'Courier New';
                    nameText.fontWeight = 'bold';
                    nameText.outlineWidth = 3;
                    nameText.outlineColor = '#000000';
                    nameText.height = '24px';

                    const ovrText = new BABYLON.GUI.TextBlock();
                    ovrText.text = dbRating.stars ? `${defender.overall} ${dbRating.stars}` : `${defender.overall}`;
                    ovrText.color = '#ffffff';
                    ovrText.fontSize = 24;
                    ovrText.fontFamily = 'Courier New';
                    ovrText.fontWeight = 'bold';
                    ovrText.outlineWidth = 4;
                    ovrText.outlineColor = '#000000';
                    ovrText.height = '32px';

                    stack.addControl(nameText);
                    stack.addControl(ovrText);
                    labelRect.addControl(stack);

                    advancedTexture.addControl(labelRect);
                    labelRect.linkWithMesh(defender);
                    labelRect.linkOffsetY = -65;
                    labelRect.alpha = 1;

                    defender.nameLabel = labelRect;
                    defender.nameTextBlock = nameText;
                    defender.ovrTextBlock = ovrText;
                });
            }

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark gray enemies
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            defenderMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            // Offensive line material - similar to receivers (blue)
            const oLineMaterial = new BABYLON.StandardMaterial('oLineMat', scene);
            oLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            oLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            oLineMaterial.specularPower = 32;

            // Defensive line material - similar to defenders (dark gray)
            const dLineMaterial = new BABYLON.StandardMaterial('dLineMat', scene);
            dLineMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            dLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            dLineMaterial.specularPower = 32;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial, oLineMaterial, dLineMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Alternating turf stripes (10-yard sections with different shades of green)
            const lightGreen = new BABYLON.StandardMaterial('lightGreen', scene);
            lightGreen.diffuseColor = new BABYLON.Color3(0.18, 0.42, 0.18);
            lightGreen.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            const darkGreen = new BABYLON.StandardMaterial('darkGreen', scene);
            darkGreen.diffuseColor = new BABYLON.Color3(0.12, 0.32, 0.12);
            darkGreen.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            // Create alternating 10-yard turf sections from -70 to +20
            const stripeStart = -70;
            const stripeEnd = 20;
            const stripeDepth = 10;
            let stripeIndex = 0;

            for (let z = stripeStart; z < stripeEnd; z += stripeDepth) {
                const stripe = BABYLON.MeshBuilder.CreateGround(`turf_${stripeIndex}`, {
                    width: FIELD_WIDTH + 2,
                    height: stripeDepth
                }, scene);
                stripe.material = (stripeIndex % 2 === 0) ? lightGreen : darkGreen;
                stripe.position.set(0, 0, z + stripeDepth / 2);
                stripeIndex++;
            }

            // Yard lines - white 10-yard markers across the full field
            // From own territory (-60) to opponent's goal line (10)
            for (let i = -60; i <= 10; i += 10) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.15
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.012, i);
            }

            // End zone (30% deeper)
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 4
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 13);

            // Sideline boundaries (football-style white lines)
            const sidelinePositions = [
                { x: -FIELD_WIDTH/2 - 0.15, z: -25 },
                { x: FIELD_WIDTH/2 + 0.15, z: -25 }
            ];

            const sidelineMat = new BABYLON.StandardMaterial('sidelineMat', scene);
            sidelineMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            sidelineMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            sidelinePositions.forEach((sp, i) => {
                // Main sideline stripe
                const sideline = BABYLON.MeshBuilder.CreateBox(`sideline_${i}`, {
                    width: 0.3,
                    height: 0.02,
                    depth: FIELD_LENGTH + 12
                }, scene);
                sideline.material = sidelineMat;
                sideline.position.set(sp.x, 0.015, sp.z);
            });

            // Line of scrimmage marker (blue)
            const losLine = BABYLON.MeshBuilder.CreateBox('losLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const losMat = new BABYLON.StandardMaterial('losMat', scene);
            losMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.9);
            losMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
            losMat.alpha = 0.8;
            losLine.material = losMat;
            losLine.position.set(0, 0.02, gameState.lineOfScrimmage);
            scene.losLine = losLine;

            // First down marker (yellow)
            const firstDownLine = BABYLON.MeshBuilder.CreateBox('firstDownLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const fdMat = new BABYLON.StandardMaterial('fdMat', scene);
            fdMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.2);
            fdMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.1);
            fdMat.alpha = 0.8;
            firstDownLine.material = fdMat;
            firstDownLine.position.set(0, 0.02, gameState.firstDownMarker);
            scene.firstDownLine = firstDownLine;
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Lineman Figure (larger than receivers)
        const createLineman = (scene, material, position, isOffense) => {
            const lineman = new BABYLON.TransformNode('lineman', scene);
            const scale = 1.25;  // Linemen are 25% bigger than receivers

            // Body (larger than knight)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = lineman;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = lineman;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = lineman;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35 * scale,
                height: 0.45 * scale,
                depth: 0.08 * scale
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3 * scale, 0.5 * scale, 0.1 * scale);
            shield.parent = lineman;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4 * scale,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = lineman;

            lineman.position = position;
            lineman.idleTime = Math.random() * Math.PI * 2;

            return lineman;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football - larger and more visible
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.6,
                segments: 12
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.5, 0.5, 1.2);  // More elongated football shape
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces - scaled up to match larger ball
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.08,
                height: 0.03,
                depth: 0.25
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            laceMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);  // Glow for visibility
            laces.material = laceMat;
            laces.position.y = 0.14;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters with smoothing to prevent jerky aiming
        let lastValidAngle = 0;  // Store last valid angle for smoothing
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Get QB's arm strength (affects max throw distance)
            // Scales from 12 yards at 50 armStrength to 26 yards at 100 armStrength
            const qb = gameState.scene?.qb;
            const armStrength = qb?.stats?.armStrength || 70;
            const qbMaxThrowDistance = 12 + ((armStrength - 50) / 50) * 14;  // 12-26 range

            // Distance dragged determines throw power
            const rawDragDistance = Math.sqrt(dx * dx + dy * dy);
            const dragDistance = rawDragDistance * DRAG_SENSITIVITY;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), qbMaxThrowDistance);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            // Only update angle if drag distance is significant enough to be stable
            let angle;
            if (rawDragDistance > 5) {  // At least 5 pixels of drag for stable angle
                angle = Math.atan2(dx, -dy);
                lastValidAngle = angle;
            } else {
                angle = lastValidAngle;  // Use last valid angle for very small drags
            }

            // Get QB max throw distance for power calculation
            const qbForPower = gameState.scene?.qb;
            const armStrengthForPower = qbForPower?.stats?.armStrength || 70;
            const maxDistForPower = 12 + ((armStrengthForPower - 50) / 50) * 14;

            return {
                distance: throwDistance,
                angle: angle,
                power: throwDistance / maxDistForPower
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw distance
            // Short throws (power ~0.2) = low arc (1.5), long throws (power ~1.0) = high arc (6)
            const maxHeight = 1 + power * power * 5;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                return false; // Route complete
            }

            let target = receiver.route[receiver.routeIndex];
            let dx = target.x - receiver.position.x;
            let dz = target.z - receiver.position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);

            // Check if reached current waypoint
            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                if (receiver.routeIndex >= receiver.route.length) {
                    receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                    return false; // Route complete
                }
                // Continue toward new waypoint this frame (don't skip a frame)
                target = receiver.route[receiver.routeIndex];
                dx = target.x - receiver.position.x;
                dz = target.z - receiver.position.z;
                dist = Math.sqrt(dx * dx + dz * dz);
            }

            if (dist > 0.1) {
                // Calculate and store velocity
                const vx = (dx / dist) * runSpeed;
                const vz = (dz / dist) * runSpeed;
                receiver.velocity = new BABYLON.Vector3(vx, 0, vz);

                // Move toward target
                receiver.position.x += vx;
                receiver.position.z += vz;
                receiver.rotation.y = Math.atan2(dx, dz);

                // Track running momentum for forward lean
                receiver.runMomentum = Math.min((receiver.runMomentum || 0) + 0.15, 1);
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0);
                // Decay forward lean when stopped
                receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.15;
            }
            return true;
        };

        // Apply forward lean to any player mesh when running
        const applyMomentumTilt = (player, dx, dz, dist, isMoving) => {
            if (isMoving && dist > 0.1) {
                // Track running momentum for forward lean
                player.runMomentum = Math.min((player.runMomentum || 0) + 0.15, 1);
                player.rotation.x = (player.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                // Decay forward lean when stopped
                player.runMomentum = (player.runMomentum || 0) * 0.95;
                player.rotation.x = (player.runMomentum || 0) * 0.15;
            }
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            // Reaction delay at start of play - defenders don't move immediately
            const timeSincePlayStart = gameState.gameTime - (gameState.playStartTime || 0);
            if (defender.reactionDelay && timeSincePlayStart < defender.reactionDelay) {
                return;  // Still reacting, don't move yet
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.2);
        };

        // Zone coverage AI - patrol assigned area, react to nearby receivers
        const moveDefenderZoneCoverage = (defender, speed) => {
            const timeSincePlayStart = gameState.gameTime - (gameState.playStartTime || 0);

            // Safety backpedal phase: first 1 second after reaction delay, move slowly backward
            const backpedalDuration = 1.0;
            const backpedalPhase = timeSincePlayStart < (defender.reactionDelay || 0) + backpedalDuration;

            if (backpedalPhase) {
                // Move backward slowly if there's room (not too close to end zone)
                const endZoneBack = 15;  // Back of end zone
                const distToEndZone = endZoneBack - defender.position.z;
                if (distToEndZone > 3) {
                    // Backpedal at 30% speed
                    const backpedalSpeed = speed * 0.3;
                    defender.position.z += backpedalSpeed;
                    // Face forward (toward line of scrimmage)
                    defender.rotation.y = Math.PI;
                }
                return;  // Don't do normal zone movement during backpedal
            }

            // Find nearest receiver in zone
            let nearestReceiver = null;
            let nearestDist = defender.zoneRadius;

            gameState.receivers.forEach(receiver => {
                const dx = receiver.position.x - defender.zoneCenter.x;
                const dz = receiver.position.z - defender.zoneCenter.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver in zone
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;  // Stay slightly behind
            } else {
                // Patrol zone center
                targetX = defender.zoneCenter.x;
                targetZ = defender.zoneCenter.z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.5);
        };

        // ============================================
        // LINE MOVEMENT AND CLASH SYSTEM
        // ============================================

        // Move D-lineman - rush toward QB
        const moveDLineman = (dLineman) => {
            // Skip if knocked down
            if (dLineman.knockdownUntil > gameState.gameTime) {
                dLineman.position.y = 0;
                return;
            }

            // Wait for snap delay before D-line starts rushing (gives QB time to drop back)
            const timeSinceSnap = gameState.playStartTime ?
                (performance.now() * 0.001 - gameState.playStartTime) : 0;
            if (timeSinceSnap < LINE_CLASH_CONSTANTS.SNAP_DELAY) {
                // D-linemen hold position during snap delay
                return;
            }

            // Get QB position (use current QB position for evasion tracking)
            const qbPos = gameState.scene.qb.position;

            // Calculate speed with any boosts
            let speed = dLineman.baseSpeed;
            if (dLineman.speedBoostUntil > gameState.gameTime) {
                speed *= LINE_CLASH_CONSTANTS.SPEED_BURST_MULTIPLIER;
            }

            // Apply engagement slowdown
            if (dLineman.engagedWith && !dLineman.engagedWith.knockdownUntil) {
                speed *= dLineman.currentSpeedMultiplier;
            }

            // Rush toward QB
            const dx = qbPos.x - dLineman.position.x;
            const dz = qbPos.z - dLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                dLineman.position.x += (dx / dist) * speed;
                dLineman.position.z += (dz / dist) * speed;
                dLineman.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(dLineman, dx, dz, dist, dist > 0.3);
        };

        // Move O-lineman - stay between assigned D-lineman and QB
        const moveOLineman = (oLineman) => {
            // Skip if knocked down
            if (oLineman.knockdownUntil > gameState.gameTime) {
                oLineman.position.y = 0;
                return;
            }

            const qbPos = gameState.scene.qb.position;

            // Find best D-lineman to block
            const targetDLineman = findBlockingTarget(oLineman);

            if (!targetDLineman) {
                // No target - hold position
                return;
            }

            // Update engagement
            oLineman.engagedWith = targetDLineman;

            // Calculate ideal blocking position - between D-lineman and QB
            const dLinePos = targetDLineman.position;

            // Vector from D-lineman to QB
            const toQbX = qbPos.x - dLinePos.x;
            const toQbZ = qbPos.z - dLinePos.z;
            const toQbDist = Math.sqrt(toQbX * toQbX + toQbZ * toQbZ);

            if (toQbDist < 0.5) return;  // Too close, don't move

            // Position 0.8 units in front of D-lineman (toward QB)
            const blockDist = 0.8;
            const targetX = dLinePos.x + (toQbX / toQbDist) * blockDist;
            const targetZ = dLinePos.z + (toQbZ / toQbDist) * blockDist;

            const dx = targetX - oLineman.position.x;
            const dz = targetZ - oLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                const speed = oLineman.baseSpeed;
                oLineman.position.x += (dx / dist) * speed;
                oLineman.position.z += (dz / dist) * speed;
                // Face the D-lineman
                oLineman.rotation.y = Math.atan2(dLinePos.x - oLineman.position.x, dLinePos.z - oLineman.position.z);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(oLineman, dx, dz, dist, dist > 0.2);
        };

        // Find the best D-lineman for an O-lineman to block
        const findBlockingTarget = (oLineman) => {
            const qbPos = gameState.scene.qb.position;
            let bestTarget = null;
            let bestScore = -Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip knocked down D-linemen
                if (dLineman.knockdownUntil > gameState.gameTime) return;

                // Calculate threat level (closer to QB = more threatening)
                const distToQb = BABYLON.Vector3.Distance(dLineman.position, qbPos);
                const distToOLine = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);

                // Check if another O-lineman is already blocking this D-lineman
                let alreadyBlocked = false;
                let blockingOLineman = null;
                gameState.offensiveLine.forEach(other => {
                    if (other !== oLineman && other.engagedWith === dLineman &&
                        other.knockdownUntil <= gameState.gameTime) {
                        alreadyBlocked = true;
                        blockingOLineman = other;
                    }
                });

                // Scoring: prioritize unblocked D-linemen, close to self, close to QB
                let score = 0;

                // Heavily prioritize unblocked rushers
                if (!alreadyBlocked) {
                    score += 100;
                }

                // Prefer D-linemen close to this O-lineman (easier to reach)
                score -= distToOLine * 5;

                // Prefer D-linemen closer to QB (more threatening)
                score -= distToQb * 2;

                // If this O-lineman was already blocking this D-lineman, prefer to stay
                if (oLineman.engagedWith === dLineman) {
                    score += 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = dLineman;
                }
            });

            return bestTarget;
        };

        // Process line clashes between O-line and D-line
        const processLineClashes = () => {
            const currentTime = gameState.gameTime;

            // Skip clash processing during snap delay
            const timeSinceSnap = gameState.playStartTime ?
                (performance.now() * 0.001 - gameState.playStartTime) : 0;
            if (timeSinceSnap < LINE_CLASH_CONSTANTS.SNAP_DELAY) {
                return;
            }

            gameState.defensiveLine.forEach(dLineman => {
                // Skip if knocked down
                if (dLineman.knockdownUntil > currentTime) {
                    dLineman.currentSpeedMultiplier = 0;
                    return;
                }

                // Reset speed boost if expired
                if (dLineman.speedBoostUntil <= currentTime) {
                    dLineman.speedBoostUntil = 0;
                }

                // Find closest O-lineman
                let closestOLineman = null;
                let closestDist = LINE_CLASH_CONSTANTS.CLASH_RANGE;

                gameState.offensiveLine.forEach(oLineman => {
                    if (oLineman.knockdownUntil > currentTime) return;

                    const dist = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestOLineman = oLineman;
                    }
                });

                if (closestOLineman) {
                    // Engaged with O-lineman
                    dLineman.engagedWith = closestOLineman;
                    closestOLineman.engagedWith = dLineman;

                    // Check if it's time for a clash resolution
                    const timeSinceLastClash = currentTime - dLineman.lastClashTime;
                    if (timeSinceLastClash >= LINE_CLASH_CONSTANTS.CLASH_INTERVAL) {
                        resolveLineClash(closestOLineman, dLineman);
                    }
                } else {
                    // Not engaged - full speed
                    dLineman.engagedWith = null;
                    dLineman.currentSpeedMultiplier = 1.0;
                }
            });
        };

        // Resolve a clash between O-lineman and D-lineman
        const resolveLineClash = (oLineman, dLineman) => {
            const currentTime = gameState.gameTime;

            // Update clash timing
            oLineman.lastClashTime = currentTime;
            dLineman.lastClashTime = currentTime;

            // Ability selection - DL initiates (attacker), OL reacts (defender)
            const abilityResult = resolveAbilityClash(dLineman, oLineman, ABILITY_MATCHUPS.linemen, true);

            // Calculate technique rolls (40% of total)
            const oTechRoll = getTechniqueRoll(oLineman.stats, CLASH_WEIGHTS.lineClash.offense);
            const dTechRoll = getTechniqueRoll(dLineman.stats, CLASH_WEIGHTS.lineClash.defense);

            // Calculate core√óability multiplicative rolls (60% of total)
            const oCoreAbilityRoll = getCoreAbilityRoll(oLineman, abilityResult.reactor);
            const dCoreAbilityRoll = getCoreAbilityRoll(dLineman, abilityResult.initiator);

            // Combined rolls with variance (¬±20%)
            const variance = 0.2;
            const oRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;
            const dRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;

            const adjustedOLineRoll = (oTechRoll + oCoreAbilityRoll) * oRollVariance;
            // Apply matchup multiplier to DL's roll (higher = better for DL)
            const adjustedDLineRoll = (dTechRoll + dCoreAbilityRoll) * dRollVariance * abilityResult.matchupMultiplier;

            const margin = adjustedOLineRoll - adjustedDLineRoll;

            if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD) {
                // O-line wins decisively - knock down D-lineman
                dLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                dLineman.currentSpeedMultiplier = 0;
                dLineman.engagedWith = null;

                // O-lineman is free to help another
                oLineman.engagedWith = null;

                // Record clash stats
                recordPlayerStat(oLineman, 'seasonClashesWon');
                recordPlayerStat(dLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesWon++;
                    oStats.clashDifficulties.push(margin);
                }
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD) {
                // D-line wins decisively - knock O-lineman aside, speed burst
                oLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                oLineman.engagedWith = null;

                // D-lineman gets speed burst
                dLineman.speedBoostUntil = currentTime + LINE_CLASH_CONSTANTS.SPEED_BURST_DURATION;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.engagedWith = null;

                // Knock O-lineman to the side
                const sideDir = Math.random() > 0.5 ? 1 : -1;
                oLineman.position.x += sideDir * 1.5;

                // Record clash stats
                recordPlayerStat(dLineman, 'seasonClashesWon');
                recordPlayerStat(oLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesWon++;
                    dStats.clashDifficulties.push(-margin);
                }
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesLost++;
                    oStats.clashDifficulties.push(margin);
                }

            } else if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD / 2) {
                // O-line winning but not decisive - D-lineman very slow
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD / 2) {
                // D-line winning but not decisive - breaking through slowly
                dLineman.currentSpeedMultiplier = 0.5;

            } else {
                // Neutral - D-lineman nearly stopped
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;
            }
        };

        // Reset offensive line to starting positions
        const resetOffensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.offensiveLine.forEach((oLineman, i) => {
                oLineman.position.x = oLineman.startPos.x;
                oLineman.position.z = lineZ - 0.5;
                oLineman.position.y = 0;
                oLineman.rotation.y = 0;
                oLineman.rotation.x = 0;
                oLineman.knockdownUntil = 0;
                oLineman.engagedWith = null;
                oLineman.lastClashTime = 0;
                oLineman.bodyMaterial.diffuseColor = oLineman.originalColor;
                oLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // Reset defensive line to starting positions
        const resetDefensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.defensiveLine.forEach((dLineman, i) => {
                dLineman.position.x = dLineman.startPos.x;
                dLineman.position.z = lineZ + 0.5;
                dLineman.position.y = 0;
                dLineman.rotation.y = Math.PI;  // Face the offense
                dLineman.rotation.x = 0;
                dLineman.knockdownUntil = 0;
                dLineman.engagedWith = null;
                dLineman.lastClashTime = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial.diffuseColor = dLineman.originalColor;
                dLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // ============================================
        // QB MOVEMENT AND SACK SYSTEM
        // ============================================

        // Move QB based on pocket behavior and threats
        const moveQB = (scene) => {
            const qb = scene.qb;
            const currentTime = gameState.gameTime;

            // Don't move if play has ended or ball is being thrown
            if (gameState.playEnded || gameState.ballInFlight) return;

            // Skip QB movement/sack logic in training mode
            if (gameState.trainingMode) return;

            // Find closest threat (D-lineman)
            let closestThreat = null;
            let closestThreatDist = Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                if (dLineman.knockdownUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(dLineman.position, qb.position);
                if (dist < closestThreatDist) {
                    closestThreatDist = dist;
                    closestThreat = dLineman;
                }
            });

            // Check for sack
            if (closestThreatDist < LINE_CLASH_CONSTANTS.TACKLE_RANGE) {
                handleSack(scene, closestThreat);
                return;
            }

            // Calculate pocket position relative to line of scrimmage
            const losZ = gameState.lineOfScrimmage;
            const pocketCenterZ = losZ - 3;  // 3 yards behind LOS
            const maxDepthZ = losZ - 6;       // 6 yards behind LOS max

            let targetX = qb.position.x;
            let targetZ = pocketCenterZ;
            let speed = POCKET_CONSTANTS.SETTLE_SPEED;

            // If threat is close, evade
            if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                speed = POCKET_CONSTANTS.EVADE_SPEED;

                // Calculate evasion direction (away from threat)
                const threatDx = qb.position.x - closestThreat.position.x;
                const threatDz = qb.position.z - closestThreat.position.z;
                const threatDist = Math.sqrt(threatDx * threatDx + threatDz * threatDz);

                if (threatDist > 0.1) {
                    // Move away from threat
                    targetX = qb.position.x + (threatDx / threatDist) * 2;
                    targetZ = qb.position.z + (threatDz / threatDist) * 2;
                }
            }

            // Apply constraints
            // Don't cross line of scrimmage
            targetZ = Math.min(targetZ, losZ);

            // Don't go too deep
            targetZ = Math.max(targetZ, maxDepthZ);

            // Stay within pocket width (with some flexibility when evading)
            const maxX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MAX_X + 2 : POCKET_CONSTANTS.POCKET_MAX_X;
            const minX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MIN_X - 2 : POCKET_CONSTANTS.POCKET_MIN_X;
            targetX = Math.max(minX, Math.min(maxX, targetX));

            // Move toward target
            const dx = targetX - qb.position.x;
            const dz = targetZ - qb.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                qb.position.x += (dx / dist) * speed;
                qb.position.z += (dz / dist) * speed;

                // Face the threat or downfield
                if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                    const faceDx = closestThreat.position.x - qb.position.x;
                    const faceDz = closestThreat.position.z - qb.position.z;
                    qb.rotation.y = Math.atan2(faceDx, faceDz);
                }
            }
        };

        // Show play result popup (game mode - not training)
        const showPlayResult = (result) => {
            if (gameState.trainingMode) return;  // Training mode has its own popup

            const popup = document.getElementById('playResultPopup');
            const mainEl = document.getElementById('playResultMain');
            const detailEl = document.getElementById('playResultDetail');
            const downEl = document.getElementById('playResultDown');
            const fieldPosEl = document.getElementById('playResultFieldPos');
            const catchInfoEl = document.getElementById('playResultCatchInfo');

            if (result.type === 'incomplete') {
                mainEl.textContent = 'INCOMPLETE';
                mainEl.style.color = '#f66';
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'touchdown') {
                mainEl.textContent = 'TOUCHDOWN!';
                mainEl.style.color = '#4f4';
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'catch') {
                const yards = result.yards;
                if (yards > 0) {
                    mainEl.textContent = `+${yards} YDS`;
                    mainEl.style.color = '#4f4';
                } else if (yards < 0) {
                    mainEl.textContent = `${yards} YDS`;
                    mainEl.style.color = '#f66';
                } else {
                    mainEl.textContent = 'NO GAIN';
                    mainEl.style.color = '#ff4';
                }
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'sack') {
                mainEl.textContent = `${result.yards} YDS`;
                mainEl.style.color = '#f66';
                detailEl.textContent = 'SACKED!';
            }

            // Show catch info if provided
            if (result.catchInfo && result.catchRoll !== undefined) {
                const catchInfo = result.catchInfo;
                const catchRoll = result.catchRoll;
                const success = result.catchSuccess;

                catchInfoEl.style.display = 'block';

                const headerEl = document.getElementById('playResultCatchHeader');
                const baseEl = document.getElementById('playResultCatchBase');
                const penaltyEl = document.getElementById('playResultCatchPenalty');
                const rollEl = document.getElementById('playResultCatchRoll');
                const modListEl = document.getElementById('playResultModifierList');

                headerEl.textContent = success ? 'CATCH!' : 'DROPPED';
                headerEl.style.color = success ? '#4f4' : '#f66';

                // Show wide open rate as base, with penalty overlay
                const baseWidth = catchInfo.wideOpenRate || 70;
                const penaltyWidth = Math.max(0, baseWidth - (catchInfo.probability || baseWidth));

                baseEl.style.width = `${baseWidth}%`;

                if (penaltyWidth > 0) {
                    penaltyEl.style.display = 'block';
                    penaltyEl.style.left = `${catchInfo.probability}%`;
                    penaltyEl.style.width = `${penaltyWidth}%`;
                } else {
                    penaltyEl.style.display = 'none';
                }

                rollEl.textContent = 'üèà';
                rollEl.style.filter = success ? 'none' : 'grayscale(100%)';
                rollEl.style.left = `${catchRoll}%`;

                // Build modifier list - simplified formula display
                const makeRow = (label, value, isPositive) => {
                    const color = isPositive ? '#4f4' : '#f66';
                    const sign = isPositive ? '+' : '';
                    return `<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#aaa;">${label}</span>
                        <span style="color:${color}; font-weight:bold;">${sign}${value}</span>
                    </div>`;
                };

                let modRows = [];

                // Show separation/coverage
                if (catchInfo.separation !== undefined) {
                    const sepYards = catchInfo.separation.toFixed(1);
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0; padding-bottom: 6px; border-bottom: 1px solid #333;">
                        <span style="color:#888;">Separation</span>
                        <span style="color:#fff;">${sepYards} yds - ${catchInfo.coverageLevel || 'open'}</span>
                    </div>`);
                }

                // Base catch rate (from catching stat)
                if (catchInfo.baseCatch !== undefined) {
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#aaa;">Base rate (${catchInfo.baseCatch} catch)</span>
                        <span style="color:#4f4; font-weight:bold;">${Math.round(catchInfo.wideOpenRate)}%</span>
                    </div>`);
                }

                // DB penalty (raw, before lead bonus reduction)
                if (catchInfo.isContested && catchInfo.dbPenalty > 0) {
                    modRows.push(makeRow('DB penalty', `-${catchInfo.dbPenalty}%`, false));
                }

                // Lead bonus (reduction of DB penalty based on throw quality)
                if (catchInfo.hasSideBonus && catchInfo.shoulderBonusSaved > 0) {
                    const leadLabel = catchInfo.leadQuality >= 80 ? 'perfect' :
                                     catchInfo.leadQuality >= 60 ? 'good' :
                                     catchInfo.leadQuality >= 40 ? 'ok' : 'poor';
                    modRows.push(makeRow(`Lead bonus (${leadLabel})`, `${catchInfo.shoulderBonusSaved}%`, true));
                }

                // Final probability
                const finalColor = catchInfo.probability >= 50 ? '#4f4' : (catchInfo.probability >= 25 ? '#ff4' : '#f66');
                modRows.push(`<div style="display:flex; justify-content:space-between; margin: 8px 0 0 0; padding-top: 6px; border-top: 1px solid #333;">
                    <span style="color:#fff; font-weight:bold;">Final catch rate</span>
                    <span style="color:${finalColor}; font-weight:bold; font-size: 15px;">${Math.round(catchInfo.probability)}%</span>
                </div>`);

                modListEl.innerHTML = modRows.join('');
            } else {
                catchInfoEl.style.display = 'none';
            }

            // Show next down info
            if (result.nextDown) {
                downEl.textContent = result.nextDown;
                downEl.style.display = 'block';
            } else {
                downEl.style.display = 'none';
            }

            // Calculate and show field position
            const END_ZONE_Z = 11;
            const yardsFromGoal = Math.round(END_ZONE_Z - gameState.lineOfScrimmage);
            let fieldPosText = '';
            if (yardsFromGoal <= 0) {
                fieldPosText = 'Ball at: GOAL LINE';
            } else if (yardsFromGoal <= 50) {
                fieldPosText = yardsFromGoal === 50 ? 'Ball at: MIDFIELD' : `Ball at: OPP ${yardsFromGoal}`;
            } else {
                const ownYardLine = 100 - yardsFromGoal;
                fieldPosText = `Ball at: OWN ${ownYardLine}`;
            }
            fieldPosEl.textContent = fieldPosText;

            popup.style.display = 'block';

            // Dismiss on any click anywhere on screen
            const dismissPopup = (e) => {
                popup.style.display = 'none';
                document.removeEventListener('click', dismissPopup);
                document.removeEventListener('touchstart', dismissPopup);
            };
            // Small delay to prevent immediate dismissal from the same click
            setTimeout(() => {
                document.addEventListener('click', dismissPopup);
                document.addEventListener('touchstart', dismissPopup);
            }, 100);
        };

        // Handle QB sack
        const handleSack = (scene, tackler) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.qbSacked = true;
            gameState.canThrow = false;

            // Calculate yards lost before updating
            const oldLOS = gameState.lineOfScrimmage;
            const yardsLost = Math.round(scene.qb.position.z - oldLOS);

            // Record sack for roster player
            recordPlayerStat(tackler, 'seasonSacks');

            // Record per-game sack stats
            if (tackler.playerId) {
                gameStats.getPlayer(tackler.playerId, tackler.displayName).sacks++;
            }

            // Move line of scrimmage back to sack location
            handleSackFieldPosition(scene.qb.position.z);

            updateMessage(`SACK by ${tackler.displayName}!`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'sack',
                yards: yardsLost,
                detail: `${tackler.displayName}`,
                nextDown: nextDownText
            });

            // QB falls down animation
            const qb = scene.qb;
            qb.rotation.x = Math.PI / 3;  // Fall forward

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // ============================================
        // RECEIVER TACKLING SYSTEM
        // ============================================

        // Move ball carrier (receiver with the ball) toward end zone
        const moveBallCarrier = (receiver) => {
            if (!receiver || receiver.knockdownUntil > gameState.gameTime) return;

            // Calculate effective speed with any boosts
            let speed = receiver.baseSpeed;
            if (receiver.breakTackleBoostUntil > gameState.gameTime) {
                speed *= TACKLE_CONSTANTS.BREAK_TACKLE_BOOST;
            }

            // Run toward back of end zone (positive Z direction)
            const targetZ = 15;  // Back of end zone
            const targetX = receiver.position.x;  // Maintain lane for now

            const dz = targetZ - receiver.position.z;
            const dx = targetX - receiver.position.x;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                receiver.position.z += (dz / dist) * speed;
                receiver.position.x += (dx / dist) * speed * 0.3;  // Slight drift
                receiver.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(receiver, dx, dz, dist, dist > 0.1);

            // Check for touchdown
            if (receiver.position.z >= 12) {
                handleTouchdown(receiver);
                return;
            }

            // Check for out of bounds
            if (Math.abs(receiver.position.x) > 8) {
                handleOutOfBounds(receiver);
                return;
            }
        };

        // Process tackle attempts by defenders on ball carrier
        const processTackles = () => {
            const receiver = gameState.ballCarrier;
            if (!receiver || gameState.playEnded) return;

            const currentTime = gameState.gameTime;

            // Check all defenders for tackle attempts
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > currentTime) return;
                if (defender.tackleStumbleUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(defender.position, receiver.position);

                if (dist < TACKLE_CONSTANTS.TACKLE_RANGE) {
                    // Check tackle cooldown
                    const timeSinceLastTackle = currentTime - (defender.lastTackleTime || 0);
                    if (timeSinceLastTackle < TACKLE_CONSTANTS.TACKLE_INTERVAL) return;

                    // Attempt tackle
                    resolveTackle(receiver, defender);
                }
            });
        };

        // Resolve a tackle attempt
        const resolveTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;
            defender.lastTackleTime = currentTime;

            // Roll for tackle
            let tackleRoll = weightedRoll(defender.stats, CLASH_WEIGHTS.tackle.tackler, defender.coreAttributes);
            const evasionRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier, receiver.coreAttributes);

            // Tackler advantage: WRs have natural +7 advantage from primary stat bonuses
            // on speed/agility, while CBs don't get bonuses on tackling/pursuit/hitPower.
            // Add a base tackler bonus to compensate and make tackling realistic.
            const tacklerBonus = 10;
            tackleRoll += tacklerBonus;

            const margin = tackleRoll - evasionRoll;

            // Tackling favors the defender - receiver needs to significantly outroll
            // to break a tackle (margin must be < -12, meaning receiver wins by 12+)
            if (margin > -12) {
                // Tackle successful!
                handleTackle(receiver, defender);
            } else {
                // Broken tackle! (rare - requires big evasion win)
                handleBrokenTackle(receiver, defender);
            }
        };

        // Handle successful tackle
        const handleTackle = (receiver, defender) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Calculate yards gained before advancing
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = Math.round(receiver.position.z - oldLOS);

            // Record tackle for roster player
            recordPlayerStat(defender, 'seasonTackles');

            // Record per-game tackle stats
            if (defender.playerId) {
                gameStats.getPlayer(defender.playerId, defender.displayName).tackles++;
            }

            // Record YAC for receiver
            if (receiver.playerId && receiver.catchPosition !== undefined) {
                const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                gameStats.getPlayer(receiver.playerId, receiver.displayName).yardsAfterCatch += yac;
            }

            // Advance ball to tackle location
            advanceBall(receiver.position.z);

            updateMessage(`TACKLED by ${defender.displayName}!`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'catch',
                yards: yardsGained,
                detail: `Tackled by ${defender.displayName}`,
                nextDown: nextDownText,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Receiver falls down
            receiver.rotation.x = Math.PI / 3;
            receiver.position.y = 0;

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Flash effects
            defender.bodyMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.5, 0.1);
            setTimeout(() => {
                defender.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 500);

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // Handle broken tackle
        const handleBrokenTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            updateMessage(`BROKEN TACKLE!`);

            // Defender stumbles
            defender.tackleStumbleUntil = currentTime + TACKLE_CONSTANTS.STUMBLE_DURATION;
            defender.rotation.x = Math.PI / 6;  // Lean forward stumbling

            // Receiver gets speed boost
            receiver.breakTackleBoostUntil = currentTime + TACKLE_CONSTANTS.BREAK_TACKLE_DURATION;

            // Flash receiver green
            receiver.bodyMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.1);
            setTimeout(() => {
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 300);

            // Reset defender stumble rotation
            setTimeout(() => {
                defender.rotation.x = 0;
            }, TACKLE_CONSTANTS.STUMBLE_DURATION * 1000);
        };

        // Reset the drive to starting position (after TD or turnover on downs)
        const resetDrive = () => {
            gameState.down = 1;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.lineOfScrimmage + 10;
            gameState.yardsToGo = 10;
        };

        // Advance the ball to a new position and handle down logic
        const advanceBall = (newPositionZ) => {
            const END_ZONE_Z = 11;  // Touchdown threshold (matches visual end zone start)
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = newPositionZ - oldLOS;

            // Update line of scrimmage
            gameState.lineOfScrimmage = newPositionZ;

            // Check for first down
            if (newPositionZ >= gameState.firstDownMarker) {
                // First down achieved!
                gameState.down = 1;
                gameState.firstDownMarker = newPositionZ + 10;
                gameState.yardsToGo = 10;

                // Cap first down marker at end zone
                if (gameState.firstDownMarker > END_ZONE_Z) {
                    gameState.yardsToGo = END_ZONE_Z - newPositionZ;
                    gameState.firstDownMarker = END_ZONE_Z;
                }

                updateMessage('FIRST DOWN!');
            } else {
                // No first down, advance to next down
                gameState.down++;
                gameState.yardsToGo = gameState.firstDownMarker - newPositionZ;

                if (gameState.down > 4) {
                    // Turnover on downs!
                    updateMessage('TURNOVER ON DOWNS!');
                    resetDrive();
                    // Management: record possession complete with 0 points (turnover)
                    if (managementState.matchInProgress) {
                        gameState.waitingForPossession = true;
                        setTimeout(() => {
                            onPossessionComplete(0);
                        }, 1500);
                    }
                }
            }
        };

        // Handle incomplete pass (same line of scrimmage, next down)
        const handleIncomplete = (detail) => {
            gameState.down++;

            // Show play result popup (before checking turnover so we can show correct down)
            if (gameState.down <= 4) {
                const downNames = ['1st', '2nd', '3rd', '4th'];
                showPlayResult({
                    type: 'incomplete',
                    detail: detail || '',
                    nextDown: `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}`,
                    catchInfo: gameState.lastCatchInfo,
                    catchRoll: gameState.lastCatchRoll,
                    catchSuccess: gameState.lastCatchSuccess
                });
            } else {
                showPlayResult({
                    type: 'incomplete',
                    detail: 'TURNOVER ON DOWNS',
                    catchInfo: gameState.lastCatchInfo,
                    catchRoll: gameState.lastCatchRoll,
                    catchSuccess: gameState.lastCatchSuccess
                });
            }

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle sack (move line back)
        const handleSackFieldPosition = (sackPositionZ) => {
            // Sack moves the line of scrimmage back
            const newLOS = Math.max(-8, sackPositionZ);  // Don't go too far back
            gameState.lineOfScrimmage = newLOS;
            gameState.yardsToGo = gameState.firstDownMarker - newLOS;
            gameState.down++;

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle touchdown
        const handleTouchdown = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.touchdowns++;
            updateScore();

            // Record TD for roster player
            recordPlayerStat(receiver, 'seasonTDs');

            // Record per-game TD stats
            if (receiver.playerId) {
                const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                rStats.touchdowns++;
                // Also record YAC for TD run
                if (receiver.catchPosition !== undefined) {
                    const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                    rStats.yardsAfterCatch += yac;
                }
            }

            updateMessage(`TOUCHDOWN by ${receiver.displayName}!`);

            // Show play result popup
            showPlayResult({
                type: 'touchdown',
                detail: `${receiver.displayName} scores!`,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Celebration
            celebrateReceiver(receiver, gameState.scene);

            // Reset drive tracking (downs/yardage)
            resetDrive();

            // Management: record possession complete with 7 points
            if (managementState.matchInProgress) {
                // Pause game during possession overlay
                gameState.waitingForPossession = true;
                setTimeout(() => {
                    onPossessionComplete(7);
                }, 2500);
                return; // Don't reset play yet - wait for overlay to be dismissed
            }

            // Only reset play immediately if not in management match
            setTimeout(() => {
                resetPlay(gameState.scene);
            }, 3000);
        };

        // Handle out of bounds
        const handleOutOfBounds = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Calculate yards gained before advancing
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = Math.round(receiver.position.z - oldLOS);

            // Advance ball to where receiver went out
            advanceBall(receiver.position.z);

            updateMessage(`OUT OF BOUNDS`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'catch',
                yards: yardsGained,
                detail: 'Out of bounds',
                nextDown: nextDownText,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 1500);
        };

        // Move defenders to pursue ball carrier
        const moveDefenderPursuit = (defender, pursuitBoost = 1.0) => {
            const receiver = gameState.ballCarrier;
            if (!receiver || defender.knockdownUntil > gameState.gameTime) return;

            // Stumbling defenders can't move well
            if (defender.tackleStumbleUntil > gameState.gameTime) {
                return;
            }

            // Base pursuit speed with time-based boost
            const speed = defender.baseSpeed * 1.1 * pursuitBoost;

            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            const lineZ = gameState.lineOfScrimmage;
            const END_ZONE_Z = 11;
            const END_ZONE_BACK = 15;  // Back of end zone - max Z position
            const SIDELINE = 8;  // Field boundary
            const distToGoal = END_ZONE_Z - lineZ;  // How far from goal line

            // Create shuffled receiver assignment for man coverage DBs
            const receiverIndices = [0, 1, 2];
            for (let i = receiverIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [receiverIndices[i], receiverIndices[j]] = [receiverIndices[j], receiverIndices[i]];
            }
            let manDefenderIndex = 0;

            gameState.defenders.forEach((defender, i) => {
                if (defender.aiType === 'man') {
                    // Man defenders cover receivers 1-to-1 (randomized assignment)
                    const receiverIndex = receiverIndices[manDefenderIndex % receiverIndices.length];
                    defender.assignedReceiver = receiverIndex;
                    const targetReceiver = gameState.receivers[receiverIndex];

                    // Cushion decreases near goal line (DBs play tighter in red zone)
                    // Far from goal: 4-7 yards, Near goal line: 1-3 yards
                    const baseCushion = Math.max(1, Math.min(4, distToGoal * 0.4));
                    const cushionVariance = Math.max(1, Math.min(3, distToGoal * 0.3));
                    defender.cushion = baseCushion + Math.random() * cushionVariance;

                    defender.startPos.x = Math.max(-SIDELINE, Math.min(SIDELINE, targetReceiver.startPos.x));
                    defender.startPos.z = Math.min(END_ZONE_BACK - 1, targetReceiver.startPos.z + defender.cushion);
                    defender.reactionDelay = 0.25;  // Quarter second before reacting
                    manDefenderIndex++;
                } else if (defender.aiType === 'zone') {
                    // Zone defender (safety) - randomized horizontal position
                    const zoneDepth = 6 + Math.random() * 4;  // 6-10 yards deep
                    const clampedZoneZ = Math.min(END_ZONE_BACK - 1, lineZ + zoneDepth);
                    // Safety can line up anywhere from -4 to +4 horizontally
                    const safetyX = (Math.random() - 0.5) * 8;
                    defender.zoneCenter = new BABYLON.Vector3(safetyX, 0, clampedZoneZ);
                    defender.zoneRadius = 5 + Math.random() * 2;  // 5-7 yard radius
                    defender.startPos.x = safetyX;
                    defender.startPos.z = Math.min(END_ZONE_BACK - 1, clampedZoneZ - 2);
                }

                // Clamp final positions to field boundaries
                defender.position.x = Math.max(-SIDELINE, Math.min(SIDELINE, defender.startPos.x));
                defender.position.z = Math.min(END_ZONE_BACK - 1, defender.startPos.z);
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.clashTiltUntil = 0;
                defender.loserFlashUntil = 0;
                defender.winnerFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.clashSpeedPenaltyUntil = 0;
                defender.lastClashTime = 0;
                defender.rotation.x = 0;  // Reset tilt
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
                // Tackling state
                defender.tackleStumbleUntil = 0;
                defender.lastTackleTime = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            // Receivers line up at the line of scrimmage
            const receiverLineZ = gameState.lineOfScrimmage;

            // Slot receiver lines up just outside the offensive tackle (randomly left or right)
            const slotSide = Math.random() > 0.5 ? 1 : -1;  // Randomly pick left or right side
            const positions = [
                -(6 + Math.random() * 1.5),   // Wide left (-6 to -7.5)
                (6 + Math.random() * 1.5),    // Wide right (6 to 7.5)
                slotSide * (4 + Math.random() * 0.5)  // Slot: Just outside tackle (¬±4 to ¬±4.5)
            ];

            // Shuffle positions so receivers line up in random slots each play
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Rarely pick 0-1 receivers to run crossing routes (less overlap)
            const numCrossing = Math.random() < 0.3 ? 1 : 0;  // 30% chance of 1 crossing route
            const crossingIndices = [];
            while (crossingIndices.length < numCrossing && crossingIndices.length < gameState.receivers.length) {
                const idx = Math.floor(Math.random() * gameState.receivers.length);
                if (!crossingIndices.includes(idx)) {
                    crossingIndices.push(idx);
                }
            }

            gameState.receivers.forEach((receiver, i) => {
                // Assign spread position
                receiver.startPos.x = positions[i] || (Math.random() - 0.5) * 6;
                receiver.startPos.z = receiverLineZ;

                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiverLineZ;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.clashTiltUntil = 0;
                receiver.loserFlashUntil = 0;
                receiver.winnerFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.clashSpeedPenaltyUntil = 0;
                receiver.clashSpeedBoostUntil = 0;
                receiver.rotation.x = 0;  // Reset tilt
                receiver.coverageAmount = 0;
                receiver.currentCatchProb = receiver.stats.catching;
                // Size based on base catching stat (80% = 0.3 + 0.9*0.8 = 1.02 scale)
                const baseScale = 0.3 + 0.9 * (receiver.stats.catching / 100);
                receiver.zoneFill.scaling = new BABYLON.Vector3(baseScale, baseScale, baseScale);
                receiver.fillMaterial.alpha = 0.5;
                // Always white
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // Reset body color to original (clear any flash effects from previous play)
                receiver.bodyMaterial.diffuseColor = receiver.originalColor.clone();
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();

                // Tackling state
                receiver.breakTackleBoostUntil = 0;

                // Generate new random route (force crossing for selected receivers)
                const isCrossing = crossingIndices.includes(i);
                generateRandomRoute(receiver, isCrossing);

                // Keep name labels hidden
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });

            // Reset play start time for label fading
            gameState.playStartTime = performance.now() * 0.001;
        };

        // Generate a random route for a receiver
        const generateRandomRoute = (receiver, forceCrossing = false) => {
            const startX = receiver.startPos.x;
            const startZ = receiver.startPos.z;
            const END_ZONE_Z = 11;  // End zone starts here
            const END_ZONE_BACK = 15;  // Back of end zone
            const SIDELINE = 8;  // Field boundary

            // Calculate available depth to end zone
            const depthToEndZone = END_ZONE_Z - startZ;
            const isVeryNearGoalLine = depthToEndZone < 2;  // Within 2 yards - need sideways cuts
            const isNearGoalLine = depthToEndZone < 8;  // Within 8 yards of end zone - use goal line routes
            const isOnSideline = Math.abs(startX) > 5;  // Near sideline
            const isInRedZone = depthToEndZone < 12;  // Inside the ~12 yard line

            // Determine lateral directions
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = startX > 0 ? 1 : -1;

            const route = [];
            let routeType;

            // Select route type based on field position
            if (isVeryNearGoalLine) {
                // Very close to goal line - routes must go into end zone then cut sideways
                if (isOnSideline) {
                    // Near sideline - cut toward middle of end zone
                    const types = ['endzone_in', 'endzone_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field - can cut either direction
                    const types = ['endzone_out', 'endzone_cross', 'endzone_corner'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isNearGoalLine) {
                // Goal line routes - short, quick, mostly crossing or corner fades
                if (isOnSideline || forceCrossing) {
                    // Near sideline + goal line = must cross toward middle
                    const types = ['quick_slant', 'corner_fade', 'flat_cross', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field near goal line - favor crossing routes
                    const types = ['quick_slant', 'flat_cross', 'back_shoulder', 'quick_slant', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isInRedZone) {
                // Red zone routes - medium depth, need to get into end zone
                if (isOnSideline) {
                    const types = ['corner', 'fade', 'comeback_corner', 'slant'];
                    routeType = forceCrossing ? 'slant' : types[Math.floor(Math.random() * types.length)];
                } else {
                    const types = ['post', 'dig', 'seam', 'out'];
                    routeType = forceCrossing ? 'dig' : types[Math.floor(Math.random() * types.length)];
                }
            } else {
                // Normal field position - full route tree
                if (forceCrossing) {
                    routeType = Math.random() > 0.5 ? 'crossing' : 'dig';
                } else if (isOnSideline) {
                    // Sideline receivers: go, corner, out, comeback
                    const types = ['go', 'corner', 'out', 'comeback', 'post'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Slot/middle receivers: slant, seam, dig, post
                    const types = ['slant', 'seam', 'dig', 'post', 'curl'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            }

            // Generate route points based on type
            switch(routeType) {
                // === END ZONE ROUTES (very close to goal line) ===
                case 'endzone_out':
                    // Go into end zone 2-3 yards, then cut sharply toward sideline
                    const ezOutDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezOutX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 3)));
                    route.push({ z: ezOutDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezOutDepth + 0.5, x: ezOutX });  // Cut sharply sideways
                    break;

                case 'endzone_in':
                    // Go into end zone 2-3 yards, then cut sharply toward middle
                    const ezInDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezInX = Math.max(-5, Math.min(5, startX + towardMiddle * (4 + Math.random() * 3)));
                    route.push({ z: ezInDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezInDepth + 0.5, x: ezInX });  // Cut sharply toward middle
                    break;

                case 'endzone_cross':
                    // Go into end zone 2-3 yards, then run horizontally across
                    const ezCrossDepth = Math.min(startZ + 2 + Math.random() * 1.5, END_ZONE_BACK - 1);
                    const ezCrossX = Math.max(-6, Math.min(6, startX + towardMiddle * (6 + Math.random() * 4)));
                    route.push({ z: ezCrossDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezCrossDepth, x: (startX + ezCrossX) / 2 });  // Start crossing
                    route.push({ z: ezCrossDepth + 0.5, x: ezCrossX });  // Continue across
                    break;

                case 'endzone_corner':
                    // Go into end zone 2-3 yards, then angle to back corner
                    const ezCornerDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_Z + 2);
                    const ezCornerX = Math.max(-7, Math.min(7, startX + towardSideline * (3 + Math.random() * 2)));
                    route.push({ z: ezCornerDepth, x: startX + towardSideline * 0.5 });  // Slight angle in
                    route.push({ z: Math.min(ezCornerDepth + 2, END_ZONE_BACK), x: ezCornerX });  // Break to corner
                    break;

                // === GOAL LINE ROUTES ===
                case 'quick_slant':
                    // Quick slant toward middle - 2-3 yards then cut, go to end zone
                    const qsDepth = startZ + 2;
                    const qsEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (4 + Math.random() * 2)));
                    route.push({ z: qsDepth, x: startX });
                    route.push({ z: qsDepth + 3, x: qsEndX });
                    route.push({ z: END_ZONE_BACK, x: qsEndX });
                    break;

                case 'flat_cross':
                    // Push 2-3 yards past LOS then cross across the formation, go to end zone
                    const fcStem = startZ + 2 + Math.random();  // 2-3 yards forward first
                    const fcX = startX + towardMiddle * (6 + Math.random() * 3);
                    route.push({ z: fcStem, x: startX });  // Vertical stem past LOS
                    route.push({ z: fcStem + 1, x: Math.max(-6, Math.min(6, fcX)) });  // Then cross
                    route.push({ z: END_ZONE_BACK, x: Math.max(-6, Math.min(6, fcX + towardMiddle * 2)) });
                    break;

                case 'back_shoulder':
                    // Straight then slight fade back - for back shoulder throw, extend to end zone
                    route.push({ z: startZ + 3, x: startX });
                    route.push({ z: startZ + 5, x: startX + towardSideline * 1.5 });
                    route.push({ z: END_ZONE_BACK, x: startX + towardSideline * 2 });
                    break;

                case 'corner_fade':
                    // Quick move to corner of end zone
                    const cfX = Math.max(-7, Math.min(7, startX + towardSideline * 3));
                    route.push({ z: startZ + 2, x: cfX });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, cfX + towardSideline * 2)) });
                    break;

                case 'out_and_up':
                    // Fake out, then go vertical to end zone
                    const oauOutX = startX + towardSideline * 2;
                    route.push({ z: startZ + 2, x: oauOutX });
                    route.push({ z: END_ZONE_BACK, x: oauOutX });
                    break;

                // === RED ZONE ROUTES ===
                case 'corner':
                    // Break toward corner of end zone - break at 3-5 yards, go to back corner
                    const cornerBreak = startZ + 3 + Math.random() * 2;
                    const cornerX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: cornerBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: cornerX });
                    break;

                case 'comeback_corner':
                    // Go 4-5 yards, comeback, then break to corner and go to end zone
                    const ccBreak = startZ + 4 + Math.random();
                    route.push({ z: ccBreak, x: startX });
                    route.push({ z: ccBreak - 1, x: startX });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + towardSideline * 4)) });
                    break;

                // === STANDARD ROUTES ===
                case 'go':
                case 'fade':
                    // Straight up the field with slight fade - go to back of end zone
                    const fadeAmount = towardSideline * (1 + Math.random() * 2);
                    route.push({ z: startZ + 8, x: startX + fadeAmount * 0.3 });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + fadeAmount)) });
                    break;

                case 'slant':
                    // Quick slant across the middle - break at 2-3 yards, then go deep
                    const slantBreak = startZ + 2 + Math.random() * 1;
                    const slantX = startX + towardMiddle * (5 + Math.random() * 3);
                    route.push({ z: slantBreak, x: startX });
                    route.push({ z: slantBreak + 5, x: Math.max(-5, Math.min(5, slantX)) });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-5, Math.min(5, slantX)) });
                    break;

                case 'out':
                    // Break to sideline - break at 3-5 yards, then continue deep
                    const outBreak = startZ + 3 + Math.random() * 2;
                    const outX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: outBreak, x: startX });
                    route.push({ z: outBreak + 1, x: outX });
                    route.push({ z: END_ZONE_BACK, x: outX });
                    break;

                case 'post':
                    // Break toward the goalpost - break at 4-6 yards, go to back of end zone
                    const postBreak = startZ + 4 + Math.random() * 2;
                    route.push({ z: postBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: towardMiddle * (2 + Math.random() * 2) });
                    break;

                case 'dig':
                case 'crossing':
                    // Cross route - break at 4-6 yards then go deep
                    const digBreak = startZ + 4 + Math.random() * 2;
                    const digEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (8 + Math.random() * 4)));
                    route.push({ z: digBreak, x: startX });
                    route.push({ z: digBreak + 2, x: digEndX });
                    route.push({ z: END_ZONE_BACK, x: digEndX });
                    break;

                case 'seam':
                    // Straight up the seam - slight angle at 3 yards, go deep
                    const seamTarget = startX > 0 ? 3 : -3;  // Stay in seam
                    route.push({ z: startZ + 3, x: (startX + seamTarget) / 2 });
                    route.push({ z: startZ + 10, x: seamTarget });
                    route.push({ z: END_ZONE_BACK, x: seamTarget });
                    break;

                case 'curl':
                case 'comeback':
                    // Run up 5-7 yards, curl back toward QB, then cross horizontally to opposite sideline
                    const curlDepth = startZ + 5 + Math.random() * 2;
                    const oppositeSideline = startX > 0 ? -6 : 6;  // Go to opposite side of field
                    route.push({ z: curlDepth, x: startX });
                    route.push({ z: curlDepth - 2, x: startX + towardMiddle * 1 });  // Curl back
                    route.push({ z: curlDepth - 1, x: oppositeSideline });  // Cross horizontally to other sideline
                    break;

                default:
                    // Fallback: simple go route to end zone
                    route.push({ z: startZ + 8, x: startX });
                    route.push({ z: END_ZONE_BACK, x: startX });
            }

            // Ensure all route points move forward (no backwards routes)
            let lastZ = startZ;
            route.forEach(point => {
                if (point.z < lastZ) {
                    point.z = lastZ + 0.5;  // Force forward movement
                }
                lastZ = point.z;
                // Clamp to field boundaries
                point.z = Math.min(point.z, END_ZONE_BACK);
                point.x = Math.max(-SIDELINE, Math.min(SIDELINE, point.x));
            });

            // Post-process: ensure routes extend into end zone if close enough
            if (route.length > 0) {
                const lastPoint = route[route.length - 1];
                const distToEndZone = END_ZONE_Z - lastPoint.z;

                // If within 8 yards of end zone and route doesn't reach it, extend
                if (distToEndZone > 0 && distToEndZone < 8) {
                    route.push({
                        z: Math.min(END_ZONE_Z + 2, END_ZONE_BACK),
                        x: lastPoint.x
                    });
                }

                // If route ends near sideline, add crossing waypoint back toward middle
                // But only if we're still in the first 15 yards of the route (not in end zone)
                const finalPoint = route[route.length - 1];
                const routeDepth = finalPoint.z - startZ;  // How far into the route
                if (Math.abs(finalPoint.x) > 6 && routeDepth < 15 && finalPoint.z < END_ZONE_Z - 2) {
                    const crossDirection = finalPoint.x > 0 ? -1 : 1;  // Cross toward middle
                    route.push({
                        z: Math.min(finalPoint.z + 2, END_ZONE_BACK),
                        x: finalPoint.x + crossDirection * 4  // Cross 4 yards toward middle
                    });
                }
            }

            receiver.route = route;

            // Update route line visual
            if (receiver.routeLine) {
                receiver.routeLine.dispose();
            }

            const routePoints = [receiver.startPos.clone()];
            routePoints[0].y = 0.05;
            route.forEach(point => {
                routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
            });

            // Need to access scene - store reference on gameState
            if (gameState.scene && gameState.routeMaterial) {
                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + receiver.name, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, gameState.scene);
                routeLine.material = gameState.routeMaterial;
                receiver.routeLine = routeLine;
            }
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');
            clearThrowHeatMap();

            // Capture receiver positions, velocities, speeds, and momentum at throw time for rating calculation
            gameState.receiverVelocitiesAtThrow = {};
            gameState.receiverPositionsAtThrow = {};
            gameState.receiverSpeedsAtThrow = {};
            gameState.receiverMomentumAtThrow = {};
            gameState.receivers.forEach(receiver => {
                gameState.receiverVelocitiesAtThrow[receiver.name] = receiver.velocity ? receiver.velocity.clone() : new BABYLON.Vector3(0, 0, 0);
                gameState.receiverPositionsAtThrow[receiver.name] = receiver.position.clone();
                // Capture current speed (includes any active boost)
                gameState.receiverSpeedsAtThrow[receiver.name] = receiver.speed || receiver.baseSpeed;
                // Capture runMomentum (smoothed 0-1 value indicating if at full running speed)
                gameState.receiverMomentumAtThrow[receiver.name] = receiver.runMomentum || 0;
            });
            gameState.throwStartTime = performance.now();

            // Record throw attempt for QB
            if (scene.qb && scene.qb.playerId) {
                const qbStats = gameStats.getPlayer(scene.qb.playerId, scene.qb.displayName || 'QB');
                qbStats.throwDistances.push(throwParams.distance);
                qbStats.airDistances.push(throwParams.distance * throwParams.power);
                gameState.currentThrowQbId = scene.qb.playerId;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            // Catch radius scales with catching stat: 0.8 at 50, 1.2 at 75, 1.8 at 100
            const baseCatchRadius = 1.2;

            let frameIndex = 0;
            // Ball flight speed - short throws faster, long throws slower for arc visibility
            // Short throws: quick (2.3), long throws: slower (0.7)
            // Apply ball speed multiplier from training settings
            const baseAnimationSpeed = 2.3 - (throwParams.power * 1.6);
            const animationSpeed = baseAnimationSpeed * gameState.ballSpeedMultiplier;
            let accumulator = 0;
            const time = { value: 0 };

            // Spiral rotation tracking - fast visible spin for tight spiral effect
            let spiralAngle = 0;
            const spiralSpeed = 45 + (throwParams.power * 25);  // Fast visible spiral, increases with power

            // Create trail effect for ball
            const trailParticles = [];
            const trailMaterial = new BABYLON.StandardMaterial('trailMat', scene);
            trailMaterial.diffuseColor = new BABYLON.Color3(1, 0.8, 0.3);
            trailMaterial.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            trailMaterial.alpha = 0.8;
            let lastTrailPos = null;
            const trailSpacing = 0.3; // Distance between trail particles

            // Create target circle at landing position (torus is horizontal by default in XZ plane)
            const targetCircle = BABYLON.MeshBuilder.CreateTorus('targetCircle', {
                diameter: 1.5,
                thickness: 0.15,
                tessellation: 32
            }, scene);
            targetCircle.position = new BABYLON.Vector3(landingPos.x, 0.05, landingPos.z);
            // No rotation needed - torus is already in XZ plane (horizontal)
            const targetMaterial = new BABYLON.StandardMaterial('targetMat', scene);
            targetMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0.3);
            targetMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
            targetMaterial.alpha = 0.7;
            targetCircle.material = targetMaterial;

            // Find closest receiver to ball landing and show optimal lead marker
            let optimalLeadMarker = null;
            let closestReceiver = null;
            let closestDist = Infinity;
            gameState.receivers.forEach(receiver => {
                const pos = gameState.receiverPositionsAtThrow[receiver.name];
                if (pos) {
                    const dist = Math.sqrt(
                        Math.pow(landingPos.x - pos.x, 2) +
                        Math.pow(landingPos.z - pos.z, 2)
                    );
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestReceiver = receiver;
                    }
                }
            });

            if (closestReceiver) {
                const throwPos = gameState.receiverPositionsAtThrow[closestReceiver.name];
                const throwVel = gameState.receiverVelocitiesAtThrow[closestReceiver.name];
                // Velocity is per-frame, convert to per-second by multiplying by 60
                const velPerSec = { x: throwVel.x * 60, z: throwVel.z * 60 };
                const velMag = Math.sqrt(velPerSec.x * velPerSec.x + velPerSec.z * velPerSec.z);

                if (velMag > 0.1) {
                    // Estimate flight time in seconds
                    const estFlightTime = path.length / (60 * animationSpeed);
                    // Ideal lead = where receiver will be at catch time (with 0.8 factor for catching room)
                    const idealLead = velMag * estFlightTime * 0.8;

                    // Optimal position = throw position + velocity direction * ideal lead
                    const optimalX = throwPos.x + (velPerSec.x / velMag) * idealLead;
                    const optimalZ = throwPos.z + (velPerSec.z / velMag) * idealLead;

                    // Create white X marker using two crossed cylinders
                    const xSize = 0.8;
                    const xThickness = 0.12;
                    const bar1 = BABYLON.MeshBuilder.CreateCylinder('optBar1', {
                        height: xSize, diameter: xThickness
                    }, scene);
                    const bar2 = BABYLON.MeshBuilder.CreateCylinder('optBar2', {
                        height: xSize, diameter: xThickness
                    }, scene);

                    // Rotate to form X shape lying flat on field
                    bar1.rotation.x = Math.PI / 2;
                    bar1.rotation.y = Math.PI / 4;
                    bar2.rotation.x = Math.PI / 2;
                    bar2.rotation.y = -Math.PI / 4;

                    bar1.position = new BABYLON.Vector3(optimalX, 0.08, optimalZ);
                    bar2.position = new BABYLON.Vector3(optimalX, 0.08, optimalZ);

                    const optimalMat = new BABYLON.StandardMaterial('optimalMat', scene);
                    optimalMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                    optimalMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                    bar1.material = optimalMat;
                    bar2.material = optimalMat;

                    optimalLeadMarker = { bar1, bar2 };
                }
            }

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path for proper orientation
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity (nose follows arc)
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Tight spiral rotation around the ball's long axis
                    spiralAngle += dt * spiralSpeed;
                    football.rotation.z = spiralAngle;

                    // Add trail particles
                    const currentPos = football.position.clone();
                    if (!lastTrailPos || BABYLON.Vector3.Distance(currentPos, lastTrailPos) > trailSpacing) {
                        const trailSphere = BABYLON.MeshBuilder.CreateSphere('trail', { diameter: 0.15, segments: 4 }, scene);
                        trailSphere.position = currentPos.clone();
                        trailSphere.material = trailMaterial;
                        trailParticles.push({ mesh: trailSphere, alpha: 0.8, createdAt: time.value });
                        lastTrailPos = currentPos.clone();
                    }

                    // Fade and remove old trail particles
                    for (let i = trailParticles.length - 1; i >= 0; i--) {
                        const particle = trailParticles[i];
                        const age = time.value - particle.createdAt;
                        particle.alpha = Math.max(0, 0.8 - age * 2);
                        particle.mesh.visibility = particle.alpha;
                        if (particle.alpha <= 0) {
                            particle.mesh.dispose();
                            trailParticles.splice(i, 1);
                        }
                    }

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Don't expire speed boosts during ball flight - keep speed locked for accurate throw rating
                        // Speed boosts will expire after the catch/incompletion

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // Calculate effective speed (apply initial clash slowdown if no outcome yet)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;
                        }

                        // Check if route is complete
                        const routeComplete = !receiver.route || receiver.routeIndex >= receiver.route.length;

                        // Calculate this receiver's catch radius based on catching stat
                        // Scales from 0.8 at 50 catching to 1.8 at 100 catching
                        const receiverCatchRadius = 0.8 + ((receiver.stats.catching - 50) / 50) * 1.0;

                        // Larger adjustment range so receivers can adjust to the ball
                        const adjustmentRange = Math.max(5, receiverCatchRadius * 3);

                        // First priority: continue running route if not complete
                        if (!routeComplete) {
                            // Ball is close - adjust toward it instead of following route
                            if (distToLanding < adjustmentRange && frameIndex > 5) {
                                if (distToLanding > 0.3) {
                                    const catchAdjustSpeed = effectiveSpeed * 0.8;
                                    receiver.position.x += (dx / distToLanding) * catchAdjustSpeed;
                                    receiver.position.z += (dz / distToLanding) * catchAdjustSpeed;
                                    receiver.rotation.y = Math.atan2(dx, dz);
                                    // Moving at full speed - maintain momentum (no change)
                                } else {
                                    // Waiting at landing spot - decay momentum
                                    receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                                }
                            } else {
                                // Keep running the route (moveReceiverAlongRoute updates momentum)
                                moveReceiverAlongRoute(receiver, effectiveSpeed);
                            }
                        } else {
                            // Route complete - move toward ball landing spot
                            if (distToLanding > 0.3) {
                                receiver.position.x += (dx / distToLanding) * effectiveSpeed;
                                receiver.position.z += (dz / distToLanding) * effectiveSpeed;
                                receiver.rotation.y = Math.atan2(dx, dz);
                                // Moving at full speed - maintain momentum (no change)
                            } else {
                                // Waiting at landing spot - decay momentum
                                receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                            }
                        }

                        // Apply momentum-based forward lean
                        receiver.rotation.x = (receiver.runMomentum || 0) * 0.25;

                        // Running animation (bob only, tilt handled by momentum system)
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Calculate effective speed with catch-up boost
                        let effectiveSpeed = defender.speed;
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running animation (bob only, tilt handled by momentum system)
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                    });

                    // Move linemen during ball flight (battle continues!)
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            return;
                        }
                        moveOLineman(oLineman);
                        oLineman.position.y = Math.abs(Math.sin(time.value * 4 + i * 0.5)) * 0.03;
                    });

                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            return;
                        }
                        moveDLineman(dLineman);
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        dLineman.position.y = Math.abs(Math.sin(time.value * (isRushing ? 8 : 4) + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes during ball flight
                    processLineClashes();

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    // Clean up trail particles, target circle, and optimal lead marker
                    trailParticles.forEach(p => p.mesh.dispose());
                    trailParticles.length = 0;
                    trailMaterial.dispose();
                    targetCircle.dispose();
                    targetMaterial.dispose();
                    if (optimalLeadMarker) {
                        optimalLeadMarker.bar1.dispose();
                        optimalLeadMarker.bar2.dispose();
                    }
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            let potentialCatcher = null;
            let closestDistance = Infinity;
            let catcherRadius = 1.2;  // Default

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                // Each receiver's catch radius depends on their catching stat
                // Scales from 0.8 at 50 catching to 1.8 at 100 catching
                const receiverCatchRadius = 0.8 + ((receiver.stats.catching - 50) / 50) * 1.0;

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                // Check if within this receiver's catch radius and closer than others
                if (distance < receiverCatchRadius && distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                    catcherRadius = receiverCatchRadius;
                }
            }

            if (potentialCatcher) {
                // Calculate throw rating first (need lead score for catch probability)
                const throwRating = calculateThrowRating(potentialCatcher, ballPosition, gameState.gameTime);

                // Calculate throw distance (from QB to ball) and accuracy
                const throwDistance = scene.qb ? BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(scene.qb.position.x, 0, scene.qb.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                ) : 10;
                const throwAccuracyMult = calculateThrowAccuracy(scene.qb, throwDistance);

                // Calculate catch probability (returns detailed info) - pass slowdown score (momentum-based) for lead bonus
                const catchInfo = calculateCatchProbability(potentialCatcher, ballPosition, throwRating.slowdownScore, throwAccuracyMult);
                const catchRoll = Math.random() * 100;
                const success = catchRoll < catchInfo.probability;

                // Track attempt
                gameState.attempts++;

                // Record target for roster player
                recordPlayerStat(potentialCatcher, 'seasonTargets');

                // Show the catch probability display with throw rating
                showCatchDisplay(catchInfo, catchRoll, success, throwRating);

                // Store catch info for game mode popup
                gameState.lastCatchInfo = catchInfo;
                gameState.lastCatchRoll = catchRoll;
                gameState.lastCatchSuccess = success;

                // Record per-game catch stats
                if (potentialCatcher.playerId) {
                    const pStats = gameStats.getPlayer(potentialCatcher.playerId, potentialCatcher.displayName);
                    pStats.catchDifficulties.push(catchInfo.probability);
                    if (success) {
                        pStats.catches++;
                    } else {
                        pStats.drops++;
                    }
                }

                // Record QB completion/incompletion
                if (gameState.currentThrowQbId) {
                    const qbStats = gameStats.getPlayer(gameState.currentThrowQbId, 'QB');
                    if (success) {
                        qbStats.completions++;
                    } else {
                        qbStats.incompletions++;
                    }
                }

                // In training mode, show throw rating
                if (gameState.trainingMode) {
                    gameState.lastThrowRating = throwRating;

                    // Update throw rating UI
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');

                    const gradeColors = {
                        'A+': '#0f0', 'A': '#4f4', 'B': '#af4',
                        'C': '#ff4', 'D': '#f84', 'F': '#f44'
                    };

                    gradeEl.textContent = throwRating.grade;
                    gradeEl.style.color = gradeColors[throwRating.grade] || '#fff';

                    // Build detailed breakdown for training feedback
                    detailsEl.textContent = throwRating.details;

                    // Build modifier list with right-aligned values and color coding
                    const modList = document.getElementById('popupModifierList');

                    // Helper to create a modifier row
                    const makeRow = (label, value, isPositive) => {
                        const color = isPositive ? '#4f4' : '#f66';
                        const sign = isPositive ? '+' : '';
                        return `<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#aaa;">${label}</span>
                            <span style="color:${color}; font-weight:bold;">${sign}${value}</span>
                        </div>`;
                    };

                    let modRows = [];

                    // === 1. BASE CATCH RATE ===
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#fff;">Base catch rate:</span>
                        <span style="color:#8f8; font-weight:bold;">${Math.round(catchInfo.wideOpenRate)}%</span>
                    </div>`);
                    modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                        catching: ${catchInfo.baseCatch}
                    </div>`);

                    // === 2. COVERAGE PENALTY ===
                    if (catchInfo.isContested && catchInfo.dbPenalty > 0) {
                        const sepYards = catchInfo.separation.toFixed(1);
                        // Find the closest defender's coverage stat
                        const defCoverage = catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0
                            ? catchInfo.defenderDetails[0].coverageStat : 0;
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Coverage penalty:</span>
                            <span style="color:#f66; font-weight:bold;">-${catchInfo.dbPenalty}%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            separation: ${sepYards}, coverage: ${defCoverage}
                        </div>`);
                    }

                    // === 3. LEAD BONUS ===
                    const momentumScore = throwRating.slowdownScore || 100;
                    const momentumLabel = momentumScore >= 90 ? 'in stride' : momentumScore >= 70 ? 'adjusted' : 'slowed down';
                    if (catchInfo.shoulderBonusSaved > 0) {
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Lead bonus:</span>
                            <span style="color:#4a4; font-weight:bold;">+${catchInfo.shoulderBonusSaved}%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            ${momentumLabel} (${Math.round(momentumScore)}% momentum)
                        </div>`);
                    } else if (catchInfo.isContested) {
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Lead bonus:</span>
                            <span style="color:#666;">0%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            ${momentumLabel} (${Math.round(momentumScore)}% momentum)
                        </div>`);
                    }

                    // === DIVIDER ===
                    modRows.push(`<div style="border-top: 1px solid #444; margin: 8px 0;"></div>`);

                    // === 4. FINAL CATCH RATE ===
                    const finalColor = catchInfo.probability >= 50 ? '#4f4' : (catchInfo.probability >= 25 ? '#ff4' : '#f66');
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#fff; font-weight:bold;">Final catch rate:</span>
                        <span style="color:${finalColor}; font-weight:bold; font-size: 16px;">${Math.round(catchInfo.probability)}%</span>
                    </div>`);

                    modList.innerHTML = modRows.join('');

                    // Update visual catch bar in popup
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBase = document.getElementById('popupCatchBase');
                    const popupPenalty = document.getElementById('popupCatchPenalty');
                    const popupRoll = document.getElementById('popupCatchRoll');

                    popupHeader.textContent = success ? 'CATCH!' : 'DROPPED';
                    popupHeader.style.color = success ? '#4f4' : '#f66';

                    // Show wide open rate as base, with penalty overlay
                    const baseWidth = catchInfo.isContested ? catchInfo.wideOpenRate : catchInfo.wideOpenRate;
                    const penaltyWidth = Math.max(0, catchInfo.wideOpenRate - catchInfo.probability);

                    popupBase.style.width = `${baseWidth}%`;

                    if (penaltyWidth > 0) {
                        popupPenalty.style.display = 'block';
                        popupPenalty.style.left = `${catchInfo.probability}%`;
                        popupPenalty.style.width = `${penaltyWidth}%`;
                    } else {
                        popupPenalty.style.display = 'none';
                    }

                    popupRoll.textContent = 'üèà';
                    popupRoll.style.filter = success ? 'none' : 'grayscale(100%)';
                    popupRoll.style.left = `${catchRoll}%`;

                    // Only show popup if setting is enabled
                    if (gameState.showGradePopup) {
                        ratingEl.style.display = 'block';

                        // Dismiss on any click anywhere on screen
                        const dismissPopup = () => {
                            ratingEl.style.display = 'none';
                            document.removeEventListener('click', dismissPopup);
                            document.removeEventListener('touchstart', dismissPopup);
                        };
                        // Small delay to prevent immediate dismissal from the same click
                        setTimeout(() => {
                            document.addEventListener('click', dismissPopup);
                            document.addEventListener('touchstart', dismissPopup);
                        }, 100);
                    }
                }

                if (success) {
                    // Successful catch! Set up ball carrier
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}! RUN!`);

                    // Record catch for roster player
                    recordPlayerStat(potentialCatcher, 'seasonCatches');

                    // Store catch position for YAC tracking
                    potentialCatcher.catchPosition = potentialCatcher.position.z;

                    // Attach ball to receiver
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    // Set up ball carrier state - play continues!
                    gameState.ballCarrier = potentialCatcher;
                    potentialCatcher.breakTackleBoostUntil = 0;

                    // Clean up any speed effects that expired during ball flight
                    cleanupExpiredSpeedEffects();

                    // Start the run-after-catch phase
                    startRunAfterCatch(scene);
                } else {
                    // Dropped or defended - incomplete pass
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    handleIncomplete(wasDefended ? 'Pass defended' : 'Dropped');
                    updateScore();
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');

                    // Clean up any speed effects that expired during ball flight
                    cleanupExpiredSpeedEffects();

                    // Record pass defended for nearest defender if it was defended
                    if (wasDefended) {
                        let closestDefender = null;
                        let closestDist = Infinity;
                        for (const def of gameState.defenders) {
                            const dist = BABYLON.Vector3.Distance(def.position, potentialCatcher.position);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestDefender = def;
                            }
                        }
                        if (closestDefender) {
                            recordPlayerStat(closestDefender, 'seasonPassesDefended');
                            // Record per-game pass defended
                            if (closestDefender.playerId) {
                                gameStats.getPlayer(closestDefender.playerId, closestDefender.displayName).passesDefended++;
                            }
                        }
                    }

                    bounceBall(scene, ballPosition);
                }
            } else {
                // No receiver nearby - incomplete pass
                handleIncomplete('Overthrown');
                updateMessage('Incomplete...');

                // In training mode, show incomplete grade (if popup enabled)
                if (gameState.trainingMode && gameState.showGradePopup) {
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBar = document.getElementById('popupCatchBar');
                    const modList = document.getElementById('popupModifierList');

                    gradeEl.textContent = 'INCOMPLETE';
                    gradeEl.style.color = '#f66';
                    gradeEl.style.fontSize = '32px';
                    detailsEl.textContent = 'No receiver in range';

                    popupHeader.textContent = '';
                    popupBar.style.display = 'none';
                    modList.innerHTML = '';

                    ratingEl.style.display = 'block';

                    // Dismiss on any click anywhere on screen
                    const dismissPopup = () => {
                        ratingEl.style.display = 'none';
                        gradeEl.style.fontSize = '48px'; // Reset font size
                        popupBar.style.display = 'block'; // Reset bar visibility
                        document.removeEventListener('click', dismissPopup);
                        document.removeEventListener('touchstart', dismissPopup);
                    };
                    // Small delay to prevent immediate dismissal from the same click
                    setTimeout(() => {
                        document.addEventListener('click', dismissPopup);
                        document.addEventListener('touchstart', dismissPopup);
                    }, 100);
                }

                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Start the run-after-catch phase with animation loop
        const startRunAfterCatch = (scene) => {
            const timeSinceCatch = { value: 0 };

            const runAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                timeSinceCatch.value += dt;
                gameState.gameTime = performance.now() * 0.001;

                // Check if play has ended
                if (gameState.playEnded) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                const ballCarrier = gameState.ballCarrier;
                if (!ballCarrier) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                // Move ball carrier
                moveBallCarrier(ballCarrier);

                // Running animation for ball carrier (bob only, tilt handled by momentum system)
                ballCarrier.position.y = Math.abs(Math.sin(timeSinceCatch.value * 10)) * 0.1;

                // Calculate pursuit boost based on time since catch
                // After 1 second: 10% boost, after 2 seconds: 20% boost
                let pursuitBoost = 1.0;
                if (timeSinceCatch.value >= 2.0) {
                    pursuitBoost = 1.2;  // 20% boost after 2 seconds
                } else if (timeSinceCatch.value >= 1.0) {
                    // Interpolate from 10% to 20% between 1 and 2 seconds
                    const t = timeSinceCatch.value - 1.0;  // 0 to 1
                    pursuitBoost = 1.1 + (t * 0.1);  // 1.1 to 1.2
                }

                // Move all defenders in pursuit with speed boost
                gameState.defenders.forEach((defender, i) => {
                    if (defender.knockdownUntil <= gameState.gameTime) {
                        moveDefenderPursuit(defender, pursuitBoost);

                        // Running animation (bob only, tilt handled by momentum system)
                        const animSpeed = 10 + (pursuitBoost - 1.0) * 20;
                        defender.position.y = Math.abs(Math.sin(timeSinceCatch.value * animSpeed + i)) * 0.08;
                    }
                });

                // Process tackle attempts
                processTackles();
            });
        };

        // Calculate QB throw accuracy based on distance
        // Uses agility √ó (shortPassAcc or longPassAcc) multiplicatively
        // Returns multiplier for lead bonus: 1.2 at 100, 1.0 at 80, 0.8 at 70, 0.7 at 60
        const calculateThrowAccuracy = (qb, throwDistance) => {
            if (!qb || !qb.stats) return 1.0;

            const agility = qb.coreAttributes?.agility || qb.stats.agility || 70;

            // Use short pass accuracy for <12 yards, long pass for 12+ yards
            const isShortPass = throwDistance < 12;
            const passAccStat = isShortPass
                ? (qb.stats.shortPassAcc || qb.stats.throwing || 70)
                : (qb.stats.longPassAcc || qb.stats.throwing || 70);

            // Multiplicative: (agility/100) √ó (passAcc/100) ‚Üí normalized 0-1
            const accuracy = (agility / 100) * (passAccStat / 100) * 100;

            // Scale to lead bonus multiplier:
            // 100 ‚Üí 1.2, 80 ‚Üí 1.0, 70 ‚Üí 0.8, 60 ‚Üí 0.7
            // Linear interpolation between these points
            if (accuracy >= 80) {
                // 80-100 maps to 1.0-1.2
                return 1.0 + (accuracy - 80) / 100;
            } else if (accuracy >= 70) {
                // 70-80 maps to 0.8-1.0
                return 0.8 + (accuracy - 70) / 50;
            } else {
                // 60-70 maps to 0.7-0.8, below 60 caps at 0.7
                return Math.max(0.7, 0.7 + (accuracy - 60) / 100);
            }
        };

        // Calculate catch probability based on receiver stats and proximity to defenders
        // NEW SIMPLIFIED FORMULA:
        // baseCatchRate = (catching - 50) √ó 2 + 20  -> 70‚Üí60%, 80‚Üí80%, 90‚Üí100%
        // dbPenalty = dbCoverage √ó 0.7 √ó proximity¬≤
        // leadBonus = up to 50% reduction of DB penalty based on momentum (slowdownScore)
        // finalRate = baseCatchRate - effectiveDbPenalty
        const calculateCatchProbability = (receiver, ballPosition, momentumScore = 50, throwAccuracyMultiplier = 1.0) => {
            const catchingStat = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            // Find closest defender and check for shoulder throw
            let closestDefenderDist = coverageRange;
            let closestDefenderCoverage = 0;
            let hasSideBonus = false;
            let hasNearbyDefender = false;
            let defenderDetails = [];

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;

                    // Get defender's coverage stat
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;

                    // Check if this is the closest defender
                    if (dist < closestDefenderDist) {
                        closestDefenderDist = dist;
                        closestDefenderCoverage = coverageStat;
                    }

                    // Check for shoulder throw (ball on opposite side from defender)
                    const ballDx = ballPosition.x - receiver.position.x;
                    const ballDz = ballPosition.z - receiver.position.z;
                    const dotProduct = dx * ballDx + dz * ballDz;
                    const isShoulder = dotProduct < 0;
                    if (isShoulder) hasSideBonus = true;

                    defenderDetails.push({
                        name: defender.name,
                        dist: dist.toFixed(2),
                        coverageStat: coverageStat,
                        aiType: defender.aiType,
                        sideBonus: isShoulder
                    });
                }
            });

            // BASE CATCH RATE: catching stat determines your potential
            // 70 catch ‚Üí 70%, 80 catch ‚Üí 95%, 90 catch ‚Üí 120%, 100 catch ‚Üí 145%
            // Not capped - high catching can exceed 100% to better absorb DB penalty
            const baseCatchRate = (catchingStat - 50) * 2.5 + 20;

            // WIDE OPEN: no nearby defender (cap at 98% for actual probability)
            if (!hasNearbyDefender) {
                return {
                    probability: Math.min(98, baseCatchRate),
                    baseCatch: catchingStat,
                    wideOpenRate: baseCatchRate,
                    separation: coverageRange,
                    coverageLevel: 'Wide Open',
                    isContested: false,
                    hasSideBonus: false,
                    shoulderBonusSaved: 0,
                    leadQuality: 0,
                    dbPenalty: 0,
                    defenderDetails: []
                };
            }

            // DB PENALTY: coverage stat √ó proximity¬≤
            // proximity: 1.0 at distance 0, 0.0 at max range
            const proximityFactor = Math.max(0, 1 - (closestDefenderDist / coverageRange));
            const tightCoverageBonus = closestDefenderDist <= 0.7 ? 1.2 : 1.0;  // +20% penalty for tight coverage
            const rawDbPenalty = closestDefenderCoverage * 1.5 * proximityFactor * proximityFactor * tightCoverageBonus;

            // LEAD BONUS: reduces DB penalty based on momentum and throw accuracy
            // Base reduction up to 50%, scaled by QB throw accuracy (0.7x to 1.2x)
            let leadReduction = 0;
            let leadBonusSaved = 0;
            if (hasSideBonus) {
                const baseLeadReduction = (momentumScore / 100) * 0.5;  // 0 to 0.5
                leadReduction = baseLeadReduction * throwAccuracyMultiplier;  // Scale by accuracy
                leadBonusSaved = Math.round(rawDbPenalty * leadReduction);
            }
            const effectiveDbPenalty = rawDbPenalty * (1 - leadReduction);

            // FINAL PROBABILITY
            const finalProbability = Math.max(5, Math.min(98, baseCatchRate - effectiveDbPenalty));

            // Determine coverage level for display
            let coverageLevel = 'Wide Open';
            if (closestDefenderDist <= 0.6) coverageLevel = 'Blanketed';
            else if (closestDefenderDist <= 1.5) coverageLevel = 'Tight Coverage';
            else if (closestDefenderDist <= 2.5) coverageLevel = 'Contested';
            else coverageLevel = 'Light Coverage';

            return {
                probability: finalProbability,
                baseCatch: catchingStat,
                wideOpenRate: baseCatchRate,
                separation: closestDefenderDist,
                coverageLevel: coverageLevel,
                isContested: true,
                hasSideBonus: hasSideBonus,
                shoulderBonusSaved: leadBonusSaved,
                leadQuality: Math.round(momentumScore),
                dbPenalty: Math.round(rawDbPenalty),
                effectiveDbPenalty: Math.round(effectiveDbPenalty),
                defenderDetails: defenderDetails
            };
        };

        // Show catch probability display
        const showCatchDisplay = (catchInfo, roll, success, throwRating = null) => {
            // Skip showing in training mode (catch info is in the popup instead)
            if (gameState.trainingMode) return;

            const display = document.getElementById('catchDisplay');
            const header = display.querySelector('.catch-header');
            const barBase = display.querySelector('.catch-bar-base');
            const barPenalty = display.querySelector('.catch-bar-penalty');
            const barRoll = display.querySelector('.catch-bar-roll');
            const defenderInfo = display.querySelector('.defender-info');
            const throwRatingInfo = display.querySelector('.throw-rating-info');

            // Set header
            header.textContent = success ? 'CATCH!' : 'DROPPED';
            header.className = 'catch-header ' + (success ? 'success' : 'fail');

            // Calculate raw catch % (base + focus, before defender penalty)
            const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
            const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

            // Set bar: green shows raw potential, dark overlay shows defender penalty
            barBase.style.width = `${rawCatch}%`;

            // Penalty overlay starts where final probability ends
            if (penaltyWidth > 0) {
                barPenalty.style.display = 'block';
                barPenalty.style.left = `${catchInfo.probability}%`;
                barPenalty.style.width = `${penaltyWidth}%`;
            } else {
                barPenalty.style.display = 'none';
            }

            // Roll marker with football icon
            barRoll.textContent = 'üèà';
            barRoll.className = 'catch-bar-roll ' + (success ? 'success' : 'fail');
            barRoll.style.filter = success ? 'none' : 'grayscale(100%)';
            barRoll.style.left = `${roll}%`;

            // Show defender distances only
            if (catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0) {
                const distances = catchInfo.defenderDetails
                    .filter(d => parseFloat(d.penalty) > 0.5)
                    .map(d => d.dist)
                    .join(', ');
                defenderInfo.textContent = distances ? distances + 'yd' : '';
            } else {
                defenderInfo.textContent = '';
            }

            // Show throw rating info if available
            if (throwRating) {
                throwRatingInfo.textContent = `${throwRating.grade} | Route: ${throwRating.distToRoute}yd off | Lead: ${throwRating.leadText || ''}`;
            } else {
                throwRatingInfo.textContent = '';
            }

            // Show display
            display.classList.add('visible');

            // Hide after 2.5 seconds
            setTimeout(() => {
                display.classList.remove('visible');
            }, 2500);
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;
            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Hide player labels when play starts
        const hidePlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 0;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });
            gameState.defenders.forEach(defender => {
                if (defender.nameLabel) {
                    defender.nameLabel.alpha = 0;
                }
            });
        };

        // Show player labels when play is frozen
        const showPlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 1;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 1;
                }
            });
            gameState.defenders.forEach(defender => {
                if (defender.nameLabel) {
                    defender.nameLabel.alpha = 1;
                }
            });
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset pointer/drag state to prevent desync issues
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragCurrent = null;
            gameState.activePointerId = null;
            gameState.canThrow = true;

            // Reset play state flags
            gameState.ballCarrier = null;
            gameState.playEnded = false;
            gameState.qbSacked = false;
            gameState.playFrozen = true;  // Freeze until player holds screen

            // Clear catch info from previous play
            gameState.lastCatchInfo = null;
            gameState.lastCatchRoll = null;
            gameState.lastCatchSuccess = null;

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Reset linemen
            resetOffensiveLine();
            resetDefensiveLine();

            // Reset QB position (relative to line of scrimmage, randomized depth behind it)
            const qbDepthBehindLine = 2 + Math.random() * 2;  // 2-4 yards behind LOS
            // Clamp QB Z position to stay on visible field (min -60 for own 35 start)
            const qbZ = Math.max(-60, gameState.lineOfScrimmage - qbDepthBehindLine);
            gameState.qbStartZ = qbZ;
            scene.qb.position.x = 0;
            scene.qb.position.z = qbZ;
            scene.qb.position.y = 0;
            scene.qb.rotation.x = 0;
            scene.qb.rotation.y = 0;

            // Update field position markers
            if (scene.losLine) {
                scene.losLine.position.z = gameState.lineOfScrimmage;
            }
            if (scene.firstDownLine) {
                scene.firstDownLine.position.z = gameState.firstDownMarker;
            }

            // Move camera to follow the line of scrimmage
            if (scene.activeCamera) {
                const camera = scene.activeCamera;

                // Target centered on the line of scrimmage
                // Allow camera to follow full field from own 35 (-60) to end zone (Z = 14)
                const cameraTargetZ = Math.max(-60, Math.min(14, gameState.lineOfScrimmage + 2));
                camera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);

                // Reset camera to current view mode settings (alpha, beta, radius)
                switch(gameState.currentView) {
                    case 'iso':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                        break;
                    case 'overhead':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = 0.1;
                        camera.radius = 28;
                        break;
                    case 'shoulder':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 2.5;
                        camera.radius = 18;
                        break;
                    default:
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                }
            }

            // Update down and distance display
            updateDownDistance();

            // Show player labels while frozen
            showPlayerLabels();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Hold to start play');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            const scoreEl = document.getElementById('score');
            scoreEl.querySelector('.catches').textContent = `${gameState.catches}/${gameState.attempts}`;
            scoreEl.querySelector('.touchdowns').textContent = gameState.touchdowns;
        };

        const updateDownDistance = () => {
            const ddEl = document.getElementById('downDistance');
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const downText = downNames[gameState.down - 1] || '4th';

            // Calculate yards to go (convert Z units to approximate yards - roughly 1 unit = 1 yard)
            const yardsToGo = Math.max(1, Math.round(gameState.yardsToGo));
            const distanceText = yardsToGo >= 10 ? '10+' : yardsToGo.toString();

            // Calculate field position (yards from end zone)
            // lineOfScrimmage goes from about -8 (own goal line) to 11 (opponent end zone)
            // Convert to standard field position (own 1-50, then opponent 49-1)
            const END_ZONE_Z = 11;
            const yardsFromGoal = Math.round(END_ZONE_Z - gameState.lineOfScrimmage);
            let fieldPosText = '';
            if (yardsFromGoal <= 0) {
                fieldPosText = 'GOAL';
            } else if (yardsFromGoal <= 50) {
                // In opponent territory or at midfield
                fieldPosText = yardsFromGoal === 50 ? 'MID' : `OPP ${yardsFromGoal}`;
            } else {
                // In own territory
                const ownYardLine = 100 - yardsFromGoal;
                fieldPosText = `OWN ${ownYardLine}`;
            }

            ddEl.querySelector('.down').textContent = downText;
            ddEl.querySelector('.distance').textContent = distanceText;
            ddEl.querySelector('.field-pos').textContent = fieldPosText;
        };

        const updateMessage = (msg) => {
            // Message display removed
        };

        // Update debug info display
        const updateDebugInfo = () => {
            if (!FEATURE_FLAGS.showDebugInfo) {
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            document.getElementById('debugInfo').style.display = 'block';

            let debugText = '=== RECEIVER STATUS ===\n';
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.receivers.forEach((receiver, i) => {
                // Find closest defender
                let closestDef = null;
                let closestDist = Infinity;
                gameState.defenders.forEach(def => {
                    if (def.knockdownUntil > gameState.gameTime) return;
                    const dx = def.position.x - receiver.position.x;
                    const dz = def.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestDef = def;
                    }
                });

                const timeSinceClash = (gameState.gameTime - receiver.lastClashTime).toFixed(1);
                const speedMod = (receiver.speed / receiver.baseSpeed * 100).toFixed(0);
                const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                const catchProb = receiver.currentCatchProb || receiver.stats.catching;

                // Determine coverage level based on catch probability
                let coverageLevel = 'OPEN';
                let levelColor = 'üü¢';
                if (catchProb < 40) {
                    coverageLevel = 'COVERED';
                    levelColor = 'üî¥';
                } else if (catchProb < 70) {
                    coverageLevel = 'CONTESTED';
                    levelColor = 'üü°';
                }

                debugText += `\n${receiver.displayName}:\n`;
                debugText += `  ${levelColor} Catch: ${catchProb.toFixed(0)}% (${coverageLevel})\n`;
                debugText += `  Speed: ${speedMod}%${hasSpeedPenalty ? ' (SLOWED)' : ''}\n`;

                if (closestDef) {
                    const defSpeedPenalty = closestDef.clashSpeedPenaltyUntil > gameState.gameTime;
                    const defCovStat = closestDef.aiType === 'zone' ?
                        closestDef.stats.zoneCoverage : closestDef.stats.manCoverage;
                    debugText += `  Nearest: ${closestDef.displayName}`;
                    if (defSpeedPenalty) debugText += ' (SLOWED)';
                    debugText += `\n`;
                    debugText += `  Dist: ${closestDist.toFixed(1)}/${coverageRange.toFixed(1)}`;
                    debugText += ` | ${closestDef.aiType === 'zone' ? 'ZoneCov' : 'ManCov'}: ${defCovStat}\n`;
                }
            });

            document.getElementById('debugInfo').textContent = debugText;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only capture left-click (button 0) or single touch for throwing
                // Let right-click (button 2) and multi-touch pass through to camera
                if (evt.button !== 0 && evt.pointerType === 'mouse') return;

                // Unfreeze play when holding down (starts the play)
                if (gameState.playFrozen) {
                    gameState.playFrozen = false;
                    gameState.playStartTime = performance.now() * 0.001;
                    hidePlayerLabels();
                }

                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.activePointerId = evt.pointerId;  // Track which pointer is dragging
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
            };

            const onPointerMove = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only track the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only respond to the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.activePointerId = null;

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                if (gameState.dragStart && gameState.dragCurrent) {
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                // Skip all game logic when in management mode
                if (!gameSceneActive) return;

                // Pause game during possession overlay
                if (gameState.waitingForPossession) return;

                // Freeze play until player holds screen
                if (gameState.playFrozen) return;

                const time = performance.now() * 0.001;

                // QB breathing/ready animation (only when not in danger)
                const qb = scene.qb;
                if (!gameState.playEnded && !gameState.qbSacked) {
                    // Only subtle breathing when not moving
                    const isEvading = gameState.defensiveLine.some(d =>
                        d.knockdownUntil <= gameState.gameTime &&
                        BABYLON.Vector3.Distance(d.position, qb.position) < POCKET_CONSTANTS.THREAT_RADIUS
                    );
                    if (!isEvading) {
                        qb.rotation.y = Math.sin(time * 2) * 0.05;
                        qb.position.y = Math.sin(time * 3) * 0.02;
                    } else {
                        qb.position.y = Math.abs(Math.sin(time * 8)) * 0.06;  // Running animation
                    }
                }

                // Track game time for clash system
                gameState.gameTime = time;

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Reset speed to base when boost/penalty expires
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate effective speed (slowdown during initial clash, unless clash outcome already applied)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash (only if no outcome yet)
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (receiver.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (receiver.clashTiltUntil - gameState.gameTime) / 0.5;
                            receiver.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                        // Show green while speed boosted, red while speed penalized
                        if (receiver.clashSpeedBoostUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const green = new BABYLON.Color3(0.2, 1.0, 0.3);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, green, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = green.scale(flashRate * 0.3);
                        } else if (receiver.clashSpeedPenaltyUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const red = new BABYLON.Color3(1.0, 0.2, 0.2);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, red, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = red.scale(flashRate * 0.3);
                        } else {
                            receiver.bodyMaterial.diffuseColor = receiver.originalColor;
                            receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
                        }
                    });

                    // Update throw heat map if enabled
                    if (gameState.showThrowHeatMap) {
                        updateThrowHeatMap();
                    }

                    // Route completion no longer triggers reset - play continues normally

                    // Move offensive linemen
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            oLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        oLineman.rotation.x = 0;

                        moveOLineman(oLineman);

                        // Subtle stance animation
                        oLineman.position.y = Math.abs(Math.sin(time * 4 + i * 0.5)) * 0.03;
                    });

                    // Move defensive linemen
                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            dLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        dLineman.rotation.x = 0;

                        moveDLineman(dLineman);

                        // Running animation when moving fast
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        const bobSpeed = isRushing ? 8 : 4;
                        dLineman.position.y = Math.abs(Math.sin(time * bobSpeed + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes
                    processLineClashes();

                    // Move QB (pocket behavior and evasion)
                    moveQB(scene);

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdowns and boosts from clashes)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }
                        if (defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.5;  // 50% slower after losing clash
                        }
                        // DB catch-up boost - kicks in after receiver's boost ends
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;  // 30% faster catch-up
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (bob only, tilt handled by momentum system)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (defender.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (defender.clashTiltUntil - gameState.gameTime) / 0.5;
                            defender.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();

                    // Name labels are hidden by hidePlayerLabels() when play starts
                    // No additional fade logic needed here
                }
            });
        };

        // Get zone colors based on catch probability (0-100%)
        // High catch % = green, medium = yellow, low = red
        const getZoneColorsByCatchProb = (catchProbability) => {
            if (catchProbability >= 70) {
                // Green - high catch chance
                return {
                    diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),
                    emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                };
            } else if (catchProbability >= 40) {
                // Yellow - moderate catch chance
                return {
                    diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                };
            } else {
                // Red - low catch chance
                return {
                    diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                };
            }
        };

        // Calculate real-time catch probability for a receiver (for visual display)
        const calculateRealtimeCatchProb = (receiver) => {
            const catchingStat = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;
            let totalDefenderInfluence = 0;
            let hasNearbyDefender = false;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / coverageRange);
                    let influence = proximityFactor * proximityFactor * (coverageStat / 100);
                    if (dist <= 0.6) influence *= 1.5;
                    totalDefenderInfluence += influence;
                }
            });

            totalDefenderInfluence = Math.min(1, totalDefenderInfluence);

            // Match the new catch system: wide open uses catching stat with bonus, contested 25-35%
            if (!hasNearbyDefender || totalDefenderInfluence < 0.1) {
                // Wide open: 60 catching = 80%, 80+ catching = 95% (capped)
                const wideOpenBase = 80 + (catchingStat - 60) * 0.75;
                return Math.min(95, wideOpenBase);
            } else {
                // 50 catching = 10%, 100 catching = 45%
                const contestedBase = 10;
                const catchingBonus = (catchingStat - 50) * 0.7;  // Catching now includes focus ability
                const defenderReduction = totalDefenderInfluence * 40;
                return Math.max(5, Math.min(95, contestedBase + catchingBonus - defenderReduction));
            }
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Calculate real-time catch probability
                const catchProb = calculateRealtimeCatchProb(receiver);
                receiver.currentCatchProb = catchProb;  // Store for debug display

                // Size based on catch probability (larger = higher catch %)
                const minScale = 0.3;  // Minimum size at 0% catch
                const maxScale = 1.2;  // Maximum size at 100% catch
                const catchFactor = catchProb / 100;  // 0-1
                const fillScale = minScale + (maxScale - minScale) * catchFactor;
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Keep white color, adjust alpha based on coverage for visibility
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                receiver.fillMaterial.alpha = 0.5;

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);
                    coveringDefender.fillMaterial.alpha = maxCoverage * 0.45;
                    coveringDefender.ringMaterial.alpha = 0.8;
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const tiltDuration = 0.5;   // seconds for grappling tilt
            const currentTime = gameState.gameTime;

            // Calculate tilt direction (towards each other)
            const dx = defender.position.x - receiver.position.x;
            const dz = defender.position.z - receiver.position.z;
            const angle = Math.atan2(dx, dz);

            // Both tilt towards each other during clash
            receiver.clashTiltUntil = currentTime + tiltDuration;
            receiver.clashTiltAngle = angle;  // Tilt towards defender
            defender.clashTiltUntil = currentTime + tiltDuration;
            defender.clashTiltAngle = angle + Math.PI;  // Tilt towards receiver (opposite)

            // Color is now controlled by speed effect timers (clashSpeedBoostUntil / clashSpeedPenaltyUntil)
            // No separate flash timer needed
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        // Uses coreAttributes for speed, agility, strength (merged stats)
        const weightedRoll = (stats, weights, coreAttributes = null) => {
            let weightedTotal = 0;
            const coreStats = ['speed', 'agility', 'strength'];
            for (const stat in weights) {
                let statValue;
                // Use coreAttributes for speed, agility, strength if available
                if (coreStats.includes(stat) && coreAttributes && coreAttributes[stat] !== undefined) {
                    statValue = coreAttributes[stat];
                } else {
                    statValue = stats[stat] || 50;  // Default to 50 if stat missing
                }
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (¬±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                // Track that they were far apart (for initial clash detection)
                if (!receiver.hasHadInitialClash) {
                    receiver.wasOutsideClashRange = true;
                }
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Cooldown - don't clash again too soon after a previous clash
            const CLASH_COOLDOWN = 2.0;  // seconds between clashes
            const timeSinceReceiverClash = currentTime - receiver.lastClashTime;
            const timeSinceDefenderClash = currentTime - defender.lastClashTime;
            if (timeSinceReceiverClash < CLASH_COOLDOWN || timeSinceDefenderClash < CLASH_COOLDOWN) {
                return { trigger: false, reason: 'cooldown' };
            }

            // Initial contact - only trigger if they were previously apart
            // This prevents clashes from happening immediately at play start
            if (!receiver.hasHadInitialClash) {
                if (receiver.wasOutsideClashRange) {
                    return { trigger: true, reason: 'initial_contact' };
                }
                return { trigger: false, reason: 'not_yet_separated' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            // Zone defenders get a small bonus from awareness instead of general coverage
            if (defender.aiType === 'zone') {
                defenderWeights.awareness = (defenderWeights.awareness || 0) + 0.05;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver, receiver.coreAttributes);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights, defender.coreAttributes);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            // Speed effect durations
            const CLASH_SPEED_EFFECT_DURATION = 1.0;  // seconds - reduced for quicker gameplay
            const DB_CATCHUP_DELAY = 2.0;             // seconds - delay before DB catch-up starts
            const DB_CATCHUP_BOOST_DURATION = 1.0;    // seconds - DB gets catch-up boost after delay
            const CLASH_SPEED_PENALTY = 0.75;  // 25% slower (was 50%, cut in half)
            const CLASH_SPEED_BOOST = 1.5;  // 50% faster
            const DB_CATCHUP_BOOST = 1.3;  // 30% faster for catch-up

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                // Receiver wins - gets speed boost for 1 second
                // Scale boost down at higher game speeds to prevent excessive speed
                const scaledBoost = 1 + (CLASH_SPEED_BOOST - 1) / gameState.gameSpeedMultiplier;
                receiver.clashSpeedBoostUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                receiver.speed = receiver.baseSpeed * scaledBoost;
                // DB gets catch-up boost 2 seconds after clash
                defender.catchupBoostStart = currentTime + DB_CATCHUP_DELAY;
                defender.catchupBoostUntil = currentTime + DB_CATCHUP_DELAY + DB_CATCHUP_BOOST_DURATION;
                defender.catchupBoostAmount = DB_CATCHUP_BOOST;
                // Record clash stats
                recordPlayerStat(receiver, 'seasonClashesWon');
                recordPlayerStat(defender, 'seasonClashesLost');
                // Record per-game clash stats
                if (receiver.playerId) {
                    const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                    rStats.clashesWon++;
                    rStats.clashDifficulties.push(margin);
                }
                if (defender.playerId) {
                    const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                // Direction changes (jukes) only benefit receivers - ignore defender wins
                if (reason === 'direction_change') {
                    result.winner = 'none';
                    result.type = 'contested';
                    // Juke failed but no penalty - just maintain current speed
                } else {
                    result.winner = 'defender';
                    result.type = 'coverage';
                    // Receiver loses - gets slowed
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                    receiver.speed = receiver.baseSpeed * CLASH_SPEED_PENALTY;
                    // Record clash stats
                    recordPlayerStat(defender, 'seasonClashesWon');
                    recordPlayerStat(receiver, 'seasonClashesLost');
                    // Record per-game clash stats
                    if (defender.playerId) {
                        const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                        dStats.clashesWon++;
                        dStats.clashDifficulties.push(-margin);
                    }
                    if (receiver.playerId) {
                        const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                        rStats.clashesLost++;
                        rStats.clashDifficulties.push(margin);
                    }
                }
            } else {
                result.winner = 'none';
                result.type = 'contested';
                // Tie - receiver maintains current speed
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Process all clashes in the game
        const processClashes = () => {
            // Skip clashes during ball flight to keep speed/distance calculations accurate
            if (gameState.ballInFlight) return;

            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // Clean up any expired speed boosts/penalties (called when ball lands)
        const cleanupExpiredSpeedEffects = () => {
            const currentTime = gameState.gameTime;
            gameState.receivers.forEach(receiver => {
                if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= currentTime) {
                    receiver.speed = receiver.baseSpeed;
                    receiver.clashSpeedBoostUntil = 0;
                }
                if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= currentTime) {
                    receiver.speed = receiver.baseSpeed;
                    receiver.clashSpeedPenaltyUntil = 0;
                }
            });
        };

        // ========================================
        // MANAGEMENT LAYER - UI SYSTEM
        // ========================================

        // UI state
        let managementUI = null;

        // Create Management UI
        function createManagementUI() {
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManagementUI");

            // Scale UI elements based on screen size for mobile
            const scale = Math.min(window.innerWidth / 400, window.innerHeight / 600, 1.5);
            advancedTexture.rootContainer.scaleX = scale;
            advancedTexture.rootContainer.scaleY = scale;

            const ui = {
                advancedTexture,
                visible: true
            };

            managementUI = ui;
            return ui;
        }

        // ========================================
        // HTML-BASED SCREEN NAVIGATION
        // ========================================

        // Hide all management screens
        function hideAllScreens() {
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
        }

        // Show a specific screen
        function showScreen(screenName) {
            const overlay = document.getElementById('managementOverlay');
            const topBar = document.getElementById('topBar');
            const viewButtons = document.getElementById('viewButtons');

            if (screenName === 'game') {
                // Game mode - hide overlay, show game
                overlay.classList.add('hidden');
                topBar.style.display = 'flex';
                viewButtons.style.display = 'flex';
                gameSceneActive = true;

                // IMPORTANT: Force engine resize after overlay is hidden
                // This fixes a rendering issue where canvas stays black
                // See TRAINING_MODE_FIX.md for details
                engine.resize();
            } else {
                // Management mode - show overlay, hide game
                overlay.classList.remove('hidden');
                topBar.style.display = 'none';
                viewButtons.style.display = 'none';
                gameSceneActive = false;

                hideAllScreens();

                switch (screenName) {
                    case 'main_menu':
                        document.getElementById('mainMenuScreen').style.display = 'block';
                        document.getElementById('btnContinue').disabled = !managementState.initialized;
                        break;
                    case 'hub':
                        document.getElementById('hubScreen').style.display = 'block';
                        refreshHubScreen();
                        break;
                    case 'roster':
                        document.getElementById('rosterScreen').style.display = 'block';
                        refreshRosterScreen();
                        break;
                    case 'free_agency':
                        document.getElementById('freeAgencyScreen').style.display = 'block';
                        refreshFreeAgencyScreen();
                        break;
                    case 'schedule':
                        document.getElementById('scheduleScreen').style.display = 'block';
                        refreshScheduleScreen();
                        break;
                    case 'facilities':
                        document.getElementById('facilitiesScreen').style.display = 'block';
                        refreshFacilitiesScreen();
                        break;
                    case 'match_end':
                        document.getElementById('matchEndScreen').style.display = 'block';
                        break;
                    case 'pre_game':
                        document.getElementById('preGameScreen').style.display = 'block';
                        break;
                    case 'draft':
                        document.getElementById('draftScreen').style.display = 'block';
                        refreshDraftScreen();
                        break;
                }
            }

            managementState.currentScreen = screenName;
        }

        // Refresh hub screen data
        function refreshHubScreen() {
            if (!managementState.team) return;
            document.getElementById('hubStatus').textContent =
                `Fame: ${managementState.team.fame.toLocaleString()} | Week ${managementState.season?.week || 1}`;
            document.getElementById('hubRecord').textContent =
                `Record: ${managementState.team.record.wins}-${managementState.team.record.losses}`;

            if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                const game = managementState.season.schedule[managementState.season.week - 1];
                document.getElementById('hubNextGame').textContent = `Next: vs ${game.opponent.name}`;
            } else {
                document.getElementById('hubNextGame').textContent = 'Season Complete!';
            }
        }

        // Calculate season stat change for a player (based on primary stats/overall)
        function calculateSeasonStatChange(player) {
            if (!player.seasonStartStats) return 0;

            // Calculate based on primary stats for the position (same as overall)
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            let currentTotal = 0;
            let startTotal = 0;
            primaryStats.forEach(stat => {
                currentTotal += player.stats[stat] || 0;
                startTotal += player.seasonStartStats[stat] || 0;
            });

            // Return change in overall (average of primary stats)
            const currentOverall = Math.round(currentTotal / primaryStats.length);
            const startOverall = Math.round(startTotal / primaryStats.length);
            return currentOverall - startOverall;
        }

        // Refresh roster screen
        function refreshRosterScreen() {
            const list = document.getElementById('rosterList');
            list.innerHTML = '';
            if (!managementState.team) return;

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                list.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    const seasonChange = calculateSeasonStatChange(player);
                    const changeClass = seasonChange > 0 ? 'positive' : seasonChange < 0 ? 'negative' : '';
                    const changeText = seasonChange > 0 ? `+${seasonChange}` : seasonChange < 0 ? `${seasonChange}` : '';

                    // Show stars for growing players, minuses for declining
                    let potentialDisplay = '';
                    let potentialColor = '#ffd700';
                    if (player.age >= player.peakAge) {
                        // Declining: show red minuses based on years past peak
                        const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                        potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                        potentialColor = '#f66';
                    } else if (player.potentialGrade > 0) {
                        // Growing: show 0-3 stars
                        potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                    }

                    // Fame bank display
                    const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
                    const fameDisplay = fameBank > 0 ? `<span style="color:#ffd700;font-size:11px;">[${fameBank}]</span>` : '';

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName} ${fameDisplay}</div>
                            <div class="stats">Age ${player.age} | ${formatSalary(player.salaryCost)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="season-gain ${changeClass}" style="min-width:28px;text-align:right;">${changeText}</span>
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    list.appendChild(item);
                });
            });
        }

        // Show player detail modal
        function showPlayerDetail(playerId) {
            const player = managementState.team.roster.find(p => p.id === playerId);
            if (!player) return;

            managementState.selectedPlayerId = playerId;

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Calculate overall change
            const currentOverall = player.overall;
            let startOverall = currentOverall;
            if (player.seasonStartStats) {
                const positionData = POSITIONS[player.position];
                const primaryStats = positionData.primaryStats;
                const startTotal = primaryStats.reduce((sum, stat) => sum + (player.seasonStartStats[stat] || 0), 0);
                startOverall = Math.round(startTotal / primaryStats.length);
            }
            const overallChange = currentOverall - startOverall;
            const overallChangeClass = overallChange > 0 ? 'positive' : overallChange < 0 ? 'negative' : '';
            const overallChangeText = overallChange !== 0 ?
                `<span class="season-change ${overallChangeClass}">${overallChange > 0 ? '+' : ''}${overallChange}</span>` : '';

            // Player info
            const tradeValue = calculateTradeValue(player);
            const tradeText = tradeValue > 0 ? `Trade Value: ${tradeValue}` : 'No Trade Value';

            // Fame/Hype info
            const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
            const hypeMultiplier = getCurrentHypeMultiplier(player);
            const hypeDisplay = hypeMultiplier.toFixed(2) + 'x';

            const infoHtml = `
                <div><span class="ovr-big">${player.overall}</span>${overallChangeText}</div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age} | Peak ${player.peakAge}<br>
                    Salary: ${formatSalary(player.salaryCost)} | Potential: ${'‚òÖ'.repeat(player.potentialGrade)}<br>
                    <span style="color:#ffd700;">Fame Bank: ${fameBank}</span> | <span style="color:#4af;">Hype: ${hypeDisplay}</span><br>
                    <span style="color:${tradeValue > 0 ? '#4f4' : '#888'}">${tradeText}</span>
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // Update trade button - use fame bank directly
            const tradeBtn = document.getElementById('btnTradePlayer');
            const cutBtn = document.getElementById('btnCutPlayer');
            cutBtn.style.display = 'block';  // Ensure cut button is visible for roster players
            if (fameBank > 0) {
                tradeBtn.textContent = `HARVEST (+${fameBank} Fame)`;
                tradeBtn.disabled = false;
                tradeBtn.style.opacity = '1';
            } else {
                tradeBtn.textContent = 'NO FAME TO HARVEST';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            }

            const getColorClass = (val) => val >= 90 ? 'stat-elite' : val >= 80 ? 'stat-good' : val >= 70 ? 'stat-average' : val >= 60 ? 'stat-below' : 'stat-poor';

            // Build unified stats panel
            const core = player.coreAttributes;
            const abilities = calculateAbilities(player);
            const bestAbility = getBestAbility(player);
            const techniqueStats = POSITIONS[player.position].techniqueStats || [];

            let statsHtml = '<div class="stats-panel">';

            // Core Attributes section
            if (core) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Core</div>
                        <div class="stats-grid">
                            <div class="stat-row str-row"><span class="stat-row-name">STR</span><span class="stat-row-value ${getColorClass(core.strength)}">${core.strength}</span></div>
                            <div class="stat-row spd-row"><span class="stat-row-name">SPD</span><span class="stat-row-value ${getColorClass(core.speed)}">${core.speed}</span></div>
                            <div class="stat-row agi-row"><span class="stat-row-name">AGI</span><span class="stat-row-value ${getColorClass(core.agility)}">${core.agility}</span></div>
                            <div class="stat-row int-row"><span class="stat-row-name">INT</span><span class="stat-row-value ${getColorClass(core.intelligence)}">${core.intelligence}</span></div>
                        </div>
                    </div>
                `;
            }

            // Abilities section
            if (abilities) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Abilities</div>
                        <div class="stats-grid">
                            ${Object.entries(abilities).map(([key, value]) => {
                                const isBest = bestAbility && bestAbility.name === key;
                                const dots = getAbilityDots(key);
                                const name = getAbilityDisplayName(key);
                                return `<div class="stat-row ${isBest ? 'best-ability' : ''}"><span class="stat-row-name">${dots}${name}</span><span class="stat-row-value ${getColorClass(value)}">${value}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Technique section with changes
            if (techniqueStats.length > 0) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Technique</div>
                        <div class="stats-grid">
                            ${techniqueStats.map(stat => {
                                const currentRaw = player.stats[stat] || 0;
                                const startRaw = player.seasonStartStats ? (player.seasonStartStats[stat] || 0) : currentRaw;
                                const current = Math.floor(currentRaw);
                                const start = Math.floor(startRaw);
                                const change = current - start;
                                const changeText = change !== 0 ? ` <span class="stat-change ${change > 0 ? 'positive' : 'negative'}">${change > 0 ? '+' : ''}${change}</span>` : '';
                                const statName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                                return `<div class="stat-row"><span class="stat-row-name">${statName}</span><span class="stat-row-value ${getColorClass(current)}">${current}${changeText}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            statsHtml += '</div>';

            // Season stats (position-dependent)
            let seasonStatsHtml = '<div class="season-stats-title">Season Stats</div><div class="season-stats-grid">';

            if (player.position === 'WR' || player.position === 'QB') {
                const catchPct = player.seasonTargets > 0
                    ? Math.round((player.seasonCatches || 0) / player.seasonTargets * 100)
                    : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTDs || 0}</div><div class="season-stat-label">TDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonCatches || 0}</div><div class="season-stat-label">Catches</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${catchPct}%</div><div class="season-stat-label">Catch %</div></div>
                `;
            } else if (player.position === 'CB') {
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTackles || 0}</div><div class="season-stat-label">Tackles</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonPassesDefended || 0}</div><div class="season-stat-label">PDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                `;
            } else if (player.position === 'OL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesLost || 0}</div><div class="season-stat-label">Clashes Lost</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            } else if (player.position === 'DL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonSacks || 0}</div><div class="season-stat-label">Sacks</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            }
            seasonStatsHtml += '</div>';

            // Show all stats in main area, season stats in secondary area
            document.getElementById('playerStats').innerHTML = statsHtml;
            document.getElementById('playerSeasonStats').innerHTML = seasonStatsHtml;

            // Career graph
            const history = player.careerHistory || [];
            let graphHtml = '<div class="career-graph-title">Career Progression</div>';

            if (history.length > 0) {
                graphHtml += '<div class="career-graph-container">';
                const maxOvr = Math.max(...history.map(h => h.overall), 99);
                const minOvr = Math.min(...history.map(h => h.overall), 40);
                const range = Math.max(maxOvr - minOvr, 20);

                history.forEach((season, idx) => {
                    const heightPct = ((season.overall - minOvr) / range) * 100;
                    const potentialStars = '‚òÖ'.repeat(season.potential || 0);
                    graphHtml += `
                        <div class="career-bar">
                            <div class="career-bar-ovr">${season.overall}</div>
                            <div class="career-bar-fill" style="height: ${Math.max(heightPct, 10)}%;">
                                <span class="career-bar-potential">${potentialStars}</span>
                            </div>
                            <div class="career-bar-label">Y${idx + 1}</div>
                        </div>
                    `;
                });
                graphHtml += '</div>';
            } else {
                graphHtml += '<div style="color:#666;font-size:12px;">No career history yet</div>';
            }
            document.getElementById('playerCareerGraph').innerHTML = graphHtml;

            // Show modal
            document.getElementById('playerDetailModal').style.display = 'flex';
        }

        // Close player detail modal
        function closePlayerDetail() {
            document.getElementById('playerDetailModal').style.display = 'none';
            managementState.selectedPlayerId = null;
        }

        // Cut player from detail view
        function cutPlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const result = cutPlayer(managementState.selectedPlayerId);
            if (result.success) {
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Harvest player for fame from detail view (returns their accumulated fame bank)
        function tradePlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const player = managementState.team.roster.find(p => p.id === managementState.selectedPlayerId);
            if (!player) return;

            const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
            if (fameBank <= 0) return;

            if (confirm(`Harvest ${player.firstName} ${player.lastName} for ${fameBank} Fame?`)) {
                managementState.team.fame += fameBank;
                cutPlayer(managementState.selectedPlayerId);
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Refresh free agency screen
        function refreshFreeAgencyScreen() {
            const list = document.getElementById('freeAgentList');
            const status = document.getElementById('faStatus');
            list.innerHTML = '';
            if (!managementState.team) return;

            const salary = calculateTeamSalary(managementState.team);
            const cap = managementState.team.salaryCap + managementState.team.salaryCapModifier;
            status.textContent = `Fame: ${formatSalary(managementState.team.fame)} | Cap: ${formatSalary(cap - salary)}`;

            if (managementState.freeAgents.length === 0) {
                list.innerHTML = '<p style="color:#888;text-align:center;">No free agents available</p>';
                return;
            }

            managementState.freeAgents.forEach(player => {
                const canSign = canSignPlayer(managementState.team, player);

                // Show stars for growing players, minuses for declining
                let potentialDisplay = '';
                let potentialColor = '#ffd700';
                if (player.age >= player.peakAge) {
                    const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                    potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                    potentialColor = '#f66';
                } else if (player.potentialGrade > 0) {
                    potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                }

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div>
                        <div class="name">${player.firstName} ${player.lastName} (${player.position})</div>
                        <div class="stats">Age ${player.age} | Salary: ${formatSalary(player.salaryCost)}</div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                        <button class="mgmt-btn fa-btn" ${canSign ? '' : 'disabled'}
                            onclick="signAndRefresh('${player.id}')">SIGN</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // Sign player and refresh
        function signAndRefresh(playerId) {
            const result = signFreeAgent(playerId);
            if (result.success) {
                refreshFreeAgencyScreen();
            }
        }

        // Calculate team overall rating
        function calculateTeamOverallRating() {
            if (!managementState.team) return 0;
            const roster = managementState.team.roster;
            if (roster.length === 0) return 0;
            const total = roster.reduce((sum, p) => sum + p.overall, 0);
            return Math.round(total / roster.length);
        }

        // Refresh schedule screen
        function refreshScheduleScreen() {
            const list = document.getElementById('scheduleList');
            list.innerHTML = '';
            if (!managementState.season) return;

            // Update team strength display
            const teamOverall = calculateTeamOverallRating();
            const teamOffense = Math.round(calculateTeamOffenseRating());
            const teamDefense = Math.round(calculateTeamDefenseRating());

            document.getElementById('strengthOverall').textContent = teamOverall;
            document.getElementById('strengthOffense').textContent = teamOffense;
            document.getElementById('strengthDefense').textContent = teamDefense;

            managementState.season.schedule.forEach((game, index) => {
                const weekNum = index + 1;
                const isCurrent = weekNum === managementState.season.week;
                const isPast = weekNum < managementState.season.week;

                const item = document.createElement('div');
                item.className = `schedule-item ${isCurrent ? 'current' : ''} ${isPast ? 'past' : ''}`;

                let resultText = '-';
                let resultClass = '';
                if (game.result) {
                    resultText = `${game.result.win ? 'W' : 'L'} ${game.result.playerScore}-${game.result.opponentScore}`;
                    resultClass = game.result.win ? 'win' : 'loss';
                } else if (isCurrent) {
                    resultText = 'NEXT';
                    resultClass = '';
                }

                // Show opponent strength
                const oppOverall = Math.round((game.opponent.offenseRating + game.opponent.defenseRating) / 2);

                item.innerHTML = `
                    <div>
                        <div>Wk ${weekNum}: ${game.isHome ? 'vs' : '@'} ${game.opponent.name}</div>
                        <div style="font-size:11px;color:#888;">OVR ${oppOverall} | OFF ${game.opponent.offenseRating} | DEF ${game.opponent.defenseRating}</div>
                    </div>
                    <div class="result ${resultClass}">${resultText}</div>
                `;
                list.appendChild(item);
            });
        }

        // Refresh facilities screen
        function refreshFacilitiesScreen() {
            if (!managementState.team) return;

            document.getElementById('facCredits').textContent = `Fame: ${managementState.team.fame.toLocaleString()}`;

            const arena = managementState.team.facilities.stadium;
            const training = managementState.team.facilities.trainingCenter;

            document.getElementById('arenaLevel').textContent = `Level ${arena.level}/${arena.maxLevel}`;
            document.getElementById('trainingLevel').textContent = `Level ${training.level}/${training.maxLevel}`;

            const arenaCost = arena.level < arena.maxLevel ? ECONOMY.STADIUM_UPGRADE_COSTS[arena.level - 1] : 0;
            const trainingCost = training.level < training.maxLevel ? ECONOMY.TRAINING_UPGRADE_COSTS[training.level - 1] : 0;

            document.getElementById('btnUpgradeArena').textContent = arena.level >= arena.maxLevel ? 'MAXED' : `UPGRADE ($${arenaCost.toLocaleString()})`;
            document.getElementById('btnUpgradeArena').disabled = arena.level >= arena.maxLevel || managementState.team.fame < arenaCost;

            document.getElementById('btnUpgradeTraining').textContent = training.level >= training.maxLevel ? 'MAXED' : `UPGRADE ($${trainingCost.toLocaleString()})`;
            document.getElementById('btnUpgradeTraining').disabled = training.level >= training.maxLevel || managementState.team.fame < trainingCost;
        }

        // Show match end result
        function showMatchEnd(matchResult) {
            const result = matchResult.result;
            document.getElementById('matchResult').textContent = result.win ? 'VICTORY!' : 'DEFEAT';
            document.getElementById('matchResult').className = result.win ? 'win' : 'loss';
            document.getElementById('matchScore').textContent = `${result.playerScore} - ${result.opponentScore}`;
            document.getElementById('matchRevenue').textContent = `+${matchResult.revenue.toLocaleString()} Fame`;

            // Add fame to players ONCE per game (prevent double-counting on re-render)
            if (!managementState.fameAddedThisGame && managementState.team && managementState.team.roster) {
                managementState.fameAddedThisGame = true;
                managementState.team.roster.forEach(player => {
                    const pStats = gameStats.players[player.id];
                    if (pStats && player.hypeData) {
                        const fameEarned = calculateGameFame(player, pStats);
                        if (fameEarned > 0) {
                            player.hypeData.accumulatedFameBank += fameEarned;
                            player.hypeData.seasonFameEarnings += fameEarned;
                        }
                    }
                });
            }

            // Build post-game stats display using roster layout
            const statsContainer = document.getElementById('postGameStats');
            statsContainer.innerHTML = '';

            // Helper to get game stats for a player
            const getPlayerGameStats = (player) => {
                const pStats = gameStats.players[player.id];
                if (!pStats) return [];

                const statItems = [];

                // QB stats
                if (pStats.completions > 0 || pStats.incompletions > 0) {
                    const total = pStats.completions + pStats.incompletions;
                    const pct = total > 0 ? Math.round(pStats.completions / total * 100) : 0;
                    statItems.push({ label: 'COMP', value: `${pStats.completions}/${total}` });
                    statItems.push({ label: '%', value: `${pct}%` });
                    if (pStats.throwDistances.length > 0) {
                        const avgDist = Math.round(pStats.throwDistances.reduce((a,b) => a+b, 0) / pStats.throwDistances.length);
                        statItems.push({ label: 'YDS', value: avgDist });
                    }
                }

                // Receiver stats
                if (pStats.catches > 0 || pStats.drops > 0) {
                    statItems.push({ label: 'REC', value: pStats.catches });
                    if (pStats.drops > 0) statItems.push({ label: 'DROP', value: pStats.drops });
                    if (pStats.yardsAfterCatch > 0) statItems.push({ label: 'YAC', value: pStats.yardsAfterCatch });
                }

                // Clash stats
                if (pStats.clashesWon > 0 || pStats.clashesLost > 0) {
                    statItems.push({ label: 'W', value: pStats.clashesWon });
                    statItems.push({ label: 'L', value: pStats.clashesLost });
                }

                // Defense stats
                if (pStats.sacks > 0) statItems.push({ label: 'SACK', value: pStats.sacks });
                if (pStats.tackles > 0) statItems.push({ label: 'TKL', value: pStats.tackles });
                if (pStats.passesDefended > 0) statItems.push({ label: 'PD', value: pStats.passesDefended });

                // TDs
                if (pStats.touchdowns > 0) statItems.push({ label: 'TD', value: pStats.touchdowns });

                return statItems;
            };

            // Helper to render a player row
            const renderPlayerRow = (player) => {
                const pStats = gameStats.players[player.id];
                const statItems = getPlayerGameStats(player);

                // Calculate fame earned this game
                const fameEarned = calculateGameFame(player, pStats);

                // Add fame to stats display if earned (always show, even if already added)
                if (fameEarned > 0) {
                    statItems.push({ label: 'FAME', value: `+${fameEarned}`, highlight: true });
                }

                const statsHtml = statItems.length > 0
                    ? statItems.map(s => `<div class="post-game-stat${s.highlight ? ' fame-stat' : ''}"><span class="post-game-stat-value">${s.value}</span><span class="post-game-stat-label">${s.label}</span></div>`).join('')
                    : '<span class="post-game-no-stats">No stats</span>';

                // Show accumulated fame bank
                const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;

                const div = document.createElement('div');
                div.className = 'post-game-player';
                div.innerHTML = `
                    <div class="post-game-player-header">
                        <span class="post-game-player-name">${player.firstName} ${player.lastName}</span>
                        <span class="post-game-player-fame" style="color:#ffd700;font-size:11px;margin-left:8px;">${fameBank > 0 ? `[${fameBank}]` : ''}</span>
                        <span class="post-game-player-ovr">${player.overall}</span>
                    </div>
                    <div class="post-game-player-stats">${statsHtml}</div>
                `;
                div.addEventListener('click', () => showPlayerDetail(player.id));
                return div;
            };

            // Group players by position category (same order as roster)
            const positionGroups = {
                'Offense': ['QB', 'WR', 'OL'],
                'Defense': ['CB', 'DL']
            };

            if (!managementState.team || !managementState.team.roster) {
                statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No roster data</p>';
                showScreen('match_end');
                return;
            }

            Object.entries(positionGroups).forEach(([groupName, positions]) => {
                const groupPlayers = managementState.team.roster
                    .filter(p => positions.includes(p.position))
                    .sort((a, b) => b.overall - a.overall);

                if (groupPlayers.length === 0) return;

                const section = document.createElement('div');
                section.className = 'post-game-section';
                section.innerHTML = `<div class="post-game-section-title">${groupName}</div>`;

                groupPlayers.forEach(player => {
                    section.appendChild(renderPlayerRow(player));
                });

                statsContainer.appendChild(section);
            });

            if (statsContainer.children.length === 0) {
                statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No player stats recorded</p>';
            }

            // Show simulation log button if there's a log
            const logBtn = document.getElementById('btnShowSimLog');
            const logContainer = document.getElementById('simLogContainer');
            if (managementState.simulationLog && managementState.simulationLog.length > 0) {
                logBtn.style.display = 'block';
                document.getElementById('simLogContent').textContent = getSimulationLog();
            } else {
                logBtn.style.display = 'none';
            }
            logContainer.style.display = 'none';

            showScreen('match_end');
        }

        // Show pre-game matchup screen
        function showPreGame(opponent) {
            document.getElementById('preGameOpponent').textContent = `VS ${opponent.name.toUpperCase()}`;

            // Calculate team offense score (QB, WRs, OL average)
            const offensivePlayers = [];
            const qb = getDepthChartPlayer('QB1');
            if (qb) offensivePlayers.push(qb);
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) offensivePlayers.push(p);
            });
            managementState.team.depthChart.OL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) offensivePlayers.push(p);
            });
            const teamOffense = offensivePlayers.length > 0
                ? Math.round(offensivePlayers.reduce((s, p) => s + p.overall, 0) / offensivePlayers.length)
                : 60;

            // Calculate team defense score (CBs, DL average)
            const defensivePlayers = [];
            ['CB1', 'CB2', 'CB3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) defensivePlayers.push(p);
            });
            managementState.team.depthChart.DL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) defensivePlayers.push(p);
            });
            const teamDefense = defensivePlayers.length > 0
                ? Math.round(defensivePlayers.reduce((s, p) => s + p.overall, 0) / defensivePlayers.length)
                : 60;

            // Get opponent roster players by position
            const getOpponentPlayers = (position) => {
                if (!opponent.roster) return [];
                return opponent.roster.filter(p => p.position === position).sort((a, b) => b.overall - a.overall);
            };
            const oppCBs = getOpponentPlayers('CB');
            const oppDL = getOpponentPlayers('DL');

            // Show team scores
            const teamScoresHtml = `
                <div class="team-score-block">
                    <div class="team-score-label">Your Offense</div>
                    <div class="team-score-value yours">${teamOffense}</div>
                </div>
                <div class="team-score-vs">vs</div>
                <div class="team-score-block">
                    <div class="team-score-label">Their Defense</div>
                    <div class="team-score-value theirs">${opponent.defenseRating}</div>
                </div>
            `;
            document.getElementById('preGameTeamScores').innerHTML = teamScoresHtml;

            // Show QB key stats
            let qbScoresHtml = '';
            if (qb) {
                const shortAcc = Math.floor(qb.stats.shortPassAcc || 0);
                const longAcc = Math.floor(qb.stats.longPassAcc || 0);
                const awareness = Math.floor(qb.stats.awareness || 0);
                qbScoresHtml = `
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">QB Overall</div>
                        <div class="qb-stat-value">${qb.overall}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Short</div>
                        <div class="qb-stat-value">${shortAcc}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Long</div>
                        <div class="qb-stat-value">${longAcc}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">AWR</div>
                        <div class="qb-stat-value">${awareness}</div>
                    </div>
                `;
            }
            document.getElementById('preGameQBScores').innerHTML = qbScoresHtml;

            const matchupsContainer = document.getElementById('preGameMatchups');
            let html = '';

            // Helper to get advantage class
            const getAdvClass = (yours, theirs) => {
                const diff = yours - theirs;
                if (diff > 3) return 'advantage';
                if (diff < -3) return 'disadvantage';
                return 'even';
            };

            // QB vs opponent defense average
            if (qb) {
                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Quarterback</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${qb.firstName} ${qb.lastName}
                                <span class="matchup-ovr ${getAdvClass(qb.overall, opponent.defenseRating)}">${qb.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${opponent.defenseRating}</span>
                                Defense
                            </div>
                        </div>
                    </div>`;
            }

            // WRs vs opponent CBs
            const wrs = ['WR1', 'WR2', 'WR3'].map(s => getDepthChartPlayer(s)).filter(Boolean);
            if (wrs.length > 0) {
                html += `<div class="matchup-section"><div class="matchup-section-title">Receivers vs Corners</div>`;
                wrs.forEach((wr, i) => {
                    const cb = oppCBs[i];
                    const cbOvr = cb ? cb.overall : opponent.defenseRating;
                    const cbName = cb ? `${cb.firstName} ${cb.lastName.charAt(0)}.` : 'CB';
                    html += `
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${wr.firstName} ${wr.lastName.charAt(0)}.
                                <span class="matchup-ovr ${getAdvClass(wr.overall, cbOvr)}">${wr.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${cbOvr}</span>
                                ${cbName}
                            </div>
                        </div>`;
                });
                html += `</div>`;
            }

            // O-Line vs opponent D-Line
            const olPlayers = managementState.team.depthChart.OL.map(id =>
                managementState.team.roster.find(p => p.id === id)
            ).filter(Boolean);

            if (olPlayers.length > 0 || oppDL.length > 0) {
                const olAvg = olPlayers.length > 0
                    ? Math.round(olPlayers.reduce((s, p) => s + p.overall, 0) / olPlayers.length)
                    : 60;
                const dlAvg = oppDL.length > 0
                    ? Math.round(oppDL.reduce((s, p) => s + p.overall, 0) / oppDL.length)
                    : opponent.defenseRating;

                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Line Battle</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                O-Line (${olPlayers.length})
                                <span class="matchup-ovr ${getAdvClass(olAvg, dlAvg)}">${olAvg}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${dlAvg}</span>
                                D-Line (${oppDL.length})
                            </div>
                        </div>
                    </div>`;
            }

            matchupsContainer.innerHTML = html;
            showScreen('pre_game');
        }

        // Start the arcade game portion
        function startArcadeGame() {
            console.log('[ARCADE] Starting arcade game...');

            // TEST: trainingMode = false but keep lines/defenders disabled
            try {
                gameState.trainingMode = false;  // TEST: Back to false
            } catch(e) { console.error('[ARCADE] Error setting trainingMode:', e); }

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('viewButtons').style.display = 'flex';
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('catchDisplay').style.display = '';
            gameSceneActive = true;

            // Reset game state
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.startingLineOfScrimmage + 10;

            try {
                gameStats.reset();
                console.log('[ARCADE] gameStats.reset() OK');
            } catch(e) { console.error('[ARCADE] Error in gameStats.reset():', e); }

            // TEST: Enable only offensive line to isolate render error
            try {
                gameState.offensiveLine.forEach(lineman => lineman.setEnabled(true));  // Enable O-line only
                gameState.defensiveLine.forEach(lineman => lineman.setEnabled(false));
                gameState.defenders.forEach(defender => defender.setEnabled(false));
                console.log('[ARCADE] TEST: Only O-line enabled');
            } catch(e) { console.error('[ARCADE] Error in line/defender setup:', e); }

            // Update game meshes with roster player data
            // TEMP: Skip this to test if it causes the render error
            try {
                // updateGamePlayersFromRoster();  // TEMPORARILY DISABLED FOR TESTING
                console.log('[ARCADE] updateGamePlayersFromRoster() SKIPPED FOR TESTING');
            } catch(e) { console.error('[ARCADE] Error in updateGamePlayersFromRoster():', e); }

            // Reset play to position all players at the line of scrimmage
            try {
                if (gameState.scene) {
                    resetPlay(gameState.scene);
                    console.log('[ARCADE] resetPlay() OK');
                }
            } catch(e) { console.error('[ARCADE] Error in resetPlay():', e); }

            try {
                updateDownDistance();
                console.log('[ARCADE] updateDownDistance() OK');
            } catch(e) { console.error('[ARCADE] Error in updateDownDistance():', e); }

            // IMPORTANT: Force engine resize after overlay is hidden
            console.log('[ARCADE] About to call engine.resize()');
            setTimeout(() => {
                try {
                    engine.resize();
                    console.log('[ARCADE] engine.resize() OK');
                } catch(e) { console.error('[ARCADE] Error in engine.resize():', e); }
            }, 50);

            console.log('[ARCADE] startArcadeGame() completed');
        }

        // Start training mode (no defenders, throw ratings)
        function startTrainingMode() {
            gameState.trainingMode = true;
            gameState.lastThrowRating = null;

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('trainingModeUI').style.display = 'block';
            document.getElementById('catchDisplay').style.display = 'none';
            gameSceneActive = true;

            // Reset game state
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.startingLineOfScrimmage + 10;

            // Hide offensive and defensive lines
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(false));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(false));

            // Reset play
            if (gameState.scene) {
                resetPlay(gameState.scene);
            }

            updateDownDistance();

            // IMPORTANT: Force engine resize after overlay is hidden
            // This fixes a rendering issue where canvas stays black
            // See TRAINING_MODE_FIX.md for details
            engine.resize();
        }

        // Exit training mode and return to hub
        function exitTrainingMode() {
            gameState.trainingMode = false;
            gameSceneActive = false; // Disable game input
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('topBar').style.display = 'none';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('catchDisplay').style.display = ''; // Restore catch display
            document.getElementById('managementOverlay').classList.remove('hidden');

            // Show offensive and defensive lines again
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(true));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(true));

            // Hide other screens and show hub (or main menu if not initialized)
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            if (managementState.initialized) {
                document.getElementById('hubScreen').style.display = 'block';
                refreshHubScreen();
            } else {
                document.getElementById('mainMenuScreen').style.display = 'block';
            }
        }

        // Update all player speeds when game speed multiplier changes
        function updateAllPlayerSpeeds() {
            // Update receivers
            gameState.receivers.forEach(receiver => {
                receiver.baseSpeed = receiver.stats.speed * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier;
                receiver.speed = receiver.baseSpeed;
            });
            // Update defenders
            gameState.defenders.forEach(defender => {
                defender.baseSpeed = defender.stats.speed * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier;
                defender.speed = defender.baseSpeed;
            });
            // Update O-line
            gameState.offensiveLine.forEach(lineman => {
                lineman.baseSpeed = lineman.stats.speed * SPEED_CONSTANTS.O_LINE_FACTOR * gameState.gameSpeedMultiplier;
                lineman.speed = lineman.baseSpeed;
            });
            // Update D-line
            gameState.defensiveLine.forEach(lineman => {
                lineman.baseSpeed = lineman.stats.speed * SPEED_CONSTANTS.D_LINE_FACTOR * gameState.gameSpeedMultiplier;
                lineman.speed = lineman.baseSpeed;
            });
            // Update display
            const speedDisplay = document.getElementById('gameSpeedDisplay');
            if (speedDisplay) speedDisplay.textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        }

        // Adjust game speed multiplier
        function adjustGameSpeed(delta) {
            gameState.gameSpeedMultiplier = Math.max(0.5, Math.min(2.0, gameState.gameSpeedMultiplier + delta));
            updateAllPlayerSpeeds();
        }

        // Apply receiver speed preset to all receivers
        function applyReceiverSpeedPreset() {
            const preset = gameState.receiverSpeedPreset;
            const speeds = preset === 'mixed' ? [90, 80, 70] : [preset, preset, preset];
            gameState.receivers.forEach((receiver, i) => {
                const speedStat = speeds[i % speeds.length];
                receiver.stats.speed = speedStat;
                receiver.baseSpeed = speedStat * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier;
                receiver.speed = receiver.baseSpeed;
                // Recalculate overall based on new speed using WR position stats
                const stats = receiver.stats;
                stats.speed = speedStat;  // Update speed stat
                const wrPrimaryStats = POSITIONS.WR.primaryStats;
                receiver.overall = Math.round(wrPrimaryStats.reduce((sum, stat) => sum + (stats[stat] || 0), 0) / wrPrimaryStats.length);
                // Update visual label
                if (receiver.ovrTextBlock) {
                    const stars = receiver.overall >= 90 ? ' ‚òÖ‚òÖ' : receiver.overall >= 85 ? ' ‚òÖ' : '';
                    receiver.ovrTextBlock.text = `${receiver.overall}${stars}`;
                }
            });
        }

        // Apply DB speed preset to all defenders
        function applyDbSpeedPreset() {
            const preset = gameState.dbSpeedPreset;
            const speeds = preset === 'mixed' ? [90, 80, 70] : [preset, preset, preset];
            gameState.defenders.forEach((defender, i) => {
                const speedStat = speeds[i % speeds.length];
                defender.stats.speed = speedStat;
                defender.baseSpeed = speedStat * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier;
                defender.speed = defender.baseSpeed;
                // Recalculate overall based on new speed using CB position stats
                const stats = defender.stats;
                stats.speed = speedStat;  // Update speed stat
                const cbPrimaryStats = POSITIONS.CB.primaryStats;
                defender.overall = Math.round(cbPrimaryStats.reduce((sum, stat) => sum + (stats[stat] || 0), 0) / cbPrimaryStats.length);
                // Update visual label
                if (defender.ovrTextBlock) {
                    const stars = defender.overall >= 90 ? ' ‚òÖ‚òÖ' : defender.overall >= 85 ? ' ‚òÖ' : '';
                    defender.ovrTextBlock.text = `${defender.overall}${stars}`;
                }
            });
        }

        // Calculate throw rating based on lead accuracy, lateral offset, and receiver slowdown
        function calculateThrowRating(receiver, ballLandingPos, catchTime) {
            // Get receiver's position, velocity, and speed at THROW time (not catch time)
            const throwPos = gameState.receiverPositionsAtThrow && gameState.receiverPositionsAtThrow[receiver.name];
            const throwVelocity = gameState.receiverVelocitiesAtThrow && gameState.receiverVelocitiesAtThrow[receiver.name];
            const throwSpeed = gameState.receiverSpeedsAtThrow && gameState.receiverSpeedsAtThrow[receiver.name];

            if (!throwPos || !throwVelocity) {
                return { grade: 'C', score: 50, details: 'No throw data', leadScore: 50 };
            }

            // Calculate ball flight time
            const flightTime = gameState.throwStartTime ?
                (performance.now() - gameState.throwStartTime) / 1000 : 1.5;

            // Get velocity direction at throw time (velocity is per-frame, convert to per-second)
            const velPerSec = { x: throwVelocity.x * 60, z: throwVelocity.z * 60 };
            const velocityMagnitude = Math.sqrt(
                velPerSec.x * velPerSec.x + velPerSec.z * velPerSec.z
            );

            // Use stored speed (includes boosts) for expected distance, fallback to velocity magnitude
            const receiverSpeed = throwSpeed || velocityMagnitude;

            // Vector from receiver (at throw time) to ball landing
            const toBall = new BABYLON.Vector3(
                ballLandingPos.x - throwPos.x,
                0,
                ballLandingPos.z - throwPos.z
            );
            const distToBall = Math.sqrt(toBall.x * toBall.x + toBall.z * toBall.z);

            let leadScore = 50;
            let lateralScore = 100;
            let slowdownScore = 100;
            let leadDistance = 0;
            let lateralOffset = 0;
            let debugInfo = null;

            if (velocityMagnitude > 0.1) {
                // Normalize velocity direction
                const velDir = new BABYLON.Vector3(
                    velPerSec.x / velocityMagnitude,
                    0,
                    velPerSec.z / velocityMagnitude
                );

                // 1. LEAD DISTANCE: Dot product gives distance along velocity direction
                leadDistance = toBall.x * velDir.x + toBall.z * velDir.z;

                // 2. LATERAL OFFSET: Cross product magnitude gives perpendicular distance
                // In 2D (XZ plane): |A √ó B| = Ax*Bz - Az*Bx
                lateralOffset = Math.abs(toBall.x * velDir.z - toBall.z * velDir.x);

                // Ideal lead scales with flight time and receiver speed
                // If receiver runs at speed S for time T, ideal lead = S * T
                const idealLead = velocityMagnitude * flightTime * 0.8; // 80% to give catching room

                // Score lead accuracy (how close to ideal)
                // More lenient: 1.5 yard buffer for full score, gentler dropoff
                const leadError = Math.abs(leadDistance - idealLead);
                if (leadDistance < 0) {
                    // Ball thrown behind - bad but not catastrophic for small amounts
                    // 0 to -1 yard: 80-100, beyond that drops faster
                    leadScore = Math.max(0, 100 + leadDistance * 20);
                } else if (leadDistance > idealLead * 2.5) {
                    // Way too far ahead - receiver can't reach
                    leadScore = Math.max(10, 60 - (leadDistance - idealLead * 2) * 8);
                } else if (leadError <= 1.5) {
                    // Within 1.5 yards of ideal = full score
                    leadScore = 100;
                } else {
                    // Outside buffer but reasonable range - gentle dropoff
                    leadScore = Math.max(40, 100 - (leadError - 1.5) * 12);
                }

                // Lateral offset penalty - each yard off costs points
                // Perfect = on the line, 3+ yards off = significant penalty
                lateralScore = Math.max(0, 100 - lateralOffset * 25);

                // 3. SLOWDOWN MEASUREMENT: Compare momentum at throw vs catch
                // runMomentum is a smoothed 0-1 value (builds 0.15/frame when running, decays 0.9x when stopped)
                // This is more reliable than distance because speed fluctuates with DB closeness
                const throwMomentum = gameState.receiverMomentumAtThrow && gameState.receiverMomentumAtThrow[receiver.name];
                const catchMomentum = receiver.runMomentum || 0;

                // Calculate momentum ratio: how much momentum was maintained
                // If throwMomentum was low (receiver wasn't running), don't penalize
                let momentumRatio;
                if (throwMomentum !== undefined && throwMomentum > 0.2) {
                    // Receiver was running at throw - compare to catch momentum
                    momentumRatio = Math.min(1, catchMomentum / throwMomentum);
                } else {
                    // Receiver was stationary or just starting - no penalty
                    momentumRatio = 1;
                }

                slowdownScore = momentumRatio * 100;

                // Store debug info for display
                debugInfo = {
                    flightTime: flightTime.toFixed(2),
                    throwMomentum: throwMomentum !== undefined ? throwMomentum.toFixed(2) : 'N/A',
                    catchMomentum: catchMomentum.toFixed(2),
                    momentumRatio: momentumRatio.toFixed(2)
                };
            } else {
                // Stationary receiver - just measure distance to ball
                const directDist = distToBall;
                leadScore = Math.max(0, 100 - directDist * 30);
                lateralScore = 100; // No direction, so no lateral concept
            }

            // Combine scores: lead most important, then slowdown, then lateral
            // Lead 40%, Slowdown 35%, Lateral 25%
            const totalScore = Math.round(
                leadScore * 0.40 +
                slowdownScore * 0.35 +
                lateralScore * 0.25
            );

            // Determine grade
            let grade;
            if (totalScore >= 90) grade = 'A+';
            else if (totalScore >= 80) grade = 'A';
            else if (totalScore >= 65) grade = 'B';
            else grade = 'C';

            // Format details
            let leadText;
            if (velocityMagnitude < 0.001) {
                leadText = 'stationary';
            } else if (leadDistance < 0) {
                leadText = `${leadDistance.toFixed(1)}yd behind`;
            } else {
                leadText = `${leadDistance.toFixed(1)}yd ahead`;
            }

            const lateralText = lateralOffset > 0.3 ? `, ${lateralOffset.toFixed(1)}yd wide` : '';

            // Check if receiver has active speed boost or penalty
            const hasSpeedBoost = receiver.clashSpeedBoostUntil > gameState.gameTime;
            const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;

            return {
                grade,
                score: totalScore,
                leadScore: Math.round(leadScore),
                lateralScore: Math.round(lateralScore),
                slowdownScore: Math.round(slowdownScore),
                leadDistance: leadDistance,
                lateralOffset: lateralOffset,
                leadText: leadText + lateralText,
                details: `Lead: ${leadText}${lateralText} | Slowdown: ${Math.round(slowdownScore)}%`,
                debugInfo: debugInfo,
                hasSpeedBoost: hasSpeedBoost,
                hasSpeedPenalty: hasSpeedPenalty
            };
        }

        // Clear heat map meshes
        function clearThrowHeatMap() {
            if (gameState.heatMapMeshes) {
                gameState.heatMapMeshes.forEach(mesh => mesh.dispose());
                gameState.heatMapMeshes = [];
            }
        }

        // Draw throw heat map showing ideal/medium/poor zones for each receiver
        function updateThrowHeatMap() {
            if (!gameState.showThrowHeatMap || !gameState.scene) return;
            clearThrowHeatMap();

            const scene = gameState.scene;
            const qbPos = scene.qb ? scene.qb.position : new BABYLON.Vector3(0, 0, gameState.qbStartZ);

            gameState.receivers.forEach((receiver, idx) => {
                if (!receiver.velocity) return;
                const pos = receiver.position;
                const vel = { x: receiver.velocity.x * 60, z: receiver.velocity.z * 60 };
                const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
                if (speed < 0.1) return;

                const throwSpeed = 25;
                for (let t = 0.3; t <= 2.0; t += 0.2) {
                    const futureX = pos.x + vel.x * t;
                    const futureZ = pos.z + vel.z * t;
                    const distToQB = Math.sqrt(Math.pow(futureX - qbPos.x, 2) + Math.pow(futureZ - qbPos.z, 2));
                    const ballFlightTime = distToQB / throwSpeed;
                    const timeDiff = Math.abs(t - ballFlightTime);

                    let color;
                    if (timeDiff < 0.15) color = new BABYLON.Color3(0, 1, 0);
                    else if (timeDiff < 0.35) color = new BABYLON.Color3(1, 1, 0);
                    else if (timeDiff < 0.6) color = new BABYLON.Color3(1, 0.5, 0);
                    else color = new BABYLON.Color3(1, 0, 0);

                    const zoneMesh = BABYLON.MeshBuilder.CreateDisc(`heatZone_${idx}_${t}`, { radius: 0.3, tessellation: 16 }, scene);
                    zoneMesh.position = new BABYLON.Vector3(futureX, 0.02, futureZ);
                    zoneMesh.rotation.x = Math.PI / 2;
                    const zoneMat = new BABYLON.StandardMaterial(`heatZoneMat_${idx}_${t}`, scene);
                    zoneMat.diffuseColor = color;
                    zoneMat.emissiveColor = color.scale(0.5);
                    zoneMat.alpha = 0.4;
                    zoneMesh.material = zoneMat;
                    gameState.heatMapMeshes.push(zoneMesh);
                }
            });
        }

        // Update game player meshes with roster data
        function updateGamePlayersFromRoster() {
            if (!managementState.initialized || !managementState.team) return;

            const scene = gameState.scene;
            if (!scene) return;

            // Helper for rating indicator text
            const getRatingText = (overall) => {
                if (overall >= 90) return `${overall} ‚òÖ‚òÖ`;
                if (overall >= 85) return `${overall} ‚òÖ`;
                return `${overall}`;
            };

            // Helper to get label background based on rating (for offense - gold tint)
            const getOffenseLabelBg = (overall) => {
                if (overall >= 90) return 'rgba(80, 60, 0, 0.85)';
                if (overall >= 85) return 'rgba(50, 40, 0, 0.8)';
                return null;  // Use default - no special background below 85
            };

            // Update QB
            const rosterQB = getDepthChartPlayer('QB');
            if (rosterQB && scene.qb) {
                try {
                    scene.qb.playerId = rosterQB.id;
                    scene.qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                    scene.qb.stats = { ...rosterQB.stats };
                    scene.qb.coreAttributes = rosterQB.coreAttributes ? { ...rosterQB.coreAttributes } : null;
                    scene.qb.lastName = rosterQB.lastName;
                    scene.qb.overall = rosterQB.overall;
                    // Update name label TextBlocks
                    if (scene.qb.nameTextBlock) {
                        scene.qb.nameTextBlock.text = rosterQB.lastName.toUpperCase();
                    }
                    if (scene.qb.ovrTextBlock) {
                        scene.qb.ovrTextBlock.text = getRatingText(rosterQB.overall);
                    }
                    if (scene.qb.nameLabel) {
                        scene.qb.nameLabel.background = getOffenseLabelBg(rosterQB.overall) || 'rgba(0, 0, 0, 0.7)';
                    }
                    console.log(`[ROSTER] QB updated: ${scene.qb.displayName} (${scene.qb.overall})`);
                } catch (e) {
                    console.error('[ROSTER] Error updating QB:', e);
                }
            }

            // Update Receivers
            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                const player = getDepthChartPlayer(slot);
                const receiver = gameState.receivers[index];
                if (player && receiver) {
                    try {
                        receiver.playerId = player.id;
                        receiver.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        receiver.stats = { ...player.stats };
                        receiver.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                        receiver.lastName = player.lastName;
                        receiver.overall = player.overall;
                        // Update name label TextBlocks
                        if (receiver.nameTextBlock) {
                            receiver.nameTextBlock.text = player.lastName.toUpperCase();
                        }
                        if (receiver.ovrTextBlock) {
                            receiver.ovrTextBlock.text = getRatingText(player.overall);
                        }
                        if (receiver.nameLabel) {
                            receiver.nameLabel.background = getOffenseLabelBg(player.overall) || 'rgba(0, 0, 0, 0.65)';
                        }
                        console.log(`[ROSTER] Receiver ${slot} updated: ${receiver.displayName} (${receiver.overall})`);
                    } catch (e) {
                        console.error(`[ROSTER] Error updating receiver ${slot}:`, e);
                    }
                }
            });

            // Update Defenders from opponent's CBs
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;
            if (opponent && opponent.roster) {
                const oppCBs = opponent.roster
                    .filter(p => p.position === 'CB')
                    .sort((a, b) => b.overall - a.overall);

                // Helper for defender label background (red theme)
                const getDefenderLabelBg = (overall) => {
                    if (overall >= 90) return 'rgba(100, 40, 40, 0.9)';
                    if (overall >= 85) return 'rgba(80, 35, 35, 0.85)';
                    return 'rgba(40, 20, 20, 0.75)';
                };

                gameState.defenders.forEach((defender, index) => {
                    const player = oppCBs[index];
                    if (player && defender) {
                        try {
                            defender.playerId = player.id;
                            defender.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                            // Preserve essential defender stats (zoneCoverage, manCoverage) while updating from roster
                            const originalZoneCov = defender.stats?.zoneCoverage || 70;
                            const originalManCov = defender.stats?.manCoverage || 70;
                            defender.stats = {
                                ...player.stats,
                                zoneCoverage: player.stats.zoneCoverage || originalZoneCov,
                                manCoverage: player.stats.manCoverage || originalManCov
                            };
                            defender.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                            defender.overall = player.overall;
                            // Update name label TextBlocks
                            if (defender.nameTextBlock) {
                                defender.nameTextBlock.text = defender.displayName.toUpperCase();
                            }
                            if (defender.ovrTextBlock) {
                                defender.ovrTextBlock.text = getRatingText(player.overall);
                            }
                            if (defender.nameLabel) {
                                defender.nameLabel.background = getDefenderLabelBg(player.overall);
                            }
                            console.log(`[ROSTER] Defender ${index} updated: ${defender.displayName} (${defender.overall})`);
                        } catch (e) {
                            console.error(`[ROSTER] Error updating defender ${index}:`, e);
                        }
                    }
                });
            }

            // Update O-Line
            managementState.team.depthChart.OL.forEach((playerId, index) => {
                const player = managementState.team.roster.find(p => p.id === playerId);
                const oLineman = gameState.offensiveLine[index];
                if (player && oLineman) {
                    try {
                        oLineman.playerId = player.id;
                        oLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        oLineman.stats = { ...player.stats };
                        oLineman.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                        console.log(`[ROSTER] O-Line ${index} updated: ${oLineman.displayName}`);
                    } catch (e) {
                        console.error(`[ROSTER] Error updating O-Line ${index}:`, e);
                    }
                }
            });

            // Update D-Line from opponent's roster
            if (opponent && opponent.roster) {
                const oppDL = opponent.roster
                    .filter(p => p.position === 'DL')
                    .sort((a, b) => b.overall - a.overall);

                gameState.defensiveLine.forEach((dLineman, index) => {
                    const player = oppDL[index];
                    if (player && dLineman) {
                        try {
                            dLineman.playerId = player.id;
                            dLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                            dLineman.stats = { ...player.stats };
                            dLineman.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                            console.log(`[ROSTER] D-Line ${index} updated: ${dLineman.displayName}`);
                        } catch (e) {
                            console.error(`[ROSTER] Error updating D-Line ${index}:`, e);
                        }
                    }
                });
            }
        }

        // Called when a drive/possession ends in the arcade game
        function onPossessionComplete(points) {
            if (!managementState.matchInProgress) return;

            const result = recordPossessionResult(points);

            // Handle case where recordPossessionResult returns undefined
            if (!result) {
                console.error('recordPossessionResult returned undefined');
                gameState.waitingForPossession = false;
                resetPlay(gameState.scene);
                return;
            }

            if (!result.ongoing) {
                showMatchEnd(result);
            } else {
                // Show enemy drive result between possessions
                showEnemyDriveResult(result);
            }
        }

        // Helper to create catch probability bar HTML
        // Shows QB roll vs catch window - lower roll is better (exponential distribution)
        function createCatchBarHTML(catchInfo, small = false) {
            if (!catchInfo) return '';

            const barWidth = small ? 80 : 100;
            const barHeight = small ? 10 : 14;
            const fontSize = small ? 10 : 12;

            const success = catchInfo.catchSuccess;
            const catchWindow = catchInfo.catchProb;
            // Scale the roll position: catchProb is the threshold, show roll relative to it
            // Bar shows 0-100 scale where catchWindow% is the "safe zone"
            const rollPosition = Math.min(100, (catchInfo.qbRoll / Math.max(1, catchWindow)) * catchWindow);

            return `
                <div style="display: inline-flex; align-items: center; gap: 6px; font-family: 'Courier New', monospace; font-size: ${fontSize}px;">
                    <span style="color: ${success ? '#4f4' : '#f66'}; font-weight: bold;">${success ? 'CATCH!' : 'INCOMPLETE'}</span>
                    <div style="position: relative; width: ${barWidth}px; height: ${barHeight}px; background: #222; border-radius: 2px; overflow: visible;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${catchWindow}%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 2px;"></div>
                        <div style="position: absolute; top: -1px; left: ${Math.min(98, rollPosition)}%; transform: translateX(-50%); font-size: ${fontSize}px; font-weight: bold; text-shadow: 0 0 2px #000; color: ${success ? '#4f4' : '#f44'}; line-height: ${barHeight}px;">${success ? '‚úì' : '‚úó'}</div>
                    </div>
                    <span style="color: #888; font-size: ${fontSize - 1}px;">${catchInfo.effectiveCatchPct}%</span>
                </div>
            `;
        }

        // Helper to create pressure bar HTML
        function createPressureBarHTML(pressureInfo) {
            if (!pressureInfo) return '';

            const pressure = pressureInfo.totalPressure;
            const level = pressureInfo.pressureLevel;
            const colors = {
                'light': '#4a4',
                'moderate': '#aa4',
                'heavy': '#f84',
                'extreme': '#f44'
            };
            const color = colors[level] || '#888';

            return `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px; width: 60px;">PRESSURE</span>
                    <div style="position: relative; width: 80px; height: 8px; background: #222; border-radius: 2px;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${pressure}%; background: ${color}; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                    <span style="color: ${color}; font-size: 10px; text-transform: uppercase;">${level}</span>
                </div>
            `;
        }

        // Show enemy drive result overlay with detailed simulation info
        function showEnemyDriveResult(result) {
            const game = managementState.season.schedule[managementState.season.week - 1];
            const plays = result.enemyResult.plays || []; // Array of detailed play objects
            const delayPerPlay = plays.length > 0 ? 1200 : 500; // Time between plays

            console.log('showEnemyDriveResult - plays count:', plays.length);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'enemyDriveOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                font-family: 'Courier New', monospace;
            `;

            const pointsColor = result.enemyResult.points > 0 ? '#f44' : '#4f4';
            const pointsText = result.enemyResult.points > 0
                ? `+${result.enemyResult.points} points`
                : 'Defensive Stop!';

            overlay.innerHTML = `
                <div style="background: #1a1a2e; border: 2px solid #333; border-radius: 12px; padding: 20px; max-width: 700px; width: 95%; text-align: center; max-height: 90vh; display: flex; flex-direction: column;">
                    <h2 style="color: #888; margin: 0 0 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; flex-shrink: 0;">
                        ${game.opponent.name} Possession
                    </h2>
                    <div id="playsScrollContainer" style="flex: 1; overflow-y: auto; min-height: 200px; max-height: 400px; padding: 8px; background: #151528; border-radius: 8px; margin-bottom: 12px;">
                        <div id="playsContainer" style="text-align: left;">
                        </div>
                    </div>
                    <div id="driveResult" style="display: none; flex-shrink: 0;">
                        <div style="color: ${pointsColor}; font-size: 24px; font-weight: bold; margin-bottom: 12px;">
                            ${pointsText}
                        </div>
                        <div style="color: #aaa; margin-bottom: 12px;">
                            <span style="color: #4af;">You: ${result.score.player}</span>
                            &nbsp;-&nbsp;
                            <span style="color: #f44;">${game.opponent.name}: ${result.score.opponent}</span>
                        </div>
                        <div style="color: #666; margin-bottom: 12px; font-size: 12px;">
                            ${getGamePhaseDisplay(result)}
                        </div>
                        ${result.message ? `<div style="color: #fa4; margin-bottom: 12px; font-size: 14px; font-weight: bold;">${result.message}</div>` : ''}
                        <button id="btnContinueDrive" style="
                            background: #4a4; color: white; border: none;
                            padding: 12px 30px; border-radius: 6px; cursor: pointer;
                            font-size: 16px; transition: background 0.2s;
                        ">Continue</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            const playsContainer = document.getElementById('playsContainer');
            const scrollContainer = document.getElementById('playsScrollContainer');
            let playIndex = 0;

            // Format a detailed play display
            const formatPlayDetails = (play, playNum) => {
                if (!play) return '<div style="color: #ccc;">Loading...</div>';

                const opponent = result.enemyResult.opponent || game.opponent;
                const teamShort = (opponent?.name || 'Enemy').split(' ')[0];
                const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

                // Determine border color based on play result
                const borderColor = play.type === 'sack' ? '#4f4' :
                                   play.type === 'interception' ? '#4f4' :
                                   play.type === 'incomplete' ? '#4af' :
                                   play.type === 'touchdown' ? '#f44' :
                                   play.type === 'complete' ? '#fa4' : '#555';

                let html = `<div style="background: #202038; border-radius: 6px; padding: 10px; margin-bottom: 8px; border-left: 4px solid ${borderColor};">`;

                // Play number and down/distance header - improved contrast
                const downStr = getDownString(play.down);
                const fieldPos = 100 - play.yardsFromGoal;
                const fieldPosStr = fieldPos > 50 ? `OPP ${100 - fieldPos}` : `OWN ${fieldPos}`;
                html += `<div style="color: #ddd; font-size: 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <span><span style="color: #888;">Play ${playNum}:</span> <span style="color: #fff; font-weight: bold;">${downStr} & ${play.yardsToGo}</span></span>
                    <span style="color: #aaa; background: #333; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${fieldPosStr}</span>
                </div>`;

                // Round events timeline (compact format)
                if (play.roundEvents && play.roundEvents.length > 0) {
                    html += `<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; font-size: 10px;">`;
                    play.roundEvents.forEach(re => {
                        re.events.forEach(ev => {
                            let badge = '';
                            if (ev.type === 'pressure') {
                                const pColor = ev.result === 'beaten badly' ? '#f44' : ev.result === 'beaten' ? '#f84' : '#fa4';
                                badge = `<span style="background: ${pColor}22; color: ${pColor}; padding: 2px 5px; border-radius: 3px; border: 1px solid ${pColor}44;">R${re.round} ‚ö°${ev.player} ${ev.result}</span>`;
                            } else if (ev.type === 'route_break') {
                                badge = `<span style="background: #4af22; color: #4af; padding: 2px 5px; border-radius: 3px; border: 1px solid #4af44;">R${re.round} WR${ev.wr} +${ev.momentum} sep</span>`;
                            } else if (ev.type === 'sack') {
                                badge = `<span style="background: #4f422; color: #4f4; padding: 2px 5px; border-radius: 3px; border: 1px solid #4f444; font-weight: bold;">R${re.round} SACK!</span>`;
                            } else if (ev.type === 'throw') {
                                const throwColor = ev.catchProb > 70 ? '#4f4' : ev.catchProb > 40 ? '#fa4' : '#f44';
                                badge = `<span style="background: ${throwColor}22; color: ${throwColor}; padding: 2px 5px; border-radius: 3px; border: 1px solid ${throwColor}44;">R${re.round} ‚Üí WR${ev.target} (${ev.catchProb}%)</span>`;
                            }
                            html += badge;
                        });
                    });
                    html += `</div>`;
                }

                if (play.type === 'sack') {
                    // Sack play
                    const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your DL';
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #203a2a; border-radius: 4px;">`;
                    html += `<div style="color: #44ff44; font-size: 14px; font-weight: bold;">üî• SACK! ${dlName} breaks through!</div>`;
                    html += `<div style="color: #aaa; font-size: 11px; margin-top: 4px;">${qbName} taken down for <span style="color: #44ff44; font-weight: bold;">${Math.abs(play.yardsGained)} yard loss</span></div>`;

                    // DL matchup details - collapsible
                    if (play.pressureInfo?.matchups) {
                        html += `<details style="margin-top: 6px;">`;
                        html += `<summary style="color: #888; cursor: pointer; font-size: 10px;">View line matchups</summary>`;
                        html += `<div style="margin-top: 4px; padding: 6px; background: #1e1e35; border-radius: 4px; font-size: 10px;">`;
                        play.pressureInfo.matchups.slice(0, 3).forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#ff4444' : m.result === 'beaten' ? '#ff8844' : m.result === 'pressured' ? '#ffaa44' : '#44aa44';
                            html += `<div style="display: flex; justify-content: space-between; color: #ccc; margin: 2px 0; padding: 2px 4px; background: #252545; border-radius: 2px;">
                                <span style="color: #44aaff;">${getPlayerFullName(m.dl)}</span>
                                <span><span style="color: #44aaff;">${m.dlRoll}</span> vs <span style="color: #ff9944;">${m.olRoll}</span> ‚Üí <span style="color: ${resultColor}; font-weight: bold;">${m.result}</span></span>
                            </div>`;
                        });
                        html += `</div></details>`;
                    }
                    html += `</div>`;
                } else if (play.fieldGoalAttempt) {
                    // Field goal attempt
                    const distance = play.yardsFromGoal + 17;
                    const successColor = play.fieldGoalSuccess ? '#44ff44' : '#ff4444';
                    const emoji = play.fieldGoalSuccess ? '‚úì' : '‚úó';
                    html += `<div style="margin-top: 8px; padding: 8px; background: ${play.fieldGoalSuccess ? '#3a2a20' : '#203a2a'}; border-radius: 4px;">`;
                    html += `<div style="color: ${successColor}; font-size: 14px; font-weight: bold;">${emoji} Field Goal ${play.fieldGoalSuccess ? 'GOOD' : 'MISSED'} from ${distance} yards!</div>`;
                    html += `</div>`;
                } else if (play.type === 'scramble') {
                    // QB scramble
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #3a3a20; border-radius: 4px;">`;
                    html += `<div style="color: #ffaa44; font-size: 13px; font-weight: bold;">üèÉ QB Scramble!</div>`;
                    html += `<div style="color: #ccc; font-size: 11px; margin-top: 4px;">${qbName} takes off for <span style="color: #ffaa44; font-weight: bold;">${play.yardsGained} yards</span></div>`;
                    html += `</div>`;
                } else if (play.type === 'throwaway') {
                    // Throwaway
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #252540; border-radius: 4px;">`;
                    html += `<div style="color: #aaa; font-size: 13px;">üì§ Throwaway</div>`;
                    html += `<div style="color: #888; font-size: 11px; margin-top: 4px;">${qbName} throws it away under pressure</div>`;
                    html += `</div>`;
                } else if (play.type === 'interception') {
                    // Interception
                    html += createPressureBarHTML(play.pressureInfo);
                    const interceptedBy = play.interceptedBy ? getPlayerFullName(play.interceptedBy) : 'Your DB';
                    html += `<div style="margin-top: 8px; padding: 8px; background: #203a2a; border-radius: 4px;">`;
                    html += `<div style="color: #44ff44; font-size: 14px; font-weight: bold;">üéØ INTERCEPTION!</div>`;
                    html += `<div style="color: #aaa; font-size: 11px; margin-top: 4px;">Picked off by <span style="color: #44aaff; font-weight: bold;">${interceptedBy}</span>!</div>`;
                    html += `</div>`;
                } else {
                    // Pass play (complete/incomplete)
                    const catchInfo = play.catchInfo;
                    const wrName = catchInfo?.receiver ? getPlayerFullName(catchInfo.receiver) : `${teamShort} WR`;
                    const cbName = catchInfo?.cb ? getPlayerFullName(catchInfo.cb) : 'Your CB';

                    // Pressure bar
                    html += createPressureBarHTML(play.pressureInfo);

                    // Target info - improved contrast
                    html += `<div style="margin: 8px 0; font-size: 12px; padding: 6px; background: #282848; border-radius: 4px;">`;
                    html += `<span style="color: #bbb;">Target:</span> <span style="color: #ff9944; font-weight: bold;">${wrName}</span>`;
                    if (play.targetSlot) html += ` <span style="color: #888;">(${play.targetSlot})</span>`;
                    html += ` <span style="color: #bbb;">vs</span> <span style="color: #44aaff; font-weight: bold;">${cbName}</span>`;
                    html += `</div>`;

                    // Show line matchups in compact format
                    if (play.pressureInfo?.matchups && play.pressureInfo.matchups.length > 0) {
                        html += `<details style="margin-top: 6px; background: #1e1e35; border-radius: 4px; padding: 6px;">`;
                        html += `<summary style="color: #aaa; cursor: pointer; font-size: 11px; user-select: none;">üìä Line Clashes (Pressure: <span style="color: #fff;">${play.pressureInfo.totalPressure}</span>)</summary>`;
                        html += `<div style="margin-top: 6px; font-size: 10px;">`;
                        play.pressureInfo.matchups.forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#f44' : m.result === 'beaten' ? '#f84' : m.result === 'pressured' ? '#fa4' : m.result === 'held' ? '#aa4' : '#4a4';
                            html += `<div style="display: flex; justify-content: space-between; color: #ccc; margin: 2px 0; padding: 2px 4px; background: #252545; border-radius: 2px;">
                                <span style="color: #44aaff;">${getPlayerFullName(m.dl)}</span>
                                <span><span style="color: #44aaff;">${m.dlRoll}</span> vs <span style="color: #ff9944;">${m.olRoll}</span> ‚Üí <span style="color: ${resultColor}; font-weight: bold;">${m.result}</span></span>
                            </div>`;
                        });
                        html += `</div></details>`;
                    }

                    if (catchInfo) {
                        // Matchup details box - improved contrast
                        html += `<div style="background: #1e1e35; border-radius: 4px; padding: 8px; margin: 8px 0; font-size: 11px;">`;
                        html += `<div style="color: #aaa; font-size: 10px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">Coverage Matchup</div>`;

                        // WR vs CB separation roll - clearer layout
                        const sepColor = catchInfo.separationMargin > 5 ? '#44ff44' : catchInfo.separationMargin < -5 ? '#ff4444' : '#ffaa44';
                        const sepLabel = catchInfo.coverageCloseness < 0.2 ? 'OPEN' :
                                        catchInfo.coverageCloseness < 0.4 ? 'SPACE' :
                                        catchInfo.coverageCloseness < 0.6 ? 'CONTESTED' :
                                        catchInfo.coverageCloseness < 0.8 ? 'TIGHT' : 'SMOTHERED';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">Separation</span>
                            <span>WR <span style="color: #ff9944; font-weight: bold;">${catchInfo.wrRoll}</span> vs CB <span style="color: #44aaff; font-weight: bold;">${catchInfo.cbRoll}</span> ‚Üí <span style="color: ${sepColor}; font-weight: bold;">${sepLabel}</span></span>
                        </div>`;

                        // Momentum advantage display (if route had direction change)
                        if (catchInfo.momentumAdvantage && catchInfo.momentumAdvantage > 0) {
                            const momColor = catchInfo.momentumAdvantage >= 15 ? '#44ff44' :
                                           catchInfo.momentumAdvantage >= 8 ? '#88ff44' : '#ffaa44';
                            const reactionLabel = catchInfo.dbReactionDelay >= 2 ? 'SLOW' :
                                                 catchInfo.dbReactionDelay >= 1 ? 'delayed' : 'quick';
                            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                                <span style="color: #ccc;">Route Break (AWR ${catchInfo.dbAwareness})</span>
                                <span style="color: ${momColor}; font-weight: bold;">+${catchInfo.momentumAdvantage} <span style="color: #888; font-weight: normal;">(${reactionLabel})</span></span>
                            </div>`;
                        }

                        // Coverage penalty
                        const penaltyColor = catchInfo.defenderPenalty > 20 ? '#ff4444' : catchInfo.defenderPenalty > 10 ? '#ffaa44' : '#44ff44';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">CB Penalty</span>
                            <span style="color: ${penaltyColor}; font-weight: bold;">-${catchInfo.defenderPenalty}</span>
                        </div>`;

                        // Catch window
                        const focusStr = catchInfo.focusMod > 0 ? `+${catchInfo.focusMod}` : '';
                        const catchColor = catchInfo.catchProb > 70 ? '#44ff44' : catchInfo.catchProb > 40 ? '#ffaa44' : '#ff4444';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #303060; border-radius: 3px;">
                            <span style="color: #ddd;">Catch Window</span>
                            <span style="color: ${catchColor}; font-weight: bold; font-size: 13px;">${catchInfo.catchProb}%</span>
                        </div>`;

                        // QB throw quality - simplified display
                        const qbColor = catchInfo.catchSuccess ? '#44ff44' : '#ff4444';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">QB Roll (ACC ${catchInfo.qbAccuracy})</span>
                            <span style="color: ${qbColor}; font-weight: bold;">${catchInfo.qbRoll} ${catchInfo.catchSuccess ? '< ' + catchInfo.catchProb + ' ‚úì' : '‚â• ' + catchInfo.catchProb + ' ‚úó'}</span>
                        </div>`;

                        html += `</div>`;
                    }

                    // Result with catch bar - improved styling
                    html += `<div style="margin-top: 8px; padding: 8px; background: ${play.type === 'complete' || play.type === 'touchdown' ? '#3a2a20' : '#203a2a'}; border-radius: 4px;">`;
                    if (play.type === 'complete' || play.type === 'touchdown') {
                        if (play.type === 'touchdown' || play.isTouchdown) {
                            html += `<div style="color: #ff4444; font-size: 14px; font-weight: bold;">üèà TOUCHDOWN! ${play.yardsGained} yards!</div>`;
                        } else {
                            html += `<div style="color: #ffcc88; font-size: 12px;">${wrName} catches for <span style="color: #ff9944; font-weight: bold;">${play.yardsGained} yards</span></div>`;
                        }
                        html += `<div style="margin-top: 6px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    } else {
                        html += `<div style="color: #44ff44; font-size: 12px; font-weight: bold;">üõ°Ô∏è Pass broken up by ${cbName}!</div>`;
                        html += `<div style="margin-top: 6px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            };

            // Show plays progressively in scrolling container
            const showNextPlay = () => {
                if (playIndex < plays.length) {
                    const play = plays[playIndex];

                    // Add play to container
                    const playDiv = document.createElement('div');
                    playDiv.innerHTML = formatPlayDetails(play, playIndex + 1);
                    playDiv.style.opacity = '0';
                    playDiv.style.transition = 'opacity 0.3s';
                    playsContainer.appendChild(playDiv);

                    // Fade in and scroll to show new play
                    setTimeout(() => {
                        playDiv.style.opacity = '1';
                        scrollContainer.scrollTop = scrollContainer.scrollHeight;
                    }, 50);

                    playIndex++;
                    setTimeout(showNextPlay, delayPerPlay);
                } else {
                    // All plays shown - add final result banner
                    const resultBanner = document.createElement('div');
                    resultBanner.style.cssText = `text-align: center; padding: 15px; color: ${pointsColor}; font-size: 16px; font-weight: bold; background: #252540; border-radius: 6px; border-left: 3px solid ${pointsColor};`;
                    const driveType = result.enemyResult.type;
                    resultBanner.textContent = (driveType === 'TD' || driveType === 'touchdown') ? 'TOUCHDOWN!' :
                        (driveType === 'FG' || driveType === 'field_goal') ? 'FIELD GOAL!' :
                        (driveType === 'PUNT' || driveType === 'punt') ? 'Forced to Punt!' :
                        (driveType === 'MISSED_FG' || driveType === 'missed_fg') ? 'Field Goal Missed!' :
                        driveType === 'turnover' ? 'TURNOVER!' : 'Drive Stopped!';
                    playsContainer.appendChild(resultBanner);
                    scrollContainer.scrollTop = scrollContainer.scrollHeight;

                    setTimeout(() => {
                        document.getElementById('driveResult').style.display = 'block';
                        document.getElementById('btnContinueDrive').addEventListener('click', () => {
                            overlay.remove();
                            gameState.waitingForPossession = false;
                            resetPlay(gameState.scene);
                        });
                    }, 300);
                }
            };

            // Start showing plays after a brief pause
            setTimeout(showNextPlay, 400);
        }

        // Main
        const scene = createScene();
        setupInput(scene);
        setupIdleAnimations(scene);

        // Handle visibility changes (app switching) - clear stale pointer state
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // App is being hidden - clear any in-progress drag
                gameState.isDragging = false;
                gameState.activePointerId = null;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            }
        });

        // Initialize management system
        initializeManagement();

        // Setup HTML button handlers
        document.getElementById('btnNewGame').addEventListener('click', () => {
            startNewGame();
            // Draft screen is shown by startNewGame() via startDraft()
        });
        document.getElementById('btnContinue').addEventListener('click', () => {
            if (managementState.initialized) showScreen('hub');
        });
        document.getElementById('btnTrainingMode').addEventListener('click', () => {
            startTrainingMode();
        });
        document.getElementById('btnExitTraining').addEventListener('click', () => {
            exitTrainingMode();
        });
        // Training settings panel toggle
        document.getElementById('btnTrainingSettings').addEventListener('click', () => {
            const panel = document.getElementById('trainingSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        // Game speed controls
        document.getElementById('btnGameSpeedDown').addEventListener('click', () => {
            adjustGameSpeed(-0.1);
            document.getElementById('gameSpeedDisplay').textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        });
        document.getElementById('btnGameSpeedUp').addEventListener('click', () => {
            adjustGameSpeed(0.1);
            document.getElementById('gameSpeedDisplay').textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        });
        // Ball speed controls
        document.getElementById('btnBallSpeedDown').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.max(0.5, gameState.ballSpeedMultiplier - 0.1);
            document.getElementById('ballSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });
        document.getElementById('btnBallSpeedUp').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.min(2.0, gameState.ballSpeedMultiplier + 0.1);
            document.getElementById('ballSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });
        // Grade popup toggle
        document.getElementById('btnToggleGradePopup').addEventListener('click', () => {
            gameState.showGradePopup = !gameState.showGradePopup;
            const btn = document.getElementById('btnToggleGradePopup');
            btn.textContent = gameState.showGradePopup ? 'ON' : 'OFF';
            btn.style.background = gameState.showGradePopup ? '#4a4' : '#444';
        });
        // Receiver speed preset buttons
        document.querySelectorAll('.rcvr-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = btn.dataset.speed;
                gameState.receiverSpeedPreset = speed === 'mixed' ? 'mixed' : parseInt(speed);
                document.querySelectorAll('.rcvr-speed-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyReceiverSpeedPreset();
            });
        });
        // DB speed preset buttons
        document.querySelectorAll('.db-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = btn.dataset.speed;
                gameState.dbSpeedPreset = speed === 'mixed' ? 'mixed' : parseInt(speed);
                document.querySelectorAll('.db-speed-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyDbSpeedPreset();
            });
        });
        document.getElementById('btnPlayGame').addEventListener('click', () => {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) return;
            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) return;
            // Skip pre_game for testing, go directly to game
            const result = startMatch();
            if (result.success) startArcadeGame();
        });
        document.getElementById('btnStartGame').addEventListener('click', () => {
            const result = startMatch();
            if (result.success) startArcadeGame();
        });
        document.getElementById('btnSimulateGame').addEventListener('click', () => {
            const simResult = simulateFullGame();
            if (simResult.success) {
                // End match to record result and get matchResult object
                const matchResult = endMatch();
                if (matchResult) {
                    showMatchEnd(matchResult);
                }
            }
        });
        document.getElementById('btnPreGameBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnRoster').addEventListener('click', () => showScreen('roster'));
        document.getElementById('btnFreeAgency').addEventListener('click', () => showScreen('free_agency'));
        document.getElementById('btnSchedule').addEventListener('click', () => showScreen('schedule'));
        document.getElementById('btnFacilities').addEventListener('click', () => showScreen('facilities'));
        document.getElementById('btnHubTraining').addEventListener('click', () => startTrainingMode());
        document.getElementById('btnHubNewGame').addEventListener('click', () => {
            if (confirm("Start a new game? All progress will be lost!")) {
                SaveSystem.clear();
                managementState.initialized = false;
                managementState.team = null;
                managementState.season = null;
                managementState.freeAgents = [];
                startNewGame();
                // Draft screen is shown by startNewGame() via startDraft()
            }
        });
        document.getElementById('btnRosterBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFABack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnScheduleBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFacilitiesBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnMatchContinue').addEventListener('click', () => {
            if (managementState.seasonJustEnded) {
                managementState.seasonJustEnded = false;
                startDraft(false);  // Start offseason draft
            } else {
                showScreen('hub');
            }
        });
        document.getElementById('btnShowSimLog').addEventListener('click', () => {
            const container = document.getElementById('simLogContainer');
            const btn = document.getElementById('btnShowSimLog');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                btn.textContent = 'HIDE LOG';
            } else {
                container.style.display = 'none';
                btn.textContent = 'VIEW LOG';
            }
        });
        document.getElementById('btnCopySimLog').addEventListener('click', () => {
            const logText = getSimulationLog();
            navigator.clipboard.writeText(logText).then(() => {
                const btn = document.getElementById('btnCopySimLog');
                btn.textContent = 'COPIED!';
                setTimeout(() => { btn.textContent = 'COPY TO CLIPBOARD'; }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        });
        document.getElementById('btnUpgradeArena').addEventListener('click', () => {
            upgradeFacility('stadium');
            refreshFacilitiesScreen();
        });
        document.getElementById('btnUpgradeTraining').addEventListener('click', () => {
            upgradeFacility('trainingCenter');
            refreshFacilitiesScreen();
        });

        // Draft screen handlers
        document.getElementById('btnSkipRound').addEventListener('click', () => {
            skipDraftPick();
        });
        document.getElementById('btnFinishDraft').addEventListener('click', () => {
            finishDraft();
        });
        document.getElementById('btnDraftPoolView').addEventListener('click', () => {
            toggleDraftView(false);
        });
        document.getElementById('btnDraftRosterView').addEventListener('click', () => {
            toggleDraftView(true);
        });

        // Draft navigation handlers
        document.getElementById('btnNextPick').addEventListener('click', () => {
            simulateNextComputerPick();
        });

        document.getElementById('btnSkipToYourPick').addEventListener('click', () => {
            skipToPlayerTurn();
        });

        // Pick trading handlers
        document.getElementById('btnTradeInPick').addEventListener('click', () => {
            if (tradeInPick()) {
                // Show feedback
                const btn = document.getElementById('btnTradeInPick');
                const originalText = btn.textContent;
                btn.textContent = 'PICK TRADED!';
                btn.disabled = true;
                setTimeout(() => {
                    btn.textContent = originalText;
                    refreshDraftScreen();
                }, 1000);
            }
        });

        document.getElementById('btnAcquirePick').addEventListener('click', () => {
            if (acquireCurrentPick()) {
                // Show feedback
                const btn = document.getElementById('btnAcquirePick');
                btn.textContent = 'PICK ACQUIRED!';
                btn.disabled = true;
                setTimeout(() => {
                    refreshDraftScreen();
                }, 1000);
            }
        });

        // Draft options modal handlers
        document.getElementById('btnDraftOptions').addEventListener('click', () => {
            // Load current settings into inputs
            document.getElementById('pickTradeInPenalty').value = managementState.settings.pickTradeInPenalty || 50;
            document.getElementById('pickAcquirePremium').value = managementState.settings.pickAcquirePremium || 10;
            document.getElementById('draftOptionsModal').style.display = 'flex';
        });

        document.getElementById('btnSaveDraftOptions').addEventListener('click', () => {
            // Save settings
            managementState.settings.pickTradeInPenalty = parseInt(document.getElementById('pickTradeInPenalty').value) || 50;
            managementState.settings.pickAcquirePremium = parseInt(document.getElementById('pickAcquirePremium').value) || 10;
            document.getElementById('draftOptionsModal').style.display = 'none';
            // Refresh draft screen to show updated values
            if (draftState.active) {
                refreshDraftScreen();
            }
            // Save if auto-save is on
            if (managementState.settings.autoSave) SaveSystem.save();
        });

        document.getElementById('btnCloseDraftOptions').addEventListener('click', () => {
            document.getElementById('draftOptionsModal').style.display = 'none';
        });

        // Player detail modal handlers
        document.getElementById('btnCloseDetail').addEventListener('click', () => {
            // Reset draft player state when closing
            if (draftState.selectedDraftPlayer) {
                draftState.selectedDraftPlayer = null;
                // Restore cut button visibility
                document.getElementById('btnCutPlayer').style.display = 'block';
            }
            closePlayerDetail();
        });
        document.getElementById('btnCutPlayer').addEventListener('click', cutPlayerFromDetail);
        console.log('Setting up btnTradePlayer click handler...');
        const tradeBtnEl = document.getElementById('btnTradePlayer');
        console.log('Found btnTradePlayer element:', tradeBtnEl);
        if (!tradeBtnEl) {
            console.error('ERROR: btnTradePlayer not found in DOM!');
            alert('ERROR: Draft button not found!');
        }
        tradeBtnEl.addEventListener('click', (e) => {
            console.log('Trade/Draft button clicked', e);
            // Handle draft player differently
            if (draftState.selectedDraftPlayer) {
                console.log('Selected draft player:', draftState.selectedDraftPlayer);
                const playerId = draftState.selectedDraftPlayer.id;
                const playerName = draftState.selectedDraftPlayer.name;
                console.log('Attempting to draft player ID:', playerId);
                const result = draftPlayer(playerId);
                console.log('draftPlayer result:', result);
                if (result) {
                    console.log('Draft succeeded! Showing confirmation...');
                    draftState.selectedDraftPlayer = null;
                    // Show confirmation on the button briefly
                    const btn = document.getElementById('btnTradePlayer');
                    btn.textContent = 'DRAFTED!';
                    btn.style.backgroundColor = '#4CAF50';
                    console.log('Button updated to DRAFTED!, closing modal in 600ms...');
                    setTimeout(() => {
                        console.log('Timeout fired, closing modal...');
                        btn.textContent = 'DRAFT';
                        btn.style.backgroundColor = '';
                        closePlayerDetail();
                    }, 600);
                } else {
                    // Draft failed - show error briefly
                    console.log('Draft failed - showing error on button');
                    const btn = document.getElementById('btnTradePlayer');
                    const originalText = btn.textContent;
                    btn.textContent = 'FAILED!';
                    btn.style.backgroundColor = '#f44';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 1000);
                }
            } else {
                tradePlayerFromDetail();
            }
        });

        // Show initial screen
        showScreen(managementState.currentScreen);

        // Heat map toggle button
        const heatMapBtn = document.getElementById('btnHeatMap');
        const updateHeatMapButton = () => {
            heatMapBtn.textContent = gameState.showThrowHeatMap ? 'Heat Map: ON' : 'Heat Map: OFF';
            heatMapBtn.classList.toggle('active', gameState.showThrowHeatMap);
        };
        heatMapBtn.addEventListener('click', () => {
            gameState.showThrowHeatMap = !gameState.showThrowHeatMap;
            if (!gameState.showThrowHeatMap) clearThrowHeatMap();
            updateHeatMapButton();
        });
        updateHeatMapButton();

        // Render loop - try/catch prevents silent failures from stopping rendering
        // See TRAINING_MODE_FIX.md for why this is important
        engine.runRenderLoop(() => {
            try {
                scene.render();
            } catch (e) {
                console.error('Render error:', e);
                console.error('Stack:', e.stack);
            }
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
