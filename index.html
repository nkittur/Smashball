<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 36px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            border-bottom: 1px solid #333;
        }

        #score {
            color: #ffd700;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }

        #score .catches { color: #8cf; }
        #score .touchdowns { color: #4f4; }
        #score .label { color: #888; }

        #downDistance {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40, 40, 40, 0.9);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        #downDistance .down { color: #ffa; }
        #downDistance .distance { color: #aef; }

        #viewButtons {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        #viewButtons button {
            background: rgba(60, 60, 60, 0.9);
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 14px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        #viewButtons button:hover {
            background: rgba(80, 80, 80, 0.9);
            color: #fff;
        }
        #viewButtons button.active {
            background: rgba(70, 90, 120, 0.9);
            border-color: #68a;
            color: #fff;
        }

        #debugInfo {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: left;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
            white-space: pre-wrap;
        }
        #catchDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #catchDisplay.visible {
            opacity: 1;
        }
        #catchDisplay .catch-header {
            font-size: 11px;
            font-weight: bold;
        }
        #catchDisplay .catch-header.success { color: #4f4; }
        #catchDisplay .catch-header.fail { color: #f66; }
        #catchDisplay .catch-bar {
            position: relative;
            width: 100px;
            height: 14px;
            background: #222;
            border-radius: 2px;
            overflow: visible;
        }
        #catchDisplay .catch-bar-base {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #3a3, #4b4);
            border-radius: 2px;
        }
        #catchDisplay .catch-bar-penalty {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
            border-left: 1px solid #f55;
        }
        #catchDisplay .catch-bar-roll {
            position: absolute;
            top: -1px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            transform: translateX(-50%);
            line-height: 14px;
        }
        #catchDisplay .catch-bar-roll.success { color: #4f4; }
        #catchDisplay .catch-bar-roll.fail { color: #f44; }
        #catchDisplay .defender-info {
            font-size: 10px;
            color: #f99;
        }
        #catchDisplay .throw-rating-info {
            font-size: 10px;
            color: #9cf;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="topBar">
        <div id="downDistance">
            <span class="down">1st</span> & <span class="distance">10</span>
        </div>
        <div id="score">
            <span><span class="label">Catches</span> <span class="catches">0/0</span></span>
            <span><span class="label">TD</span> <span class="touchdowns">0</span></span>
        </div>
        <div id="catchDisplay">
            <div class="catch-header">CATCH</div>
            <div class="catch-bar">
                <div class="catch-bar-base"></div>
                <div class="catch-bar-penalty"></div>
                <div class="catch-bar-roll">üèà</div>
            </div>
            <div class="defender-info"></div>
            <div class="throw-rating-info"></div>
        </div>
    </div>
    <div id="viewButtons">
        <button id="viewIso" class="active">Iso</button>
        <button id="viewOverhead">Top</button>
        <button id="viewShoulder">Behind</button>
    </div>
    <div id="debugInfo"></div>

    <!-- Training Mode UI -->
    <div id="trainingModeUI" style="display: none;">
        <button id="btnExitTraining" style="
            position: fixed;
            top: 46px;
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
            color: #ccc;
            border: 1px solid #444;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            z-index: 1001;
        ">‚Üê</button>
        <div id="trainingTitle" style="
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #4a4;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1001;
        ">TRAINING MODE</div>
        <div id="throwRating" style="
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            padding: 15px 30px;
            border-radius: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1000;
            display: none;
        ">
            <div id="throwGrade" style="font-size: 48px; font-weight: bold; color: #4f4;"></div>
            <div id="throwDetails" style="font-size: 14px; color: #aaa; margin-top: 5px;"></div>
            <div id="throwCatchInfo" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #444;">
                <div id="popupCatchHeader" style="font-size: 14px; font-weight: bold; margin-bottom: 6px;">CATCH</div>
                <div id="popupCatchBar" style="position: relative; width: 150px; height: 16px; background: #222; border-radius: 3px; margin: 0 auto; overflow: visible;">
                    <div id="popupCatchBase" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 3px;"></div>
                    <div id="popupCatchPenalty" style="position: absolute; top: 0; height: 100%; background: rgba(0, 0, 0, 0.55); border-left: 1px solid #f55;"></div>
                    <div id="popupCatchRoll" style="position: absolute; top: -2px; font-size: 14px; font-weight: bold; transform: translateX(-50%); line-height: 16px;">üèà</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Management UI Overlay -->
    <div id="managementOverlay">
        <!-- Main Menu -->
        <div id="mainMenuScreen" class="mgmt-screen">
            <h1>SMASHBALL</h1>
            <p class="subtitle">Medieval Football Management</p>
            <button id="btnNewGame" class="mgmt-btn">NEW GAME</button>
            <button id="btnContinue" class="mgmt-btn">CONTINUE</button>
            <button id="btnTrainingMode" class="mgmt-btn" style="margin-top: 30px; background: #2a4a2a;">TRAINING MODE</button>
        </div>

        <!-- Hub Screen -->
        <div id="hubScreen" class="mgmt-screen" style="display:none;">
            <div class="hub-status" id="hubStatus">Fame: 1,000 | Week 1</div>
            <h2>TEAM HUB</h2>
            <div class="hub-buttons">
                <button id="btnPlayGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnRoster" class="mgmt-btn">ROSTER</button>
                <button id="btnFreeAgency" class="mgmt-btn">FREE AGENCY</button>
                <button id="btnSchedule" class="mgmt-btn">SCHEDULE</button>
                <button id="btnFacilities" class="mgmt-btn">FACILITIES</button>
                <button id="btnHubTraining" class="mgmt-btn" style="background: #2a4a2a;">TRAINING</button>
            </div>
            <p id="hubRecord" class="hub-record">Record: 0-0</p>
            <p id="hubNextGame" class="hub-next"></p>
            <button id="btnHubNewGame" class="mgmt-btn danger" style="margin-top: 30px;">NEW GAME</button>
        </div>

        <!-- Roster Screen -->
        <div id="rosterScreen" class="mgmt-screen" style="display:none;">
            <button id="btnRosterBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>ROSTER</h2>
            <div id="rosterList" class="roster-list"></div>
        </div>

        <!-- Free Agency Screen -->
        <div id="freeAgencyScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFABack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FREE AGENCY</h2>
            <p id="faStatus" class="fa-status"></p>
            <div id="freeAgentList" class="roster-list"></div>
        </div>

        <!-- Schedule Screen -->
        <div id="scheduleScreen" class="mgmt-screen" style="display:none;">
            <button id="btnScheduleBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>SCHEDULE</h2>
            <div id="teamStrength" class="team-strength">
                <h3>YOUR TEAM</h3>
                <div class="strength-ratings">
                    <div class="strength-item">
                        <div class="label">OVERALL</div>
                        <div class="value" id="strengthOverall">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">OFFENSE</div>
                        <div class="value" id="strengthOffense">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">DEFENSE</div>
                        <div class="value" id="strengthDefense">--</div>
                    </div>
                </div>
            </div>
            <div id="scheduleList" class="schedule-list"></div>
        </div>

        <!-- Facilities Screen -->
        <div id="facilitiesScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFacilitiesBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FACILITIES</h2>
            <p id="facCredits" class="fac-credits"></p>
            <div class="facility-item">
                <h3>ARENA</h3>
                <p id="arenaLevel">Level 1/5</p>
                <p class="fac-desc">Increases home game revenue</p>
                <button id="btnUpgradeArena" class="mgmt-btn">UPGRADE</button>
            </div>
            <div class="facility-item">
                <h3>TRAINING GROUNDS</h3>
                <p id="trainingLevel">Level 1/5</p>
                <p class="fac-desc">Boosts player development</p>
                <button id="btnUpgradeTraining" class="mgmt-btn">UPGRADE</button>
            </div>
        </div>

        <!-- Match End Screen -->
        <div id="matchEndScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <h1 id="matchResult">VICTORY!</h1>
            <p id="matchScore" class="match-score">21 - 14</p>
            <p id="matchRevenue" class="match-revenue"></p>
            <div id="postGameStats" class="post-game-stats"></div>
            <button id="btnMatchContinue" class="mgmt-btn primary">CONTINUE</button>
        </div>

        <!-- Pre-Game Matchup Screen -->
        <div id="preGameScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <h2 id="preGameOpponent">VS OPPONENT</h2>
            <div id="preGameTeamScores" class="pre-game-team-scores"></div>
            <div id="preGameQBScores" class="pre-game-qb-scores"></div>
            <div id="preGameMatchups" class="pre-game-matchups"></div>
            <button id="btnStartGame" class="mgmt-btn primary">START GAME</button>
        </div>

        <!-- Player Detail Modal -->
        <div id="playerDetailModal" class="mgmt-modal" style="display:none;">
            <div class="modal-content">
                <button id="btnCloseDetail" class="mgmt-btn back-btn">‚Üê</button>
                <h2 id="playerName">Player Name</h2>
                <div id="playerInfo" class="player-info"></div>
                <div id="playerStats" class="player-stats"></div>
                <div id="playerSeasonStats" class="player-season-stats"></div>
                <div id="playerCareerGraph" class="player-career-graph"></div>
                <div class="modal-actions">
                    <button id="btnTradePlayer" class="mgmt-btn primary">TRADE FOR FAME</button>
                    <button id="btnCutPlayer" class="mgmt-btn danger">CUT PLAYER</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        #managementOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #0a0a14;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #managementOverlay.hidden { display: none; }
        .mgmt-screen {
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
            width: 100%;
            max-width: 400px;
        }
        .mgmt-screen h1 {
            color: #ffd700;
            font-size: 48px;
            margin: 0 0 10px 0;
        }
        .mgmt-screen h2 {
            color: #ffd700;
            font-size: 28px;
            margin: 50px 0 20px 0;
        }
        .mgmt-screen .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 40px;
        }
        .mgmt-btn {
            display: block;
            width: 100%;
            max-width: 280px;
            margin: 10px auto;
            padding: 16px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: #2a2a40;
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 8px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .mgmt-btn:active { background: #3a3a50; }
        .mgmt-btn:disabled { opacity: 0.5; }
        .mgmt-btn.primary { background: #3a3a60; }
        .mgmt-btn.back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
        }
        .hub-status {
            position: absolute;
            top: 10px;
            right: 15px;
            text-align: right;
            color: #ffd700;
            font-size: 14px;
        }
        .hub-record { font-size: 20px; margin-top: 30px; }
        .hub-next { color: #aaa; font-size: 14px; }
        .roster-list, .schedule-list {
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .roster-item, .schedule-item {
            background: #1a1a2a;
            padding: 12px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-item .name { font-size: 14px; }
        .roster-item .stats { font-size: 12px; color: #aaa; }
        .roster-item .ovr { color: #4f4; font-size: 16px; }
        .position-header {
            background: #2a2a40;
            color: #ffd700;
            padding: 8px 12px;
            margin-top: 12px;
            font-size: 14px;
        }
        .schedule-item.current { background: #2a3a2a; }
        .schedule-item.past { opacity: 0.6; }
        .schedule-item .result { font-weight: bold; }
        .schedule-item .result.win { color: #4f4; }
        .schedule-item .result.loss { color: #f44; }
        .facility-item {
            background: #1a1a2a;
            padding: 16px;
            margin: 12px 0;
            border-radius: 8px;
            text-align: left;
        }
        .facility-item h3 { color: #ffd700; margin: 0 0 8px 0; font-size: 16px; }
        .fac-desc { color: #888; font-size: 12px; margin: 8px 0; }
        .fac-credits { color: #ffd700; font-size: 18px; }
        .fa-status { color: #aaa; font-size: 14px; }
        .fa-btn { padding: 8px 16px; font-size: 14px; }
        .match-score { font-size: 36px; margin: 20px 0; }
        .match-revenue { color: #4f4; font-size: 18px; margin-bottom: 15px; }
        #matchResult.win { color: #4f4; }
        #matchResult.loss { color: #f44; }

        /* Post-game stats - roster-like layout */
        .post-game-stats {
            max-height: 350px;
            overflow-y: auto;
            margin: 10px 0;
            text-align: left;
        }
        .post-game-section {
            margin-bottom: 12px;
        }
        .post-game-section-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 6px;
            padding-left: 4px;
        }
        .post-game-player {
            background: #1a1a2a;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .post-game-player:hover {
            background: #252540;
        }
        .post-game-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .post-game-player-name {
            font-weight: bold;
            color: #fff;
        }
        .post-game-player-ovr {
            font-weight: bold;
            color: #ffd700;
            font-size: 16px;
        }
        .post-game-player-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 11px;
        }
        .post-game-stat {
            display: flex;
            align-items: baseline;
            gap: 3px;
        }
        .post-game-stat-value {
            color: #4af;
            font-size: 13px;
            font-weight: bold;
        }
        .post-game-stat-label {
            font-size: 10px;
            color: #888;
        }
        .post-game-no-stats {
            color: #555;
            font-size: 11px;
            font-style: italic;
        }

        /* Pre-game matchups */
        .pre-game-matchups {
            margin: 15px 0;
            text-align: left;
        }
        .matchup-section {
            margin: 12px 0;
            padding: 10px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .matchup-section-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .matchup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .matchup-row:last-child { border-bottom: none; }
        .matchup-player {
            flex: 1;
            font-size: 13px;
        }
        .matchup-player.yours { color: #4af; }
        .matchup-player.theirs { color: #f66; text-align: right; }
        .matchup-vs {
            color: #666;
            padding: 0 8px;
            font-size: 11px;
        }
        .matchup-ovr {
            font-weight: bold;
            font-size: 14px;
        }
        .matchup-ovr.advantage { color: #4f4; }
        .matchup-ovr.disadvantage { color: #f44; }
        .matchup-ovr.even { color: #ff0; }

        /* Pre-game team scores */
        .pre-game-team-scores {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .team-score-block {
            text-align: center;
        }
        .team-score-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .team-score-value {
            font-size: 28px;
            font-weight: bold;
        }
        .team-score-value.yours { color: #4af; }
        .team-score-value.theirs { color: #f66; }
        .team-score-vs {
            font-size: 18px;
            color: #666;
            align-self: center;
        }

        /* Pre-game QB scores */
        .pre-game-qb-scores {
            display: flex;
            justify-content: space-around;
            margin: 10px 0 15px 0;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .qb-stat-block {
            text-align: center;
        }
        .qb-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        .qb-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4af;
        }

        /* Player Detail Modal */
        .mgmt-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            overflow-y: auto;
        }
        .modal-content {
            background: #0a0a14;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .modal-content h2 {
            color: #ffd700;
            margin: 40px 0 10px 0;
            text-align: center;
        }
        .player-info {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .player-info .ovr-big {
            font-size: 48px;
            color: #4f4;
            font-weight: bold;
        }
        .player-info .season-change {
            font-size: 18px;
            margin-left: 10px;
        }
        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .stat-row {
            background: #1a1a2a;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }
        .stat-row .stat-name { color: #888; }
        .stat-row .stat-values {
            display: flex;
            align-items: center;
            min-width: 60px;
            justify-content: flex-end;
        }
        .stat-row .stat-value {
            display: inline-block;
            width: 24px;
            text-align: right;
        }
        .stat-row .stat-change {
            display: inline-block;
            width: 28px;
            text-align: right;
            font-size: 11px;
        }
        /* Stat color coding by value */
        .stat-elite { color: #4f4; }      /* 90+ green */
        .stat-good { color: #8f8; }       /* 80-89 light green */
        .stat-average { color: #ff0; }    /* 70-79 yellow */
        .stat-below { color: #f80; }      /* 60-69 orange */
        .stat-poor { color: #f44; }       /* <60 red */
        .stat-change.positive { color: #4f4; }
        .stat-change.negative { color: #f44; }
        /* Season stats section */
        .player-season-stats {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .season-stats-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .season-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        .season-stat-item {
            text-align: center;
        }
        .season-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4f4;
        }
        .season-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        /* Career graph section */
        .player-career-graph {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .career-graph-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .career-graph-container {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 4px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .career-bar {
            flex: 1;
            min-width: 20px;
            max-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .career-bar-fill {
            width: 100%;
            background: linear-gradient(to top, #4f4, #8f8);
            border-radius: 2px 2px 0 0;
            position: relative;
        }
        .career-bar-potential {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-size: 8px;
        }
        .career-bar-label {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }
        .career-bar-ovr {
            font-size: 10px;
            color: #fff;
            margin-bottom: 2px;
        }
        .modal-actions {
            margin-top: 20px;
            text-align: center;
        }
        .mgmt-btn.danger {
            background: #4a2020;
            border-color: #f44;
            color: #f44;
        }
        .roster-item { cursor: pointer; }
        .roster-item:active { background: #2a2a3a; }
        .roster-item .season-gain {
            font-size: 12px;
            margin-left: 8px;
        }
        .season-gain.positive { color: #4f4; }
        .season-gain.negative { color: #f44; }

        /* Team Strength Display */
        .team-strength {
            background: #1a1a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .team-strength h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .strength-ratings {
            display: flex;
            justify-content: space-around;
        }
        .strength-item {
            text-align: center;
        }
        .strength-item .label { color: #888; font-size: 11px; }
        .strength-item .value { color: #4f4; font-size: 20px; font-weight: bold; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        // Game State
        const gameState = {
            catches: 0,
            attempts: 0,            // Total catch attempts
            touchdowns: 0,          // Touchdowns scored
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            activePointerId: null,  // Track which pointer is dragging
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            offensiveLine: [],      // O-line players
            defensiveLine: [],      // D-line players
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0,  // Seconds between time-based clashes
            playStartTime: 0,  // When current play started (for label fading)
            ballCarrier: null,      // Receiver carrying the ball after catch
            playEnded: false,       // Track if play has ended (tackle/sack/TD)
            waitingForPossession: false, // Pause game during possession overlay
            playFrozen: true,       // Play frozen until player holds screen
            qbSacked: false,        // Track if QB was sacked
            qbStartZ: -6,           // QB's randomized starting position (set each play)
            currentView: 'iso',     // Camera view: 'iso', 'overhead', 'shoulder'
            // Down and distance tracking
            down: 1,                // Current down (1-4)
            yardsToGo: 10,          // Yards needed for first down
            lineOfScrimmage: -5,    // Current field position (Z coordinate) - own 30
            firstDownMarker: 5,     // Z position where first down is achieved
            startingLineOfScrimmage: -5,  // Where drive started - own 30 yard line
            // Training mode
            trainingMode: false,    // Training mode: no defenders, throw ratings
            lastThrowRating: null   // Last throw rating for display
        };

        // Per-game stats tracking (reset each match)
        const gameStats = {
            players: {},  // Keyed by playerId

            // Initialize or get player stats
            getPlayer(playerId, name) {
                if (!this.players[playerId]) {
                    this.players[playerId] = {
                        name: name || 'Unknown',
                        // Catching
                        catches: 0,
                        drops: 0,
                        catchDifficulties: [],  // Array of difficulty values
                        yardsAfterCatch: 0,
                        // Throwing (QB)
                        completions: 0,
                        incompletions: 0,
                        throwDistances: [],     // Total distance
                        airDistances: [],       // In-air distance
                        // Clashes
                        clashesWon: 0,
                        clashesLost: 0,
                        clashDifficulties: [],  // Margin of win/loss
                        // Defense
                        sacks: 0,
                        tackles: 0,
                        passesDefended: 0,
                        // Touchdowns
                        touchdowns: 0
                    };
                }
                return this.players[playerId];
            },

            // Reset all stats for new game
            reset() {
                this.players = {};
            }
        };

        // Management mode flag - when false, game input is disabled
        let gameSceneActive = false;

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 1.8,           // Distance for clash detection (reduced for more separation time)
            SEPARATION_THRESHOLD: 3,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 3,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
        };

        // Line clash system constants
        const LINE_CLASH_CONSTANTS = {
            CLASH_RANGE: 1.5,           // Distance for line clash detection
            CLASH_INTERVAL: 0.5,        // Seconds between clash resolutions while engaged
            NEUTRAL_SPEED: 0.05,        // Near-zero speed on neutral clash
            OFFENSE_WIN_THRESHOLD: 5,   // Margin needed for O-line to win decisively
            DEFENSE_WIN_THRESHOLD: 5,   // Margin needed for D-line to win decisively
            KNOCKDOWN_DURATION: 1.0,    // Seconds knocked down
            SPEED_BURST_MULTIPLIER: 1.5,// Speed boost after D-line wins
            SPEED_BURST_DURATION: 1.5,  // Duration of speed burst
            TACKLE_RANGE: 1.2,          // Distance for QB sack
        };

        // Receiver tackling constants
        const TACKLE_CONSTANTS = {
            TACKLE_RANGE: 1.0,          // Distance for tackle attempt
            TACKLE_INTERVAL: 0.3,       // Seconds between tackle attempts
            STUMBLE_DURATION: 0.5,      // How long defender stumbles after failed tackle
            BREAK_TACKLE_BOOST: 1.3,    // Speed boost after breaking tackle
            BREAK_TACKLE_DURATION: 0.8, // Duration of break tackle speed boost
        };

        // QB pocket constants
        const POCKET_CONSTANTS = {
            POCKET_CENTER_Z: -7,        // Ideal pocket depth (3 yards behind LOS)
            POCKET_MIN_X: -3,           // Pocket left boundary
            POCKET_MAX_X: 3,            // Pocket right boundary
            POCKET_MAX_DEPTH: -10,      // Don't go deeper than this
            LINE_OF_SCRIMMAGE: -4,      // Can't cross this going forward
            THREAT_RADIUS: 4,           // Start evading when defender this close
            EVADE_SPEED: 0.06,          // Speed when evading
            SETTLE_SPEED: 0.03,         // Speed when settling into pocket
        };

        // Stat weights for clash resolution
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.20, acceleration: 0.15, release: 0.15 },
                defender: { speed: 0.20, agility: 0.20, manCoverage: 0.25, pursuit: 0.20, awareness: 0.15 }
            },
            physical: {
                attacker: { strength: 0.35, aggression: 0.25, hitPower: 0.25, balance: 0.15 },
                defender: { strength: 0.35, aggression: 0.25, tackling: 0.25, balance: 0.15 }
            },
            lineClash: {
                offense: { passBlock: 0.35, strength: 0.30, balance: 0.20, awareness: 0.15 },
                defense: { passRush: 0.35, strength: 0.30, acceleration: 0.20, speed: 0.15 }
            },
            tackle: {
                tackler: { tackling: 0.40, pursuit: 0.30, hitPower: 0.30 },
                ballCarrier: { agility: 0.35, speed: 0.30, balance: 0.35 }
            }
        };

        // ========================================
        // ROUTE TEMPLATES FOR SIMULATION
        // ========================================
        // Each route has per-round depth (yards from LOS) and crossing (direction change)
        // When crossing = true, receiver moves horizontally so depth stays same or gains minimally
        // breakRound is when the route "breaks" - creates separation opportunity
        const ROUTE_TEMPLATES = {
            standard: {
                go: {
                    name: 'go',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 20, crossing: false },
                        { depth: 28, crossing: false },
                        { depth: 35, crossing: false }
                    ],
                    breakRound: null
                },
                slant: {
                    name: 'slant',
                    rounds: [
                        { depth: 3, crossing: false },  // Vertical stem past LOS first
                        { depth: 6, crossing: true },   // Then diagonal cross
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false }
                    ],
                    breakRound: 2
                },
                out: {
                    name: 'out',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking out - no depth gain
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: 2
                },
                in: {
                    name: 'in',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking in - no depth gain
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 2
                },
                post: {
                    name: 'post',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking post - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                corner: {
                    name: 'corner',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking corner - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                curl: {
                    name: 'curl',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 10, crossing: true },  // Coming back - loses depth
                        { depth: 10, crossing: false },
                        { depth: 10, crossing: false }
                    ],
                    breakRound: 3
                },
                comeback: {
                    name: 'comeback',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 14, crossing: false },
                        { depth: 12, crossing: true },  // Coming back - loses depth
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 3
                },
                dig: {
                    name: 'dig',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: true },  // Crossing - no depth gain
                        { depth: 14, crossing: false },
                        { depth: 14, crossing: false }
                    ],
                    breakRound: 3
                },
                seam: {
                    name: 'seam',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 10, crossing: false },
                        { depth: 16, crossing: false },
                        { depth: 22, crossing: false },
                        { depth: 28, crossing: false }
                    ],
                    breakRound: null
                },
                flat: {
                    name: 'flat',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Then horizontal cross
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false }
                    ],
                    breakRound: 2
                },
                wheel: {
                    name: 'wheel',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Release horizontally
                        { depth: 8, crossing: false },  // Turn upfield
                        { depth: 16, crossing: false },
                        { depth: 24, crossing: false }
                    ],
                    breakRound: 2
                },
                hitch: {
                    name: 'hitch',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },  // Stop and wait
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 1
                }
            },
            redzone: {
                fade: {
                    name: 'fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 15, crossing: false },
                        { depth: 15, crossing: false }
                    ],
                    breakRound: null
                },
                back_shoulder: {
                    name: 'back_shoulder',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 8, crossing: true },   // Fading back - loses depth
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 3
                },
                corner_fade: {
                    name: 'corner_fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 5, crossing: true },   // Breaking corner - minimal gain
                        { depth: 10, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 2
                },
                quick_slant: {
                    name: 'quick_slant',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 4, crossing: true },   // Then diagonal slant
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false }
                    ],
                    breakRound: 2
                },
                out_quick: {
                    name: 'out_quick',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: true },   // Breaking out - no depth gain
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                }
            },
            goalline: {
                endzone_fade: {
                    name: 'endzone_fade',
                    rounds: [
                        { depth: 2, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: null
                },
                endzone_slant: {
                    name: 'endzone_slant',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step into endzone
                        { depth: 3, crossing: true },   // Then diagonal cross
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_out: {
                    name: 'endzone_out',
                    rounds: [
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: true },   // Breaking out - no depth gain
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_flat: {
                    name: 'endzone_flat',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step forward
                        { depth: 2, crossing: true },   // Then horizontal cross
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false }
                    ],
                    breakRound: 2
                }
            }
        };

        // QB personality traits that affect decision making
        const QB_TRAITS = {
            gunslinger: {
                name: 'Gunslinger',
                description: 'Waits for big plays, takes risks',
                openThreshold: 60,       // Needs higher catch % to throw
                pressureMultiplier: 0.7, // Less affected by pressure
                firstDownBias: -10,      // Less likely to take short gains
                aggressiveness: 1.3      // More likely to throw into coverage
            },
            game_manager: {
                name: 'Game Manager',
                description: 'Takes safe throws, avoids mistakes',
                openThreshold: 45,       // Throws to first open receiver
                pressureMultiplier: 1.3, // More affected by pressure
                firstDownBias: 20,       // Heavily favors first down throws
                aggressiveness: 0.7      // Avoids risky throws
            },
            balanced: {
                name: 'Balanced',
                description: 'Adapts to situation',
                openThreshold: 52,
                pressureMultiplier: 1.0,
                firstDownBias: 5,
                aggressiveness: 1.0
            },
            scrambler: {
                name: 'Scrambler',
                description: 'Prefers to run when pressured',
                openThreshold: 55,
                pressureMultiplier: 0.5, // Much less affected by pressure
                firstDownBias: 0,
                aggressiveness: 0.9,
                scrambleBonus: 20        // Extra likelihood to scramble
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false,  // Show defender zone rings and fills
            showDebugInfo: false       // Show on-screen debug info for coverage/catch factors
        };

        // ========================================
        // MANAGEMENT LAYER - DATA MODELS
        // ========================================

        // Management state - persisted between sessions
        const managementState = {
            team: null,
            season: null,
            freeAgents: [],
            settings: {
                difficulty: 'normal',  // easy, normal, hard
                autoSave: true
            },
            initialized: false,
            currentScreen: 'main_menu',  // main_menu, hub, roster, player_detail, free_agency, facilities, schedule, game
            selectedPlayerId: null,
            matchInProgress: false,
            currentPossession: 0,
            matchScore: { player: 0, opponent: 0 }
        };

        // Position definitions with stat priorities
        const POSITIONS = {
            WR: {
                name: 'Wide Receiver',
                shortName: 'WR',
                primaryStats: ['speed', 'catching', 'routeRunning', 'agility'],
                count: 3
            },
            CB: {
                name: 'Cornerback',
                shortName: 'CB',
                primaryStats: ['speed', 'manCoverage', 'zoneCoverage', 'agility'],
                count: 4
            },
            OL: {
                name: 'Offensive Lineman',
                shortName: 'OL',
                primaryStats: ['passBlock', 'strength', 'balance', 'awareness'],
                count: 5
            },
            DL: {
                name: 'Defensive Lineman',
                shortName: 'DL',
                primaryStats: ['passRush', 'strength', 'acceleration', 'tackling'],
                count: 4
            },
            QB: {
                name: 'Quarterback',
                shortName: 'QB',
                primaryStats: ['throwing', 'awareness', 'agility', 'speed'],
                count: 1
            }
        };

        // Medieval-themed name pools
        const FIRST_NAMES = [
            'Aldric', 'Baldwin', 'Cedric', 'Duncan', 'Edmund', 'Fabian', 'Gareth', 'Harold',
            'Ivan', 'Jasper', 'Kendrick', 'Leopold', 'Magnus', 'Norbert', 'Oswald', 'Percival',
            'Quincy', 'Roderick', 'Sigmund', 'Thaddeus', 'Ulric', 'Victor', 'Wallace', 'Xavier',
            'Yorick', 'Zephyr', 'Arthur', 'Bernard', 'Conrad', 'Dorian', 'Edgar', 'Felix',
            'Geoffrey', 'Hugo', 'Ignatius', 'Julius', 'Klaus', 'Lionel', 'Marcus', 'Neville'
        ];

        const LAST_NAMES = [
            'Blackwood', 'Ironforge', 'Stoneheart', 'Thornfield', 'Winterbane', 'Ashford',
            'Brighthelm', 'Coldwell', 'Darkwater', 'Everhart', 'Foxworth', 'Grimshaw',
            'Hawthorne', 'Ironcrest', 'Jarvis', 'Kingsley', 'Lockwood', 'Montague',
            'Northwind', 'Oakenshield', 'Proudfoot', 'Queensbury', 'Ravenwood', 'Silverton',
            'Thunderstone', 'Underhill', 'Vanguard', 'Westbrook', 'Yarrow', 'Zephyrus',
            'Battleborn', 'Crossbow', 'Dragonbane', 'Eaglecrest', 'Flameheart', 'Goldmane'
        ];

        // Team name components
        const TEAM_CITIES = [
            'Ironhelm', 'Stormwall', 'Dragonfire', 'Shadowmere', 'Frostpeak', 'Sunspire',
            'Bloodstone', 'Thornwood', 'Goldcrest', 'Ravenmoor', 'Wolfhaven', 'Eaglekeep',
            'Lionhart', 'Bearhold', 'Hawkridge', 'Serpentine'
        ];

        const TEAM_NAMES = [
            'Crusaders', 'Sentinels', 'Legion', 'Knights', 'Warriors', 'Guardians',
            'Paladins', 'Champions', 'Defenders', 'Marauders', 'Vanguard', 'Templars',
            'Berserkers', 'Wardens', 'Lancers', 'Reavers'
        ];

        // Economy constants
        const ECONOMY = {
            STARTING_FAME: 1000,
            SALARY_CAP: 12000,  // Slightly higher than typical team salary (~11.5k)
            SALARY_MULTIPLIER: 10,  // salary = sum(stats) * 10

            // Revenue
            HOME_GAME_BASE: 50,
            HOME_GAME_STADIUM_BONUS: 30,  // per level
            AWAY_GAME_REVENUE: 25,
            PLAYER_SALE_RATE: 0.5,  // get 50% of salary value

            // Facility costs by level (1->2, 2->3, etc)
            STADIUM_UPGRADE_COSTS: [200, 500, 1000, 2000, 4000],
            TRAINING_UPGRADE_COSTS: [150, 400, 800, 1500, 3000],

            // Other
            BRIBE_COST: 1000,
            BRIBE_CAP_BONUS: 500
        };

        // Progression constants
        const PROGRESSION = {
            // Growth is based purely on potential grade
            GROWTH_CHANCE_BASE: 0.20,           // 20% base chance per stat per week
            GROWTH_AMOUNT_MIN: 1,               // Minimum +1 when growth happens
            // Potential decay: chance for potential to drop each year
            POTENTIAL_DECAY_EARLY: 0.15,        // 15% chance years 1-3
            POTENTIAL_DECAY_LATE: 0.50,         // 50% chance after year 3
            POTENTIAL_DROP_TWO_CHANCE: 0.25,    // 25% chance to drop 2 levels instead of 1
            // Decline rates
            DECLINE_RATE: 0.3,                  // per year over peak (base)
            // Physical stats: grow less often, decline in phases
            PHYSICAL_STATS: ['speed', 'acceleration', 'agility', 'strength', 'stamina'],
            PHYSICAL_GROWTH_CHANCE_MULT: 0.50,  // 50% of normal growth chance
            PHYSICAL_DECLINE_EARLY_MULT: 0.5,   // Gentle decline years 1-3 after peak
            PHYSICAL_DECLINE_LATE_MULT: 3.0,    // Steep decline years 4+ after peak
            PHYSICAL_DECLINE_LATE_START: 4,     // When steep decline begins
            // Skill stats: decline very slowly
            SKILL_STATS: ['catching', 'routeRunning', 'blocking', 'runBlock', 'passBlock',
                          'tackling', 'manCoverage', 'zoneCoverage', 'passRush', 'awareness', 'focus'],
            SKILL_DECLINE_MULT: 0.1,            // Only 10% of normal decline
            MIN_STAT: 20,
            MIN_AVERAGE_STAT: 35,  // retire if average drops below
            MAX_AGE: 40
        };

        // Season constants
        const SEASON = {
            WEEKS: 16,
            POSSESSIONS_PER_GAME: 4  // 4 quarters, with possible 2-minute drill and overtime
        };

        // ========================================
        // MANAGEMENT LAYER - UTILITY FUNCTIONS
        // ========================================

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Random from array
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Random int between min and max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Format salary in millions (e.g., 5000 -> "$5M")
        function formatSalary(amount) {
            return amount.toLocaleString();
        }

        // Shuffle array (Fisher-Yates)
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // ========================================
        // MANAGEMENT LAYER - SAVE/LOAD SYSTEM
        // ========================================

        const SaveSystem = {
            SAVE_KEY: 'smashball_management_save',

            save() {
                if (!managementState.initialized) return false;

                const saveData = {
                    version: 1,
                    timestamp: Date.now(),
                    team: managementState.team,
                    season: managementState.season,
                    freeAgents: managementState.freeAgents,
                    settings: managementState.settings
                };

                try {
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('Game saved successfully');
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            },

            load() {
                try {
                    const data = localStorage.getItem(this.SAVE_KEY);
                    if (!data) return null;

                    const saveData = JSON.parse(data);
                    console.log('Game loaded successfully, version:', saveData.version);
                    return saveData;
                } catch (e) {
                    console.error('Failed to load game:', e);
                    return null;
                }
            },

            exists() {
                return localStorage.getItem(this.SAVE_KEY) !== null;
            },

            clear() {
                localStorage.removeItem(this.SAVE_KEY);
                console.log('Save data cleared');
            },

            applySaveData(saveData) {
                if (!saveData) return false;

                managementState.team = saveData.team;
                managementState.season = saveData.season;
                managementState.freeAgents = saveData.freeAgents || [];
                managementState.settings = saveData.settings || managementState.settings;
                managementState.initialized = true;

                // Migrate old saves: credits -> fame
                if (managementState.team && managementState.team.credits !== undefined) {
                    managementState.team.fame = Math.round(managementState.team.credits / 10);
                    delete managementState.team.credits;
                }

                return true;
            }
        };

        // ========================================
        // MANAGEMENT LAYER - PLAYER GENERATION
        // ========================================

        // Generate base stats for a tier
        function getBaseStatsForTier(tier) {
            const ranges = {
                rookie: { min: 45, max: 62 },        // Raw talent, inconsistent
                below_average: { min: 50, max: 68 }, // Backup caliber
                average: { min: 58, max: 75 },       // Solid starter
                veteran: { min: 68, max: 82 },       // Reliable contributor
                star: { min: 78, max: 90 },          // Pro Bowl caliber
                elite: { min: 88, max: 99 }          // All-Pro / HOF caliber
            };
            const range = ranges[tier] || ranges.average;
            return { min: range.min, max: range.max };
        }

        // Roll age based on tier
        function rollAge(tier) {
            switch(tier) {
                case 'rookie': return randomInt(20, 23);
                case 'below_average': return randomInt(22, 30);
                case 'average': return randomInt(23, 28);
                case 'veteran': return randomInt(27, 33);
                case 'star': return randomInt(24, 30);
                case 'elite': return randomInt(25, 31);
                default: return randomInt(22, 28);
            }
        }

        // Roll potential grade based on age and tier (0-3 scale)
        // Distribution: max (3) 15%, average (2) 35%, low (1) 35%, very low (0) 15%
        function rollPotential(age, tier) {
            // Base weighted distribution
            const roll = Math.random() * 100;
            let potential;
            if (roll < 15) potential = 3;        // 15% max
            else if (roll < 50) potential = 2;   // 35% average
            else if (roll < 85) potential = 1;   // 35% low
            else potential = 0;                   // 15% very low

            // Age modifier: older players lose potential
            if (age > 28) potential = Math.max(0, potential - 1);
            if (age > 32) potential = Math.max(0, potential - 1);

            // Tier bonus for young elite/rookie players
            if ((tier === 'elite' || tier === 'rookie') && age <= 24) {
                potential = Math.min(3, potential + 1);
            }

            return potential;
        }

        // Generate position-specific stats
        function generatePositionStats(position, baseRange) {
            const stats = {};
            const positionData = POSITIONS[position];

            // All possible stats
            const allStats = [
                'speed', 'acceleration', 'agility', 'strength', 'stamina', 'balance',
                'catching', 'throwing', 'routeRunning', 'release', 'jumping', 'focus',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'hitPower', 'pursuit', 'awareness',
                'passBlock', 'passRush', 'aggression'
            ];

            // Generate all stats
            allStats.forEach(stat => {
                // Primary stats get bonus
                const isPrimary = positionData.primaryStats.includes(stat);
                const bonus = isPrimary ? 10 : 0;

                stats[stat] = Math.min(99, Math.max(1,
                    randomInt(baseRange.min, baseRange.max) + bonus
                ));
            });

            return stats;
        }

        // Calculate salary from stats
        // Calculate overall rating (average of primary stats for position)
        function calculateOverall(player) {
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;
            const total = primaryStats.reduce((sum, stat) => sum + (player.stats[stat] || 0), 0);
            return Math.round(total / primaryStats.length);
        }

        // Calculate salary based on overall rating (quadratic scaling)
        function calculateSalary(stats, position = 'WR') {
            const positionData = POSITIONS[position];
            const primaryStats = positionData.primaryStats;
            const total = primaryStats.reduce((sum, stat) => sum + (stats[stat] || 0), 0);
            const overall = Math.round(total / primaryStats.length);
            // Quadratic scaling: 60 OVR = 200, 80 OVR = 800, 95 OVR = 1512
            const base = 0.5 * Math.pow(overall - 40, 2);
            return Math.floor(base);
        }

        // Calculate trade value (fame received for trading a player)
        function calculateTradeValue(player) {
            const overall = player.overall;
            if (overall < 80) return 0;
            if (overall < 90) {
                // 80-89: linear scaling, 0 to 150
                return Math.floor((overall - 80) * 15);
            }
            // 90+: exponential scaling
            // 90 = 150, 92 = 250, 95 = 775, 99 = 2175
            return Math.floor(150 + Math.pow(overall - 90, 2) * 25);
        }

        // Generate a player
        function generatePlayer(position, tier = 'average') {
            const baseRange = getBaseStatsForTier(tier);
            const age = rollAge(tier);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Years in league based on age (rookies start at 0)
            const yearsInLeague = tier === 'rookie' ? 0 : Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, tier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats, position),
                seasonStartStats: { ...stats },
                // Season stats
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                // Career history (array of season snapshots)
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, tier)
                }]
            };

            player.overall = calculateOverall(player);

            // Assign QB trait based on stats
            if (position === 'QB') {
                // Weight trait selection based on QB's style
                // High awareness + low agility = game_manager
                // High agility + speed = scrambler
                // High throwing = gunslinger
                // Otherwise balanced
                const awareness = stats.awareness || 70;
                const agility = stats.agility || 70;
                const speed = stats.speed || 70;
                const throwing = stats.throwing || 70;

                if (agility > 78 && speed > 75) {
                    player.qbTrait = 'scrambler';
                } else if (awareness > 80 && throwing < 75) {
                    player.qbTrait = 'game_manager';
                } else if (throwing > 82) {
                    player.qbTrait = 'gunslinger';
                } else {
                    player.qbTrait = 'balanced';
                }
            }

            return player;
        }

        // Generate initial roster for new game
        function generateInitialRoster() {
            const roster = [];

            // WRs: 1 good, 2 average
            roster.push(generatePlayer('WR', 'veteran'));
            roster.push(generatePlayer('WR', 'average'));
            roster.push(generatePlayer('WR', 'average'));

            // CBs: 1 good, 3 average
            roster.push(generatePlayer('CB', 'veteran'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));

            // OL: 1 good, 4 average
            roster.push(generatePlayer('OL', 'veteran'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));

            // DL: 1 good, 3 average
            roster.push(generatePlayer('DL', 'veteran'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));

            // QB
            roster.push(generatePlayer('QB', 'average'));

            return roster;
        }

        // Auto-assign depth chart based on overall ratings
        function autoAssignDepthChart(team) {
            const roster = team.roster;

            // Group by position and sort by overall
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            Object.keys(byPosition).forEach(pos => {
                byPosition[pos].sort((a, b) => b.overall - a.overall);
            });

            // Assign to depth chart
            const depthChart = {
                WR1: byPosition.WR?.[0]?.id || null,
                WR2: byPosition.WR?.[1]?.id || null,
                WR3: byPosition.WR?.[2]?.id || null,
                CB1: byPosition.CB?.[0]?.id || null,
                CB2: byPosition.CB?.[1]?.id || null,
                CB3: byPosition.CB?.[2]?.id || null,
                CB4: byPosition.CB?.[3]?.id || null,
                OL: (byPosition.OL || []).slice(0, 5).map(p => p.id),
                DL: (byPosition.DL || []).slice(0, 4).map(p => p.id),
                QB: byPosition.QB?.[0]?.id || null
            };

            // Pad OL and DL if needed
            while (depthChart.OL.length < 5) depthChart.OL.push(null);
            while (depthChart.DL.length < 4) depthChart.DL.push(null);

            team.depthChart = depthChart;
        }

        // Create a new team
        function createNewTeam(name = 'Your Team') {
            const team = {
                name,
                fame: ECONOMY.STARTING_FAME,
                salaryCap: ECONOMY.SALARY_CAP,
                salaryCapModifier: 0,
                roster: generateInitialRoster(),
                depthChart: {},
                facilities: {
                    stadium: { level: 1, maxLevel: 5 },
                    trainingCenter: { level: 1, maxLevel: 5 }
                },
                record: { wins: 0, losses: 0 }
            };

            autoAssignDepthChart(team);
            return team;
        }

        // ========================================
        // MANAGEMENT LAYER - OPPONENT GENERATION
        // ========================================

        // Generate a roster for an opponent team based on difficulty
        function generateOpponentRoster(difficulty) {
            // Helper to pick a random tier based on weighted probabilities
            const pickTier = (weights) => {
                const tiers = ['rookie', 'below_average', 'average', 'veteran', 'star', 'elite'];
                const total = weights.reduce((a, b) => a + b, 0);
                let roll = Math.random() * total;
                for (let i = 0; i < tiers.length; i++) {
                    roll -= weights[i];
                    if (roll <= 0) return tiers[i];
                }
                return 'average';
            };

            // Weights for each tier: [rookie, below_average, average, veteran, star, elite]
            // Each team has a spread from poor to elite, but difficulty shifts the distribution
            // Easy teams average low 70s, elite teams average low 90s
            const tierWeights = {
                'easy':   [2, 8, 35, 45, 8, 2],      // Avg ~72: mostly average/veteran
                'medium': [1, 5, 25, 50, 15, 4],    // Avg ~75: solid veterans with stars
                'hard':   [0, 2, 15, 45, 30, 8],    // Avg ~79: veteran-heavy with stars
                'elite':  [0, 0, 0, 5, 30, 65]      // Avg ~91: almost all stars/elites
            };
            const weights = tierWeights[difficulty] || tierWeights['medium'];

            // Create weighted tiers for key vs role players
            // Key players: boosted toward star/elite
            // Role players: can be average/veteran (depth pieces)
            const keyPlayerWeights = weights.map((w, i) => i >= 4 ? w * 2.5 : i >= 3 ? w * 1.2 : w * 0.3);
            const rolePlayerWeights = weights.map((w, i) => i <= 3 ? w * 1.5 : w * 0.5);

            const roster = [];

            // QB - franchise player, heavily boosted
            const qbWeights = weights.map((w, i) => i >= 4 ? w * 3 : i >= 3 ? w * 1.5 : w * 0.2);
            roster.push(generatePlayer('QB', pickTier(qbWeights)));

            // WRs: WR1 is key player, WR2-3 are role players
            roster.push(generatePlayer('WR', pickTier(keyPlayerWeights)));   // WR1 - star
            roster.push(generatePlayer('WR', pickTier(weights)));            // WR2 - normal
            roster.push(generatePlayer('WR', pickTier(rolePlayerWeights)));  // WR3 - depth

            // CBs: CB1 is key player, CB2-3 are role players
            roster.push(generatePlayer('CB', pickTier(keyPlayerWeights)));   // CB1 - star
            roster.push(generatePlayer('CB', pickTier(weights)));            // CB2 - normal
            roster.push(generatePlayer('CB', pickTier(rolePlayerWeights)));  // CB3 - depth

            // OL: 1 anchor, rest are role players
            roster.push(generatePlayer('OL', pickTier(keyPlayerWeights)));   // LT - anchor
            roster.push(generatePlayer('OL', pickTier(rolePlayerWeights)));  // LG
            roster.push(generatePlayer('OL', pickTier(rolePlayerWeights)));  // C
            roster.push(generatePlayer('OL', pickTier(rolePlayerWeights)));  // RG/RT

            // DL: 1-2 pass rushers, rest are role players
            roster.push(generatePlayer('DL', pickTier(keyPlayerWeights)));   // Edge rusher
            roster.push(generatePlayer('DL', pickTier(weights)));            // DT
            roster.push(generatePlayer('DL', pickTier(rolePlayerWeights)));  // DT
            roster.push(generatePlayer('DL', pickTier(rolePlayerWeights)));  // Rotational

            return roster;
        }

        // Calculate team ratings from roster (weighted by key positions)
        function calculateTeamRatings(roster) {
            // Weight key positions more heavily
            const getPositionWeight = (player, index, position) => {
                if (position === 'QB') return 3.0;        // QB is most important
                if (position === 'WR' && index === 0) return 2.0;  // WR1
                if (position === 'CB' && index === 0) return 2.0;  // CB1
                if (position === 'DL' && index === 0) return 1.5;  // Pass rusher
                if (position === 'OL' && index === 0) return 1.5;  // LT
                return 1.0;  // Role players
            };

            const offense = roster.filter(p => ['QB', 'WR', 'OL'].includes(p.position));
            const defense = roster.filter(p => ['CB', 'DL'].includes(p.position));

            // Group by position for index-based weighting
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            let offenseWeightedSum = 0, offenseWeightTotal = 0;
            let defenseWeightedSum = 0, defenseWeightTotal = 0;

            Object.entries(byPosition).forEach(([pos, players]) => {
                players.sort((a, b) => b.overall - a.overall); // Best first
                players.forEach((p, i) => {
                    const weight = getPositionWeight(p, i, pos);
                    if (['QB', 'WR', 'OL'].includes(pos)) {
                        offenseWeightedSum += p.overall * weight;
                        offenseWeightTotal += weight;
                    } else {
                        defenseWeightedSum += p.overall * weight;
                        defenseWeightTotal += weight;
                    }
                });
            });

            const offenseRating = offenseWeightTotal > 0
                ? Math.round(offenseWeightedSum / offenseWeightTotal)
                : 60;
            const defenseRating = defenseWeightTotal > 0
                ? Math.round(defenseWeightedSum / defenseWeightTotal)
                : 60;

            return { offenseRating, defenseRating };
        }

        // Pre-defined opponents with varying difficulty
        function generateOpponents() {
            const difficulties = ['easy', 'medium', 'hard', 'elite'];

            const opponents = [];
            const usedNames = new Set();

            // Generate 16 unique opponents
            while (opponents.length < 16) {
                const city = randomFrom(TEAM_CITIES);
                const teamName = randomFrom(TEAM_NAMES);
                const fullName = `${city} ${teamName}`;

                if (usedNames.has(fullName)) continue;
                usedNames.add(fullName);

                // Distribute difficulty: 4 easy, 6 medium, 4 hard, 2 elite
                let difficulty;
                if (opponents.length < 4) difficulty = 'easy';
                else if (opponents.length < 10) difficulty = 'medium';
                else if (opponents.length < 14) difficulty = 'hard';
                else difficulty = 'elite';

                // Generate roster and calculate ratings from it
                const roster = generateOpponentRoster(difficulty);
                const ratings = calculateTeamRatings(roster);

                opponents.push({
                    id: generateUUID(),
                    name: fullName,
                    difficulty,
                    roster,
                    offenseRating: ratings.offenseRating,
                    defenseRating: ratings.defenseRating,
                    record: { wins: 0, losses: 0 }
                });
            }

            return shuffleArray(opponents);
        }

        // Generate season schedule
        function generateSchedule(opponents) {
            const schedule = [];
            const shuffledOpponents = shuffleArray([...opponents]);

            for (let week = 1; week <= SEASON.WEEKS; week++) {
                const opponent = shuffledOpponents[(week - 1) % shuffledOpponents.length];
                schedule.push({
                    week,
                    opponent,
                    isHome: Math.random() > 0.5,
                    result: null  // { playerScore, opponentScore, win }
                });
            }

            return schedule;
        }

        // Create a new season
        function createNewSeason() {
            const opponents = generateOpponents();
            return {
                week: 1,
                opponents,
                schedule: generateSchedule(opponents)
            };
        }

        // ========================================
        // MANAGEMENT LAYER - ECONOMY SYSTEM
        // ========================================

        // Calculate current team salary
        function calculateTeamSalary(team) {
            return team.roster.reduce((sum, p) => sum + p.salaryCost, 0);
        }

        // Check if can sign player (under cap)
        function canSignPlayer(team, player) {
            const currentSalary = calculateTeamSalary(team);
            const cap = team.salaryCap + team.salaryCapModifier;
            return currentSalary + player.salaryCost <= cap;
        }

        // Sign a free agent
        function signFreeAgent(playerId) {
            const player = managementState.freeAgents.find(p => p.id === playerId);
            if (!player) return { success: false, error: 'Player not found' };

            if (!canSignPlayer(managementState.team, player)) {
                return { success: false, error: 'Over salary cap' };
            }

            managementState.team.roster.push(player);
            managementState.freeAgents = managementState.freeAgents.filter(p => p.id !== playerId);

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true };
        }

        // Cut/release a player
        function cutPlayer(playerId) {
            const playerIndex = managementState.team.roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return { success: false, error: 'Player not found' };

            const player = managementState.team.roster[playerIndex];
            const payout = Math.floor(player.salaryCost * ECONOMY.PLAYER_SALE_RATE);

            managementState.team.fame += payout;
            managementState.team.roster.splice(playerIndex, 1);

            // Remove from depth chart
            const dc = managementState.team.depthChart;
            Object.keys(dc).forEach(slot => {
                if (Array.isArray(dc[slot])) {
                    const idx = dc[slot].indexOf(playerId);
                    if (idx !== -1) dc[slot][idx] = null;
                } else if (dc[slot] === playerId) {
                    dc[slot] = null;
                }
            });

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, payout };
        }

        // Award game revenue
        function awardGameRevenue(isHome) {
            let revenue;
            if (isHome) {
                revenue = ECONOMY.HOME_GAME_BASE +
                    (managementState.team.facilities.stadium.level * ECONOMY.HOME_GAME_STADIUM_BONUS);
            } else {
                revenue = ECONOMY.AWAY_GAME_REVENUE;
            }

            managementState.team.fame += revenue;
            return revenue;
        }

        // Upgrade facility
        function upgradeFacility(facilityType) {
            const facility = managementState.team.facilities[facilityType];
            if (!facility) return { success: false, error: 'Invalid facility' };

            if (facility.level >= facility.maxLevel) {
                return { success: false, error: 'Already at max level' };
            }

            const costs = facilityType === 'stadium'
                ? ECONOMY.STADIUM_UPGRADE_COSTS
                : ECONOMY.TRAINING_UPGRADE_COSTS;
            const cost = costs[facility.level - 1];

            if (managementState.team.fame < cost) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= cost;
            facility.level++;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newLevel: facility.level, cost };
        }

        // Bribe officials for more cap space
        function bribeOfficials() {
            if (managementState.team.fame < ECONOMY.BRIBE_COST) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= ECONOMY.BRIBE_COST;
            managementState.team.salaryCapModifier += ECONOMY.BRIBE_CAP_BONUS;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newCap: managementState.team.salaryCap + managementState.team.salaryCapModifier };
        }

        // ========================================
        // MANAGEMENT LAYER - PROGRESSION SYSTEM
        // ========================================

        // Process growth for a player (weekly)
        // Growth is based purely on current potential grade
        function processPlayerGrowth(player) {
            if (player.age >= player.peakAge) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: No growth - age ${player.age} >= peakAge ${player.peakAge}`);
                return [];
            }
            if (player.potentialGrade <= 0) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: No growth - potentialGrade ${player.potentialGrade} <= 0`);
                return []; // No growth potential left
            }

            // Potential grade affects growth chance (0-3 scale)
            const potentialMultiplier = 0.5 + (player.potentialGrade * 0.5); // 0.5x to 2.0x
            const baseGrowthChance = PROGRESSION.GROWTH_CHANCE_BASE * potentialMultiplier;

            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            const improvements = [];
            primaryStats.forEach(stat => {
                if (player.stats[stat] === undefined) return;

                // Physical stats grow very rarely
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const growthChance = isPhysical
                    ? baseGrowthChance * PROGRESSION.PHYSICAL_GROWTH_CHANCE_MULT
                    : baseGrowthChance;

                if (Math.random() < growthChance) {
                    const oldVal = player.stats[stat];
                    // Growth is always at least +1, with potential for more based on potential
                    const bonusGrowth = Math.floor(Math.random() * player.potentialGrade);
                    const growth = PROGRESSION.GROWTH_AMOUNT_MIN + bonusGrowth;
                    player.stats[stat] = Math.min(99, player.stats[stat] + growth);
                    if (player.stats[stat] > oldVal) {
                        console.log(`[GROWTH] ${player.firstName} ${player.lastName}: ${stat} +${player.stats[stat] - oldVal} (${oldVal} -> ${player.stats[stat]})`);
                        improvements.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            if (improvements.length === 0) {
                console.log(`[GROWTH] ${player.firstName} ${player.lastName}: Eligible but no growth this week (chance: ${(baseGrowthChance * 100).toFixed(1)}%)`);
            }

            return improvements;
        }

        // Process decline for a player (weekly)
        function processPlayerDecline(player) {
            if (player.age < player.peakAge) return [];

            const yearsOver = player.age - player.peakAge;
            const baseDeclineRate = yearsOver * PROGRESSION.DECLINE_RATE;

            const declines = [];

            // Process all stats the player has
            Object.keys(player.stats).forEach(stat => {
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const isSkill = PROGRESSION.SKILL_STATS.includes(stat);

                let declineRate;
                let minStat = PROGRESSION.MIN_STAT;

                if (isPhysical) {
                    // Physical stats: gentle decline years 1-3, steep decline years 4+
                    const isLateDecline = yearsOver >= PROGRESSION.PHYSICAL_DECLINE_LATE_START;
                    const physicalMult = isLateDecline
                        ? PROGRESSION.PHYSICAL_DECLINE_LATE_MULT
                        : PROGRESSION.PHYSICAL_DECLINE_EARLY_MULT;
                    declineRate = baseDeclineRate * physicalMult;
                } else if (isSkill) {
                    // Skill stats barely decline (10% of normal)
                    declineRate = baseDeclineRate * PROGRESSION.SKILL_DECLINE_MULT;
                    minStat = PROGRESSION.MIN_STAT + 15; // Skills floor higher
                } else {
                    // Other stats decline normally
                    declineRate = baseDeclineRate;
                }

                // Apply decline with some randomness
                if (Math.random() < 0.5 + (yearsOver * 0.1)) { // More likely to decline as years pass
                    const oldVal = player.stats[stat];
                    const actualDecline = declineRate * (0.5 + Math.random()); // 50-150% of rate
                    player.stats[stat] = Math.max(minStat, player.stats[stat] - actualDecline);
                    if (player.stats[stat] < oldVal) {
                        declines.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            return declines;
        }

        // Check if player should retire
        function checkRetirement(player) {
            if (player.age > PROGRESSION.MAX_AGE) return true;

            const statValues = Object.values(player.stats);
            const avgStat = statValues.reduce((a, b) => a + b, 0) / statValues.length;

            return avgStat < PROGRESSION.MIN_AVERAGE_STAT;
        }

        // Process weekly progression for all players
        function processWeeklyProgression() {
            console.log(`[PROGRESSION] Processing weekly progression for ${managementState.team.roster.length} players`);
            const results = {
                improvements: [],
                declines: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                // Growth or decline
                const improvements = processPlayerGrowth(player);
                const declines = processPlayerDecline(player);

                if (improvements.length > 0) {
                    results.improvements.push({ player, improvements });
                }
                if (declines.length > 0) {
                    results.declines.push({ player, declines });
                }

                // Check retirement
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Also process opponent team progressions
            processOpponentProgression();

            return results;
        }

        // Process weekly progression for all opponent teams
        function processOpponentProgression() {
            if (!managementState.season || !managementState.season.opponents) return;

            managementState.season.opponents.forEach(opponent => {
                if (!opponent.roster) return;

                const toRemove = [];
                opponent.roster.forEach(player => {
                    // Apply growth/decline (simplified - no retirement tracking for opponents)
                    processPlayerGrowth(player);
                    processPlayerDecline(player);

                    // Simple retirement check - replace with new player
                    if (checkRetirement(player)) {
                        toRemove.push(player);
                    }
                });

                // Replace retired opponents with new players
                toRemove.forEach(oldPlayer => {
                    const idx = opponent.roster.indexOf(oldPlayer);
                    if (idx !== -1) {
                        const tierMap = {
                            'easy': 'average',
                            'medium': 'average',
                            'hard': 'veteran',
                            'elite': 'star'
                        };
                        opponent.roster[idx] = generatePlayer(oldPlayer.position, tierMap[opponent.difficulty] || 'average');
                    }
                });

                // Recalculate team ratings
                const ratings = calculateTeamRatings(opponent.roster);
                opponent.offenseRating = ratings.offenseRating;
                opponent.defenseRating = ratings.defenseRating;
            });
        }

        // Process end of season (age all players)
        function processEndOfSeason() {
            const results = {
                ageUps: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                player.age++;
                player.yearsInLeague = (player.yearsInLeague || 0) + 1;
                results.ageUps.push(player);

                // Potential decay: chance for potential to drop each year
                // Much higher chance after year 3
                if (player.potentialGrade > 0 && player.age < player.peakAge) {
                    const decayChance = player.yearsInLeague <= 3
                        ? PROGRESSION.POTENTIAL_DECAY_EARLY
                        : PROGRESSION.POTENTIAL_DECAY_LATE;

                    if (Math.random() < decayChance) {
                        // Chance to drop 2 levels instead of 1
                        const dropAmount = Math.random() < PROGRESSION.POTENTIAL_DROP_TWO_CHANCE ? 2 : 1;
                        player.potentialGrade = Math.max(0, player.potentialGrade - dropAmount);
                    }
                }

                // Record career history before resetting
                if (!player.careerHistory) player.careerHistory = [];
                player.careerHistory.push({
                    season: player.careerHistory.length,
                    overall: player.overall,
                    potential: player.potentialGrade,
                    gamesPlayed: player.gamesPlayed || 0,
                    tds: player.seasonTDs || 0,
                    catches: player.seasonCatches || 0,
                    targets: player.seasonTargets || 0,
                    tackles: player.seasonTackles || 0,
                    clashesWon: player.seasonClashesWon || 0,
                    clashesLost: player.seasonClashesLost || 0,
                    sacks: player.seasonSacks || 0,
                    passesDefended: player.seasonPassesDefended || 0
                });

                // Reset season stats
                player.seasonStartStats = { ...player.stats };
                player.gamesPlayed = 0;
                player.seasonTDs = 0;
                player.seasonCatches = 0;
                player.seasonTargets = 0;
                player.seasonTackles = 0;
                player.seasonClashesWon = 0;
                player.seasonClashesLost = 0;
                player.seasonSacks = 0;
                player.seasonPassesDefended = 0;

                // Check retirement after aging
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Create new season
            managementState.season = createNewSeason();

            // Refresh free agents
            refreshFreeAgents();

            if (managementState.settings.autoSave) SaveSystem.save();

            return results;
        }

        // ========================================
        // MANAGEMENT LAYER - FREE AGENCY
        // ========================================

        // Roll tier for free agent (weighted towards average)
        function rollFreeAgentTier() {
            const roll = Math.random();
            if (roll < 0.1) return 'elite';      // 10%
            if (roll < 0.25) return 'veteran';   // 15%
            if (roll < 0.75) return 'average';   // 50%
            return 'rookie';                      // 25%
        }

        // Refresh free agent pool
        function refreshFreeAgents() {
            managementState.freeAgents = [];

            const count = randomInt(5, 8);
            const positions = ['WR', 'CB', 'OL', 'DL'];

            for (let i = 0; i < count; i++) {
                const position = randomFrom(positions);
                const tier = rollFreeAgentTier();
                managementState.freeAgents.push(generatePlayer(position, tier));
            }
        }

        // ========================================
        // MANAGEMENT LAYER - MATCH SIMULATION
        // ========================================

        // Calculate team defense rating
        function calculateTeamDefenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // CBs
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.manCoverage + player.stats.zoneCoverage + player.stats.tackling) / 3;
                        count++;
                    }
                }
            });

            // DL
            dc.DL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passRush + player.stats.tackling) / 2;
                        count++;
                    }
                }
            });

            return count > 0 ? total / count : 50;
        }

        // Calculate team offense rating
        function calculateTeamOffenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // WRs
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.speed + player.stats.catching + player.stats.routeRunning) / 3;
                        count++;
                    }
                }
            });

            // OL
            dc.OL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passBlock + player.stats.strength) / 2;
                        count++;
                    }
                }
            });

            // QB
            if (dc.QB) {
                const qb = roster.find(p => p.id === dc.QB);
                if (qb) {
                    total += (qb.stats.throwing + qb.stats.awareness) / 2;
                    count++;
                }
            }

            return count > 0 ? total / count : 50;
        }

        // ========================================
        // REALISTIC ENEMY DRIVE SIMULATION
        // ========================================

        // Weighted roll using stat weights (same formula as real game)
        function weightedStatRoll(stats, weights) {
            let weightedTotal = 0;
            for (const stat in weights) {
                const statValue = stats[stat] || 50;
                weightedTotal += statValue * weights[stat];
            }
            // Add ¬±20% variance
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);
            return roll;
        }

        // Get player's full name
        function getPlayerFullName(player) {
            if (!player) return 'Unknown';
            const first = player.firstName || 'Player';
            const last = player.lastName || '';
            return `${first} ${last.charAt(0) || ''}.`.trim();
        }

        // ========================================
        // HIGH-FIDELITY ROUND-BASED SIMULATION
        // ========================================

        // Select routes for receivers based on field position and situation
        function selectRoutesForPlay(receivers, yardsFromGoal, yardsToGo, down) {
            const routeAssignments = {};

            // Determine field zone
            const zone = yardsFromGoal <= 8 ? 'goalline' :
                         yardsFromGoal <= 20 ? 'redzone' : 'standard';

            const availableRoutes = Object.values(ROUTE_TEMPLATES[zone]);

            // Identify crossing/comeback routes (have crossing round or specific route types)
            const isCrossingRoute = (route) => {
                const crossingNames = ['slant', 'dig', 'comeback', 'curl', 'out', 'in', 'flat', 'quick_slant', 'endzone_slant'];
                if (crossingNames.some(name => route.name?.includes(name))) return true;
                // Or has a round with crossing: true after round 1
                return route.rounds?.some((r, i) => i > 0 && r.crossing);
            };

            const crossingRoutes = availableRoutes.filter(isCrossingRoute);

            // Categorize routes by depth
            const quickRoutes = availableRoutes.filter(r => r.rounds[1].depth <= 6);
            const mediumRoutes = availableRoutes.filter(r => r.rounds[1].depth > 6 && r.rounds[2].depth <= 12);
            const deepRoutes = availableRoutes.filter(r => r.rounds[2].depth > 12);

            // Randomly pick which receiver gets the guaranteed crossing route (usually slot/WR3)
            const crossingReceiverIndex = Math.random() < 0.6 ? 2 : (Math.random() < 0.5 ? 1 : 0);

            // Select based on situation
            receivers.forEach((wr, index) => {
                let routePool;

                // Ensure one receiver always runs a crossing/comeback route
                if (index === crossingReceiverIndex && crossingRoutes.length > 0) {
                    routePool = crossingRoutes;
                } else if (down >= 3 && yardsToGo > 7) {
                    // 3rd/4th and long - need deep routes
                    routePool = index === 0 ? deepRoutes : (index === 1 ? mediumRoutes : quickRoutes);
                } else if (down >= 3 && yardsToGo <= 3) {
                    // 3rd/4th and short - quick routes
                    routePool = index === 0 ? quickRoutes : (index === 1 ? mediumRoutes : deepRoutes);
                } else {
                    // Normal downs - mix it up
                    routePool = index === 0 ? mediumRoutes : (index === 1 ? deepRoutes : quickRoutes);
                }

                // Fallback if pool is empty
                if (routePool.length === 0) routePool = availableRoutes;

                // Pick random route from pool
                const route = routePool[Math.floor(Math.random() * routePool.length)];
                routeAssignments[wr.id || index] = route;
            });

            return routeAssignments;
        }

        // Initialize play state for round-based simulation
        function initializePlayState(offense, defense, fieldPosition) {
            const routes = selectRoutesForPlay(
                offense.receivers,
                fieldPosition.yardsFromGoal,
                fieldPosition.yardsToGo,
                fieldPosition.down
            );

            return {
                round: 0,
                maxRounds: 5,

                // Field state
                yardsFromGoal: fieldPosition.yardsFromGoal,
                yardsToGo: fieldPosition.yardsToGo,
                down: fieldPosition.down,

                // Pressure tracking
                totalPressure: 0,
                sacked: false,
                sackingPlayer: null,
                lineMatchups: [],  // Track OL/DL clashes for display

                // Receiver states
                receivers: offense.receivers.map((wr, index) => ({
                    id: wr.id || index,
                    player: wr,
                    stats: wr.stats,
                    route: routes[wr.id || index],
                    currentDepth: 0,
                    separation: 0,
                    catchProbability: 0,
                    effectiveCatchPct: 0,
                    rollMean: 79,
                    // Momentum tracking
                    lastDirection: 'vertical',  // 'vertical' or 'horizontal'
                    momentum: 0                  // Built up over consecutive same-direction rounds
                })),

                // Defender states (DBs)
                defenders: defense.dbs.map((db, index) => ({
                    id: db.id || index,
                    player: db,
                    stats: db.stats,
                    position: db.position || 'CB',
                    // Momentum tracking for defenders
                    lastDirection: 'vertical',
                    momentum: 0
                })),

                // O-Line states
                oLine: offense.oLine.map((ol, index) => ({
                    id: ol.id || index,
                    player: ol,
                    stats: ol.stats,
                    knockedDown: false
                })),

                // D-Line states
                dLine: defense.dLine.map((dl, index) => ({
                    id: dl.id || index,
                    player: dl,
                    stats: dl.stats,
                    knockedDown: false,
                    pressureContribution: 0
                })),

                // QB state
                qb: {
                    player: offense.qb,
                    stats: offense.qb.stats,
                    trait: offense.qb.qbTrait || 'balanced',
                    hasThrown: false
                },

                // Result tracking
                result: null
            };
        }

        // Process OL/DL clashes for a single round
        function processLineClashesRound(state) {
            const roundBonus = (state.round - 1) * 5;  // DL gets +5 per round
            let totalPressure = 0;

            // Reset pressure contributions
            state.dLine.forEach(dl => { dl.pressureContribution = 0; });

            // Clear matchups for this round (we'll keep the latest round's matchups)
            state.lineMatchups = [];

            for (let i = 0; i < state.dLine.length; i++) {
                const dl = state.dLine[i];

                if (dl.knockedDown) {
                    continue;
                }

                // Find corresponding OL (or closest available non-knocked-down)
                let ol = state.oLine[i];
                if (!ol || ol.knockedDown) {
                    ol = state.oLine.find(o => !o.knockedDown);
                }

                if (!ol) {
                    // Unblocked rusher - maximum pressure
                    dl.pressureContribution = 40;
                    totalPressure += 40;

                    // Record matchup
                    state.lineMatchups.push({
                        dl: dl.player,
                        ol: null,
                        dlRoll: 99,
                        olRoll: 0,
                        result: 'unblocked',
                        pressure: 40
                    });

                    // High sack chance for unblocked rusher
                    if (Math.random() < 0.35) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    continue;
                }

                // Resolve clash
                const olRoll = weightedStatRoll(ol.stats, CLASH_WEIGHTS.lineClash.offense);
                const dlRoll = weightedStatRoll(dl.stats, CLASH_WEIGHTS.lineClash.defense) + roundBonus;
                const margin = dlRoll - olRoll;

                let result = 'held';
                // Determine outcome based on margin
                if (margin > 18) {
                    // DL dominant win - sack chance
                    dl.pressureContribution = 35;
                    result = 'beaten badly';
                    if (Math.random() < 0.25) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    // OL might get knocked down
                    if (Math.random() < 0.3) {
                        ol.knockedDown = true;
                    }
                } else if (margin > 10) {
                    dl.pressureContribution = 25;
                    result = 'beaten';
                } else if (margin > 5) {
                    dl.pressureContribution = 15;
                    result = 'pressured';
                } else if (margin > 2) {
                    dl.pressureContribution = 10;
                    result = 'pressured';
                } else if (margin > -2) {
                    dl.pressureContribution = 3;
                    result = 'held';
                } else if (margin > -10) {
                    dl.pressureContribution = 0;
                    result = 'blocked';
                } else {
                    // OL dominant win - DL might get knocked down
                    dl.pressureContribution = 0;
                    result = 'pancaked';
                    if (Math.random() < 0.2) {
                        dl.knockedDown = true;
                    }
                }

                // Record matchup for display
                state.lineMatchups.push({
                    dl: dl.player,
                    ol: ol.player,
                    dlRoll: Math.round(dlRoll),
                    olRoll: Math.round(olRoll),
                    result: result,
                    pressure: dl.pressureContribution
                });

                totalPressure += dl.pressureContribution;
            }

            state.totalPressure = Math.min(totalPressure, 100);
        }

        // Process WR/DB separation clashes for a single round
        // Momentum mechanics - both players have same physics, but DB must REACT while WR pre-plans
        function processReceiverClashesRound(state) {
            for (let i = 0; i < state.receivers.length; i++) {
                const receiver = state.receivers[i];
                const routeRound = receiver.route.rounds[state.round - 1];
                const isCrossing = routeRound.crossing;
                const isBreakRound = receiver.route.breakRound === state.round;

                // Determine current direction
                const currentDirection = isCrossing ? 'horizontal' : 'vertical';
                const directionChanged = currentDirection !== receiver.lastDirection;

                // Update receiver depth
                receiver.currentDepth = routeRound.depth;

                // Find covering defender
                const defender = state.defenders[i] || state.defenders[0];

                if (!defender) {
                    receiver.separation = 30;  // Wide open
                    receiver.momentum = directionChanged ? 1 : Math.min(receiver.momentum + 1, 5);
                    receiver.lastDirection = currentDirection;
                    receiver.momentumAdvantage = 0;
                    continue;
                }

                // ========================================
                // MOMENTUM MECHANICS (UNIFIED PHYSICS)
                // ========================================
                // Both players have the same momentum physics when changing direction
                // The difference: WR pre-plans the cut, DB must REACT

                // Agility determines how well a player changes direction
                const wrAgility = receiver.stats.agility || 70;
                const dbAgility = defender.stats.agility || 70;

                // DB reaction time based on awareness (0-100)
                // Low awareness = slow to recognize the cut = still moving wrong way
                const dbAwareness = defender.stats.awareness || 70;
                // Reaction frames: 100 awareness = 0 frames, 50 awareness = 2.5 frames delay
                const reactionFrames = (100 - dbAwareness) / 20;

                // Momentum effect multiplier (same physics for both)
                // Higher momentum = harder to change direction
                const momentumPenaltyPerLevel = 8;  // Strong effect

                let wrMomentumEffect = 0;
                let dbMomentumEffect = 0;
                let momentumAdvantage = 0;

                if (directionChanged) {
                    // WR changes direction instantly (pre-planned)
                    // Penalty based on their momentum, reduced by agility
                    const wrAgilityFactor = wrAgility / 100;
                    wrMomentumEffect = receiver.momentum * momentumPenaltyPerLevel * (1 - wrAgilityFactor * 0.5);

                    // DB must REACT - they keep moving wrong way during reaction time
                    // Then they change direction with same physics
                    const dbAgilityFactor = dbAgility / 100;

                    // Reaction delay: DB's momentum CONTINUES building during reaction time
                    const effectiveMomentum = defender.momentum + reactionFrames;
                    dbMomentumEffect = effectiveMomentum * momentumPenaltyPerLevel * (1 - dbAgilityFactor * 0.5);

                    // Momentum advantage = how much the WR gained from the cut
                    momentumAdvantage = dbMomentumEffect - wrMomentumEffect;

                    // Store for display
                    receiver.momentumAdvantage = Math.round(momentumAdvantage);
                    receiver.dbReactionDelay = reactionFrames;
                } else {
                    receiver.momentumAdvantage = 0;
                    receiver.dbReactionDelay = 0;
                }

                // ========================================
                // BASE SEPARATION ROLL
                // ========================================
                let receiverRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);

                // Crossing route bonus - route running helps execute cuts cleanly
                if (isCrossing) {
                    const crossingBonus = receiver.stats.routeRunning * 0.3;
                    receiverRoll += crossingBonus;
                }

                // Break round bonus (the "snap" of the route creates separation)
                if (isBreakRound) {
                    const breakBonus = receiver.stats.routeRunning * 0.25;
                    receiverRoll += breakBonus;
                }

                // ========================================
                // DEFENDER ROLL
                // ========================================
                let defenderRoll = weightedStatRoll(defender.stats, CLASH_WEIGHTS.separation.defender);

                // ========================================
                // APPLY MOMENTUM ADVANTAGE
                // ========================================
                // The momentum advantage goes directly to separation
                // Positive = WR gained separation from the cut
                receiverRoll += momentumAdvantage;

                // ========================================
                // UPDATE MOMENTUM FOR NEXT ROUND
                // ========================================
                if (directionChanged) {
                    // Both reset to 1 after direction change
                    receiver.momentum = 1;
                    defender.momentum = 1;
                } else {
                    // Build momentum in current direction (cap at 5 for stronger effect)
                    receiver.momentum = Math.min(receiver.momentum + 1, 5);
                    defender.momentum = Math.min(defender.momentum + 1, 5);
                }

                receiver.lastDirection = currentDirection;
                defender.lastDirection = currentDirection;

                // Calculate separation margin
                receiver.separation = receiverRoll - defenderRoll;
            }
        }

        // Calculate catch probabilities using exponential distribution
        function simCalculateCatchProbabilities(state) {
            const qbAccuracy = (state.qb.stats.throwing + state.qb.stats.awareness) / 2;
            const pressure = state.totalPressure;

            // QB throw quality - rollMean determines accuracy distribution
            const rollMean = 79 + (75 - qbAccuracy) * 1.7 + pressure * 0.5;

            for (const receiver of state.receivers) {
                let catchProb = receiver.stats.catching;

                // Separation bonus/penalty
                if (receiver.separation >= 20) {
                    catchProb += 15;
                } else if (receiver.separation >= 10) {
                    catchProb += 8;
                } else if (receiver.separation >= 3) {
                    catchProb += 3;
                } else if (receiver.separation >= -3) {
                    catchProb += 0;
                } else if (receiver.separation >= -10) {
                    catchProb -= 15;
                } else {
                    catchProb -= 30;
                }

                // Focus for contested catches
                if (receiver.separation < 5) {
                    const focusBonus = (receiver.stats.focus - 70) * 0.3;
                    catchProb += focusBonus;
                }

                // Depth penalty for longer throws
                const depthPenalty = Math.max(0, (receiver.currentDepth - 15) * 0.3);
                catchProb -= depthPenalty;

                // Clamp
                catchProb = Math.max(5, Math.min(95, catchProb));

                // Calculate effective catch % with exponential
                const effectiveCatchPct = (1 - Math.exp(-catchProb / rollMean)) * 100;

                receiver.catchProbability = catchProb;
                receiver.effectiveCatchPct = effectiveCatchPct;
                receiver.rollMean = rollMean;
            }
        }

        // QB decision: should throw, and to whom?
        function processQBDecision(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;
            const qbStats = state.qb.stats;

            // Step 1: Vision check - can QB see each receiver?
            const visibleReceivers = [];
            for (const receiver of state.receivers) {
                const visionRoll = weightedStatRoll(qbStats, {
                    awareness: 0.50,
                    throwing: 0.30,
                    focus: 0.20
                });

                // Easier to notice more open receivers
                const noticeThreshold = 70 - receiver.separation;
                const noticeRoll = visionRoll + (Math.random() * 20 - 10);

                if (noticeRoll >= noticeThreshold) {
                    visibleReceivers.push(receiver);
                }
            }

            // Step 2: Evaluate throw options
            let throwLikelihood = 0;
            let bestTarget = null;
            let bestScore = -999;

            for (const receiver of visibleReceivers) {
                let score = receiver.effectiveCatchPct;

                // First down consideration
                const wouldGetFirstDown = receiver.currentDepth >= state.yardsToGo;
                if (wouldGetFirstDown) {
                    score += trait.firstDownBias;
                } else {
                    score -= state.round * 3;  // Penalty for short throws late
                }

                // Down urgency
                if (state.down >= 3 && !wouldGetFirstDown) {
                    score -= 15;
                }

                // Trait threshold
                if (receiver.effectiveCatchPct < trait.openThreshold) {
                    score -= 20;
                }

                // Aggressiveness for contested
                if (receiver.separation < 5) {
                    score *= trait.aggressiveness;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = receiver;
                }
            }

            // Step 3: Calculate throw likelihood
            if (bestTarget) {
                throwLikelihood = bestScore;

                // Pressure urgency
                const pressureUrgency = state.totalPressure * trait.pressureMultiplier;
                throwLikelihood += pressureUrgency * 0.5;

                // Round urgency
                throwLikelihood += state.round * 8;

                // Very high pressure = must throw
                if (state.totalPressure > 70) {
                    throwLikelihood += 30;
                }
            } else {
                // No visible targets
                throwLikelihood = state.totalPressure * 0.5 + state.round * 10;
            }

            // Step 4: Roll to throw
            const throwRoll = Math.random() * 100;
            const shouldThrow = throwRoll < throwLikelihood;

            return {
                shouldThrow,
                target: bestTarget,
                throwLikelihood,
                visibleReceivers
            };
        }

        // Resolve a throw attempt
        function simResolveThrow(state, target) {
            if (!target) {
                return {
                    type: 'throwaway',
                    yardsGained: 0,
                    description: 'QB throws the ball away',
                    _targetReceiver: null,
                    _qbRoll: 0,
                    _catchSuccess: false
                };
            }

            // Exponential roll for throw quality
            const qbRoll = -target.rollMean * Math.log(Math.random());
            const caught = qbRoll < target.catchProbability;

            let result;
            if (caught) {
                result = simResolveCatchAndRun(state, target);
            } else {
                result = simResolveIncompletions(state, target, qbRoll);
            }

            // Attach tracking info for legacy display
            result._targetReceiver = target;
            result._qbRoll = qbRoll;
            result._catchSuccess = caught;

            return result;
        }

        // Resolve incomplete pass (check for INT)
        function simResolveIncompletions(state, receiver, qbRoll) {
            const defenderIndex = state.receivers.indexOf(receiver);
            const defender = state.defenders[defenderIndex] || state.defenders[0];

            if (defender && receiver.separation < 0) {
                const throwBadness = qbRoll - receiver.catchProbability;

                let intChance = Math.min(throwBadness * 0.4, 25);
                intChance += (defender.stats.awareness - 60) * 0.2;
                intChance += ((defender.stats.catching || 50) - 50) * 0.1;

                if (receiver.separation < -10) {
                    intChance += 5;
                }

                intChance = Math.max(5, Math.min(35, intChance));

                if (Math.random() * 100 < intChance) {
                    return {
                        type: 'interception',
                        yardsGained: 0,
                        interceptedBy: defender.player,
                        description: `Intercepted by ${getPlayerFullName(defender.player)}!`
                    };
                }
            }

            return {
                type: 'incomplete',
                yardsGained: 0,
                description: 'Pass incomplete'
            };
        }

        // Resolve catch and YAC
        function simResolveCatchAndRun(state, receiver) {
            let totalYards = receiver.currentDepth;
            const yacEvents = [];

            // Find nearest defender for tackle
            const defenderIndex = state.receivers.indexOf(receiver);
            const nearestDB = state.defenders[defenderIndex] || state.defenders[0];

            // Immediate tackle attempt if covered
            if (nearestDB && receiver.separation < 10) {
                const tackleResult = simResolveTackleAttempt(receiver, nearestDB, 0);

                if (tackleResult.tackled) {
                    return {
                        type: 'complete',
                        yardsGained: totalYards,
                        caughtBy: receiver.player,
                        tackledBy: nearestDB.player,
                        yac: 0,
                        description: `Caught for ${totalYards} yards, tackled immediately`
                    };
                }
                yacEvents.push(tackleResult);
            }

            // YAC phase - up to 3 tackle attempts
            let tackled = false;
            for (let attempt = 0; attempt < 3 && !tackled; attempt++) {
                // YAC yards proportional to receiver stats
                const yacRoll = weightedStatRoll(receiver.stats, {
                    speed: 0.35,
                    acceleration: 0.25,
                    agility: 0.25,
                    balance: 0.15
                });
                const segmentYards = Math.floor(2 + (yacRoll / 100) * 10);

                // Find next tackler (cycle through defenders, safety gets bonus)
                const tacklerIndex = (defenderIndex + attempt + 1) % state.defenders.length;
                const tackler = state.defenders[tacklerIndex];

                if (!tackler) {
                    totalYards += segmentYards;
                    continue;
                }

                // Safety bonus on later attempts
                const safetyBonus = (tackler.position === 'S' || attempt > 0) ? (10 + attempt * 5) : 0;
                const tackleResult = simResolveTackleAttempt(receiver, tackler, safetyBonus);

                if (tackleResult.tackled) {
                    totalYards += Math.floor(segmentYards * 0.5);
                    tackled = true;
                    yacEvents.push(tackleResult);
                } else {
                    totalYards += segmentYards;
                    yacEvents.push(tackleResult);
                }
            }

            // Check for TD
            const isTouchdown = totalYards >= state.yardsFromGoal;

            return {
                type: isTouchdown ? 'touchdown' : 'complete',
                yardsGained: isTouchdown ? state.yardsFromGoal : totalYards,
                caughtBy: receiver.player,
                tackledBy: yacEvents.find(e => e.tackled)?.tackler || null,
                yac: totalYards - receiver.currentDepth,
                description: isTouchdown ?
                    `TOUCHDOWN! ${totalYards} yard catch and run!` :
                    `Caught for ${receiver.currentDepth} yards, ${totalYards - receiver.currentDepth} YAC`
            };
        }

        // Resolve a tackle attempt
        function simResolveTackleAttempt(receiver, tackler, safetyBonus) {
            const evasionRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier);
            let tackleRoll = weightedStatRoll(tackler.stats, CLASH_WEIGHTS.tackle.tackler);
            tackleRoll += safetyBonus;

            const margin = tackleRoll - evasionRoll;
            const breakTackleThreshold = -12;

            if (margin > breakTackleThreshold) {
                return {
                    type: 'tackle',
                    tackled: true,
                    tackler: tackler.player,
                    margin
                };
            } else {
                return {
                    type: 'broken_tackle',
                    tackled: false,
                    tackler: tackler.player,
                    margin
                };
            }
        }

        // Resolve sack
        function simResolveSack(state) {
            const sackYards = 5 + Math.floor(Math.random() * 6);
            return {
                type: 'sack',
                yardsGained: -sackYards,
                tackler: state.sackingPlayer,
                description: `Sacked for a loss of ${sackYards} yards`
            };
        }

        // Resolve desperation play (max rounds exceeded)
        function simResolveDesperationPlay(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;

            if (state.totalPressure > 60 && Math.random() < 0.4) {
                return {
                    type: 'sack',
                    yardsGained: -Math.floor(5 + Math.random() * 5),
                    description: 'Sacked after holding the ball too long'
                };
            }

            // Scrambler might run
            if (trait.scrambleBonus && Math.random() < 0.3) {
                const scrambleYards = Math.floor(
                    (state.qb.stats.speed * 0.1) +
                    (state.qb.stats.agility * 0.05) +
                    Math.random() * 5
                );
                return {
                    type: 'scramble',
                    yardsGained: scrambleYards,
                    description: `QB scrambles for ${scrambleYards} yards`
                };
            }

            // Heave to best available
            const bestReceiver = state.receivers.reduce((best, r) =>
                r.effectiveCatchPct > (best?.effectiveCatchPct || 0) ? r : best, null
            );

            if (bestReceiver && bestReceiver.effectiveCatchPct > 20) {
                bestReceiver.catchProbability *= 0.7;
                return simResolveThrow(state, bestReceiver);
            }

            return {
                type: 'throwaway',
                yardsGained: 0,
                description: 'QB throws it away under pressure'
            };
        }

        // Main play simulation loop
        function simulatePlayRoundBased(offense, defense, fieldPosition) {
            const state = initializePlayState(offense, defense, fieldPosition);

            while (state.round < state.maxRounds && !state.result) {
                state.round++;

                // Phase 1: OL/DL Clashes
                processLineClashesRound(state);

                // Check for sack
                if (state.sacked) {
                    state.result = simResolveSack(state);
                    break;
                }

                // Phase 2: WR/DB Separation
                processReceiverClashesRound(state);

                // Phase 3: Calculate catch probabilities
                simCalculateCatchProbabilities(state);

                // Phase 4: QB Decision
                const decision = processQBDecision(state);

                if (decision.shouldThrow) {
                    state.result = simResolveThrow(state, decision.target);
                    break;
                }
            }

            // Desperation if no throw
            if (!state.result) {
                state.result = simResolveDesperationPlay(state);
            }

            state.result.roundsElapsed = state.round;
            state.result.finalPressure = state.totalPressure;

            // ========================================
            // BUILD LEGACY-COMPATIBLE DISPLAY PROPERTIES
            // ========================================

            // Attach QB
            state.result.qb = state.qb.player;

            // Attach sackingPlayer for sacks
            if (state.result.type === 'sack') {
                state.result.sackingPlayer = state.sackingPlayer;
            }

            // Build pressureInfo (legacy format)
            const pressureLevel = state.totalPressure >= 70 ? 'heavy' :
                                  state.totalPressure >= 50 ? 'moderate' :
                                  state.totalPressure >= 25 ? 'light' : 'none';

            state.result.pressureInfo = {
                totalPressure: state.totalPressure,
                pressureLevel: pressureLevel,
                matchups: state.lineMatchups,
                sackingDL: state.sackingPlayer || null
            };

            // Build catchInfo for pass plays
            const targetReceiver = state.result._targetReceiver;
            if (targetReceiver) {
                const receiverIndex = state.receivers.indexOf(targetReceiver);
                const defender = state.defenders[receiverIndex] || state.defenders[0];

                // Calculate display values
                const wrRoll = Math.round(targetReceiver.separation + 50);
                const cbRoll = Math.round(50 - targetReceiver.separation);
                const separationMargin = targetReceiver.separation;
                const coverageCloseness = Math.max(0, Math.min(1, 1 - (separationMargin + 30) / 60));
                const defenderPenalty = Math.round(Math.pow(coverageCloseness, 3) * (defender?.stats?.coverage || 70) * 0.8);
                const baseCatch = targetReceiver.player?.stats?.catching || 70;
                const focusMod = (targetReceiver.player?.stats?.focus || 70) - 60;
                const catchProb = Math.round(targetReceiver.catchProbability);
                const qbAccuracy = state.qb.player?.stats?.accuracy || 70;

                state.result.catchInfo = {
                    receiver: targetReceiver.player,
                    cb: defender?.player || null,
                    wrRoll: wrRoll,
                    cbRoll: cbRoll,
                    separationMargin: Math.round(separationMargin),
                    coverageCloseness: Math.round(coverageCloseness * 100) / 100,
                    defenderPenalty: defenderPenalty,
                    baseCatch: baseCatch,
                    focusMod: focusMod > 0 ? focusMod : 0,
                    catchProb: catchProb,
                    qbAccuracy: qbAccuracy,
                    pressure: Math.round(state.totalPressure),
                    rollMean: Math.round(targetReceiver.rollMean),
                    qbRoll: Math.round(state.result._qbRoll),
                    catchSuccess: state.result._catchSuccess,
                    throwGood: state.result._qbRoll < targetReceiver.rollMean * 1.5,
                    cbCoverage: defender?.stats?.coverage || 70,
                    effectiveCatchPct: Math.round(targetReceiver.effectiveCatchPct || catchProb),
                    // Momentum tracking for display
                    momentumAdvantage: targetReceiver.momentumAdvantage || 0,
                    dbReactionDelay: targetReceiver.dbReactionDelay || 0,
                    dbAwareness: defender?.stats?.awareness || 70
                };

                // Attach target slot
                state.result.targetSlot = ['WR1', 'WR2', 'WR3'][receiverIndex] || 'WR';
            }

            // Clean up internal tracking properties
            delete state.result._targetReceiver;
            delete state.result._qbRoll;
            delete state.result._catchSuccess;

            return state.result;
        }

        // Full drive simulation using round-based plays
        function simulateDriveRoundBased(offense, defense, startingFieldPosition) {
            let fieldPosition = { ...startingFieldPosition };
            const plays = [];
            let driveResult = null;

            const maxPlays = 15;

            while (!driveResult && plays.length < maxPlays) {
                // Store the pre-play situation
                const prePlayDown = fieldPosition.down;
                const prePlayYardsToGo = fieldPosition.yardsToGo;
                const prePlayYardsFromGoal = fieldPosition.yardsFromGoal;

                const playResult = simulatePlayRoundBased(offense, defense, fieldPosition);

                // Attach pre-play situation to the result for display
                playResult.down = prePlayDown;
                playResult.yardsToGo = prePlayYardsToGo;
                playResult.yardsFromGoal = prePlayYardsFromGoal;

                plays.push(playResult);

                // Update field position
                const newYardsFromGoal = fieldPosition.yardsFromGoal - playResult.yardsGained;
                const yardsGainedTowardFirst = playResult.yardsGained;

                // Check first down
                if (yardsGainedTowardFirst >= fieldPosition.yardsToGo) {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: 10,
                        down: 1
                    };
                } else {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: fieldPosition.yardsToGo - yardsGainedTowardFirst,
                        down: fieldPosition.down + 1
                    };
                }

                // Attach post-play situation
                playResult.newYardsFromGoal = fieldPosition.yardsFromGoal;
                playResult.newYardsToGo = fieldPosition.yardsToGo;
                playResult.newDown = fieldPosition.down;

                // Check for drive-ending results
                if (playResult.type === 'touchdown') {
                    driveResult = { points: 7, type: 'touchdown', plays };
                } else if (playResult.type === 'interception') {
                    driveResult = { points: 0, type: 'turnover', plays };
                } else if (fieldPosition.down > 4) {
                    if (fieldPosition.yardsFromGoal <= 40) {
                        const fgDistance = fieldPosition.yardsFromGoal + 17;
                        const fgSuccess = Math.random() < (0.95 - fgDistance * 0.01);

                        // Mark the last play as a field goal attempt for display
                        playResult.fieldGoalAttempt = true;
                        playResult.fieldGoalSuccess = fgSuccess;

                        driveResult = {
                            points: fgSuccess ? 3 : 0,
                            type: fgSuccess ? 'field_goal' : 'missed_fg',
                            plays
                        };
                    } else {
                        driveResult = { points: 0, type: 'punt', plays };
                    }
                }
            }

            if (!driveResult) {
                driveResult = { points: 0, type: 'punt', plays };
            }

            return driveResult;
        }

        // Simulate player's offensive drive using high-fidelity system
        // Can be used for "auto-play" or "simulate" option
        function simulatePlayerDriveHighFidelity(playerTeam, opponent) {
            // Get player offense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            let playerQB = dc.QB ? roster.find(p => p.id === dc.QB) : null;
            if (!playerQB) playerQB = generateWalkOn('QB');

            const playerWRs = [];
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerWRs.push(player);
                }
            });

            const playerOL = [];
            (dc.OL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerOL.push(player);
                }
            });

            // Get opponent defense
            const oppCBs = opponent.roster.filter(p => p.position === 'CB').sort((a, b) => b.overall - a.overall);
            const oppDL = opponent.roster.filter(p => p.position === 'DL').sort((a, b) => b.overall - a.overall);

            // Fill walk-ons if needed
            while (playerWRs.length < 3) playerWRs.push(generateWalkOn('WR'));
            while (playerOL.length < 5) playerOL.push(generateWalkOn('OL'));
            while (oppCBs.length < 4) oppCBs.push(generateWalkOn('CB'));
            while (oppDL.length < 4) oppDL.push(generateWalkOn('DL'));

            // Build offense/defense objects
            const offense = {
                qb: playerQB,
                receivers: playerWRs.slice(0, 3),
                oLine: playerOL.slice(0, 5)
            };

            const defense = {
                dbs: oppCBs.slice(0, 4),
                dLine: oppDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Add team reference
            result.team = playerTeam;

            return result;
        }

        // Adapter to use new round-based simulation for enemy possessions
        function simulateEnemyDriveHighFidelity(opponent, playerTeam) {
            // Get opponent offense
            let oppQB = opponent.roster.find(p => p.position === 'QB');
            if (!oppQB) oppQB = generateWalkOn('QB');

            const oppWRs = opponent.roster.filter(p => p.position === 'WR').sort((a, b) => b.overall - a.overall);
            const oppOL = opponent.roster.filter(p => p.position === 'OL').sort((a, b) => b.overall - a.overall);

            // Get player defense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            const playerCBs = [];
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerCBs.push(player);
                }
            });

            const playerDL = [];
            (dc.DL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerDL.push(player);
                }
            });

            // Fill walk-ons if needed
            while (playerCBs.length < 3) playerCBs.push(generateWalkOn('CB'));
            while (playerDL.length < 4) playerDL.push(generateWalkOn('DL'));
            while (oppWRs.length < 3) oppWRs.push(generateWalkOn('WR'));
            while (oppOL.length < 5) oppOL.push(generateWalkOn('OL'));

            // Build offense/defense objects for new simulation
            const offense = {
                qb: oppQB,
                receivers: oppWRs.slice(0, 3),
                oLine: oppOL.slice(0, 5)
            };

            const defense = {
                dbs: playerCBs.slice(0, 4),
                dLine: playerDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the new high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Add opponent reference for compatibility
            result.opponent = opponent;

            return result;
        }

        // ========================================
        // LEGACY SIMULATION (kept for compatibility)
        // ========================================

        // Simulate DL vs OL pressure for the play
        function simulateDLPressure(playerOL, opponentDL) {
            const matchups = [];
            let totalPressure = 0;
            let sackingDL = null;

            // Match up DL vs OL (up to 4 matchups typically)
            const numMatchups = Math.min(playerOL.length, opponentDL.length);

            console.log(`DL Pressure - ${numMatchups} matchups. OL count: ${playerOL.length}, DL count: ${opponentDL.length}`);

            for (let i = 0; i < numMatchups; i++) {
                const ol = playerOL[i];
                const dl = opponentDL[i];

                const olRoll = weightedStatRoll(ol.stats, CLASH_WEIGHTS.lineClash.offense);
                const dlRoll = weightedStatRoll(dl.stats, CLASH_WEIGHTS.lineClash.defense);

                const margin = dlRoll - olRoll;
                let pressureContribution = 0;
                let result = 'held';

                if (margin > 18) {
                    // Dominant DL win - potential sack (rare, requires big mismatch)
                    pressureContribution = 35;
                    result = 'beaten badly';
                    if (!sackingDL && Math.random() < 0.25) {
                        sackingDL = dl;
                        console.log(`SACK triggered! DL ${dl.firstName} margin=${Math.round(margin)}`);
                    }
                } else if (margin > 10) {
                    // Strong DL win - heavy pressure but no sack
                    pressureContribution = 25;
                    result = 'beaten';
                } else if (margin > 5) {
                    // Moderate DL win - some pressure
                    pressureContribution = 15;
                    result = 'pressured';
                } else if (margin > 2) {
                    // Slight DL win - some pressure
                    pressureContribution = 10;
                    result = 'pressured';
                } else if (margin > -2) {
                    // Neutral - minimal pressure
                    pressureContribution = 3;
                    result = 'held';
                } else {
                    // OL wins - no pressure
                    pressureContribution = 0;
                    result = 'stonewalled';
                }

                console.log(`  Matchup ${i+1}: ${getPlayerFullName(dl)} (DL ${Math.round(dlRoll)}) vs ${getPlayerFullName(ol)} (OL ${Math.round(olRoll)}) = margin ${Math.round(margin)} -> ${result}`);

                totalPressure += pressureContribution;

                matchups.push({
                    ol: ol,
                    dl: dl,
                    olRoll: Math.round(olRoll),
                    dlRoll: Math.round(dlRoll),
                    margin: Math.round(margin),
                    result: result,
                    pressure: pressureContribution
                });
            }

            // Cap total pressure at 100
            totalPressure = Math.min(100, totalPressure);

            console.log(`  Total pressure: ${totalPressure}, sackingDL: ${sackingDL ? getPlayerFullName(sackingDL) : 'none'}`);

            return {
                matchups,
                totalPressure,
                sackingDL,
                pressureLevel: totalPressure > 60 ? 'extreme' : totalPressure > 40 ? 'heavy' : totalPressure > 20 ? 'moderate' : 'light'
            };
        }

        // Select receiver with weighting (WR1 50%, WR2 30%, WR3 20%)
        function selectTargetReceiver(opponentWRs) {
            const roll = Math.random() * 100;
            let targetIndex;
            if (roll < 50) {
                targetIndex = 0; // WR1 - 50%
            } else if (roll < 80) {
                targetIndex = 1; // WR2 - 30%
            } else {
                targetIndex = 2; // WR3 - 20%
            }
            // Fallback if not enough WRs
            targetIndex = Math.min(targetIndex, opponentWRs.length - 1);
            return {
                receiver: opponentWRs[targetIndex],
                slot: `WR${targetIndex + 1}`,
                targetRoll: Math.round(roll)
            };
        }

        // Simulate WR vs CB matchup and catch probability
        // Aligned with player offense catch calculation (calculateCatchProbability)
        function simulateCatchAttempt(receiver, cb, qbStats, pressureInfo) {
            // WR roll for separation/positioning
            const wrRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);
            // CB roll for coverage
            const cbRoll = weightedStatRoll(cb.stats, CLASH_WEIGHTS.separation.defender);

            const separationMargin = wrRoll - cbRoll;

            // Convert separation margin to "coverage closeness" (simulates physical proximity)
            // Scaled so that (with ~80 catching, ~80 CB coverage):
            //   CB wins by 10  ‚Üí closeness ‚âà 0.95 ‚Üí ~25% catch
            //   Even matchup   ‚Üí closeness ‚âà 0.78 ‚Üí ~50% catch
            //   WR wins by 20  ‚Üí closeness ‚âà 0.45 ‚Üí ~75% catch
            //   WR wins by 45+ ‚Üí closeness ‚Üí 0    ‚Üí ~80%+ catch (wide open)
            const coverageCloseness = Math.max(0, Math.min(1, 0.78 - (separationMargin / 60)));

            // Get CB's coverage stat (use average of man/zone if available, or overall proxy)
            const cbCoverage = cb.stats.manCoverage || cb.stats.coverage ||
                ((cb.stats.speed + cb.stats.awareness) / 2) || 70;

            // Calculate defender penalty using same formula as player offense:
            // penalty = proximityFactor¬≥ √ó coverageStat √ó 0.8
            const defenderPenalty = Math.pow(coverageCloseness, 3) * cbCoverage * 0.8;

            // Base catch from receiver's catching stat
            const baseCatch = receiver.stats.catching;

            // Focus modifier - only applies when under pressure (closeness > 0.3)
            const focusMod = coverageCloseness > 0.3 ? (receiver.stats.focus - 70) * 0.3 : 0;

            // Calculate catch probability (same structure as player offense)
            let catchProb = Math.max(5, Math.min(95, baseCatch + focusMod - defenderPenalty));

            // QB throw quality using exponential distribution
            // Better QB = lower rollMean = rolls cluster near 0 = easier catches
            // Pressure increases rollMean = rolls spread higher = harder catches
            const qbAccuracy = (qbStats.throwing + qbStats.awareness) / 2;
            const pressure = pressureInfo.totalPressure;

            // Formula tuned so that (at base 50% catch):
            //   QB 95, no pressure: +34% bonus ‚Üí 67% effective
            //   QB 85, no pressure: +10% bonus ‚Üí 55% effective
            //   QB 75, no pressure: -6% penalty ‚Üí 47% effective
            //   QB 65, no pressure: -18% penalty ‚Üí 41% effective
            const rollMean = 79 + (75 - qbAccuracy) * 1.7 + pressure * 0.5;

            // Exponential random: lower is better, need to roll under catchProb
            const qbRoll = -rollMean * Math.log(Math.random());

            // Effective catch % for display: P(roll < catchProb) = 1 - e^(-catchProb/rollMean)
            const effectiveCatchPct = (1 - Math.exp(-catchProb / rollMean)) * 100;

            // Success if QB roll is under the catch probability
            const catchSuccess = qbRoll < catchProb;

            return {
                receiver,
                cb,
                wrRoll: Math.round(wrRoll),
                cbRoll: Math.round(cbRoll),
                separationMargin: Math.round(separationMargin),
                coverageCloseness: Math.round(coverageCloseness * 100) / 100,
                cbCoverage: Math.round(cbCoverage),
                defenderPenalty: Math.round(defenderPenalty),
                baseCatch: Math.round(baseCatch),
                focusMod: Math.round(focusMod),
                catchProb: Math.round(catchProb),
                qbAccuracy: Math.round(qbAccuracy),
                pressure: Math.round(pressure),
                rollMean: Math.round(rollMean),
                qbRoll: Math.round(qbRoll),
                effectiveCatchPct: Math.round(effectiveCatchPct),
                catchSuccess
            };
        }

        // Simulate a single enemy play
        function simulateEnemyPlay(opponent, playerTeam, down, yardsToGo, yardsFromGoal) {
            // Get opponent offense - use walk-ons for missing players
            let oppQB = opponent.roster.find(p => p.position === 'QB');
            if (!oppQB) oppQB = generateWalkOn('QB');

            const oppWRs = opponent.roster.filter(p => p.position === 'WR').sort((a, b) => b.overall - a.overall);
            const oppOL = opponent.roster.filter(p => p.position === 'OL').sort((a, b) => b.overall - a.overall);

            // Get player defense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            const playerCBs = [];
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerCBs.push(player);
                }
            });

            const playerDL = [];
            (dc.DL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerDL.push(player);
                }
            });

            // Fill in walk-ons if needed
            while (playerCBs.length < 3) playerCBs.push(generateWalkOn('CB'));
            while (playerDL.length < 4) playerDL.push(generateWalkOn('DL'));
            while (oppWRs.length < 3) oppWRs.push(generateWalkOn('WR'));
            while (oppOL.length < 4) oppOL.push(generateWalkOn('OL'));

            // Sort by overall so best faces best (minimizes mismatches)
            playerDL.sort((a, b) => b.overall - a.overall);
            oppOL.sort((a, b) => b.overall - a.overall);
            playerCBs.sort((a, b) => b.overall - a.overall);
            oppWRs.sort((a, b) => b.overall - a.overall);

            // Step 1: Simulate DL pressure
            const pressureInfo = simulateDLPressure(oppOL, playerDL);

            // Step 2: Check for sack
            if (pressureInfo.sackingDL) {
                return {
                    type: 'sack',
                    down,
                    yardsToGo,
                    yardsFromGoal,
                    yardsGained: -7,
                    pressureInfo,
                    sackingPlayer: pressureInfo.sackingDL,
                    qb: oppQB
                };
            }

            // Step 3: Select target receiver
            const targetInfo = selectTargetReceiver(oppWRs);
            const targetWR = targetInfo.receiver;
            const targetSlot = targetInfo.slot;

            // Step 4: Match with corresponding CB
            const cbIndex = Math.min(oppWRs.indexOf(targetWR), playerCBs.length - 1);
            const coveringCB = playerCBs[Math.max(0, cbIndex)];

            // Step 5: Simulate catch attempt
            const qbStats = oppQB.stats || { throwing: 50, awareness: 50 };
            const catchInfo = simulateCatchAttempt(targetWR, coveringCB, qbStats, pressureInfo);

            // Calculate yards gained on catch
            let yardsGained = 0;
            if (catchInfo.catchSuccess) {
                // Base yards from coverage margin and receiver speed
                const baseYards = 5 + (catchInfo.coverageMargin > 0 ? catchInfo.coverageMargin * 0.3 : 0);
                yardsGained = Math.round(baseYards + Math.random() * 8);
                // Big play potential on strong WR wins
                if (catchInfo.coverageMargin > 15) {
                    yardsGained += Math.round(Math.random() * 15);
                }
                // Cap at yards from goal for TD
                yardsGained = Math.min(yardsGained, yardsFromGoal);
            }

            return {
                type: catchInfo.catchSuccess ? 'complete' : 'incomplete',
                down,
                yardsToGo,
                yardsFromGoal,
                yardsGained,
                pressureInfo,
                targetInfo,
                targetSlot,
                catchInfo,
                qb: oppQB
            };
        }

        // Simulate full enemy drive with realistic play-by-play
        function simulateRealisticEnemyDrive(opponent) {
            const playerTeam = managementState.team;

            // Generate roster if missing (can happen with older saves)
            if (opponent && !opponent.roster) {
                console.log('Generating missing roster for opponent:', opponent.name);
                opponent.roster = generateOpponentRoster(opponent.difficulty || 'medium');
            }

            // Validate required data exists
            if (!opponent || !opponent.roster || !playerTeam || !playerTeam.depthChart) {
                console.error('Missing required data for enemy drive simulation:', {
                    hasOpponent: !!opponent,
                    hasOpponentRoster: !!(opponent && opponent.roster),
                    hasPlayerTeam: !!playerTeam,
                    hasDepthChart: !!(playerTeam && playerTeam.depthChart)
                });
                throw new Error('Missing required simulation data');
            }

            const plays = [];
            let yardsFromGoal = 75; // Start at own 25
            let down = 1;
            let yardsToGo = 10;
            let driveResult = null;

            // Maximum plays in a drive
            const maxPlays = 12;

            for (let playNum = 0; playNum < maxPlays && !driveResult; playNum++) {
                const play = simulateEnemyPlay(opponent, playerTeam, down, yardsToGo, yardsFromGoal);
                plays.push(play);

                if (play.type === 'sack') {
                    yardsFromGoal += 7;
                    yardsToGo += 7;
                    down++;

                    // Record sack stat
                    if (play.sackingPlayer && play.sackingPlayer.id) {
                        const player = playerTeam.roster.find(p => p.id === play.sackingPlayer.id);
                        if (player) {
                            if (player.seasonSacks === undefined) player.seasonSacks = 0;
                            player.seasonSacks++;
                        }
                    }
                } else if (play.type === 'complete') {
                    yardsFromGoal -= play.yardsGained;
                    yardsToGo -= play.yardsGained;

                    // Touchdown check
                    if (yardsFromGoal <= 0) {
                        driveResult = { points: 7, type: 'TD' };
                        play.isTouchdown = true;
                    }

                    // First down check
                    if (yardsToGo <= 0) {
                        down = 1;
                        yardsToGo = 10;
                    } else {
                        down++;
                    }
                } else {
                    // Incomplete
                    down++;

                    // Record pass defended stat
                    if (play.catchInfo && play.catchInfo.cb && play.catchInfo.cb.id) {
                        const player = playerTeam.roster.find(p => p.id === play.catchInfo.cb.id);
                        if (player) {
                            if (player.seasonPassesDefended === undefined) player.seasonPassesDefended = 0;
                            player.seasonPassesDefended++;
                        }
                    }
                }

                // Fourth down - punt or FG attempt
                if (down > 4 && !driveResult) {
                    if (yardsFromGoal <= 40) {
                        // Field goal range - attempt
                        const fgSuccess = Math.random() < (0.9 - yardsFromGoal * 0.01);
                        if (fgSuccess) {
                            driveResult = { points: 3, type: 'FG' };
                            play.fieldGoalAttempt = true;
                            play.fieldGoalSuccess = true;
                        } else {
                            driveResult = { points: 0, type: 'MISSED_FG' };
                            play.fieldGoalAttempt = true;
                            play.fieldGoalSuccess = false;
                        }
                    } else {
                        // Punt - drive over
                        driveResult = { points: 0, type: 'PUNT' };
                    }
                }

                // Update play with current field position
                play.newYardsFromGoal = yardsFromGoal;
                play.newDown = down;
                play.newYardsToGo = yardsToGo;
            }

            // If we hit max plays without resolution, punt
            if (!driveResult) {
                driveResult = { points: 0, type: 'PUNT' };
            }

            return {
                ...driveResult,
                plays,
                opponent
            };
        }

        // Simulate enemy possession using realistic simulation
        function simulateEnemyPossession(opponent) {
            try {
                console.log('Starting enemy drive simulation (high-fidelity) for:', opponent?.name);
                console.log('Opponent roster size:', opponent?.roster?.length);
                console.log('Player team exists:', !!managementState.team);
                console.log('Player depthChart exists:', !!managementState.team?.depthChart);

                // Generate roster if missing
                if (opponent && !opponent.roster) {
                    console.log('Generating missing roster for opponent:', opponent.name);
                    opponent.roster = generateOpponentRoster(opponent.difficulty || 'medium');
                }

                // Validate required data
                if (!opponent || !opponent.roster || !managementState.team || !managementState.team.depthChart) {
                    throw new Error('Missing required simulation data');
                }

                // Use the new high-fidelity round-based simulation
                const driveResult = simulateEnemyDriveHighFidelity(opponent, managementState.team);

                console.log('Drive result:', driveResult.type, 'with', driveResult.plays?.length, 'plays');

                // Format narrative from new play format
                const narrative = driveResult.plays.map((p, i) => {
                    const down = Math.min(4, Math.floor(i / 3) + 1);
                    if (p.type === 'sack') {
                        return `Sack! ${p.description}`;
                    } else if (p.type === 'interception') {
                        return `INTERCEPTION! ${p.description}`;
                    } else if (p.type === 'touchdown') {
                        return `TOUCHDOWN! ${p.description}`;
                    } else if (p.type === 'complete') {
                        return `Complete! ${p.yardsGained} yards${p.yac > 0 ? ` (${p.yac} YAC)` : ''}`;
                    } else if (p.type === 'incomplete') {
                        return 'Pass incomplete';
                    } else if (p.type === 'throwaway') {
                        return 'QB throws it away';
                    } else if (p.type === 'scramble') {
                        return p.description;
                    }
                    return `${p.type}: ${p.yardsGained} yards`;
                });

                return {
                    points: driveResult.points,
                    type: driveResult.type,
                    plays: driveResult.plays,
                    opponent: driveResult.opponent,
                    narrative
                };
            } catch (error) {
                console.error('Enemy drive simulation error:', error);
                console.error('Error stack:', error.stack);
                // Fallback to simple result on error
                const roll = Math.random() * 100;
                const points = roll < 50 ? 7 : roll < 70 ? 3 : 0;
                const type = points === 7 ? 'TD' : points === 3 ? 'FG' : 'STOP';
                return {
                    points,
                    type,
                    plays: [],
                    opponent,
                    narrative: [type === 'TD' ? 'Touchdown!' : type === 'FG' ? 'Field goal!' : 'Defensive stop!']
                };
            }
        }

        // Format a play into narrative text
        function formatPlayNarrative(play, opponent) {
            const teamShort = opponent.name.split(' ')[0];
            const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

            if (play.type === 'sack') {
                const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your defense';
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${dlName} breaks through! SACK for ${Math.abs(play.yardsGained)} yard loss!`;
            }

            if (play.fieldGoalAttempt) {
                const distance = play.yardsFromGoal + 17; // Add end zone
                if (play.fieldGoalSuccess) {
                    return `Field goal attempt from ${distance} yards... GOOD!`;
                } else {
                    return `Field goal attempt from ${distance} yards... NO GOOD!`;
                }
            }

            const wrName = play.catchInfo?.receiver ? getPlayerFullName(play.catchInfo.receiver) : `${teamShort} WR`;
            const cbName = play.catchInfo?.cb ? getPlayerFullName(play.catchInfo.cb) : 'Your CB';

            if (play.type === 'complete') {
                if (play.isTouchdown) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} finds ${wrName}... TOUCHDOWN ${opponent.name}!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} hits ${wrName} for ${play.yardsGained} yards.`;
            } else {
                if (!play.catchInfo?.throwGood) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} under pressure, throws it away!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: Pass to ${wrName} broken up by ${cbName}!`;
            }
        }

        function getDownString(down) {
            const ordinals = ['1st', '2nd', '3rd', '4th'];
            return ordinals[down - 1] || `${down}th`;
        }

        // Get display text for current game phase
        function getGamePhaseDisplay(result) {
            const phase = result.gamePhase || managementState.gamePhase || 'regulation';
            const possession = result.possession + 1;

            if (phase === 'overtime') {
                const otPossession = managementState.overtimePossession || 1;
                return `OVERTIME - Possession ${otPossession}`;
            } else if (phase === 'twoMinuteDrill') {
                return '2-MINUTE DRILL';
            } else {
                // Regulation - show as quarters
                const quarter = Math.min(possession, 4);
                const quarterNames = ['1st Quarter', '2nd Quarter', '3rd Quarter', '4th Quarter'];
                return quarterNames[quarter - 1] || `Quarter ${quarter}`;
            }
        }

        // Start a match
        function startMatch() {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                return { success: false, error: 'Season is over' };
            }

            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) {
                return { success: false, error: 'Game already played' };
            }

            managementState.matchInProgress = true;
            managementState.currentPossession = 0;
            managementState.matchScore = { player: 0, opponent: 0 };
            managementState.currentScreen = 'game';
            managementState.gamePhase = 'regulation';  // regulation, twoMinuteDrill, overtime
            managementState.overtimePossession = 0;

            return { success: true, opponent: game.opponent, isHome: game.isHome };
        }

        // Record possession result (called after each arcade possession)
        function recordPossessionResult(points) {
            if (!managementState.matchInProgress) return;

            managementState.matchScore.player += points;

            // Enemy gets counter-possession
            const game = managementState.season.schedule[managementState.season.week - 1];
            const enemyResult = simulateEnemyPossession(game.opponent);
            managementState.matchScore.opponent += enemyResult.points;

            managementState.currentPossession++;

            const playerScore = managementState.matchScore.player;
            const oppScore = managementState.matchScore.opponent;
            const scoreDiff = playerScore - oppScore;

            // Check game state based on phase
            if (managementState.gamePhase === 'regulation') {
                if (managementState.currentPossession >= SEASON.POSSESSIONS_PER_GAME) {
                    // End of 4 quarters
                    if (scoreDiff === 0) {
                        // Tied - go to overtime
                        managementState.gamePhase = 'overtime';
                        managementState.overtimePossession = 0;
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'overtime',
                            message: 'Tied game! Heading to overtime!'
                        };
                    } else if (scoreDiff < 0 && scoreDiff >= -7) {
                        // Losing by 7 or less - 2 minute drill
                        managementState.gamePhase = 'twoMinuteDrill';
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'twoMinuteDrill',
                            message: `Down by ${Math.abs(scoreDiff)}! 2-minute drill to tie or win!`
                        };
                    } else {
                        // Game over (winning or losing by more than 7)
                        return endMatch();
                    }
                }
            } else if (managementState.gamePhase === 'twoMinuteDrill') {
                // After 2-minute drill possession
                if (scoreDiff === 0) {
                    // Tied - go to overtime
                    managementState.gamePhase = 'overtime';
                    managementState.overtimePossession = 0;
                    return {
                        ongoing: true,
                        possession: managementState.currentPossession,
                        score: managementState.matchScore,
                        enemyResult,
                        gamePhase: 'overtime',
                        message: 'Tied game! Heading to overtime!'
                    };
                } else {
                    // Game over (win or loss)
                    return endMatch();
                }
            } else if (managementState.gamePhase === 'overtime') {
                managementState.overtimePossession++;
                // In overtime, check after each possession pair
                if (scoreDiff !== 0) {
                    // Someone is ahead - game over
                    return endMatch();
                }
                // Still tied - continue overtime
                return {
                    ongoing: true,
                    possession: managementState.currentPossession,
                    score: managementState.matchScore,
                    enemyResult,
                    gamePhase: 'overtime',
                    message: `Overtime continues! Still tied ${playerScore}-${oppScore}`
                };
            }

            return {
                ongoing: true,
                possession: managementState.currentPossession,
                score: managementState.matchScore,
                enemyResult,
                gamePhase: managementState.gamePhase
            };
        }

        // End match
        function endMatch() {
            if (!managementState.matchInProgress) return null;

            const game = managementState.season.schedule[managementState.season.week - 1];
            const win = managementState.matchScore.player > managementState.matchScore.opponent;

            // Record result
            game.result = {
                playerScore: managementState.matchScore.player,
                opponentScore: managementState.matchScore.opponent,
                win
            };

            // Update records
            if (win) {
                managementState.team.record.wins++;
            } else {
                managementState.team.record.losses++;
            }

            // Award revenue
            const revenue = awardGameRevenue(game.isHome);

            // Process weekly progression
            const progressionResults = processWeeklyProgression();

            // Advance week
            managementState.season.week++;

            // Check end of season
            let seasonEnded = false;
            if (managementState.season.week > SEASON.WEEKS) {
                processEndOfSeason();
                seasonEnded = true;
            }

            managementState.matchInProgress = false;
            managementState.currentScreen = 'hub';

            if (managementState.settings.autoSave) SaveSystem.save();

            return {
                ongoing: false,
                result: game.result,
                revenue,
                progression: progressionResults,
                seasonEnded
            };
        }

        // ========================================
        // MANAGEMENT LAYER - GAME INTEGRATION
        // ========================================

        // Get player from depth chart slot
        function getDepthChartPlayer(slot) {
            if (!managementState.team || !managementState.team.depthChart) return null;

            const dc = managementState.team.depthChart;
            let playerId;

            if (Array.isArray(dc[slot])) {
                // For OL/DL arrays, slot should be like 'OL' with index
                return null;  // Handle differently
            } else {
                playerId = dc[slot];
            }

            if (!playerId) return null;
            return managementState.team.roster.find(p => p.id === playerId);
        }

        // Generate walk-on player (lower stats but not terrible) for empty slots
        function generateWalkOn(position) {
            const player = generatePlayer(position, 'average');
            // Reduce stats moderately - walk-ons should be below average but not terrible
            Object.keys(player.stats).forEach(stat => {
                player.stats[stat] = Math.max(55, player.stats[stat] - 10);
            });
            player.firstName = 'Recruit';
            player.lastName = position;
            player.salaryCost = 0;
            player.overall = calculateOverall(player);
            return player;
        }

        // Convert roster player to game receiver config
        function playerToReceiverConfig(player, index, startZ) {
            const xPositions = [-5, 0, 5];
            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                lastName: player.lastName,
                overall: player.overall || calculateOverall(player),
                playerId: player.id,
                start: new BABYLON.Vector3(xPositions[index], 0, startZ),
                route: [],  // Will be generated
                stats: { ...player.stats }
            };
        }

        // Convert roster player to game defender config
        function playerToDefenderConfig(player, index, startZ, receiverIndex) {
            const aiTypes = ['man', 'man', 'man', 'zone'];
            const cushions = [2, 4, 3, 4];
            const zoneColors = [
                new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(1.0, 0.5, 0.1)   // Orange for zone
            ];

            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                playerId: player.id,
                aiType: aiTypes[index],
                assignedReceiver: receiverIndex !== undefined ? receiverIndex : index,
                cushion: cushions[index],
                zoneCenter: index === 3 ? new BABYLON.Vector3(0, 0, startZ + 8) : null,
                zoneRadius: index === 3 ? 6 : 0,
                zoneColor: zoneColors[index],
                stats: { ...player.stats }
            };
        }

        // Get receiver configs from roster
        function getReceiverConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                let player = getDepthChartPlayer(slot);
                if (!player) {
                    player = generateWalkOn('WR');
                }
                configs.push(playerToReceiverConfig(player, index, RECEIVER_START_Z));
            });

            return configs;
        }

        // Get defender configs from opponent's roster
        function getDefenderConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            // Get opponent's CBs sorted by overall
            const oppCBs = opponent.roster
                .filter(p => p.position === 'CB')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppCBs[i];
                if (!player) {
                    player = generateWalkOn('CB');
                }
                configs.push(playerToDefenderConfig(player, i, RECEIVER_START_Z, i < 3 ? i : undefined));
            }

            return configs;
        }

        // Get OL configs from roster
        function getOLineConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;
            }

            const configs = [];
            const posLabels = ['C', 'LG', 'RG', 'LT', 'RT'];

            managementState.team.depthChart.OL.forEach((playerId, index) => {
                let player = playerId ? managementState.team.roster.find(p => p.id === playerId) : null;
                if (!player) {
                    player = generateWalkOn('OL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[index],
                    stats: { ...player.stats }
                });
            });

            return configs;
        }

        // Get DL configs from opponent's roster
        function getDLineConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;
            }

            const configs = [];
            const posLabels = ['LDE', 'LDT', 'RDT', 'RDE'];

            // Get opponent's DL sorted by overall
            const oppDL = opponent.roster
                .filter(p => p.position === 'DL')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppDL[i];
                if (!player) {
                    player = generateWalkOn('DL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[i],
                    stats: { ...player.stats }
                });
            }

            return configs;
        }

        // Record a stat for a roster player by their in-game mesh
        function recordPlayerStat(gameMesh, statName, increment = 1) {
            if (!gameMesh || !gameMesh.playerId) return;
            if (!managementState.team || !managementState.team.roster) return;

            const player = managementState.team.roster.find(p => p.id === gameMesh.playerId);
            if (!player) return;

            // Initialize stat if it doesn't exist
            if (player[statName] === undefined) player[statName] = 0;
            player[statName] += increment;
        }

        // Initialize management system
        function initializeManagement() {
            // Try to load existing save
            if (SaveSystem.exists()) {
                const saveData = SaveSystem.load();
                if (saveData && SaveSystem.applySaveData(saveData)) {
                    console.log('Loaded existing save');
                    managementState.currentScreen = 'hub';
                    return;
                }
            }

            // No save - show main menu
            managementState.currentScreen = 'main_menu';
        }

        // Start new game
        function startNewGame(teamName = 'Your Knights') {
            managementState.team = createNewTeam(teamName);
            managementState.season = createNewSeason();
            refreshFreeAgents();
            managementState.initialized = true;
            managementState.currentScreen = 'hub';

            SaveSystem.save();
        }

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 20;
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true
        });
        // Set hardware scaling for sharp rendering on high-DPI screens
        engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Camera is view-only, no user controls
            scene.activeCamera = camera;

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback - link to roster QB
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';

            // Link QB to roster player
            const rosterQB = getDepthChartPlayer('QB1');
            if (rosterQB) {
                qb.playerId = rosterQB.id;
                qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                qb.stats = { ...rosterQB.stats };
            } else {
                // Fallback stats
                qb.stats = {
                    throwing: 75, awareness: 70, agility: 65, speed: 60,
                    strength: 65, accuracy: 75, armStrength: 70
                };
            }

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line

            // Try to get roster configs, fall back to defaults
            const rosterReceiverConfigs = getReceiverConfigsFromRoster();
            const receiverConfigs = rosterReceiverConfigs || [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 80, acceleration: 72, agility: 85,
                        routeRunning: 88, release: 75, catching: 80,
                        jumping: 70, strength: 60, balance: 72,
                        aggression: 45, stamina: 80, focus: 88
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 80, acceleration: 92, agility: 78,
                        routeRunning: 65, release: 70, catching: 80,
                        jumping: 75, strength: 50, balance: 60,
                        aggression: 40, stamina: 85, focus: 68
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 80, acceleration: 78, agility: 80,
                        routeRunning: 82, release: 78, catching: 80,
                        jumping: 82, strength: 72, balance: 78,
                        aggression: 55, stamina: 82, focus: 80
                    }
                }
            ];

            // Defender configurations - try roster first
            const rosterDefenderConfigs = getDefenderConfigsFromRoster();
            const defenderConfigs = rosterDefenderConfigs || [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 70, agility: 75,
                        manCoverage: 80, zoneCoverage: 80, press: 78,
                        tackling: 80, hitPower: 85, pursuit: 75,
                        awareness: 72, strength: 82, balance: 78,
                        aggression: 75, stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 85, agility: 82,
                        manCoverage: 80, zoneCoverage: 80, press: 60,
                        tackling: 70, hitPower: 65, pursuit: 90,
                        awareness: 75, strength: 65, balance: 72,
                        aggression: 55, stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'man',
                    assignedReceiver: 2,  // Covers Baron Wyatt
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 68, agility: 70,
                        manCoverage: 80, zoneCoverage: 80, press: 72,
                        tackling: 85, hitPower: 90, pursuit: 72,
                        awareness: 85, strength: 88, balance: 82,
                        aggression: 70, stamina: 75
                    }
                },
                {
                    name: "The Sentinel",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 6,
                    cushion: 4,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 80, acceleration: 72, agility: 78,
                        manCoverage: 80, zoneCoverage: 80, press: 65,
                        tackling: 78, hitPower: 75, pursuit: 80,
                        awareness: 88, strength: 75, balance: 80,
                        aggression: 60, stamina: 82
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            // Store references for route regeneration
            gameState.scene = scene;
            gameState.routeMaterial = routeMat;

            receiverConfigs.forEach((config, i) => {
                // Clone material so each receiver can flash independently
                const receiverMat = materials.receiverMaterial.clone(`receiverMat_${i}`);
                const receiver = createKnight(scene, receiverMat, config.start.clone());
                receiver.name = `receiver_${i}`;
                receiver.bodyMaterial = receiverMat;
                receiver.originalColor = receiverMat.diffuseColor.clone();

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.lastName = config.lastName || config.name.split(' ').pop();  // Extract last name from display name if not provided
                receiver.overall = config.overall || Math.round(Object.values(config.stats).reduce((a, b) => a + b, 0) / Object.keys(config.stats).length);
                receiver.playerId = config.playerId || null;  // Link to roster player
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;

                // Derive base speed from stats (normalized to game units)
                receiver.baseSpeed = config.stats.speed * 0.00064;  // Balanced pace
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // Legacy - kept for compatibility
                receiver.clashSpeedPenaltyUntil = 0;  // Clash loser speed penalty timer
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;  // Track if WR/DB were apart before clashing
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);  // White
                fillMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                fillMat.alpha = 0.5;  // Base visibility
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);  // Start with base visible circle

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation
                receiver.clashTiltUntil = 0;  // For grappling tilt
                receiver.clashTiltAngle = 0;
                receiver.loserFlashUntil = 0;   // Red flash when losing clash
                receiver.winnerFlashUntil = 0;  // Green flash when winning clash
                receiver.clashSpeedBoostUntil = 0;  // Speed boost timer

                // Hide the outer ring - only show proximity-based fill
                zoneRing.setEnabled(false);

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders (skip in training mode)
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            if (!gameState.trainingMode) {
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                // Clone material so each defender can flash independently
                const defenderMat = materials.defenderMaterial.clone(`defenderMat_${i}`);
                const defender = createKnight(scene, defenderMat, startPos);
                defender.name = `defender_${i}`;
                defender.bodyMaterial = defenderMat;
                defender.originalColor = defenderMat.diffuseColor.clone();

                // Store config data on defender
                defender.displayName = config.name;
                defender.playerId = config.playerId || null;  // Link to roster player
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.startPos = startPos.clone();

                // Derive base speed from stats
                defender.baseSpeed = config.stats.speed * 0.00064;  // Matches receiver pace
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact
                defender.clashSpeedPenaltyUntil = 0;  // Speed penalty from losing clash

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation
                defender.clashTiltUntil = 0;  // For grappling tilt
                defender.clashTiltAngle = 0;
                defender.loserFlashUntil = 0;   // Red flash when losing clash
                defender.winnerFlashUntil = 0;  // Green flash when winning clash

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });
            } // End of training mode skip for defenders

            // Offensive Line configurations (5 players) - skip in training mode
            if (!gameState.trainingMode) {
            const LINE_OF_SCRIMMAGE_Z = RECEIVER_START_Z;  // Same as receivers start
            const rosterOLineConfigs = getOLineConfigsFromRoster();
            const defaultOLineConfigs = [
                {
                    name: "Sir Bulwark",
                    position: 'C',
                    startX: 0,
                    stats: { passBlock: 82, strength: 80, balance: 85, awareness: 80, speed: 60, acceleration: 65 }
                },
                {
                    name: "Ironside",
                    position: 'LG',
                    startX: -1.5,
                    stats: { passBlock: 80, strength: 85, balance: 78, awareness: 75, speed: 58, acceleration: 62 }
                },
                {
                    name: "Stonewall",
                    position: 'RG',
                    startX: 1.5,
                    stats: { passBlock: 78, strength: 88, balance: 80, awareness: 72, speed: 55, acceleration: 60 }
                },
                {
                    name: "Rampart",
                    position: 'LT',
                    startX: -3.5,
                    stats: { passBlock: 85, strength: 78, balance: 82, awareness: 78, speed: 62, acceleration: 68 }
                },
                {
                    name: "Bastion",
                    position: 'RT',
                    startX: 3.5,
                    stats: { passBlock: 83, strength: 80, balance: 80, awareness: 76, speed: 60, acceleration: 65 }
                }
            ];
            // Merge roster configs with default positions/startX
            const oLineConfigs = rosterOLineConfigs ? rosterOLineConfigs.map((rc, i) => ({
                ...defaultOLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultOLineConfigs;

            // Create Offensive Line
            oLineConfigs.forEach((config, i) => {
                const oLineMat = materials.oLineMaterial.clone(`oLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z - 0.5);
                const oLineman = createLineman(scene, oLineMat, startPos, true);
                oLineman.name = `oline_${i}`;
                oLineman.displayName = config.name;
                oLineman.playerId = config.playerId || null;  // Link to roster player
                oLineman.position_label = config.position;
                oLineman.stats = config.stats;
                oLineman.startPos = startPos.clone();
                oLineman.baseSpeed = config.stats.speed * 0.0004;
                oLineman.speed = oLineman.baseSpeed;

                // Blocking state
                oLineman.engagedWith = null;         // D-lineman currently blocking
                oLineman.lastClashTime = 0;
                oLineman.knockdownUntil = 0;
                oLineman.bodyMaterial = oLineMat;
                oLineman.originalColor = oLineMat.diffuseColor.clone();

                gameState.offensiveLine.push(oLineman);
            });

            // Defensive Line configurations (4 players) - try roster first
            const rosterDLineConfigs = getDLineConfigsFromRoster();
            const defaultDLineConfigs = [
                {
                    name: "Siege Breaker",
                    position: 'LDE',
                    startX: -3,
                    stats: { passRush: 82, strength: 80, acceleration: 78, speed: 72, awareness: 75, tackling: 80 }
                },
                {
                    name: "Crusher",
                    position: 'LDT',
                    startX: -1,
                    stats: { passRush: 78, strength: 90, acceleration: 70, speed: 65, awareness: 72, tackling: 82 }
                },
                {
                    name: "Devastator",
                    position: 'RDT',
                    startX: 1,
                    stats: { passRush: 80, strength: 88, acceleration: 72, speed: 68, awareness: 74, tackling: 80 }
                },
                {
                    name: "Ramraid",
                    position: 'RDE',
                    startX: 3,
                    stats: { passRush: 85, strength: 78, acceleration: 82, speed: 75, awareness: 78, tackling: 78 }
                }
            ];
            // Merge roster configs with default positions/startX
            const dLineConfigs = rosterDLineConfigs ? rosterDLineConfigs.map((rc, i) => ({
                ...defaultDLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultDLineConfigs;

            // Create Defensive Line
            dLineConfigs.forEach((config, i) => {
                const dLineMat = materials.dLineMaterial.clone(`dLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z + 0.5);
                const dLineman = createLineman(scene, dLineMat, startPos, false);
                dLineman.name = `dline_${i}`;
                dLineman.displayName = config.name;
                dLineman.playerId = config.playerId || null;  // Link to roster player
                dLineman.position_label = config.position;
                dLineman.stats = config.stats;
                dLineman.startPos = startPos.clone();
                dLineman.baseSpeed = config.stats.speed * 0.0005;
                dLineman.speed = dLineman.baseSpeed;

                // Pass rush state
                dLineman.engagedWith = null;         // O-lineman currently engaged with
                dLineman.lastClashTime = 0;
                dLineman.knockdownUntil = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial = dLineMat;
                dLineman.originalColor = dLineMat.diffuseColor.clone();

                gameState.defensiveLine.push(dLineman);
            });
            } // End of training mode skip for OL/DL

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Get QB data from roster
            let qbPlayer = null;
            if (managementState.initialized && managementState.team && managementState.team.depthChart.QB) {
                qbPlayer = managementState.team.roster.find(p => p.id === managementState.team.depthChart.QB);
            }
            if (!qbPlayer) {
                qbPlayer = { firstName: 'Knight', lastName: 'Commander', overall: 80 };
            }
            qb.lastName = qbPlayer.lastName;
            qb.overall = qbPlayer.overall;
            qb.displayName = `${qbPlayer.firstName} ${qbPlayer.lastName.charAt(0)}.`;

            // Add name label to QB (stacked: name on top, OVR below bigger)
            const qbLabelRect = new BABYLON.GUI.Rectangle();
            qbLabelRect.width = '140px';
            qbLabelRect.height = '70px';
            qbLabelRect.cornerRadius = 6;
            qbLabelRect.thickness = 0;
            qbLabelRect.background = 'rgba(0, 0, 0, 0.7)';

            const qbStack = new BABYLON.GUI.StackPanel();
            qbStack.isVertical = true;

            const qbNameText = new BABYLON.GUI.TextBlock();
            qbNameText.text = qb.lastName.toUpperCase();
            qbNameText.color = '#ffcc44';
            qbNameText.fontSize = 20;
            qbNameText.fontFamily = 'Courier New';
            qbNameText.fontWeight = 'bold';
            qbNameText.outlineWidth = 3;
            qbNameText.outlineColor = '#000000';
            qbNameText.height = '28px';

            const qbOvrText = new BABYLON.GUI.TextBlock();
            qbOvrText.text = `${qb.overall}`;
            qbOvrText.color = '#ffffff';
            qbOvrText.fontSize = 28;
            qbOvrText.fontFamily = 'Courier New';
            qbOvrText.fontWeight = 'bold';
            qbOvrText.outlineWidth = 4;
            qbOvrText.outlineColor = '#000000';
            qbOvrText.height = '36px';

            qbStack.addControl(qbNameText);
            qbStack.addControl(qbOvrText);
            qbLabelRect.addControl(qbStack);

            advancedTexture.addControl(qbLabelRect);
            qbLabelRect.linkWithMesh(qb);
            qbLabelRect.linkOffsetY = -70;
            qbLabelRect.alpha = 1;  // Show when frozen

            qb.nameLabel = qbLabelRect;
            qb.nameTextBlock = qbNameText;
            qb.ovrTextBlock = qbOvrText;

            // Add name labels to receivers (stacked: name on top, OVR below bigger)
            gameState.receivers.forEach((receiver, i) => {
                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '130px';
                labelRect.height = '65px';
                labelRect.cornerRadius = 6;
                labelRect.thickness = 0;
                labelRect.background = 'rgba(0, 0, 0, 0.65)';

                const stack = new BABYLON.GUI.StackPanel();
                stack.isVertical = true;

                const nameText = new BABYLON.GUI.TextBlock();
                nameText.text = receiver.lastName.toUpperCase();
                nameText.color = '#88bbff';
                nameText.fontSize = 18;
                nameText.fontFamily = 'Courier New';
                nameText.fontWeight = 'bold';
                nameText.outlineWidth = 3;
                nameText.outlineColor = '#000000';
                nameText.height = '26px';

                const ovrText = new BABYLON.GUI.TextBlock();
                ovrText.text = `${receiver.overall}`;
                ovrText.color = '#ffffff';
                ovrText.fontSize = 26;
                ovrText.fontFamily = 'Courier New';
                ovrText.fontWeight = 'bold';
                ovrText.outlineWidth = 4;
                ovrText.outlineColor = '#000000';
                ovrText.height = '34px';

                stack.addControl(nameText);
                stack.addControl(ovrText);
                labelRect.addControl(stack);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -65;
                labelRect.alpha = 1;  // Show when frozen

                receiver.nameLabel = labelRect;
                receiver.nameTextBlock = nameText;
                receiver.ovrTextBlock = ovrText;
            });

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark gray enemies
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            defenderMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            // Offensive line material - similar to receivers (blue)
            const oLineMaterial = new BABYLON.StandardMaterial('oLineMat', scene);
            oLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            oLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            oLineMaterial.specularPower = 32;

            // Defensive line material - similar to defenders (dark gray)
            const dLineMaterial = new BABYLON.StandardMaterial('dLineMat', scene);
            dLineMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            dLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            dLineMaterial.specularPower = 32;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial, oLineMaterial, dLineMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Main field (extended for deeper end zone and own territory)
            const field = BABYLON.MeshBuilder.CreateGround('field', {
                width: FIELD_WIDTH + 2,
                height: FIELD_LENGTH + 12
            }, scene);
            field.material = materials.fieldMaterial;
            field.position.z = -0.5;

            // Yard lines - only 10-yard markers (every 5 units)
            for (let i = 0; i <= 10; i += 5) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.1
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.01, i);
            }

            // End zone (30% deeper)
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 4
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 13);

            // Border walls (castle-like)
            const wallHeight = 0.8;
            const wallPositions = [
                { x: -FIELD_WIDTH/2 - 0.5, z: -0.5, width: 1, depth: FIELD_LENGTH + 12 },
                { x: FIELD_WIDTH/2 + 0.5, z: -0.5, width: 1, depth: FIELD_LENGTH + 12 }
            ];

            wallPositions.forEach((wp, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall_${i}`, {
                    width: wp.width,
                    height: wallHeight,
                    depth: wp.depth
                }, scene);
                const wallMat = new BABYLON.StandardMaterial(`wallMat_${i}`, scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.35, 0.3, 0.25);
                wall.material = wallMat;
                wall.position.set(wp.x, wallHeight/2, wp.z);

                // Battlements
                for (let j = 0; j < 13; j++) {
                    const merlon = BABYLON.MeshBuilder.CreateBox(`merlon_${i}_${j}`, {
                        width: 0.4,
                        height: 0.3,
                        depth: 0.4
                    }, scene);
                    merlon.material = wallMat;
                    merlon.position.set(wp.x, wallHeight + 0.15, -13 + j * 2.2);
                }
            });

            // Line of scrimmage marker (blue)
            const losLine = BABYLON.MeshBuilder.CreateBox('losLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const losMat = new BABYLON.StandardMaterial('losMat', scene);
            losMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.9);
            losMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
            losMat.alpha = 0.8;
            losLine.material = losMat;
            losLine.position.set(0, 0.02, gameState.lineOfScrimmage);
            scene.losLine = losLine;

            // First down marker (yellow)
            const firstDownLine = BABYLON.MeshBuilder.CreateBox('firstDownLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const fdMat = new BABYLON.StandardMaterial('fdMat', scene);
            fdMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.2);
            fdMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.1);
            fdMat.alpha = 0.8;
            firstDownLine.material = fdMat;
            firstDownLine.position.set(0, 0.02, gameState.firstDownMarker);
            scene.firstDownLine = firstDownLine;
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Lineman Figure (larger than receivers)
        const createLineman = (scene, material, position, isOffense) => {
            const lineman = new BABYLON.TransformNode('lineman', scene);
            const scale = 1.25;  // Linemen are 25% bigger than receivers

            // Body (larger than knight)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = lineman;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = lineman;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = lineman;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35 * scale,
                height: 0.45 * scale,
                depth: 0.08 * scale
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3 * scale, 0.5 * scale, 0.1 * scale);
            shield.parent = lineman;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4 * scale,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = lineman;

            lineman.position = position;
            lineman.idleTime = Math.random() * Math.PI * 2;

            return lineman;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football - larger and more visible
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.6,
                segments: 12
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.5, 0.5, 1.2);  // More elongated football shape
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces - scaled up to match larger ball
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.08,
                height: 0.03,
                depth: 0.25
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            laceMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);  // Glow for visibility
            laces.material = laceMat;
            laces.position.y = 0.14;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters with smoothing to prevent jerky aiming
        let lastValidAngle = 0;  // Store last valid angle for smoothing
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Distance dragged determines throw power
            const rawDragDistance = Math.sqrt(dx * dx + dy * dy);
            const dragDistance = rawDragDistance * DRAG_SENSITIVITY;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), MAX_THROW_DISTANCE);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            // Only update angle if drag distance is significant enough to be stable
            let angle;
            if (rawDragDistance > 5) {  // At least 5 pixels of drag for stable angle
                angle = Math.atan2(dx, -dy);
                lastValidAngle = angle;
            } else {
                angle = lastValidAngle;  // Use last valid angle for very small drags
            }

            return {
                distance: throwDistance,
                angle: angle,
                power: throwDistance / MAX_THROW_DISTANCE
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw distance
            // Short throws (power ~0.2) = low arc (1.5), long throws (power ~1.0) = high arc (6)
            const maxHeight = 1 + power * power * 5;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                return false; // Route complete
            }

            let target = receiver.route[receiver.routeIndex];
            let dx = target.x - receiver.position.x;
            let dz = target.z - receiver.position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);

            // Check if reached current waypoint
            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                if (receiver.routeIndex >= receiver.route.length) {
                    receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                    return false; // Route complete
                }
                // Continue toward new waypoint this frame (don't skip a frame)
                target = receiver.route[receiver.routeIndex];
                dx = target.x - receiver.position.x;
                dz = target.z - receiver.position.z;
                dist = Math.sqrt(dx * dx + dz * dz);
            }

            if (dist > 0.1) {
                // Calculate and store velocity
                const vx = (dx / dist) * runSpeed;
                const vz = (dz / dist) * runSpeed;
                receiver.velocity = new BABYLON.Vector3(vx, 0, vz);

                // Move toward target
                receiver.position.x += vx;
                receiver.position.z += vz;
                receiver.rotation.y = Math.atan2(dx, dz);

                // Track running momentum for forward lean
                receiver.runMomentum = Math.min((receiver.runMomentum || 0) + 0.15, 1);
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0);
                // Decay forward lean when stopped
                receiver.runMomentum = (receiver.runMomentum || 0) * 0.9;
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.15;
            }
            return true;
        };

        // Apply forward lean to any player mesh when running
        const applyMomentumTilt = (player, dx, dz, dist, isMoving) => {
            if (isMoving && dist > 0.1) {
                // Track running momentum for forward lean
                player.runMomentum = Math.min((player.runMomentum || 0) + 0.15, 1);
                player.rotation.x = (player.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                // Decay forward lean when stopped
                player.runMomentum = (player.runMomentum || 0) * 0.9;
                player.rotation.x = (player.runMomentum || 0) * 0.15;
            }
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            // Reaction delay at start of play - defenders don't move immediately
            const timeSincePlayStart = gameState.gameTime - (gameState.playStartTime || 0);
            if (defender.reactionDelay && timeSincePlayStart < defender.reactionDelay) {
                return;  // Still reacting, don't move yet
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.2);
        };

        // Zone coverage AI - patrol assigned area, react to nearby receivers
        const moveDefenderZoneCoverage = (defender, speed) => {
            // Find nearest receiver in zone
            let nearestReceiver = null;
            let nearestDist = defender.zoneRadius;

            gameState.receivers.forEach(receiver => {
                const dx = receiver.position.x - defender.zoneCenter.x;
                const dz = receiver.position.z - defender.zoneCenter.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver in zone
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;  // Stay slightly behind
            } else {
                // Patrol zone center
                targetX = defender.zoneCenter.x;
                targetZ = defender.zoneCenter.z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.5);
        };

        // ============================================
        // LINE MOVEMENT AND CLASH SYSTEM
        // ============================================

        // Move D-lineman - rush toward QB
        const moveDLineman = (dLineman) => {
            // Skip if knocked down
            if (dLineman.knockdownUntil > gameState.gameTime) {
                dLineman.position.y = 0;
                return;
            }

            // Get QB position (use current QB position for evasion tracking)
            const qbPos = gameState.scene.qb.position;

            // Calculate speed with any boosts
            let speed = dLineman.baseSpeed;
            if (dLineman.speedBoostUntil > gameState.gameTime) {
                speed *= LINE_CLASH_CONSTANTS.SPEED_BURST_MULTIPLIER;
            }

            // Apply engagement slowdown
            if (dLineman.engagedWith && !dLineman.engagedWith.knockdownUntil) {
                speed *= dLineman.currentSpeedMultiplier;
            }

            // Rush toward QB
            const dx = qbPos.x - dLineman.position.x;
            const dz = qbPos.z - dLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                dLineman.position.x += (dx / dist) * speed;
                dLineman.position.z += (dz / dist) * speed;
                dLineman.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(dLineman, dx, dz, dist, dist > 0.3);
        };

        // Move O-lineman - stay between assigned D-lineman and QB
        const moveOLineman = (oLineman) => {
            // Skip if knocked down
            if (oLineman.knockdownUntil > gameState.gameTime) {
                oLineman.position.y = 0;
                return;
            }

            const qbPos = gameState.scene.qb.position;

            // Find best D-lineman to block
            const targetDLineman = findBlockingTarget(oLineman);

            if (!targetDLineman) {
                // No target - hold position
                return;
            }

            // Update engagement
            oLineman.engagedWith = targetDLineman;

            // Calculate ideal blocking position - between D-lineman and QB
            const dLinePos = targetDLineman.position;

            // Vector from D-lineman to QB
            const toQbX = qbPos.x - dLinePos.x;
            const toQbZ = qbPos.z - dLinePos.z;
            const toQbDist = Math.sqrt(toQbX * toQbX + toQbZ * toQbZ);

            if (toQbDist < 0.5) return;  // Too close, don't move

            // Position 0.8 units in front of D-lineman (toward QB)
            const blockDist = 0.8;
            const targetX = dLinePos.x + (toQbX / toQbDist) * blockDist;
            const targetZ = dLinePos.z + (toQbZ / toQbDist) * blockDist;

            const dx = targetX - oLineman.position.x;
            const dz = targetZ - oLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                const speed = oLineman.baseSpeed;
                oLineman.position.x += (dx / dist) * speed;
                oLineman.position.z += (dz / dist) * speed;
                // Face the D-lineman
                oLineman.rotation.y = Math.atan2(dLinePos.x - oLineman.position.x, dLinePos.z - oLineman.position.z);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(oLineman, dx, dz, dist, dist > 0.2);
        };

        // Find the best D-lineman for an O-lineman to block
        const findBlockingTarget = (oLineman) => {
            const qbPos = gameState.scene.qb.position;
            let bestTarget = null;
            let bestScore = -Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip knocked down D-linemen
                if (dLineman.knockdownUntil > gameState.gameTime) return;

                // Calculate threat level (closer to QB = more threatening)
                const distToQb = BABYLON.Vector3.Distance(dLineman.position, qbPos);
                const distToOLine = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);

                // Check if another O-lineman is already blocking this D-lineman
                let alreadyBlocked = false;
                let blockingOLineman = null;
                gameState.offensiveLine.forEach(other => {
                    if (other !== oLineman && other.engagedWith === dLineman &&
                        other.knockdownUntil <= gameState.gameTime) {
                        alreadyBlocked = true;
                        blockingOLineman = other;
                    }
                });

                // Scoring: prioritize unblocked D-linemen, close to self, close to QB
                let score = 0;

                // Heavily prioritize unblocked rushers
                if (!alreadyBlocked) {
                    score += 100;
                }

                // Prefer D-linemen close to this O-lineman (easier to reach)
                score -= distToOLine * 5;

                // Prefer D-linemen closer to QB (more threatening)
                score -= distToQb * 2;

                // If this O-lineman was already blocking this D-lineman, prefer to stay
                if (oLineman.engagedWith === dLineman) {
                    score += 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = dLineman;
                }
            });

            return bestTarget;
        };

        // Process line clashes between O-line and D-line
        const processLineClashes = () => {
            const currentTime = gameState.gameTime;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip if knocked down
                if (dLineman.knockdownUntil > currentTime) {
                    dLineman.currentSpeedMultiplier = 0;
                    return;
                }

                // Reset speed boost if expired
                if (dLineman.speedBoostUntil <= currentTime) {
                    dLineman.speedBoostUntil = 0;
                }

                // Find closest O-lineman
                let closestOLineman = null;
                let closestDist = LINE_CLASH_CONSTANTS.CLASH_RANGE;

                gameState.offensiveLine.forEach(oLineman => {
                    if (oLineman.knockdownUntil > currentTime) return;

                    const dist = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestOLineman = oLineman;
                    }
                });

                if (closestOLineman) {
                    // Engaged with O-lineman
                    dLineman.engagedWith = closestOLineman;
                    closestOLineman.engagedWith = dLineman;

                    // Check if it's time for a clash resolution
                    const timeSinceLastClash = currentTime - dLineman.lastClashTime;
                    if (timeSinceLastClash >= LINE_CLASH_CONSTANTS.CLASH_INTERVAL) {
                        resolveLineClash(closestOLineman, dLineman);
                    }
                } else {
                    // Not engaged - full speed
                    dLineman.engagedWith = null;
                    dLineman.currentSpeedMultiplier = 1.0;
                }
            });
        };

        // Resolve a clash between O-lineman and D-lineman
        const resolveLineClash = (oLineman, dLineman) => {
            const currentTime = gameState.gameTime;

            // Update clash timing
            oLineman.lastClashTime = currentTime;
            dLineman.lastClashTime = currentTime;

            // Roll for clash
            const oLineRoll = weightedRoll(oLineman.stats, CLASH_WEIGHTS.lineClash.offense);
            const dLineRoll = weightedRoll(dLineman.stats, CLASH_WEIGHTS.lineClash.defense);

            const margin = oLineRoll - dLineRoll;

            if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD) {
                // O-line wins decisively - knock down D-lineman
                dLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                dLineman.currentSpeedMultiplier = 0;
                dLineman.engagedWith = null;

                // O-lineman is free to help another
                oLineman.engagedWith = null;

                // Record clash stats
                recordPlayerStat(oLineman, 'seasonClashesWon');
                recordPlayerStat(dLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesWon++;
                    oStats.clashDifficulties.push(margin);
                }
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD) {
                // D-line wins decisively - knock O-lineman aside, speed burst
                oLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                oLineman.engagedWith = null;

                // D-lineman gets speed burst
                dLineman.speedBoostUntil = currentTime + LINE_CLASH_CONSTANTS.SPEED_BURST_DURATION;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.engagedWith = null;

                // Knock O-lineman to the side
                const sideDir = Math.random() > 0.5 ? 1 : -1;
                oLineman.position.x += sideDir * 1.5;

                // Record clash stats
                recordPlayerStat(dLineman, 'seasonClashesWon');
                recordPlayerStat(oLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesWon++;
                    dStats.clashDifficulties.push(-margin);
                }
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesLost++;
                    oStats.clashDifficulties.push(margin);
                }

            } else if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD / 2) {
                // O-line winning but not decisive - D-lineman very slow
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD / 2) {
                // D-line winning but not decisive - breaking through slowly
                dLineman.currentSpeedMultiplier = 0.5;

            } else {
                // Neutral - D-lineman nearly stopped
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;
            }
        };

        // Reset offensive line to starting positions
        const resetOffensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.offensiveLine.forEach((oLineman, i) => {
                oLineman.position.x = oLineman.startPos.x;
                oLineman.position.z = lineZ - 0.5;
                oLineman.position.y = 0;
                oLineman.rotation.y = 0;
                oLineman.rotation.x = 0;
                oLineman.knockdownUntil = 0;
                oLineman.engagedWith = null;
                oLineman.lastClashTime = 0;
                oLineman.bodyMaterial.diffuseColor = oLineman.originalColor;
                oLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // Reset defensive line to starting positions
        const resetDefensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.defensiveLine.forEach((dLineman, i) => {
                dLineman.position.x = dLineman.startPos.x;
                dLineman.position.z = lineZ + 0.5;
                dLineman.position.y = 0;
                dLineman.rotation.y = Math.PI;  // Face the offense
                dLineman.rotation.x = 0;
                dLineman.knockdownUntil = 0;
                dLineman.engagedWith = null;
                dLineman.lastClashTime = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial.diffuseColor = dLineman.originalColor;
                dLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // ============================================
        // QB MOVEMENT AND SACK SYSTEM
        // ============================================

        // Move QB based on pocket behavior and threats
        const moveQB = (scene) => {
            const qb = scene.qb;
            const currentTime = gameState.gameTime;

            // Don't move if play has ended or ball is being thrown
            if (gameState.playEnded || gameState.ballInFlight) return;

            // Skip QB movement/sack logic in training mode
            if (gameState.trainingMode) return;

            // Find closest threat (D-lineman)
            let closestThreat = null;
            let closestThreatDist = Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                if (dLineman.knockdownUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(dLineman.position, qb.position);
                if (dist < closestThreatDist) {
                    closestThreatDist = dist;
                    closestThreat = dLineman;
                }
            });

            // Check for sack
            if (closestThreatDist < LINE_CLASH_CONSTANTS.TACKLE_RANGE) {
                handleSack(scene, closestThreat);
                return;
            }

            // Calculate pocket position relative to line of scrimmage
            const losZ = gameState.lineOfScrimmage;
            const pocketCenterZ = losZ - 3;  // 3 yards behind LOS
            const maxDepthZ = losZ - 6;       // 6 yards behind LOS max

            let targetX = qb.position.x;
            let targetZ = pocketCenterZ;
            let speed = POCKET_CONSTANTS.SETTLE_SPEED;

            // If threat is close, evade
            if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                speed = POCKET_CONSTANTS.EVADE_SPEED;

                // Calculate evasion direction (away from threat)
                const threatDx = qb.position.x - closestThreat.position.x;
                const threatDz = qb.position.z - closestThreat.position.z;
                const threatDist = Math.sqrt(threatDx * threatDx + threatDz * threatDz);

                if (threatDist > 0.1) {
                    // Move away from threat
                    targetX = qb.position.x + (threatDx / threatDist) * 2;
                    targetZ = qb.position.z + (threatDz / threatDist) * 2;
                }
            }

            // Apply constraints
            // Don't cross line of scrimmage
            targetZ = Math.min(targetZ, losZ);

            // Don't go too deep
            targetZ = Math.max(targetZ, maxDepthZ);

            // Stay within pocket width (with some flexibility when evading)
            const maxX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MAX_X + 2 : POCKET_CONSTANTS.POCKET_MAX_X;
            const minX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MIN_X - 2 : POCKET_CONSTANTS.POCKET_MIN_X;
            targetX = Math.max(minX, Math.min(maxX, targetX));

            // Move toward target
            const dx = targetX - qb.position.x;
            const dz = targetZ - qb.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                qb.position.x += (dx / dist) * speed;
                qb.position.z += (dz / dist) * speed;

                // Face the threat or downfield
                if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                    const faceDx = closestThreat.position.x - qb.position.x;
                    const faceDz = closestThreat.position.z - qb.position.z;
                    qb.rotation.y = Math.atan2(faceDx, faceDz);
                }
            }
        };

        // Handle QB sack
        const handleSack = (scene, tackler) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.qbSacked = true;
            gameState.canThrow = false;

            // Record sack for roster player
            recordPlayerStat(tackler, 'seasonSacks');

            // Record per-game sack stats
            if (tackler.playerId) {
                gameStats.getPlayer(tackler.playerId, tackler.displayName).sacks++;
            }

            // Move line of scrimmage back to sack location
            handleSackFieldPosition(scene.qb.position.z);

            updateMessage(`SACK by ${tackler.displayName}!`);

            // QB falls down animation
            const qb = scene.qb;
            qb.rotation.x = Math.PI / 3;  // Fall forward

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // ============================================
        // RECEIVER TACKLING SYSTEM
        // ============================================

        // Move ball carrier (receiver with the ball) toward end zone
        const moveBallCarrier = (receiver) => {
            if (!receiver || receiver.knockdownUntil > gameState.gameTime) return;

            // Calculate effective speed with any boosts
            let speed = receiver.baseSpeed;
            if (receiver.breakTackleBoostUntil > gameState.gameTime) {
                speed *= TACKLE_CONSTANTS.BREAK_TACKLE_BOOST;
            }

            // Run toward back of end zone (positive Z direction)
            const targetZ = 15;  // Back of end zone
            const targetX = receiver.position.x;  // Maintain lane for now

            const dz = targetZ - receiver.position.z;
            const dx = targetX - receiver.position.x;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                receiver.position.z += (dz / dist) * speed;
                receiver.position.x += (dx / dist) * speed * 0.3;  // Slight drift
                receiver.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(receiver, dx, dz, dist, dist > 0.1);

            // Check for touchdown
            if (receiver.position.z >= 12) {
                handleTouchdown(receiver);
                return;
            }

            // Check for out of bounds
            if (Math.abs(receiver.position.x) > 8) {
                handleOutOfBounds(receiver);
                return;
            }
        };

        // Process tackle attempts by defenders on ball carrier
        const processTackles = () => {
            const receiver = gameState.ballCarrier;
            if (!receiver || gameState.playEnded) return;

            const currentTime = gameState.gameTime;

            // Check all defenders for tackle attempts
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > currentTime) return;
                if (defender.tackleStumbleUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(defender.position, receiver.position);

                if (dist < TACKLE_CONSTANTS.TACKLE_RANGE) {
                    // Check tackle cooldown
                    const timeSinceLastTackle = currentTime - (defender.lastTackleTime || 0);
                    if (timeSinceLastTackle < TACKLE_CONSTANTS.TACKLE_INTERVAL) return;

                    // Attempt tackle
                    resolveTackle(receiver, defender);
                }
            });
        };

        // Resolve a tackle attempt
        const resolveTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;
            defender.lastTackleTime = currentTime;

            // Roll for tackle
            const tackleRoll = weightedRoll(defender.stats, CLASH_WEIGHTS.tackle.tackler);
            const evasionRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier);

            const margin = tackleRoll - evasionRoll;

            // Tackling favors the defender - receiver needs to significantly outroll
            // to break a tackle (margin must be < -12, meaning receiver wins by 12+)
            if (margin > -12) {
                // Tackle successful!
                handleTackle(receiver, defender);
            } else {
                // Broken tackle! (rare - requires big evasion win)
                handleBrokenTackle(receiver, defender);
            }
        };

        // Handle successful tackle
        const handleTackle = (receiver, defender) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Record tackle for roster player
            recordPlayerStat(defender, 'seasonTackles');

            // Record per-game tackle stats
            if (defender.playerId) {
                gameStats.getPlayer(defender.playerId, defender.displayName).tackles++;
            }

            // Record YAC for receiver
            if (receiver.playerId && receiver.catchPosition !== undefined) {
                const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                gameStats.getPlayer(receiver.playerId, receiver.displayName).yardsAfterCatch += yac;
            }

            // Advance ball to tackle location
            advanceBall(receiver.position.z);

            updateMessage(`TACKLED by ${defender.displayName}!`);

            // Receiver falls down
            receiver.rotation.x = Math.PI / 3;
            receiver.position.y = 0;

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Flash effects
            defender.bodyMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.5, 0.1);
            setTimeout(() => {
                defender.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 500);

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // Handle broken tackle
        const handleBrokenTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            updateMessage(`BROKEN TACKLE!`);

            // Defender stumbles
            defender.tackleStumbleUntil = currentTime + TACKLE_CONSTANTS.STUMBLE_DURATION;
            defender.rotation.x = Math.PI / 6;  // Lean forward stumbling

            // Receiver gets speed boost
            receiver.breakTackleBoostUntil = currentTime + TACKLE_CONSTANTS.BREAK_TACKLE_DURATION;

            // Flash receiver green
            receiver.bodyMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.1);
            setTimeout(() => {
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 300);

            // Reset defender stumble rotation
            setTimeout(() => {
                defender.rotation.x = 0;
            }, TACKLE_CONSTANTS.STUMBLE_DURATION * 1000);
        };

        // Reset the drive to starting position (after TD or turnover on downs)
        const resetDrive = () => {
            gameState.down = 1;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.lineOfScrimmage + 10;
            gameState.yardsToGo = 10;
        };

        // Advance the ball to a new position and handle down logic
        const advanceBall = (newPositionZ) => {
            const END_ZONE_Z = 11;  // Touchdown threshold (matches visual end zone start)
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = newPositionZ - oldLOS;

            // Update line of scrimmage
            gameState.lineOfScrimmage = newPositionZ;

            // Check for first down
            if (newPositionZ >= gameState.firstDownMarker) {
                // First down achieved!
                gameState.down = 1;
                gameState.firstDownMarker = newPositionZ + 10;
                gameState.yardsToGo = 10;

                // Cap first down marker at end zone
                if (gameState.firstDownMarker > END_ZONE_Z) {
                    gameState.yardsToGo = END_ZONE_Z - newPositionZ;
                    gameState.firstDownMarker = END_ZONE_Z;
                }

                updateMessage('FIRST DOWN!');
            } else {
                // No first down, advance to next down
                gameState.down++;
                gameState.yardsToGo = gameState.firstDownMarker - newPositionZ;

                if (gameState.down > 4) {
                    // Turnover on downs!
                    updateMessage('TURNOVER ON DOWNS!');
                    resetDrive();
                    // Management: record possession complete with 0 points (turnover)
                    if (managementState.matchInProgress) {
                        gameState.waitingForPossession = true;
                        setTimeout(() => {
                            onPossessionComplete(0);
                        }, 1500);
                    }
                }
            }
        };

        // Handle incomplete pass (same line of scrimmage, next down)
        const handleIncomplete = () => {
            gameState.down++;
            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle sack (move line back)
        const handleSackFieldPosition = (sackPositionZ) => {
            // Sack moves the line of scrimmage back
            const newLOS = Math.max(-8, sackPositionZ);  // Don't go too far back
            gameState.lineOfScrimmage = newLOS;
            gameState.yardsToGo = gameState.firstDownMarker - newLOS;
            gameState.down++;

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle touchdown
        const handleTouchdown = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.touchdowns++;
            updateScore();

            // Record TD for roster player
            recordPlayerStat(receiver, 'seasonTDs');

            // Record per-game TD stats
            if (receiver.playerId) {
                const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                rStats.touchdowns++;
                // Also record YAC for TD run
                if (receiver.catchPosition !== undefined) {
                    const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                    rStats.yardsAfterCatch += yac;
                }
            }

            updateMessage(`TOUCHDOWN by ${receiver.displayName}!`);

            // Celebration
            celebrateReceiver(receiver, gameState.scene);

            // Reset drive tracking (downs/yardage)
            resetDrive();

            // Management: record possession complete with 7 points
            if (managementState.matchInProgress) {
                // Pause game during possession overlay
                gameState.waitingForPossession = true;
                setTimeout(() => {
                    onPossessionComplete(7);
                }, 2500);
                return; // Don't reset play yet - wait for overlay to be dismissed
            }

            // Only reset play immediately if not in management match
            setTimeout(() => {
                resetPlay(gameState.scene);
            }, 3000);
        };

        // Handle out of bounds
        const handleOutOfBounds = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Advance ball to where receiver went out
            advanceBall(receiver.position.z);

            updateMessage(`OUT OF BOUNDS`);

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 1500);
        };

        // Move defenders to pursue ball carrier
        const moveDefenderPursuit = (defender, pursuitBoost = 1.0) => {
            const receiver = gameState.ballCarrier;
            if (!receiver || defender.knockdownUntil > gameState.gameTime) return;

            // Stumbling defenders can't move well
            if (defender.tackleStumbleUntil > gameState.gameTime) {
                return;
            }

            // Base pursuit speed with time-based boost
            const speed = defender.baseSpeed * 1.1 * pursuitBoost;

            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            const lineZ = gameState.lineOfScrimmage;
            let manDefenderIndex = 0;

            gameState.defenders.forEach((defender, i) => {
                if (defender.aiType === 'man') {
                    // Man defenders cover receivers 1-to-1
                    const receiverIndex = manDefenderIndex % gameState.receivers.length;
                    defender.assignedReceiver = receiverIndex;
                    const targetReceiver = gameState.receivers[receiverIndex];

                    // Position directly above receiver with varying depth (far enough for clash delay)
                    defender.cushion = 4 + Math.random() * 3;  // 4-7 yards cushion
                    defender.startPos.x = targetReceiver.startPos.x;
                    defender.startPos.z = targetReceiver.startPos.z + defender.cushion;
                    defender.reactionDelay = 0.25;  // Quarter second before reacting
                    manDefenderIndex++;
                } else if (defender.aiType === 'zone') {
                    // Zone defender in middle of field with random depth
                    const zoneDepth = 8 + Math.random() * 4;  // 8-12 yards deep
                    defender.zoneCenter = new BABYLON.Vector3(0, 0, lineZ + zoneDepth);
                    defender.zoneRadius = 5 + Math.random() * 2;  // 5-7 yard radius
                    defender.startPos.x = 0;
                    defender.startPos.z = lineZ + zoneDepth - 2;
                }

                defender.position.x = defender.startPos.x;
                defender.position.z = defender.startPos.z;
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.clashTiltUntil = 0;
                defender.loserFlashUntil = 0;
                defender.winnerFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.clashSpeedPenaltyUntil = 0;
                defender.lastClashTime = 0;
                defender.rotation.x = 0;  // Reset tilt
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
                // Tackling state
                defender.tackleStumbleUntil = 0;
                defender.lastTackleTime = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            // Receivers line up at the line of scrimmage
            const receiverLineZ = gameState.lineOfScrimmage;

            // Fixed positions - receivers stay in same relative spots each play
            // Slot receiver lines up just outside the offensive tackle (randomly left or right)
            const slotSide = Math.random() > 0.5 ? 1 : -1;  // Randomly pick left or right side
            const positions = [
                -(6 + Math.random() * 1.5),   // WR1: Wide left (-6 to -7.5)
                (6 + Math.random() * 1.5),    // WR2: Wide right (6 to 7.5)
                slotSide * (4 + Math.random() * 0.5)  // WR3/Slot: Just outside tackle (¬±4 to ¬±4.5)
            ];
            // No shuffle - receivers stay in consistent positions

            // Rarely pick 0-1 receivers to run crossing routes (less overlap)
            const numCrossing = Math.random() < 0.3 ? 1 : 0;  // 30% chance of 1 crossing route
            const crossingIndices = [];
            while (crossingIndices.length < numCrossing && crossingIndices.length < gameState.receivers.length) {
                const idx = Math.floor(Math.random() * gameState.receivers.length);
                if (!crossingIndices.includes(idx)) {
                    crossingIndices.push(idx);
                }
            }

            gameState.receivers.forEach((receiver, i) => {
                // Assign spread position
                receiver.startPos.x = positions[i] || (Math.random() - 0.5) * 6;
                receiver.startPos.z = receiverLineZ;

                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiverLineZ;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.clashTiltUntil = 0;
                receiver.loserFlashUntil = 0;
                receiver.winnerFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.clashSpeedPenaltyUntil = 0;
                receiver.clashSpeedBoostUntil = 0;
                receiver.rotation.x = 0;  // Reset tilt
                receiver.coverageAmount = 0;
                receiver.currentCatchProb = receiver.stats.catching;
                // Size based on base catching stat (80% = 0.3 + 0.9*0.8 = 1.02 scale)
                const baseScale = 0.3 + 0.9 * (receiver.stats.catching / 100);
                receiver.zoneFill.scaling = new BABYLON.Vector3(baseScale, baseScale, baseScale);
                receiver.fillMaterial.alpha = 0.5;
                // Always white
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // Tackling state
                receiver.breakTackleBoostUntil = 0;

                // Generate new random route (force crossing for selected receivers)
                const isCrossing = crossingIndices.includes(i);
                generateRandomRoute(receiver, isCrossing);

                // Keep name labels hidden
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });

            // Reset play start time for label fading
            gameState.playStartTime = performance.now() * 0.001;
        };

        // Generate a random route for a receiver
        const generateRandomRoute = (receiver, forceCrossing = false) => {
            const startX = receiver.startPos.x;
            const startZ = receiver.startPos.z;
            const END_ZONE_Z = 11;  // End zone starts here
            const END_ZONE_BACK = 15;  // Back of end zone
            const SIDELINE = 8;  // Field boundary

            // Calculate available depth to end zone
            const depthToEndZone = END_ZONE_Z - startZ;
            const isVeryNearGoalLine = depthToEndZone < 2;  // Within 2 yards - need sideways cuts
            const isNearGoalLine = depthToEndZone < 8;  // Within 8 yards of end zone - use goal line routes
            const isOnSideline = Math.abs(startX) > 5;  // Near sideline
            const isInRedZone = depthToEndZone < 12;  // Inside the ~12 yard line

            // Determine lateral directions
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = startX > 0 ? 1 : -1;

            const route = [];
            let routeType;

            // Select route type based on field position
            if (isVeryNearGoalLine) {
                // Very close to goal line - routes must go into end zone then cut sideways
                if (isOnSideline) {
                    // Near sideline - cut toward middle of end zone
                    const types = ['endzone_in', 'endzone_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field - can cut either direction
                    const types = ['endzone_out', 'endzone_cross', 'endzone_corner'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isNearGoalLine) {
                // Goal line routes - short, quick, mostly crossing or corner fades
                if (isOnSideline || forceCrossing) {
                    // Near sideline + goal line = must cross toward middle
                    const types = ['quick_slant', 'corner_fade', 'flat_cross', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field near goal line - favor crossing routes
                    const types = ['quick_slant', 'flat_cross', 'back_shoulder', 'quick_slant', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isInRedZone) {
                // Red zone routes - medium depth, need to get into end zone
                if (isOnSideline) {
                    const types = ['corner', 'fade', 'comeback_corner', 'slant'];
                    routeType = forceCrossing ? 'slant' : types[Math.floor(Math.random() * types.length)];
                } else {
                    const types = ['post', 'dig', 'seam', 'out'];
                    routeType = forceCrossing ? 'dig' : types[Math.floor(Math.random() * types.length)];
                }
            } else {
                // Normal field position - full route tree
                if (forceCrossing) {
                    routeType = Math.random() > 0.5 ? 'crossing' : 'dig';
                } else if (isOnSideline) {
                    // Sideline receivers: go, corner, out, comeback
                    const types = ['go', 'corner', 'out', 'comeback', 'post'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Slot/middle receivers: slant, seam, dig, post
                    const types = ['slant', 'seam', 'dig', 'post', 'curl'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            }

            // Generate route points based on type
            switch(routeType) {
                // === END ZONE ROUTES (very close to goal line) ===
                case 'endzone_out':
                    // Go into end zone 2-3 yards, then cut sharply toward sideline
                    const ezOutDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezOutX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 3)));
                    route.push({ z: ezOutDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezOutDepth + 0.5, x: ezOutX });  // Cut sharply sideways
                    break;

                case 'endzone_in':
                    // Go into end zone 2-3 yards, then cut sharply toward middle
                    const ezInDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezInX = Math.max(-5, Math.min(5, startX + towardMiddle * (4 + Math.random() * 3)));
                    route.push({ z: ezInDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezInDepth + 0.5, x: ezInX });  // Cut sharply toward middle
                    break;

                case 'endzone_cross':
                    // Go into end zone 2-3 yards, then run horizontally across
                    const ezCrossDepth = Math.min(startZ + 2 + Math.random() * 1.5, END_ZONE_BACK - 1);
                    const ezCrossX = Math.max(-6, Math.min(6, startX + towardMiddle * (6 + Math.random() * 4)));
                    route.push({ z: ezCrossDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezCrossDepth, x: (startX + ezCrossX) / 2 });  // Start crossing
                    route.push({ z: ezCrossDepth + 0.5, x: ezCrossX });  // Continue across
                    break;

                case 'endzone_corner':
                    // Go into end zone 2-3 yards, then angle to back corner
                    const ezCornerDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_Z + 2);
                    const ezCornerX = Math.max(-7, Math.min(7, startX + towardSideline * (3 + Math.random() * 2)));
                    route.push({ z: ezCornerDepth, x: startX + towardSideline * 0.5 });  // Slight angle in
                    route.push({ z: Math.min(ezCornerDepth + 2, END_ZONE_BACK), x: ezCornerX });  // Break to corner
                    break;

                // === GOAL LINE ROUTES ===
                case 'quick_slant':
                    // Quick slant toward middle - 2-3 yards then cut
                    const qsDepth = Math.min(startZ + 2, END_ZONE_Z);
                    const qsEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (4 + Math.random() * 2)));
                    route.push({ z: qsDepth, x: startX });
                    route.push({ z: Math.min(qsDepth + 3, END_ZONE_BACK), x: qsEndX });
                    break;

                case 'flat_cross':
                    // Push 2-3 yards past LOS then cross across the formation
                    const fcStem = startZ + 2 + Math.random();  // 2-3 yards forward first
                    const fcX = startX + towardMiddle * (6 + Math.random() * 3);
                    route.push({ z: fcStem, x: startX });  // Vertical stem past LOS
                    route.push({ z: fcStem + 1, x: Math.max(-6, Math.min(6, fcX)) });  // Then cross
                    route.push({ z: Math.min(fcStem + 4, END_ZONE_BACK), x: Math.max(-6, Math.min(6, fcX + towardMiddle * 2)) });
                    break;

                case 'back_shoulder':
                    // Straight then slight fade back - for back shoulder throw
                    route.push({ z: Math.min(startZ + 3, END_ZONE_Z + 1), x: startX });
                    route.push({ z: Math.min(startZ + 2, END_ZONE_Z), x: startX + towardSideline * 1.5 });
                    break;

                case 'corner_fade':
                    // Quick move to corner of end zone
                    const cfX = Math.max(-7, Math.min(7, startX + towardSideline * 3));
                    route.push({ z: Math.min(startZ + 2, END_ZONE_Z), x: cfX });
                    route.push({ z: Math.min(startZ + 5, END_ZONE_BACK), x: Math.max(-7, Math.min(7, cfX + towardSideline * 2)) });
                    break;

                case 'out_and_up':
                    // Fake out, then go vertical
                    const oauOutX = startX + towardSideline * 2;
                    route.push({ z: startZ + 2, x: oauOutX });
                    route.push({ z: Math.min(startZ + 6, END_ZONE_BACK), x: oauOutX });
                    break;

                // === RED ZONE ROUTES ===
                case 'corner':
                    // Break toward corner of end zone - break at 3-5 yards, go to back corner
                    const cornerBreak = startZ + 3 + Math.random() * 2;
                    const cornerX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: cornerBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: cornerX });
                    break;

                case 'comeback_corner':
                    // Go 4-5 yards, comeback, then break to corner
                    const ccBreak = startZ + 4 + Math.random();
                    route.push({ z: Math.min(ccBreak, END_ZONE_Z), x: startX });
                    route.push({ z: Math.min(ccBreak - 1, END_ZONE_Z - 1), x: startX });
                    route.push({ z: Math.min(ccBreak + 5, END_ZONE_BACK), x: Math.max(-7, Math.min(7, startX + towardSideline * 4)) });
                    break;

                // === STANDARD ROUTES ===
                case 'go':
                case 'fade':
                    // Straight up the field with slight fade - go to back of end zone
                    const fadeAmount = towardSideline * (1 + Math.random() * 2);
                    route.push({ z: startZ + 8, x: startX + fadeAmount * 0.3 });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + fadeAmount)) });
                    break;

                case 'slant':
                    // Quick slant across the middle - break at 2-3 yards, then go deep
                    const slantBreak = startZ + 2 + Math.random() * 1;
                    const slantX = startX + towardMiddle * (5 + Math.random() * 3);
                    route.push({ z: slantBreak, x: startX });
                    route.push({ z: slantBreak + 5, x: Math.max(-5, Math.min(5, slantX)) });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-5, Math.min(5, slantX)) });
                    break;

                case 'out':
                    // Break to sideline - break at 3-5 yards, then continue deep
                    const outBreak = startZ + 3 + Math.random() * 2;
                    const outX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: outBreak, x: startX });
                    route.push({ z: outBreak + 1, x: outX });
                    route.push({ z: END_ZONE_BACK, x: outX });
                    break;

                case 'post':
                    // Break toward the goalpost - break at 4-6 yards, go to back of end zone
                    const postBreak = startZ + 4 + Math.random() * 2;
                    route.push({ z: postBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: towardMiddle * (2 + Math.random() * 2) });
                    break;

                case 'dig':
                case 'crossing':
                    // Cross route - break at 4-6 yards then go deep
                    const digBreak = startZ + 4 + Math.random() * 2;
                    const digEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (8 + Math.random() * 4)));
                    route.push({ z: digBreak, x: startX });
                    route.push({ z: digBreak + 2, x: digEndX });
                    route.push({ z: END_ZONE_BACK, x: digEndX });
                    break;

                case 'seam':
                    // Straight up the seam - slight angle at 3 yards, go deep
                    const seamTarget = startX > 0 ? 3 : -3;  // Stay in seam
                    route.push({ z: startZ + 3, x: (startX + seamTarget) / 2 });
                    route.push({ z: startZ + 10, x: seamTarget });
                    route.push({ z: END_ZONE_BACK, x: seamTarget });
                    break;

                case 'curl':
                case 'comeback':
                    // Run up 5-7 yards, curl back toward QB
                    const curlDepth = startZ + 5 + Math.random() * 2;
                    route.push({ z: curlDepth, x: startX });
                    route.push({ z: curlDepth - 2, x: startX + towardMiddle * 1 });
                    break;

                default:
                    // Fallback: simple go route
                    route.push({ z: Math.min(startZ + 8, END_ZONE_Z), x: startX });
                    route.push({ z: Math.min(startZ + 14, END_ZONE_BACK), x: startX });
            }

            // Ensure all route points move forward (no backwards routes)
            let lastZ = startZ;
            route.forEach(point => {
                if (point.z < lastZ) {
                    point.z = lastZ + 0.5;  // Force forward movement
                }
                lastZ = point.z;
                // Clamp to field boundaries
                point.z = Math.min(point.z, END_ZONE_BACK);
                point.x = Math.max(-SIDELINE, Math.min(SIDELINE, point.x));
            });

            // Post-process: ensure routes extend into end zone if close enough
            if (route.length > 0) {
                const lastPoint = route[route.length - 1];
                const distToEndZone = END_ZONE_Z - lastPoint.z;

                // If within 8 yards of end zone and route doesn't reach it, extend
                if (distToEndZone > 0 && distToEndZone < 8) {
                    route.push({
                        z: Math.min(END_ZONE_Z + 2, END_ZONE_BACK),
                        x: lastPoint.x
                    });
                }

                // If route ends near sideline, add crossing waypoint back toward middle
                // But only if we're still in the first 15 yards of the route (not in end zone)
                const finalPoint = route[route.length - 1];
                const routeDepth = finalPoint.z - startZ;  // How far into the route
                if (Math.abs(finalPoint.x) > 6 && routeDepth < 15 && finalPoint.z < END_ZONE_Z - 2) {
                    const crossDirection = finalPoint.x > 0 ? -1 : 1;  // Cross toward middle
                    route.push({
                        z: Math.min(finalPoint.z + 2, END_ZONE_BACK),
                        x: finalPoint.x + crossDirection * 4  // Cross 4 yards toward middle
                    });
                }
            }

            receiver.route = route;

            // Update route line visual
            if (receiver.routeLine) {
                receiver.routeLine.dispose();
            }

            const routePoints = [receiver.startPos.clone()];
            routePoints[0].y = 0.05;
            route.forEach(point => {
                routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
            });

            // Need to access scene - store reference on gameState
            if (gameState.scene && gameState.routeMaterial) {
                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + receiver.name, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, gameState.scene);
                routeLine.material = gameState.routeMaterial;
                receiver.routeLine = routeLine;
            }
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');

            // Capture receiver velocities at throw time for rating calculation
            gameState.receiverVelocitiesAtThrow = {};
            gameState.receivers.forEach(receiver => {
                gameState.receiverVelocitiesAtThrow[receiver.name] = receiver.velocity ? receiver.velocity.clone() : new BABYLON.Vector3(0, 0, 0);
            });

            // Record throw attempt for QB
            if (scene.qb && scene.qb.playerId) {
                const qbStats = gameStats.getPlayer(scene.qb.playerId, scene.qb.displayName || 'QB');
                qbStats.throwDistances.push(throwParams.distance);
                qbStats.airDistances.push(throwParams.distance * throwParams.power);
                gameState.currentThrowQbId = scene.qb.playerId;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            const catchRadius = 1.2;

            let frameIndex = 0;
            // Ball flight speed - short throws faster, long throws slower for arc visibility
            // Short throws: quick (2.4), long throws: slower (0.8)
            const animationSpeed = 2.4 - (throwParams.power * 1.6);
            let accumulator = 0;
            const time = { value: 0 };

            // Spiral rotation tracking - fast visible spin for tight spiral effect
            let spiralAngle = 0;
            const spiralSpeed = 45 + (throwParams.power * 25);  // Fast visible spiral, increases with power

            // Create trail effect for ball
            const trailParticles = [];
            const trailMaterial = new BABYLON.StandardMaterial('trailMat', scene);
            trailMaterial.diffuseColor = new BABYLON.Color3(1, 0.8, 0.3);
            trailMaterial.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            trailMaterial.alpha = 0.8;
            let lastTrailPos = null;
            const trailSpacing = 0.3; // Distance between trail particles

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path for proper orientation
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity (nose follows arc)
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Tight spiral rotation around the ball's long axis
                    spiralAngle += dt * spiralSpeed;
                    football.rotation.z = spiralAngle;

                    // Add trail particles
                    const currentPos = football.position.clone();
                    if (!lastTrailPos || BABYLON.Vector3.Distance(currentPos, lastTrailPos) > trailSpacing) {
                        const trailSphere = BABYLON.MeshBuilder.CreateSphere('trail', { diameter: 0.15, segments: 4 }, scene);
                        trailSphere.position = currentPos.clone();
                        trailSphere.material = trailMaterial;
                        trailParticles.push({ mesh: trailSphere, alpha: 0.8, createdAt: time.value });
                        lastTrailPos = currentPos.clone();
                    }

                    // Fade and remove old trail particles
                    for (let i = trailParticles.length - 1; i >= 0; i--) {
                        const particle = trailParticles[i];
                        const age = time.value - particle.createdAt;
                        particle.alpha = Math.max(0, 0.8 - age * 2);
                        particle.mesh.visibility = particle.alpha;
                        if (particle.alpha <= 0) {
                            particle.mesh.dispose();
                            trailParticles.splice(i, 1);
                        }
                    }

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Reset speed to base when boost/penalty expires (also during ball flight)
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // Calculate effective speed (apply initial clash slowdown if no outcome yet)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;
                        }

                        // Check if route is complete
                        const routeComplete = !receiver.route || receiver.routeIndex >= receiver.route.length;

                        // If ball is coming to them (within catch range) OR route is done, move toward ball
                        // Moving off-route to catch slows the receiver down (allows defenders to close)
                        if ((distToLanding < catchRadius * 2.5 && frameIndex > 5) || routeComplete) {
                            if (distToLanding > 0.2) {
                                // Reduced speed when adjusting to catch (70% of normal)
                                const catchAdjustSpeed = effectiveSpeed * 0.7;
                                receiver.position.x += (dx / distToLanding) * catchAdjustSpeed;
                                receiver.position.z += (dz / distToLanding) * catchAdjustSpeed;
                                receiver.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            // Follow their route
                            moveReceiverAlongRoute(receiver, effectiveSpeed);
                        }

                        // Running animation (bob only, tilt handled by momentum system)
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Calculate effective speed with catch-up boost
                        let effectiveSpeed = defender.speed;
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running animation (bob only, tilt handled by momentum system)
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                    });

                    // Move linemen during ball flight (battle continues!)
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            return;
                        }
                        moveOLineman(oLineman);
                        oLineman.position.y = Math.abs(Math.sin(time.value * 4 + i * 0.5)) * 0.03;
                    });

                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            return;
                        }
                        moveDLineman(dLineman);
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        dLineman.position.y = Math.abs(Math.sin(time.value * (isRushing ? 8 : 4) + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes during ball flight
                    processLineClashes();

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    // Clean up trail particles
                    trailParticles.forEach(p => p.mesh.dispose());
                    trailParticles.length = 0;
                    trailMaterial.dispose();
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            const catchRadius = 1.2;
            let potentialCatcher = null;
            let closestDistance = catchRadius;

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                }
            }

            if (potentialCatcher) {
                // Calculate catch probability (returns detailed info)
                const catchInfo = calculateCatchProbability(potentialCatcher, ballPosition);
                const catchRoll = Math.random() * 100;
                const success = catchRoll < catchInfo.probability;

                // Track attempt
                gameState.attempts++;

                // Record target for roster player
                recordPlayerStat(potentialCatcher, 'seasonTargets');

                // Calculate throw rating (always, for display purposes)
                const throwRating = calculateThrowRating(potentialCatcher, ballPosition, gameState.gameTime);

                // Show the catch probability display with throw rating
                showCatchDisplay(catchInfo, catchRoll, success, throwRating);

                // Record per-game catch stats
                if (potentialCatcher.playerId) {
                    const pStats = gameStats.getPlayer(potentialCatcher.playerId, potentialCatcher.displayName);
                    pStats.catchDifficulties.push(catchInfo.probability);
                    if (success) {
                        pStats.catches++;
                    } else {
                        pStats.drops++;
                    }
                }

                // Record QB completion/incompletion
                if (gameState.currentThrowQbId) {
                    const qbStats = gameStats.getPlayer(gameState.currentThrowQbId, 'QB');
                    if (success) {
                        qbStats.completions++;
                    } else {
                        qbStats.incompletions++;
                    }
                }

                // In training mode, show throw rating
                if (gameState.trainingMode) {
                    gameState.lastThrowRating = throwRating;

                    // Update throw rating UI
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');

                    const gradeColors = {
                        'A+': '#0f0', 'A': '#4f4', 'B': '#af4',
                        'C': '#ff4', 'D': '#f84', 'F': '#f44'
                    };

                    gradeEl.textContent = throwRating.grade;
                    gradeEl.style.color = gradeColors[throwRating.grade] || '#fff';
                    detailsEl.textContent = throwRating.details;

                    // Update visual catch bar in popup
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBase = document.getElementById('popupCatchBase');
                    const popupPenalty = document.getElementById('popupCatchPenalty');
                    const popupRoll = document.getElementById('popupCatchRoll');

                    popupHeader.textContent = success ? 'CATCH!' : 'DROPPED';
                    popupHeader.style.color = success ? '#4f4' : '#f66';

                    const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
                    const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

                    popupBase.style.width = `${rawCatch}%`;

                    if (penaltyWidth > 0) {
                        popupPenalty.style.display = 'block';
                        popupPenalty.style.left = `${catchInfo.probability}%`;
                        popupPenalty.style.width = `${penaltyWidth}%`;
                    } else {
                        popupPenalty.style.display = 'none';
                    }

                    popupRoll.textContent = 'üèà';
                    popupRoll.style.filter = success ? 'none' : 'grayscale(100%)';
                    popupRoll.style.left = `${catchRoll}%`;

                    ratingEl.style.display = 'block';

                    // Hide after 3 seconds
                    setTimeout(() => {
                        ratingEl.style.display = 'none';
                    }, 3000);
                }

                if (success) {
                    // Successful catch! Set up ball carrier
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}! RUN!`);

                    // Record catch for roster player
                    recordPlayerStat(potentialCatcher, 'seasonCatches');

                    // Store catch position for YAC tracking
                    potentialCatcher.catchPosition = potentialCatcher.position.z;

                    // Attach ball to receiver
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    // Set up ball carrier state - play continues!
                    gameState.ballCarrier = potentialCatcher;
                    potentialCatcher.breakTackleBoostUntil = 0;

                    // Start the run-after-catch phase
                    startRunAfterCatch(scene);
                } else {
                    // Dropped or defended - incomplete pass
                    handleIncomplete();
                    updateScore();
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');

                    // Record pass defended for nearest defender if it was defended
                    if (wasDefended) {
                        let closestDefender = null;
                        let closestDist = Infinity;
                        for (const def of gameState.defenders) {
                            const dist = BABYLON.Vector3.Distance(def.position, potentialCatcher.position);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestDefender = def;
                            }
                        }
                        if (closestDefender) {
                            recordPlayerStat(closestDefender, 'seasonPassesDefended');
                            // Record per-game pass defended
                            if (closestDefender.playerId) {
                                gameStats.getPlayer(closestDefender.playerId, closestDefender.displayName).passesDefended++;
                            }
                        }
                    }

                    bounceBall(scene, ballPosition);
                }
            } else {
                // No receiver nearby - incomplete pass
                handleIncomplete();
                updateMessage('Incomplete...');

                // In training mode, show incomplete grade
                if (gameState.trainingMode) {
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBar = document.getElementById('popupCatchBar');

                    gradeEl.textContent = 'INCOMPLETE';
                    gradeEl.style.color = '#f66';
                    gradeEl.style.fontSize = '32px';
                    detailsEl.textContent = 'No receiver in range';

                    popupHeader.textContent = '';
                    popupBar.style.display = 'none';

                    ratingEl.style.display = 'block';

                    setTimeout(() => {
                        ratingEl.style.display = 'none';
                        gradeEl.style.fontSize = '48px'; // Reset font size
                        popupBar.style.display = 'block'; // Reset bar visibility
                    }, 3000);
                }

                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Start the run-after-catch phase with animation loop
        const startRunAfterCatch = (scene) => {
            const timeSinceCatch = { value: 0 };

            const runAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                timeSinceCatch.value += dt;
                gameState.gameTime = performance.now() * 0.001;

                // Check if play has ended
                if (gameState.playEnded) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                const ballCarrier = gameState.ballCarrier;
                if (!ballCarrier) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                // Move ball carrier
                moveBallCarrier(ballCarrier);

                // Running animation for ball carrier (bob only, tilt handled by momentum system)
                ballCarrier.position.y = Math.abs(Math.sin(timeSinceCatch.value * 10)) * 0.1;

                // Calculate pursuit boost based on time since catch
                // After 1 second: 10% boost, after 2 seconds: 20% boost
                let pursuitBoost = 1.0;
                if (timeSinceCatch.value >= 2.0) {
                    pursuitBoost = 1.2;  // 20% boost after 2 seconds
                } else if (timeSinceCatch.value >= 1.0) {
                    // Interpolate from 10% to 20% between 1 and 2 seconds
                    const t = timeSinceCatch.value - 1.0;  // 0 to 1
                    pursuitBoost = 1.1 + (t * 0.1);  // 1.1 to 1.2
                }

                // Move all defenders in pursuit with speed boost
                gameState.defenders.forEach((defender, i) => {
                    if (defender.knockdownUntil <= gameState.gameTime) {
                        moveDefenderPursuit(defender, pursuitBoost);

                        // Running animation (bob only, tilt handled by momentum system)
                        const animSpeed = 10 + (pursuitBoost - 1.0) * 20;
                        defender.position.y = Math.abs(Math.sin(timeSinceCatch.value * animSpeed + i)) * 0.08;
                    }
                });

                // Process tackle attempts
                processTackles();
            });
        };

        // Calculate catch probability based on receiver stats and proximity to defenders
        const calculateCatchProbability = (receiver, ballPosition) => {
            // Base catch rate from receiver's catching stat
            let baseCatch = receiver.stats.catching;

            // Find defenders and apply proximity penalty
            let defenderProximityPenalty = 0;
            let defenderDetails = [];
            let hasNearbyDefender = false;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            // For zone defenders, count how many receivers are in their zone to split coverage
            const zoneReceiverCounts = new Map();
            gameState.defenders.forEach(defender => {
                if (defender.aiType === 'zone' && defender.knockdownUntil <= gameState.gameTime) {
                    let count = 0;
                    gameState.receivers.forEach(rec => {
                        const dist = BABYLON.Vector3.Distance(defender.position, rec.position);
                        if (dist < coverageRange) count++;
                    });
                    zoneReceiverCounts.set(defender, Math.max(1, count));
                }
            });

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;

                    // Get defender's coverage stat based on their type
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;

                    // Proximity factor: 1.0 at distance 0, 0.0 at max range
                    const proximityFactor = 1 - (dist / coverageRange);

                    // At distance 0, if coverage equals catching, apply 80% penalty
                    // penalty = proximityFactor^3 * coverageStat * 0.8
                    // Cubed for steeper dropoff - separation is rewarded more
                    let penalty = proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;

                    // Very close defenders (0.6 or closer) have 50% more influence
                    const CLOSE_DEFENDER_THRESHOLD = 0.6;
                    if (dist <= CLOSE_DEFENDER_THRESHOLD) {
                        penalty *= 1.5;
                    }

                    // Check if ball is on opposite side from defender
                    // Only applies if defender isn't right on top of receiver (dist > 0.8)
                    const MIN_DIST_FOR_SIDE_BONUS = 0.8;
                    if (dist > MIN_DIST_FOR_SIDE_BONUS) {
                        const defenderSide = Math.sign(defender.position.x - receiver.position.x);
                        const ballSide = Math.sign(ballPosition.x - receiver.position.x);

                        // If ball and defender are on opposite sides, halve the penalty
                        if (defenderSide !== 0 && ballSide !== 0 && defenderSide !== ballSide) {
                            penalty *= 0.5;
                        }
                    }

                    // If defender lost a clash (has speed penalty), reduce their coverage effect by 50%
                    if (defender.clashSpeedPenaltyUntil && defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                        penalty *= 0.5;
                    }

                    // For zone defenders covering multiple receivers, split their coverage
                    if (defender.aiType === 'zone') {
                        const receiversInZone = zoneReceiverCounts.get(defender) || 1;
                        if (receiversInZone > 1) {
                            penalty /= receiversInZone;
                        }
                    }

                    defenderProximityPenalty += penalty;
                    defenderDetails.push({
                        name: defender.name,
                        dist: dist.toFixed(2),
                        penalty: penalty.toFixed(1),
                        coverageStat: coverageStat,
                        aiType: defender.aiType
                    });
                }
            });

            // Focus stat helps when defenders are nearby (higher focus = better under pressure)
            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;

            // Calculate final probability (clamped between 5% and 95%)
            const finalProbability = Math.max(5, Math.min(95,
                baseCatch + focusMod - defenderProximityPenalty
            ));

            // Store for visual display
            receiver.lastCatchProbability = finalProbability;

            // Return detailed info for UI display
            return {
                probability: finalProbability,
                baseCatch: baseCatch,
                focusMod: focusMod,
                defenderPenalty: defenderProximityPenalty,
                defenderDetails: defenderDetails
            };
        };

        // Show catch probability display
        const showCatchDisplay = (catchInfo, roll, success, throwRating = null) => {
            // Skip showing in training mode (catch info is in the popup instead)
            if (gameState.trainingMode) return;

            const display = document.getElementById('catchDisplay');
            const header = display.querySelector('.catch-header');
            const barBase = display.querySelector('.catch-bar-base');
            const barPenalty = display.querySelector('.catch-bar-penalty');
            const barRoll = display.querySelector('.catch-bar-roll');
            const defenderInfo = display.querySelector('.defender-info');
            const throwRatingInfo = display.querySelector('.throw-rating-info');

            // Set header
            header.textContent = success ? 'CATCH!' : 'DROPPED';
            header.className = 'catch-header ' + (success ? 'success' : 'fail');

            // Calculate raw catch % (base + focus, before defender penalty)
            const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
            const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

            // Set bar: green shows raw potential, dark overlay shows defender penalty
            barBase.style.width = `${rawCatch}%`;

            // Penalty overlay starts where final probability ends
            if (penaltyWidth > 0) {
                barPenalty.style.display = 'block';
                barPenalty.style.left = `${catchInfo.probability}%`;
                barPenalty.style.width = `${penaltyWidth}%`;
            } else {
                barPenalty.style.display = 'none';
            }

            // Roll marker with football icon
            barRoll.textContent = 'üèà';
            barRoll.className = 'catch-bar-roll ' + (success ? 'success' : 'fail');
            barRoll.style.filter = success ? 'none' : 'grayscale(100%)';
            barRoll.style.left = `${roll}%`;

            // Show defender distances only
            if (catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0) {
                const distances = catchInfo.defenderDetails
                    .filter(d => parseFloat(d.penalty) > 0.5)
                    .map(d => d.dist)
                    .join(', ');
                defenderInfo.textContent = distances ? distances + 'yd' : '';
            } else {
                defenderInfo.textContent = '';
            }

            // Show throw rating info if available
            if (throwRating) {
                throwRatingInfo.textContent = `${throwRating.grade} | Route: ${throwRating.distToRoute}yd off | Lead: ${throwRating.leadText || ''}`;
            } else {
                throwRatingInfo.textContent = '';
            }

            // Show display
            display.classList.add('visible');

            // Hide after 2.5 seconds
            setTimeout(() => {
                display.classList.remove('visible');
            }, 2500);
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;
            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Hide player labels when play starts
        const hidePlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 0;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });
        };

        // Show player labels when play is frozen
        const showPlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 1;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 1;
                }
            });
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset pointer/drag state to prevent desync issues
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragCurrent = null;
            gameState.activePointerId = null;
            gameState.canThrow = true;

            // Reset play state flags
            gameState.ballCarrier = null;
            gameState.playEnded = false;
            gameState.qbSacked = false;
            gameState.playFrozen = true;  // Freeze until player holds screen

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Reset linemen
            resetOffensiveLine();
            resetDefensiveLine();

            // Reset QB position (relative to line of scrimmage, randomized depth behind it)
            const qbDepthBehindLine = 2 + Math.random() * 2;  // 2-4 yards behind LOS
            // Clamp QB Z position to stay on visible field (min -14 with extended field)
            const qbZ = Math.max(-14, gameState.lineOfScrimmage - qbDepthBehindLine);
            gameState.qbStartZ = qbZ;
            scene.qb.position.x = 0;
            scene.qb.position.z = qbZ;
            scene.qb.position.y = 0;
            scene.qb.rotation.x = 0;
            scene.qb.rotation.y = 0;

            // Update field position markers
            if (scene.losLine) {
                scene.losLine.position.z = gameState.lineOfScrimmage;
            }
            if (scene.firstDownLine) {
                scene.firstDownLine.position.z = gameState.firstDownMarker;
            }

            // Move camera to follow the line of scrimmage
            if (scene.activeCamera) {
                const camera = scene.activeCamera;

                // Target centered on the line of scrimmage
                // Allow camera to follow into own territory (-10) and into end zone (Z = 14)
                const cameraTargetZ = Math.max(-10, Math.min(14, gameState.lineOfScrimmage + 2));
                camera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);

                // Reset camera to current view mode settings (alpha, beta, radius)
                switch(gameState.currentView) {
                    case 'iso':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                        break;
                    case 'overhead':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = 0.1;
                        camera.radius = 28;
                        break;
                    case 'shoulder':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 2.5;
                        camera.radius = 18;
                        break;
                    default:
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                }
            }

            // Update down and distance display
            updateDownDistance();

            // Show player labels while frozen
            showPlayerLabels();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Hold to start play');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            const scoreEl = document.getElementById('score');
            scoreEl.querySelector('.catches').textContent = `${gameState.catches}/${gameState.attempts}`;
            scoreEl.querySelector('.touchdowns').textContent = gameState.touchdowns;
        };

        const updateDownDistance = () => {
            const ddEl = document.getElementById('downDistance');
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const downText = downNames[gameState.down - 1] || '4th';

            // Calculate yards to go (convert Z units to approximate yards - roughly 1 unit = 1 yard)
            const yardsToGo = Math.max(1, Math.round(gameState.yardsToGo));
            const distanceText = yardsToGo >= 10 ? '10+' : yardsToGo.toString();

            ddEl.querySelector('.down').textContent = downText;
            ddEl.querySelector('.distance').textContent = distanceText;
        };

        const updateMessage = (msg) => {
            // Message display removed
        };

        // Update debug info display
        const updateDebugInfo = () => {
            if (!FEATURE_FLAGS.showDebugInfo) {
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            document.getElementById('debugInfo').style.display = 'block';

            let debugText = '=== RECEIVER STATUS ===\n';
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.receivers.forEach((receiver, i) => {
                // Find closest defender
                let closestDef = null;
                let closestDist = Infinity;
                gameState.defenders.forEach(def => {
                    if (def.knockdownUntil > gameState.gameTime) return;
                    const dx = def.position.x - receiver.position.x;
                    const dz = def.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestDef = def;
                    }
                });

                const timeSinceClash = (gameState.gameTime - receiver.lastClashTime).toFixed(1);
                const speedMod = (receiver.speed / receiver.baseSpeed * 100).toFixed(0);
                const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                const catchProb = receiver.currentCatchProb || receiver.stats.catching;

                // Determine coverage level based on catch probability
                let coverageLevel = 'OPEN';
                let levelColor = 'üü¢';
                if (catchProb < 40) {
                    coverageLevel = 'COVERED';
                    levelColor = 'üî¥';
                } else if (catchProb < 70) {
                    coverageLevel = 'CONTESTED';
                    levelColor = 'üü°';
                }

                debugText += `\n${receiver.displayName}:\n`;
                debugText += `  ${levelColor} Catch: ${catchProb.toFixed(0)}% (${coverageLevel})\n`;
                debugText += `  Speed: ${speedMod}%${hasSpeedPenalty ? ' (SLOWED)' : ''}\n`;

                if (closestDef) {
                    const defSpeedPenalty = closestDef.clashSpeedPenaltyUntil > gameState.gameTime;
                    const defCovStat = closestDef.aiType === 'zone' ?
                        closestDef.stats.zoneCoverage : closestDef.stats.manCoverage;
                    debugText += `  Nearest: ${closestDef.displayName}`;
                    if (defSpeedPenalty) debugText += ' (SLOWED)';
                    debugText += `\n`;
                    debugText += `  Dist: ${closestDist.toFixed(1)}/${coverageRange.toFixed(1)}`;
                    debugText += ` | ${closestDef.aiType === 'zone' ? 'ZoneCov' : 'ManCov'}: ${defCovStat}\n`;
                }
            });

            document.getElementById('debugInfo').textContent = debugText;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only capture left-click (button 0) or single touch for throwing
                // Let right-click (button 2) and multi-touch pass through to camera
                if (evt.button !== 0 && evt.pointerType === 'mouse') return;

                // Unfreeze play when holding down (starts the play)
                if (gameState.playFrozen) {
                    gameState.playFrozen = false;
                    gameState.playStartTime = performance.now() * 0.001;
                    hidePlayerLabels();
                }

                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.activePointerId = evt.pointerId;  // Track which pointer is dragging
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
            };

            const onPointerMove = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only track the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only respond to the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.activePointerId = null;

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                if (gameState.dragStart && gameState.dragCurrent) {
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                // Skip all game logic when in management mode
                if (!gameSceneActive) return;

                // Pause game during possession overlay
                if (gameState.waitingForPossession) return;

                // Freeze play until player holds screen
                if (gameState.playFrozen) return;

                const time = performance.now() * 0.001;

                // QB breathing/ready animation (only when not in danger)
                const qb = scene.qb;
                if (!gameState.playEnded && !gameState.qbSacked) {
                    // Only subtle breathing when not moving
                    const isEvading = gameState.defensiveLine.some(d =>
                        d.knockdownUntil <= gameState.gameTime &&
                        BABYLON.Vector3.Distance(d.position, qb.position) < POCKET_CONSTANTS.THREAT_RADIUS
                    );
                    if (!isEvading) {
                        qb.rotation.y = Math.sin(time * 2) * 0.05;
                        qb.position.y = Math.sin(time * 3) * 0.02;
                    } else {
                        qb.position.y = Math.abs(Math.sin(time * 8)) * 0.06;  // Running animation
                    }
                }

                // Track game time for clash system
                gameState.gameTime = time;

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Reset speed to base when boost/penalty expires
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate effective speed (slowdown during initial clash, unless clash outcome already applied)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash (only if no outcome yet)
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (receiver.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (receiver.clashTiltUntil - gameState.gameTime) / 0.5;
                            receiver.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                        // Show green while speed boosted, red while speed penalized
                        if (receiver.clashSpeedBoostUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const green = new BABYLON.Color3(0.2, 1.0, 0.3);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, green, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = green.scale(flashRate * 0.3);
                        } else if (receiver.clashSpeedPenaltyUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const red = new BABYLON.Color3(1.0, 0.2, 0.2);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, red, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = red.scale(flashRate * 0.3);
                        } else {
                            receiver.bodyMaterial.diffuseColor = receiver.originalColor;
                            receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
                        }
                    });

                    // Route completion no longer triggers reset - play continues normally

                    // Move offensive linemen
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            oLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        oLineman.rotation.x = 0;

                        moveOLineman(oLineman);

                        // Subtle stance animation
                        oLineman.position.y = Math.abs(Math.sin(time * 4 + i * 0.5)) * 0.03;
                    });

                    // Move defensive linemen
                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            dLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        dLineman.rotation.x = 0;

                        moveDLineman(dLineman);

                        // Running animation when moving fast
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        const bobSpeed = isRushing ? 8 : 4;
                        dLineman.position.y = Math.abs(Math.sin(time * bobSpeed + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes
                    processLineClashes();

                    // Move QB (pocket behavior and evasion)
                    moveQB(scene);

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdowns and boosts from clashes)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }
                        if (defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.5;  // 50% slower after losing clash
                        }
                        // DB catch-up boost - kicks in after receiver's boost ends
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;  // 30% faster catch-up
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (bob only, tilt handled by momentum system)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (defender.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (defender.clashTiltUntil - gameState.gameTime) / 0.5;
                            defender.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();

                    // Fade out name labels after 1 second
                    const timeSinceStart = time - gameState.playStartTime;
                    if (timeSinceStart > 1.0 && timeSinceStart < 2.0) {
                        // Fade over 1 second (from t=1 to t=2)
                        const fadeProgress = timeSinceStart - 1.0;
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 1 - fadeProgress;
                            }
                        });
                    } else if (timeSinceStart >= 2.0) {
                        // Fully hidden
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 0;
                            }
                        });
                    }
                }
            });
        };

        // Get zone colors based on catch probability (0-100%)
        // High catch % = green, medium = yellow, low = red
        const getZoneColorsByCatchProb = (catchProbability) => {
            if (catchProbability >= 70) {
                // Green - high catch chance
                return {
                    diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),
                    emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                };
            } else if (catchProbability >= 40) {
                // Yellow - moderate catch chance
                return {
                    diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                };
            } else {
                // Red - low catch chance
                return {
                    diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                };
            }
        };

        // Calculate real-time catch probability for a receiver (for visual display)
        const calculateRealtimeCatchProb = (receiver) => {
            const baseCatch = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;
            let defenderPenalty = 0;
            let hasNearbyDefender = false;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / coverageRange);
                    // Match the catch calculation: cubed for steeper dropoff
                    defenderPenalty += proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;
                }
            });

            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;
            return Math.max(5, Math.min(95, baseCatch + focusMod - defenderPenalty));
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Calculate real-time catch probability
                const catchProb = calculateRealtimeCatchProb(receiver);
                receiver.currentCatchProb = catchProb;  // Store for debug display

                // Size based on catch probability (larger = higher catch %)
                const minScale = 0.3;  // Minimum size at 0% catch
                const maxScale = 1.2;  // Maximum size at 100% catch
                const catchFactor = catchProb / 100;  // 0-1
                const fillScale = minScale + (maxScale - minScale) * catchFactor;
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Keep white color, adjust alpha based on coverage for visibility
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                receiver.fillMaterial.alpha = 0.5;

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);
                    coveringDefender.fillMaterial.alpha = maxCoverage * 0.45;
                    coveringDefender.ringMaterial.alpha = 0.8;
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const tiltDuration = 0.5;   // seconds for grappling tilt
            const currentTime = gameState.gameTime;

            // Calculate tilt direction (towards each other)
            const dx = defender.position.x - receiver.position.x;
            const dz = defender.position.z - receiver.position.z;
            const angle = Math.atan2(dx, dz);

            // Both tilt towards each other during clash
            receiver.clashTiltUntil = currentTime + tiltDuration;
            receiver.clashTiltAngle = angle;  // Tilt towards defender
            defender.clashTiltUntil = currentTime + tiltDuration;
            defender.clashTiltAngle = angle + Math.PI;  // Tilt towards receiver (opposite)

            // Color is now controlled by speed effect timers (clashSpeedBoostUntil / clashSpeedPenaltyUntil)
            // No separate flash timer needed
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        const weightedRoll = (stats, weights) => {
            let weightedTotal = 0;
            for (const stat in weights) {
                const statValue = stats[stat] || 50;  // Default to 50 if stat missing
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (¬±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                // Track that they were far apart (for initial clash detection)
                if (!receiver.hasHadInitialClash) {
                    receiver.wasOutsideClashRange = true;
                }
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Cooldown - don't clash again too soon after a previous clash
            const CLASH_COOLDOWN = 2.0;  // seconds between clashes
            const timeSinceReceiverClash = currentTime - receiver.lastClashTime;
            const timeSinceDefenderClash = currentTime - defender.lastClashTime;
            if (timeSinceReceiverClash < CLASH_COOLDOWN || timeSinceDefenderClash < CLASH_COOLDOWN) {
                return { trigger: false, reason: 'cooldown' };
            }

            // Initial contact - only trigger if they were previously apart
            // This prevents clashes from happening immediately at play start
            if (!receiver.hasHadInitialClash) {
                if (receiver.wasOutsideClashRange) {
                    return { trigger: true, reason: 'initial_contact' };
                }
                return { trigger: false, reason: 'not_yet_separated' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            if (defender.aiType === 'zone') {
                defenderWeights.zoneCoverage = defenderWeights.manCoverage;
                delete defenderWeights.manCoverage;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            // Speed effect durations
            const CLASH_SPEED_EFFECT_DURATION = 1.0;  // seconds - reduced for quicker gameplay
            const DB_CATCHUP_DELAY = 2.0;             // seconds - delay before DB catch-up starts
            const DB_CATCHUP_BOOST_DURATION = 1.0;    // seconds - DB gets catch-up boost after delay
            const CLASH_SPEED_PENALTY = 0.75;  // 25% slower (was 50%, cut in half)
            const CLASH_SPEED_BOOST = 1.5;  // 50% faster
            const DB_CATCHUP_BOOST = 1.3;  // 30% faster for catch-up

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                // Receiver wins - gets speed boost for 1 second
                receiver.clashSpeedBoostUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                receiver.speed = receiver.baseSpeed * CLASH_SPEED_BOOST;
                // DB gets catch-up boost 2 seconds after clash
                defender.catchupBoostStart = currentTime + DB_CATCHUP_DELAY;
                defender.catchupBoostUntil = currentTime + DB_CATCHUP_DELAY + DB_CATCHUP_BOOST_DURATION;
                defender.catchupBoostAmount = DB_CATCHUP_BOOST;
                // Record clash stats
                recordPlayerStat(receiver, 'seasonClashesWon');
                recordPlayerStat(defender, 'seasonClashesLost');
                // Record per-game clash stats
                if (receiver.playerId) {
                    const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                    rStats.clashesWon++;
                    rStats.clashDifficulties.push(margin);
                }
                if (defender.playerId) {
                    const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                // Direction changes (jukes) only benefit receivers - ignore defender wins
                if (reason === 'direction_change') {
                    result.winner = 'none';
                    result.type = 'contested';
                    // Juke failed but no penalty - just maintain current speed
                } else {
                    result.winner = 'defender';
                    result.type = 'coverage';
                    // Receiver loses - gets slowed
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                    receiver.speed = receiver.baseSpeed * CLASH_SPEED_PENALTY;
                    // Record clash stats
                    recordPlayerStat(defender, 'seasonClashesWon');
                    recordPlayerStat(receiver, 'seasonClashesLost');
                    // Record per-game clash stats
                    if (defender.playerId) {
                        const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                        dStats.clashesWon++;
                        dStats.clashDifficulties.push(-margin);
                    }
                    if (receiver.playerId) {
                        const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                        rStats.clashesLost++;
                        rStats.clashDifficulties.push(margin);
                    }
                }
            } else {
                result.winner = 'none';
                result.type = 'contested';
                // Tie - receiver maintains current speed
            }

            // Physical battle check (based on aggression)
            const physicalChance = (receiver.stats.aggression + defender.stats.aggression) / 200;
            if (Math.random() < physicalChance) {
                resolvePhysicalClash(receiver, defender, result);
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Resolve physical aspect of clash (knockdowns)
        const resolvePhysicalClash = (receiver, defender, separationResult) => {
            const currentTime = gameState.gameTime;

            // Roll physical battle
            const receiverPhysical = weightedRoll(receiver.stats, CLASH_WEIGHTS.physical.attacker);
            const defenderPhysical = weightedRoll(defender.stats, CLASH_WEIGHTS.physical.defender);

            const margin = receiverPhysical - defenderPhysical;
            const loser = margin > 0 ? defender : receiver;
            const winner = margin > 0 ? receiver : defender;

            // Check for knockdown
            const knockdownChance = CLASH_CONSTANTS.KNOCKDOWN_BASE_CHANCE +
                (Math.abs(margin) / 100) * 0.1 -
                loser.knockdownResistance;

            if (Math.random() < Math.max(0, knockdownChance)) {
                // Knockdown!
                loser.knockdownUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                loser.knockdownResistance += CLASH_CONSTANTS.KNOCKDOWN_RESISTANCE_GAIN;

                // If receiver knocked down, apply heavy speed penalty
                if (loser === receiver) {
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                }
            }
        };

        // Process all clashes in the game
        const processClashes = () => {
            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // ========================================
        // MANAGEMENT LAYER - UI SYSTEM
        // ========================================

        // UI state
        let managementUI = null;

        // Create Management UI
        function createManagementUI() {
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManagementUI");

            // Scale UI elements based on screen size for mobile
            const scale = Math.min(window.innerWidth / 400, window.innerHeight / 600, 1.5);
            advancedTexture.rootContainer.scaleX = scale;
            advancedTexture.rootContainer.scaleY = scale;

            const ui = {
                advancedTexture,
                visible: true
            };

            managementUI = ui;
            return ui;
        }

        // ========================================
        // HTML-BASED SCREEN NAVIGATION
        // ========================================

        // Hide all management screens
        function hideAllScreens() {
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
        }

        // Show a specific screen
        function showScreen(screenName) {
            const overlay = document.getElementById('managementOverlay');
            const topBar = document.getElementById('topBar');
            const viewButtons = document.getElementById('viewButtons');

            if (screenName === 'game') {
                // Game mode - hide overlay, show game
                overlay.classList.add('hidden');
                topBar.style.display = 'flex';
                viewButtons.style.display = 'flex';
                gameSceneActive = true;
            } else {
                // Management mode - show overlay, hide game
                overlay.classList.remove('hidden');
                topBar.style.display = 'none';
                viewButtons.style.display = 'none';
                gameSceneActive = false;

                hideAllScreens();

                switch (screenName) {
                    case 'main_menu':
                        document.getElementById('mainMenuScreen').style.display = 'block';
                        document.getElementById('btnContinue').disabled = !managementState.initialized;
                        break;
                    case 'hub':
                        document.getElementById('hubScreen').style.display = 'block';
                        refreshHubScreen();
                        break;
                    case 'roster':
                        document.getElementById('rosterScreen').style.display = 'block';
                        refreshRosterScreen();
                        break;
                    case 'free_agency':
                        document.getElementById('freeAgencyScreen').style.display = 'block';
                        refreshFreeAgencyScreen();
                        break;
                    case 'schedule':
                        document.getElementById('scheduleScreen').style.display = 'block';
                        refreshScheduleScreen();
                        break;
                    case 'facilities':
                        document.getElementById('facilitiesScreen').style.display = 'block';
                        refreshFacilitiesScreen();
                        break;
                    case 'match_end':
                        document.getElementById('matchEndScreen').style.display = 'block';
                        break;
                    case 'pre_game':
                        document.getElementById('preGameScreen').style.display = 'block';
                        break;
                }
            }

            managementState.currentScreen = screenName;
        }

        // Refresh hub screen data
        function refreshHubScreen() {
            if (!managementState.team) return;
            document.getElementById('hubStatus').textContent =
                `Fame: ${managementState.team.fame.toLocaleString()} | Week ${managementState.season?.week || 1}`;
            document.getElementById('hubRecord').textContent =
                `Record: ${managementState.team.record.wins}-${managementState.team.record.losses}`;

            if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                const game = managementState.season.schedule[managementState.season.week - 1];
                document.getElementById('hubNextGame').textContent = `Next: vs ${game.opponent.name}`;
            } else {
                document.getElementById('hubNextGame').textContent = 'Season Complete!';
            }
        }

        // Calculate season stat change for a player (based on primary stats/overall)
        function calculateSeasonStatChange(player) {
            if (!player.seasonStartStats) return 0;

            // Calculate based on primary stats for the position (same as overall)
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            let currentTotal = 0;
            let startTotal = 0;
            primaryStats.forEach(stat => {
                currentTotal += player.stats[stat] || 0;
                startTotal += player.seasonStartStats[stat] || 0;
            });

            // Return change in overall (average of primary stats)
            const currentOverall = Math.round(currentTotal / primaryStats.length);
            const startOverall = Math.round(startTotal / primaryStats.length);
            return currentOverall - startOverall;
        }

        // Refresh roster screen
        function refreshRosterScreen() {
            const list = document.getElementById('rosterList');
            list.innerHTML = '';
            if (!managementState.team) return;

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                list.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    const seasonChange = calculateSeasonStatChange(player);
                    const changeClass = seasonChange > 0 ? 'positive' : seasonChange < 0 ? 'negative' : '';
                    const changeText = seasonChange > 0 ? `+${seasonChange}` : seasonChange < 0 ? `${seasonChange}` : '';

                    // Show stars for growing players, minuses for declining
                    let potentialDisplay = '';
                    let potentialColor = '#ffd700';
                    if (player.age >= player.peakAge) {
                        // Declining: show red minuses based on years past peak
                        const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                        potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                        potentialColor = '#f66';
                    } else if (player.potentialGrade > 0) {
                        // Growing: show 0-3 stars
                        potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                    }

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName}</div>
                            <div class="stats">Age ${player.age} | ${formatSalary(player.salaryCost)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="season-gain ${changeClass}" style="min-width:28px;text-align:right;">${changeText}</span>
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    list.appendChild(item);
                });
            });
        }

        // Show player detail modal
        function showPlayerDetail(playerId) {
            const player = managementState.team.roster.find(p => p.id === playerId);
            if (!player) return;

            managementState.selectedPlayerId = playerId;

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Calculate overall change
            const currentOverall = player.overall;
            let startOverall = currentOverall;
            if (player.seasonStartStats) {
                const positionData = POSITIONS[player.position];
                const primaryStats = positionData.primaryStats;
                const startTotal = primaryStats.reduce((sum, stat) => sum + (player.seasonStartStats[stat] || 0), 0);
                startOverall = Math.round(startTotal / primaryStats.length);
            }
            const overallChange = currentOverall - startOverall;
            const overallChangeClass = overallChange > 0 ? 'positive' : overallChange < 0 ? 'negative' : '';
            const overallChangeText = overallChange !== 0 ?
                `<span class="season-change ${overallChangeClass}">${overallChange > 0 ? '+' : ''}${overallChange}</span>` : '';

            // Player info
            const tradeValue = calculateTradeValue(player);
            const tradeText = tradeValue > 0 ? `Trade Value: ${tradeValue}` : 'No Trade Value';
            const infoHtml = `
                <div><span class="ovr-big">${player.overall}</span>${overallChangeText}</div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age} | Peak ${player.peakAge}<br>
                    Salary: ${formatSalary(player.salaryCost)} | Potential: ${'‚òÖ'.repeat(player.potentialGrade + 1)}<br>
                    <span style="color:${tradeValue > 0 ? '#4f4' : '#888'}">${tradeText}</span>
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // Update trade button
            const tradeBtn = document.getElementById('btnTradePlayer');
            if (tradeValue > 0) {
                tradeBtn.textContent = `TRADE (+${tradeValue} Fame)`;
                tradeBtn.disabled = false;
                tradeBtn.style.opacity = '1';
            } else {
                tradeBtn.textContent = 'NO TRADE VALUE';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            }

            // All stats with changes
            const allStats = [
                'speed', 'acceleration', 'agility', 'strength', 'stamina', 'balance',
                'catching', 'throwing', 'routeRunning', 'release', 'jumping', 'focus',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'hitPower', 'pursuit', 'awareness',
                'passBlock', 'passRush', 'aggression'
            ];

            const statsHtml = allStats.map(stat => {
                const currentRaw = player.stats[stat] || 0;
                const startRaw = player.seasonStartStats ? (player.seasonStartStats[stat] || 0) : currentRaw;
                const current = Math.floor(currentRaw);
                const start = Math.floor(startRaw);
                const change = current - start;
                const changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : '';
                const changeText = change !== 0 ? `${change > 0 ? '+' : ''}${change}` : '';

                // Color code based on stat value
                const statColorClass = current >= 90 ? 'stat-elite' :
                                       current >= 80 ? 'stat-good' :
                                       current >= 70 ? 'stat-average' :
                                       current >= 60 ? 'stat-below' : 'stat-poor';

                // Format stat name
                const statName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());

                return `<div class="stat-row">
                    <span class="stat-name">${statName}</span>
                    <span class="stat-values">
                        <span class="stat-value ${statColorClass}">${current}</span>
                        <span class="stat-change ${changeClass}">${changeText}</span>
                    </span>
                </div>`;
            }).join('');
            document.getElementById('playerStats').innerHTML = statsHtml;

            // Season stats (position-dependent)
            let seasonStatsHtml = '<div class="season-stats-title">Season Stats</div><div class="season-stats-grid">';

            if (player.position === 'WR' || player.position === 'QB') {
                const catchPct = player.seasonTargets > 0
                    ? Math.round((player.seasonCatches || 0) / player.seasonTargets * 100)
                    : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTDs || 0}</div><div class="season-stat-label">TDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonCatches || 0}</div><div class="season-stat-label">Catches</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${catchPct}%</div><div class="season-stat-label">Catch %</div></div>
                `;
            } else if (player.position === 'CB') {
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTackles || 0}</div><div class="season-stat-label">Tackles</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonPassesDefended || 0}</div><div class="season-stat-label">PDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                `;
            } else if (player.position === 'OL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesLost || 0}</div><div class="season-stat-label">Clashes Lost</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            } else if (player.position === 'DL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonSacks || 0}</div><div class="season-stat-label">Sacks</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            }
            seasonStatsHtml += '</div>';
            document.getElementById('playerSeasonStats').innerHTML = seasonStatsHtml;

            // Career graph
            const history = player.careerHistory || [];
            let graphHtml = '<div class="career-graph-title">Career Progression</div>';

            if (history.length > 0) {
                graphHtml += '<div class="career-graph-container">';
                const maxOvr = Math.max(...history.map(h => h.overall), 99);
                const minOvr = Math.min(...history.map(h => h.overall), 40);
                const range = Math.max(maxOvr - minOvr, 20);

                history.forEach((season, idx) => {
                    const heightPct = ((season.overall - minOvr) / range) * 100;
                    const potentialStars = '‚òÖ'.repeat((season.potential || 0) + 1);
                    graphHtml += `
                        <div class="career-bar">
                            <div class="career-bar-ovr">${season.overall}</div>
                            <div class="career-bar-fill" style="height: ${Math.max(heightPct, 10)}%;">
                                <span class="career-bar-potential">${potentialStars}</span>
                            </div>
                            <div class="career-bar-label">Y${idx + 1}</div>
                        </div>
                    `;
                });
                graphHtml += '</div>';
            } else {
                graphHtml += '<div style="color:#666;font-size:12px;">No career history yet</div>';
            }
            document.getElementById('playerCareerGraph').innerHTML = graphHtml;

            // Show modal
            document.getElementById('playerDetailModal').style.display = 'flex';
        }

        // Close player detail modal
        function closePlayerDetail() {
            document.getElementById('playerDetailModal').style.display = 'none';
            managementState.selectedPlayerId = null;
        }

        // Cut player from detail view
        function cutPlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const result = cutPlayer(managementState.selectedPlayerId);
            if (result.success) {
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Trade player for fame from detail view
        function tradePlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const player = managementState.team.roster.find(p => p.id === managementState.selectedPlayerId);
            if (!player) return;

            const tradeValue = calculateTradeValue(player);
            if (tradeValue <= 0) return;

            if (confirm(`Trade ${player.firstName} ${player.lastName} for ${tradeValue} Fame?`)) {
                managementState.team.fame += tradeValue;
                cutPlayer(managementState.selectedPlayerId);
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Refresh free agency screen
        function refreshFreeAgencyScreen() {
            const list = document.getElementById('freeAgentList');
            const status = document.getElementById('faStatus');
            list.innerHTML = '';
            if (!managementState.team) return;

            const salary = calculateTeamSalary(managementState.team);
            const cap = managementState.team.salaryCap + managementState.team.salaryCapModifier;
            status.textContent = `Fame: ${formatSalary(managementState.team.fame)} | Cap: ${formatSalary(cap - salary)}`;

            if (managementState.freeAgents.length === 0) {
                list.innerHTML = '<p style="color:#888;text-align:center;">No free agents available</p>';
                return;
            }

            managementState.freeAgents.forEach(player => {
                const canSign = canSignPlayer(managementState.team, player);

                // Show stars for growing players, minuses for declining
                let potentialDisplay = '';
                let potentialColor = '#ffd700';
                if (player.age >= player.peakAge) {
                    const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                    potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                    potentialColor = '#f66';
                } else if (player.potentialGrade > 0) {
                    potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                }

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div>
                        <div class="name">${player.firstName} ${player.lastName} (${player.position})</div>
                        <div class="stats">Age ${player.age} | Salary: ${formatSalary(player.salaryCost)}</div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                        <button class="mgmt-btn fa-btn" ${canSign ? '' : 'disabled'}
                            onclick="signAndRefresh('${player.id}')">SIGN</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // Sign player and refresh
        function signAndRefresh(playerId) {
            const result = signFreeAgent(playerId);
            if (result.success) {
                refreshFreeAgencyScreen();
            }
        }

        // Calculate team overall rating
        function calculateTeamOverallRating() {
            if (!managementState.team) return 0;
            const roster = managementState.team.roster;
            if (roster.length === 0) return 0;
            const total = roster.reduce((sum, p) => sum + p.overall, 0);
            return Math.round(total / roster.length);
        }

        // Refresh schedule screen
        function refreshScheduleScreen() {
            const list = document.getElementById('scheduleList');
            list.innerHTML = '';
            if (!managementState.season) return;

            // Update team strength display
            const teamOverall = calculateTeamOverallRating();
            const teamOffense = Math.round(calculateTeamOffenseRating());
            const teamDefense = Math.round(calculateTeamDefenseRating());

            document.getElementById('strengthOverall').textContent = teamOverall;
            document.getElementById('strengthOffense').textContent = teamOffense;
            document.getElementById('strengthDefense').textContent = teamDefense;

            managementState.season.schedule.forEach((game, index) => {
                const weekNum = index + 1;
                const isCurrent = weekNum === managementState.season.week;
                const isPast = weekNum < managementState.season.week;

                const item = document.createElement('div');
                item.className = `schedule-item ${isCurrent ? 'current' : ''} ${isPast ? 'past' : ''}`;

                let resultText = '-';
                let resultClass = '';
                if (game.result) {
                    resultText = `${game.result.win ? 'W' : 'L'} ${game.result.playerScore}-${game.result.opponentScore}`;
                    resultClass = game.result.win ? 'win' : 'loss';
                } else if (isCurrent) {
                    resultText = 'NEXT';
                    resultClass = '';
                }

                // Show opponent strength
                const oppOverall = Math.round((game.opponent.offenseRating + game.opponent.defenseRating) / 2);

                item.innerHTML = `
                    <div>
                        <div>Wk ${weekNum}: ${game.isHome ? 'vs' : '@'} ${game.opponent.name}</div>
                        <div style="font-size:11px;color:#888;">OVR ${oppOverall} | OFF ${game.opponent.offenseRating} | DEF ${game.opponent.defenseRating}</div>
                    </div>
                    <div class="result ${resultClass}">${resultText}</div>
                `;
                list.appendChild(item);
            });
        }

        // Refresh facilities screen
        function refreshFacilitiesScreen() {
            if (!managementState.team) return;

            document.getElementById('facCredits').textContent = `Fame: ${managementState.team.fame.toLocaleString()}`;

            const arena = managementState.team.facilities.stadium;
            const training = managementState.team.facilities.trainingCenter;

            document.getElementById('arenaLevel').textContent = `Level ${arena.level}/${arena.maxLevel}`;
            document.getElementById('trainingLevel').textContent = `Level ${training.level}/${training.maxLevel}`;

            const arenaCost = arena.level < arena.maxLevel ? ECONOMY.STADIUM_UPGRADE_COSTS[arena.level - 1] : 0;
            const trainingCost = training.level < training.maxLevel ? ECONOMY.TRAINING_UPGRADE_COSTS[training.level - 1] : 0;

            document.getElementById('btnUpgradeArena').textContent = arena.level >= arena.maxLevel ? 'MAXED' : `UPGRADE ($${arenaCost.toLocaleString()})`;
            document.getElementById('btnUpgradeArena').disabled = arena.level >= arena.maxLevel || managementState.team.fame < arenaCost;

            document.getElementById('btnUpgradeTraining').textContent = training.level >= training.maxLevel ? 'MAXED' : `UPGRADE ($${trainingCost.toLocaleString()})`;
            document.getElementById('btnUpgradeTraining').disabled = training.level >= training.maxLevel || managementState.team.fame < trainingCost;
        }

        // Show match end result
        function showMatchEnd(matchResult) {
            const result = matchResult.result;
            document.getElementById('matchResult').textContent = result.win ? 'VICTORY!' : 'DEFEAT';
            document.getElementById('matchResult').className = result.win ? 'win' : 'loss';
            document.getElementById('matchScore').textContent = `${result.playerScore} - ${result.opponentScore}`;
            document.getElementById('matchRevenue').textContent = `+${matchResult.revenue.toLocaleString()} Fame`;

            // Build post-game stats display using roster layout
            const statsContainer = document.getElementById('postGameStats');
            statsContainer.innerHTML = '';

            // Helper to get game stats for a player
            const getPlayerGameStats = (player) => {
                const pStats = gameStats.players[player.id];
                if (!pStats) return [];

                const statItems = [];

                // QB stats
                if (pStats.completions > 0 || pStats.incompletions > 0) {
                    const total = pStats.completions + pStats.incompletions;
                    const pct = total > 0 ? Math.round(pStats.completions / total * 100) : 0;
                    statItems.push({ label: 'COMP', value: `${pStats.completions}/${total}` });
                    statItems.push({ label: '%', value: `${pct}%` });
                    if (pStats.throwDistances.length > 0) {
                        const avgDist = Math.round(pStats.throwDistances.reduce((a,b) => a+b, 0) / pStats.throwDistances.length);
                        statItems.push({ label: 'YDS', value: avgDist });
                    }
                }

                // Receiver stats
                if (pStats.catches > 0 || pStats.drops > 0) {
                    statItems.push({ label: 'REC', value: pStats.catches });
                    if (pStats.drops > 0) statItems.push({ label: 'DROP', value: pStats.drops });
                    if (pStats.yardsAfterCatch > 0) statItems.push({ label: 'YAC', value: pStats.yardsAfterCatch });
                }

                // Clash stats
                if (pStats.clashesWon > 0 || pStats.clashesLost > 0) {
                    statItems.push({ label: 'W', value: pStats.clashesWon });
                    statItems.push({ label: 'L', value: pStats.clashesLost });
                }

                // Defense stats
                if (pStats.sacks > 0) statItems.push({ label: 'SACK', value: pStats.sacks });
                if (pStats.tackles > 0) statItems.push({ label: 'TKL', value: pStats.tackles });
                if (pStats.passesDefended > 0) statItems.push({ label: 'PD', value: pStats.passesDefended });

                // TDs
                if (pStats.touchdowns > 0) statItems.push({ label: 'TD', value: pStats.touchdowns });

                return statItems;
            };

            // Helper to render a player row
            const renderPlayerRow = (player) => {
                const statItems = getPlayerGameStats(player);
                const statsHtml = statItems.length > 0
                    ? statItems.map(s => `<div class="post-game-stat"><span class="post-game-stat-value">${s.value}</span><span class="post-game-stat-label">${s.label}</span></div>`).join('')
                    : '<span class="post-game-no-stats">No stats</span>';

                const div = document.createElement('div');
                div.className = 'post-game-player';
                div.innerHTML = `
                    <div class="post-game-player-header">
                        <span class="post-game-player-name">${player.firstName} ${player.lastName}</span>
                        <span class="post-game-player-ovr">${player.overall}</span>
                    </div>
                    <div class="post-game-player-stats">${statsHtml}</div>
                `;
                div.addEventListener('click', () => showPlayerDetail(player.id));
                return div;
            };

            // Group players by position category (same order as roster)
            const positionGroups = {
                'Offense': ['QB', 'WR', 'OL'],
                'Defense': ['CB', 'DL']
            };

            if (!managementState.team || !managementState.team.roster) {
                statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No roster data</p>';
                showScreen('match_end');
                return;
            }

            Object.entries(positionGroups).forEach(([groupName, positions]) => {
                const groupPlayers = managementState.team.roster
                    .filter(p => positions.includes(p.position))
                    .sort((a, b) => b.overall - a.overall);

                if (groupPlayers.length === 0) return;

                const section = document.createElement('div');
                section.className = 'post-game-section';
                section.innerHTML = `<div class="post-game-section-title">${groupName}</div>`;

                groupPlayers.forEach(player => {
                    section.appendChild(renderPlayerRow(player));
                });

                statsContainer.appendChild(section);
            });

            if (statsContainer.children.length === 0) {
                statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No player stats recorded</p>';
            }

            showScreen('match_end');
        }

        // Show pre-game matchup screen
        function showPreGame(opponent) {
            document.getElementById('preGameOpponent').textContent = `VS ${opponent.name.toUpperCase()}`;

            // Calculate team offense score (QB, WRs, OL average)
            const offensivePlayers = [];
            const qb = getDepthChartPlayer('QB1');
            if (qb) offensivePlayers.push(qb);
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) offensivePlayers.push(p);
            });
            managementState.team.depthChart.OL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) offensivePlayers.push(p);
            });
            const teamOffense = offensivePlayers.length > 0
                ? Math.round(offensivePlayers.reduce((s, p) => s + p.overall, 0) / offensivePlayers.length)
                : 60;

            // Calculate team defense score (CBs, DL average)
            const defensivePlayers = [];
            ['CB1', 'CB2', 'CB3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) defensivePlayers.push(p);
            });
            managementState.team.depthChart.DL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) defensivePlayers.push(p);
            });
            const teamDefense = defensivePlayers.length > 0
                ? Math.round(defensivePlayers.reduce((s, p) => s + p.overall, 0) / defensivePlayers.length)
                : 60;

            // Get opponent roster players by position
            const getOpponentPlayers = (position) => {
                if (!opponent.roster) return [];
                return opponent.roster.filter(p => p.position === position).sort((a, b) => b.overall - a.overall);
            };
            const oppCBs = getOpponentPlayers('CB');
            const oppDL = getOpponentPlayers('DL');

            // Show team scores
            const teamScoresHtml = `
                <div class="team-score-block">
                    <div class="team-score-label">Your Offense</div>
                    <div class="team-score-value yours">${teamOffense}</div>
                </div>
                <div class="team-score-vs">vs</div>
                <div class="team-score-block">
                    <div class="team-score-label">Their Defense</div>
                    <div class="team-score-value theirs">${opponent.defenseRating}</div>
                </div>
            `;
            document.getElementById('preGameTeamScores').innerHTML = teamScoresHtml;

            // Show QB key stats
            let qbScoresHtml = '';
            if (qb) {
                const throwStat = Math.floor(qb.stats.throwing || 0);
                const accStat = Math.floor(qb.stats.acceleration || 0);
                const focusStat = Math.floor(qb.stats.focus || 0);
                const agiStat = Math.floor(qb.stats.agility || 0);
                qbScoresHtml = `
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">QB Overall</div>
                        <div class="qb-stat-value">${qb.overall}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Throw</div>
                        <div class="qb-stat-value">${throwStat}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Focus</div>
                        <div class="qb-stat-value">${focusStat}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Accel</div>
                        <div class="qb-stat-value">${accStat}</div>
                    </div>
                `;
            }
            document.getElementById('preGameQBScores').innerHTML = qbScoresHtml;

            const matchupsContainer = document.getElementById('preGameMatchups');
            let html = '';

            // Helper to get advantage class
            const getAdvClass = (yours, theirs) => {
                const diff = yours - theirs;
                if (diff > 3) return 'advantage';
                if (diff < -3) return 'disadvantage';
                return 'even';
            };

            // QB vs opponent defense average
            if (qb) {
                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Quarterback</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${qb.firstName} ${qb.lastName}
                                <span class="matchup-ovr ${getAdvClass(qb.overall, opponent.defenseRating)}">${qb.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${opponent.defenseRating}</span>
                                Defense
                            </div>
                        </div>
                    </div>`;
            }

            // WRs vs opponent CBs
            const wrs = ['WR1', 'WR2', 'WR3'].map(s => getDepthChartPlayer(s)).filter(Boolean);
            if (wrs.length > 0) {
                html += `<div class="matchup-section"><div class="matchup-section-title">Receivers vs Corners</div>`;
                wrs.forEach((wr, i) => {
                    const cb = oppCBs[i];
                    const cbOvr = cb ? cb.overall : opponent.defenseRating;
                    const cbName = cb ? `${cb.firstName} ${cb.lastName.charAt(0)}.` : 'CB';
                    html += `
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${wr.firstName} ${wr.lastName.charAt(0)}.
                                <span class="matchup-ovr ${getAdvClass(wr.overall, cbOvr)}">${wr.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${cbOvr}</span>
                                ${cbName}
                            </div>
                        </div>`;
                });
                html += `</div>`;
            }

            // O-Line vs opponent D-Line
            const olPlayers = managementState.team.depthChart.OL.map(id =>
                managementState.team.roster.find(p => p.id === id)
            ).filter(Boolean);

            if (olPlayers.length > 0 || oppDL.length > 0) {
                const olAvg = olPlayers.length > 0
                    ? Math.round(olPlayers.reduce((s, p) => s + p.overall, 0) / olPlayers.length)
                    : 60;
                const dlAvg = oppDL.length > 0
                    ? Math.round(oppDL.reduce((s, p) => s + p.overall, 0) / oppDL.length)
                    : opponent.defenseRating;

                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Line Battle</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                O-Line (${olPlayers.length})
                                <span class="matchup-ovr ${getAdvClass(olAvg, dlAvg)}">${olAvg}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${dlAvg}</span>
                                D-Line (${oppDL.length})
                            </div>
                        </div>
                    </div>`;
            }

            matchupsContainer.innerHTML = html;
            showScreen('pre_game');
        }

        // Start the arcade game portion
        function startArcadeGame() {
            showScreen('game');
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameStats.reset();  // Reset per-game stats

            // Update game meshes with roster player data
            updateGamePlayersFromRoster();
        }

        // Start training mode (no defenders, throw ratings)
        function startTrainingMode() {
            gameState.trainingMode = true;
            gameState.lastThrowRating = null;

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('viewButtons').style.display = 'none'; // Hide view buttons in training
            document.getElementById('trainingModeUI').style.display = 'block';
            document.getElementById('catchDisplay').style.display = 'none'; // Hide top-right catch display in training
            gameSceneActive = true; // Enable game input

            // Reset game state
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameState.lineOfScrimmage = -5;
            gameState.firstDownMarker = 5;

            // Keep defensive backs visible but hide offensive and defensive lines
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(false));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(false));

            // Reset play
            if (gameState.scene) {
                resetPlay(gameState.scene);
            }

            // Update UI
            updateDownDisplay();
        }

        // Exit training mode and return to hub
        function exitTrainingMode() {
            gameState.trainingMode = false;
            gameSceneActive = false; // Disable game input
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('topBar').style.display = 'none';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('catchDisplay').style.display = ''; // Restore catch display
            document.getElementById('managementOverlay').classList.remove('hidden');

            // Show offensive and defensive lines again
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(true));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(true));

            // Hide other screens and show hub (or main menu if not initialized)
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            if (managementState.initialized) {
                document.getElementById('hubScreen').style.display = 'block';
                refreshHubScreen();
            } else {
                document.getElementById('mainMenuScreen').style.display = 'block';
            }
        }

        // Calculate throw rating based on route proximity and leading
        function calculateThrowRating(receiver, ballLandingPos, catchTime) {
            // Get the receiver's route waypoints
            const route = receiver.route || [];
            if (route.length === 0) return { grade: 'C', score: 50, details: 'No route data' };

            // Find the closest point on the route to where the ball landed
            let minDist = Infinity;
            let closestRoutePoint = null;

            // Check distance to each route waypoint
            route.forEach(waypoint => {
                const dist = Math.sqrt(
                    Math.pow(ballLandingPos.x - waypoint.x, 2) +
                    Math.pow(ballLandingPos.z - waypoint.z, 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    closestRoutePoint = waypoint;
                }
            });

            // Also check current receiver position at catch time
            const receiverPos = receiver.position;
            const distToReceiver = Math.sqrt(
                Math.pow(ballLandingPos.x - receiverPos.x, 2) +
                Math.pow(ballLandingPos.z - receiverPos.z, 2)
            );

            // Calculate lead accuracy: was the ball thrown ahead of the receiver?
            // Positive lead = thrown ahead (good), negative = thrown behind (bad)
            // Use velocity captured at throw time, not current velocity (receiver may have stopped)
            const storedVelocity = gameState.receiverVelocitiesAtThrow && gameState.receiverVelocitiesAtThrow[receiver.name];
            const receiverVelocity = storedVelocity || receiver.velocity || new BABYLON.Vector3(0, 0, 0);
            const leadVector = new BABYLON.Vector3(
                ballLandingPos.x - receiverPos.x,
                0,
                ballLandingPos.z - receiverPos.z
            );

            // Dot product with velocity direction (positive = leading, negative = behind)
            const velocityMagnitude = Math.sqrt(receiverVelocity.x * receiverVelocity.x + receiverVelocity.z * receiverVelocity.z);
            let leadScore = 50; // Default neutral
            let leadDistance = 0; // Actual lead distance (positive = ahead, negative = behind)
            const idealLead = 1.0; // Ideal lead distance in units

            if (velocityMagnitude > 0.001) {
                const leadDot = (leadVector.x * receiverVelocity.x + leadVector.z * receiverVelocity.z) / velocityMagnitude;
                leadDistance = leadDot;
                // Good lead is 0.5-2 units ahead
                if (leadDot > 0 && leadDot < 3) {
                    leadScore = 100 - Math.abs(leadDot - idealLead) * 20; // Best at 1 unit lead
                } else if (leadDot < 0) {
                    leadScore = Math.max(0, 50 + leadDot * 20); // Penalty for behind
                } else {
                    leadScore = Math.max(30, 100 - leadDot * 15); // Too far ahead
                }
            }

            // Route accuracy score (how close to the route) - less strict
            const routeScore = Math.max(0, 100 - minDist * 20);

            // Combine scores (lead accuracy weighted more heavily)
            const totalScore = Math.round(routeScore * 0.3 + leadScore * 0.7);

            // Determine grade (minimum C, no D or F)
            let grade;
            if (totalScore >= 90) grade = 'A+';
            else if (totalScore >= 80) grade = 'A';
            else if (totalScore >= 65) grade = 'B';
            else grade = 'C';

            // Format lead deviation from ideal
            const leadDeviation = leadDistance - idealLead;
            let leadText;
            if (Math.abs(leadDistance) < 0.1 && velocityMagnitude < 0.001) {
                leadText = 'stationary';
            } else if (leadDeviation > 0.1) {
                leadText = `+${leadDeviation.toFixed(1)} (too far ahead)`;
            } else if (leadDeviation < -0.1 && leadDistance >= 0) {
                leadText = `${leadDeviation.toFixed(1)} (short lead)`;
            } else if (leadDistance < 0) {
                leadText = `${leadDistance.toFixed(1)} (behind)`;
            } else {
                leadText = `${leadDeviation.toFixed(1)} (good)`;
            }

            return {
                grade,
                score: totalScore,
                routeScore: Math.round(routeScore),
                leadScore: Math.round(leadScore),
                distToRoute: minDist.toFixed(1),
                leadText: leadText,
                details: `Route: ${minDist.toFixed(1)} yds off | Lead: ${leadText}`
            };
        }

        // Update game player meshes with roster data
        function updateGamePlayersFromRoster() {
            if (!managementState.initialized || !managementState.team) return;

            const scene = gameState.scene;
            if (!scene) return;

            // Update QB
            const rosterQB = getDepthChartPlayer('QB1');
            if (rosterQB && scene.qb) {
                scene.qb.playerId = rosterQB.id;
                scene.qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                scene.qb.stats = { ...rosterQB.stats };
                scene.qb.lastName = rosterQB.lastName;
                scene.qb.overall = rosterQB.overall;
                // Update name label TextBlocks
                if (scene.qb.nameTextBlock) {
                    scene.qb.nameTextBlock.text = rosterQB.lastName.toUpperCase();
                }
                if (scene.qb.ovrTextBlock) {
                    scene.qb.ovrTextBlock.text = `${rosterQB.overall}`;
                }
            }

            // Update Receivers
            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                const player = getDepthChartPlayer(slot);
                const receiver = gameState.receivers[index];
                if (player && receiver) {
                    receiver.playerId = player.id;
                    receiver.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                    receiver.stats = { ...player.stats };
                    receiver.lastName = player.lastName;
                    receiver.overall = player.overall;
                    // Update name label TextBlocks
                    if (receiver.nameTextBlock) {
                        receiver.nameTextBlock.text = player.lastName.toUpperCase();
                    }
                    if (receiver.ovrTextBlock) {
                        receiver.ovrTextBlock.text = `${player.overall}`;
                    }
                }
            });

            // Update Defenders from opponent's CBs
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;
            if (opponent && opponent.roster) {
                const oppCBs = opponent.roster
                    .filter(p => p.position === 'CB')
                    .sort((a, b) => b.overall - a.overall);

                gameState.defenders.forEach((defender, index) => {
                    const player = oppCBs[index];
                    if (player && defender) {
                        defender.playerId = player.id;
                        defender.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        defender.stats = { ...player.stats };
                    }
                });
            }

            // Update O-Line
            managementState.team.depthChart.OL.forEach((playerId, index) => {
                const player = managementState.team.roster.find(p => p.id === playerId);
                const oLineman = gameState.offensiveLine[index];
                if (player && oLineman) {
                    oLineman.playerId = player.id;
                    oLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                    oLineman.stats = { ...player.stats };
                }
            });

            // Update D-Line from opponent's roster
            if (opponent && opponent.roster) {
                const oppDL = opponent.roster
                    .filter(p => p.position === 'DL')
                    .sort((a, b) => b.overall - a.overall);

                gameState.defensiveLine.forEach((dLineman, index) => {
                    const player = oppDL[index];
                    if (player && dLineman) {
                        dLineman.playerId = player.id;
                        dLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        dLineman.stats = { ...player.stats };
                    }
                });
            }
        }

        // Called when a drive/possession ends in the arcade game
        function onPossessionComplete(points) {
            if (!managementState.matchInProgress) return;

            const result = recordPossessionResult(points);

            // Handle case where recordPossessionResult returns undefined
            if (!result) {
                console.error('recordPossessionResult returned undefined');
                gameState.waitingForPossession = false;
                resetPlay(gameState.scene);
                return;
            }

            if (!result.ongoing) {
                showMatchEnd(result);
            } else {
                // Show enemy drive result between possessions
                showEnemyDriveResult(result);
            }
        }

        // Helper to create catch probability bar HTML
        // Shows QB roll vs catch window - lower roll is better (exponential distribution)
        function createCatchBarHTML(catchInfo, small = false) {
            if (!catchInfo) return '';

            const barWidth = small ? 80 : 100;
            const barHeight = small ? 10 : 14;
            const fontSize = small ? 10 : 12;

            const success = catchInfo.catchSuccess;
            const catchWindow = catchInfo.catchProb;
            // Scale the roll position: catchProb is the threshold, show roll relative to it
            // Bar shows 0-100 scale where catchWindow% is the "safe zone"
            const rollPosition = Math.min(100, (catchInfo.qbRoll / Math.max(1, catchWindow)) * catchWindow);

            return `
                <div style="display: inline-flex; align-items: center; gap: 6px; font-family: 'Courier New', monospace; font-size: ${fontSize}px;">
                    <span style="color: ${success ? '#4f4' : '#f66'}; font-weight: bold;">${success ? 'CATCH!' : 'INCOMPLETE'}</span>
                    <div style="position: relative; width: ${barWidth}px; height: ${barHeight}px; background: #222; border-radius: 2px; overflow: visible;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${catchWindow}%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 2px;"></div>
                        <div style="position: absolute; top: -1px; left: ${Math.min(98, rollPosition)}%; transform: translateX(-50%); font-size: ${fontSize}px; font-weight: bold; text-shadow: 0 0 2px #000; color: ${success ? '#4f4' : '#f44'}; line-height: ${barHeight}px;">${success ? '‚úì' : '‚úó'}</div>
                    </div>
                    <span style="color: #888; font-size: ${fontSize - 1}px;">${catchInfo.effectiveCatchPct}%</span>
                </div>
            `;
        }

        // Helper to create pressure bar HTML
        function createPressureBarHTML(pressureInfo) {
            if (!pressureInfo) return '';

            const pressure = pressureInfo.totalPressure;
            const level = pressureInfo.pressureLevel;
            const colors = {
                'light': '#4a4',
                'moderate': '#aa4',
                'heavy': '#f84',
                'extreme': '#f44'
            };
            const color = colors[level] || '#888';

            return `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px; width: 60px;">PRESSURE</span>
                    <div style="position: relative; width: 80px; height: 8px; background: #222; border-radius: 2px;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${pressure}%; background: ${color}; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                    <span style="color: ${color}; font-size: 10px; text-transform: uppercase;">${level}</span>
                </div>
            `;
        }

        // Show enemy drive result overlay with detailed simulation info
        function showEnemyDriveResult(result) {
            const game = managementState.season.schedule[managementState.season.week - 1];
            const plays = result.enemyResult.plays || []; // Array of detailed play objects
            const delayPerPlay = plays.length > 0 ? 1200 : 500; // Time between plays

            console.log('showEnemyDriveResult - plays count:', plays.length);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'enemyDriveOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                font-family: 'Courier New', monospace;
            `;

            const pointsColor = result.enemyResult.points > 0 ? '#f44' : '#4f4';
            const pointsText = result.enemyResult.points > 0
                ? `+${result.enemyResult.points} points`
                : 'Defensive Stop!';

            overlay.innerHTML = `
                <div style="background: #1a1a2e; border: 2px solid #333; border-radius: 12px; padding: 20px; max-width: 700px; width: 95%; text-align: center; max-height: 90vh; display: flex; flex-direction: column;">
                    <h2 style="color: #888; margin: 0 0 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; flex-shrink: 0;">
                        ${game.opponent.name} Possession
                    </h2>
                    <div id="playsScrollContainer" style="flex: 1; overflow-y: auto; min-height: 200px; max-height: 400px; padding: 8px; background: #151528; border-radius: 8px; margin-bottom: 12px;">
                        <div id="playsContainer" style="text-align: left;">
                        </div>
                    </div>
                    <div id="driveResult" style="display: none; flex-shrink: 0;">
                        <div style="color: ${pointsColor}; font-size: 24px; font-weight: bold; margin-bottom: 12px;">
                            ${pointsText}
                        </div>
                        <div style="color: #aaa; margin-bottom: 12px;">
                            <span style="color: #4af;">You: ${result.score.player}</span>
                            &nbsp;-&nbsp;
                            <span style="color: #f44;">${game.opponent.name}: ${result.score.opponent}</span>
                        </div>
                        <div style="color: #666; margin-bottom: 12px; font-size: 12px;">
                            ${getGamePhaseDisplay(result)}
                        </div>
                        ${result.message ? `<div style="color: #fa4; margin-bottom: 12px; font-size: 14px; font-weight: bold;">${result.message}</div>` : ''}
                        <button id="btnContinueDrive" style="
                            background: #4a4; color: white; border: none;
                            padding: 12px 30px; border-radius: 6px; cursor: pointer;
                            font-size: 16px; transition: background 0.2s;
                        ">Continue</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            const playsContainer = document.getElementById('playsContainer');
            const scrollContainer = document.getElementById('playsScrollContainer');
            let playIndex = 0;

            // Format a detailed play display
            const formatPlayDetails = (play, playNum) => {
                if (!play) return '<div style="color: #888;">Loading...</div>';

                const opponent = result.enemyResult.opponent || game.opponent;
                const teamShort = (opponent?.name || 'Enemy').split(' ')[0];
                const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

                let html = `<div style="background: #252540; border-radius: 6px; padding: 10px; margin-bottom: 8px; border-left: 3px solid #444;">`;

                // Play number and down/distance header
                const downStr = getDownString(play.down);
                const fieldPos = 100 - play.yardsFromGoal;
                html += `<div style="color: #aaa; font-size: 12px; margin-bottom: 6px; display: flex; justify-content: space-between;">
                    <span><span style="color: #666;">Play ${playNum}:</span> <span style="color: #fff; font-weight: bold;">${downStr}</span> & ${play.yardsToGo}</span>
                    <span style="color: #555;">Ball at ${fieldPos > 50 ? 'OPP ' + (100 - fieldPos) : 'OWN ' + fieldPos}</span>
                </div>`;

                if (play.type === 'sack') {
                    // Sack play
                    const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your DL';
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 6px;">`;
                    html += `<div style="color: #4f4; font-size: 13px; font-weight: bold;">SACK! ${dlName} breaks through!</div>`;
                    html += `<div style="color: #888; font-size: 10px; margin-top: 2px;">${qbName} taken down for ${Math.abs(play.yardsGained)} yard loss</div>`;

                    // DL matchup details
                    if (play.pressureInfo?.matchups) {
                        html += `<div style="margin-top: 6px; padding: 6px; background: #1a1a2e; border-radius: 4px; font-size: 10px;">`;
                        html += `<div style="color: #666; margin-bottom: 3px;">LINE MATCHUPS:</div>`;
                        play.pressureInfo.matchups.slice(0, 3).forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#f44' : m.result === 'beaten' ? '#f84' : m.result === 'pressured' ? '#aa4' : '#4a4';
                            html += `<div style="display: flex; justify-content: space-between; color: #888; margin: 1px 0;">
                                <span>${getPlayerFullName(m.dl)} vs ${getPlayerFullName(m.ol)}</span>
                                <span style="color: ${resultColor};">${m.dlRoll} vs ${m.olRoll} ‚Üí ${m.result}</span>
                            </div>`;
                        });
                        html += `</div>`;
                    }
                    html += `</div>`;
                } else if (play.fieldGoalAttempt) {
                    // Field goal attempt
                    const distance = play.yardsFromGoal + 17;
                    const successColor = play.fieldGoalSuccess ? '#4f4' : '#f44';
                    html += `<div style="color: ${successColor}; font-size: 13px; font-weight: bold;">`;
                    html += play.fieldGoalSuccess ? `Field Goal GOOD from ${distance} yards!` : `Field Goal MISSED from ${distance} yards!`;
                    html += `</div>`;
                } else if (play.type === 'scramble') {
                    // QB scramble
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 6px;">`;
                    html += `<div style="color: #fa4; font-size: 13px; font-weight: bold;">QB Scramble!</div>`;
                    html += `<div style="color: #888; font-size: 10px; margin-top: 2px;">${qbName} takes off for ${play.yardsGained} yards</div>`;
                    html += `</div>`;
                } else if (play.type === 'throwaway') {
                    // Throwaway
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 6px;">`;
                    html += `<div style="color: #888; font-size: 13px;">Throwaway</div>`;
                    html += `<div style="color: #666; font-size: 10px; margin-top: 2px;">${qbName} throws it away under pressure</div>`;
                    html += `</div>`;
                } else if (play.type === 'interception') {
                    // Interception
                    html += createPressureBarHTML(play.pressureInfo);
                    const interceptedBy = play.interceptedBy ? getPlayerFullName(play.interceptedBy) : 'Your DB';
                    html += `<div style="margin-top: 6px;">`;
                    html += `<div style="color: #4f4; font-size: 13px; font-weight: bold;">INTERCEPTION!</div>`;
                    html += `<div style="color: #888; font-size: 10px; margin-top: 2px;">Picked off by ${interceptedBy}!</div>`;
                    html += `</div>`;
                } else {
                    // Pass play (complete/incomplete)
                    const catchInfo = play.catchInfo;
                    const wrName = catchInfo?.receiver ? getPlayerFullName(catchInfo.receiver) : `${teamShort} WR`;
                    const cbName = catchInfo?.cb ? getPlayerFullName(catchInfo.cb) : 'Your CB';

                    // Pressure bar
                    html += createPressureBarHTML(play.pressureInfo);

                    // Target info
                    html += `<div style="margin: 6px 0; font-size: 11px;">`;
                    html += `<span style="color: #888;">Target:</span> <span style="color: #f94;">${wrName}</span>`;
                    if (play.targetSlot) html += ` <span style="color: #555;">(${play.targetSlot})</span>`;
                    html += ` <span style="color: #888;">vs</span> <span style="color: #4af;">${cbName}</span>`;
                    html += `</div>`;

                    // Show line matchups for pass plays too (not just sacks)
                    if (play.pressureInfo?.matchups && play.pressureInfo.matchups.length > 0) {
                        html += `<div style="margin-top: 6px; padding: 6px; background: #1a1a2e; border-radius: 4px; font-size: 10px;">`;
                        html += `<div style="color: #666; margin-bottom: 3px;">LINE CLASHES:</div>`;
                        play.pressureInfo.matchups.forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#f44' : m.result === 'beaten' ? '#f84' : m.result === 'pressured' ? '#fa4' : m.result === 'held' ? '#aa4' : '#4a4';
                            html += `<div style="display: flex; justify-content: space-between; color: #888; margin: 1px 0;">
                                <span style="color: #4af;">${getPlayerFullName(m.dl)}</span>
                                <span><span style="color: #4af;">${m.dlRoll}</span> vs <span style="color: #f94;">${m.olRoll}</span> ‚Üí <span style="color: ${resultColor};">${m.result}</span> (+${m.pressure})</span>
                            </div>`;
                        });
                        html += `<div style="color: #888; margin-top: 3px; border-top: 1px solid #333; padding-top: 3px;">Total Pressure: <span style="color: #fff;">${play.pressureInfo.totalPressure}</span> (${play.pressureInfo.pressureLevel})</div>`;
                        html += `</div>`;
                    }

                    if (catchInfo) {
                        // Matchup details box - aligned with player offense formula
                        html += `<div style="background: #1a1a2e; border-radius: 4px; padding: 6px; margin: 6px 0; font-size: 10px;">`;

                        // WR vs CB separation roll
                        const sepColor = catchInfo.separationMargin > 5 ? '#4f4' : catchInfo.separationMargin < -5 ? '#f44' : '#aa4';
                        const sepLabel = catchInfo.coverageCloseness < 0.2 ? 'OPEN' :
                                        catchInfo.coverageCloseness < 0.4 ? 'some space' :
                                        catchInfo.coverageCloseness < 0.6 ? 'contested' :
                                        catchInfo.coverageCloseness < 0.8 ? 'tight' : 'SMOTHERED';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                            <span style="color: #666;">Separation:</span>
                            <span>WR <span style="color: #f94;">${catchInfo.wrRoll}</span> vs CB <span style="color: #4af;">${catchInfo.cbRoll}</span> ‚Üí <span style="color: ${sepColor};">${sepLabel}</span></span>
                        </div>`;

                        // Momentum advantage display (if route had direction change)
                        if (catchInfo.momentumAdvantage && catchInfo.momentumAdvantage > 0) {
                            const momColor = catchInfo.momentumAdvantage >= 15 ? '#4f4' :
                                           catchInfo.momentumAdvantage >= 8 ? '#8f4' : '#aa4';
                            const reactionLabel = catchInfo.dbReactionDelay >= 2 ? 'SLOW REACT' :
                                                 catchInfo.dbReactionDelay >= 1 ? 'delayed' : 'quick';
                            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                                <span style="color: #666;">Momentum (DB AWR ${catchInfo.dbAwareness}):</span>
                                <span style="color: ${momColor};">+${catchInfo.momentumAdvantage} sep <span style="color: #888;">(${reactionLabel})</span></span>
                            </div>`;
                        }

                        // Coverage penalty (like player offense defender proximity penalty)
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                            <span style="color: #666;">CB Penalty (${catchInfo.coverageCloseness}¬≥ √ó ${catchInfo.cbCoverage} √ó 0.8):</span>
                            <span style="color: #f44;">-${catchInfo.defenderPenalty}</span>
                        </div>`;

                        // Catch window from WR/CB matchup
                        const focusStr = catchInfo.focusMod !== 0 ? `+${catchInfo.focusMod}` : '';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                            <span style="color: #666;">Catch Window (${catchInfo.baseCatch}${focusStr}-${catchInfo.defenderPenalty}):</span>
                            <span style="color: #fff;">${catchInfo.catchProb}%</span>
                        </div>`;

                        // QB throw quality with exponential distribution
                        const qbColor = catchInfo.catchSuccess ? '#4f4' : '#f44';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 3px;">
                            <span style="color: #666;">QB (${catchInfo.qbAccuracy} acc, ${catchInfo.pressure} pres ‚Üí Œº=${catchInfo.rollMean}):</span>
                            <span style="color: ${qbColor};">roll ${catchInfo.qbRoll} ${catchInfo.catchSuccess ? '<' : '‚â•'} ${catchInfo.catchProb}</span>
                        </div>`;

                        // Effective catch % after QB modifier
                        html += `<div style="display: flex; justify-content: space-between;">
                            <span style="color: #666;">Effective Catch:</span>
                            <span style="color: #fff; font-weight: bold;">${catchInfo.effectiveCatchPct}%</span>
                        </div>`;

                        html += `</div>`;
                    }

                    // Result with catch bar
                    html += `<div style="margin-top: 6px;">`;
                    if (play.type === 'complete' || play.type === 'touchdown') {
                        if (play.type === 'touchdown' || play.isTouchdown) {
                            html += `<div style="color: #f44; font-size: 13px; font-weight: bold;">TOUCHDOWN! ${wrName} catches it for ${play.yardsGained} yards!</div>`;
                        } else {
                            html += `<div style="color: #ccc; font-size: 12px;">${wrName} catches for <span style="color: #f94;">${play.yardsGained} yards</span></div>`;
                        }
                        html += `<div style="margin-top: 4px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    } else {
                        html += `<div style="color: #4f4; font-size: 12px;">Pass broken up by ${cbName}!</div>`;
                        html += `<div style="margin-top: 4px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            };

            // Show plays progressively in scrolling container
            const showNextPlay = () => {
                if (playIndex < plays.length) {
                    const play = plays[playIndex];

                    // Add play to container
                    const playDiv = document.createElement('div');
                    playDiv.innerHTML = formatPlayDetails(play, playIndex + 1);
                    playDiv.style.opacity = '0';
                    playDiv.style.transition = 'opacity 0.3s';
                    playsContainer.appendChild(playDiv);

                    // Fade in and scroll to show new play
                    setTimeout(() => {
                        playDiv.style.opacity = '1';
                        scrollContainer.scrollTop = scrollContainer.scrollHeight;
                    }, 50);

                    playIndex++;
                    setTimeout(showNextPlay, delayPerPlay);
                } else {
                    // All plays shown - add final result banner
                    const resultBanner = document.createElement('div');
                    resultBanner.style.cssText = `text-align: center; padding: 15px; color: ${pointsColor}; font-size: 16px; font-weight: bold; background: #252540; border-radius: 6px; border-left: 3px solid ${pointsColor};`;
                    const driveType = result.enemyResult.type;
                    resultBanner.textContent = (driveType === 'TD' || driveType === 'touchdown') ? 'TOUCHDOWN!' :
                        (driveType === 'FG' || driveType === 'field_goal') ? 'FIELD GOAL!' :
                        (driveType === 'PUNT' || driveType === 'punt') ? 'Forced to Punt!' :
                        (driveType === 'MISSED_FG' || driveType === 'missed_fg') ? 'Field Goal Missed!' :
                        driveType === 'turnover' ? 'TURNOVER!' : 'Drive Stopped!';
                    playsContainer.appendChild(resultBanner);
                    scrollContainer.scrollTop = scrollContainer.scrollHeight;

                    setTimeout(() => {
                        document.getElementById('driveResult').style.display = 'block';
                        document.getElementById('btnContinueDrive').addEventListener('click', () => {
                            overlay.remove();
                            gameState.waitingForPossession = false;
                            resetPlay(gameState.scene);
                        });
                    }, 300);
                }
            };

            // Start showing plays after a brief pause
            setTimeout(showNextPlay, 400);
        }

        // Main
        const scene = createScene();
        setupInput(scene);
        setupIdleAnimations(scene);

        // Handle visibility changes (app switching) - clear stale pointer state
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // App is being hidden - clear any in-progress drag
                gameState.isDragging = false;
                gameState.activePointerId = null;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            }
        });

        // Initialize management system
        initializeManagement();

        // Setup HTML button handlers
        document.getElementById('btnNewGame').addEventListener('click', () => {
            startNewGame();
            showScreen('hub');
        });
        document.getElementById('btnContinue').addEventListener('click', () => {
            if (managementState.initialized) showScreen('hub');
        });
        document.getElementById('btnTrainingMode').addEventListener('click', () => {
            startTrainingMode();
        });
        document.getElementById('btnExitTraining').addEventListener('click', () => {
            exitTrainingMode();
        });
        document.getElementById('btnPlayGame').addEventListener('click', () => {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) return;
            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) return;
            showPreGame(game.opponent);
        });
        document.getElementById('btnStartGame').addEventListener('click', () => {
            const result = startMatch();
            if (result.success) startArcadeGame();
        });
        document.getElementById('btnRoster').addEventListener('click', () => showScreen('roster'));
        document.getElementById('btnFreeAgency').addEventListener('click', () => showScreen('free_agency'));
        document.getElementById('btnSchedule').addEventListener('click', () => showScreen('schedule'));
        document.getElementById('btnFacilities').addEventListener('click', () => showScreen('facilities'));
        document.getElementById('btnHubTraining').addEventListener('click', () => startTrainingMode());
        document.getElementById('btnHubNewGame').addEventListener('click', () => {
            if (confirm("Start a new game? All progress will be lost!")) {
                SaveSystem.clear();
                managementState.initialized = false;
                managementState.team = null;
                managementState.season = null;
                managementState.freeAgents = [];
                startNewGame();
                showScreen('hub');
            }
        });
        document.getElementById('btnRosterBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFABack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnScheduleBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFacilitiesBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnMatchContinue').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnUpgradeArena').addEventListener('click', () => {
            upgradeFacility('stadium');
            refreshFacilitiesScreen();
        });
        document.getElementById('btnUpgradeTraining').addEventListener('click', () => {
            upgradeFacility('trainingCenter');
            refreshFacilitiesScreen();
        });

        // Player detail modal handlers
        document.getElementById('btnCloseDetail').addEventListener('click', closePlayerDetail);
        document.getElementById('btnCutPlayer').addEventListener('click', cutPlayerFromDetail);
        document.getElementById('btnTradePlayer').addEventListener('click', tradePlayerFromDetail);

        // Show initial screen
        showScreen(managementState.currentScreen);

        // Camera view switching
        const setCameraView = (viewType) => {
            const camera = scene.activeCamera;
            if (!camera) return;
            gameState.currentView = viewType;
            document.querySelectorAll('#viewButtons button').forEach(btn => btn.classList.remove('active'));
            switch(viewType) {
                case 'iso':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 3.5;
                    camera.radius = 32;
                    document.getElementById('viewIso').classList.add('active');
                    break;
                case 'overhead':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = 0.1;
                    camera.radius = 28;
                    document.getElementById('viewOverhead').classList.add('active');
                    break;
                case 'shoulder':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 2.5;
                    camera.radius = 18;
                    document.getElementById('viewShoulder').classList.add('active');
                    break;
            }
        };

        document.getElementById('viewIso').addEventListener('click', () => setCameraView('iso'));
        document.getElementById('viewOverhead').addEventListener('click', () => setCameraView('overhead'));
        document.getElementById('viewShoulder').addEventListener('click', () => setCameraView('shoulder'));

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
