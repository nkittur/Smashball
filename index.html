<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: calc(36px + env(safe-area-inset-top, 0px));
            padding-top: env(safe-area-inset-top, 0px);
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-left: 15px;
            padding-right: 15px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            border-bottom: 1px solid #333;
            box-sizing: border-box;
        }

        #score {
            color: #ffd700;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }

        #score .catches { color: #8cf; }
        #score .touchdowns { color: #4f4; }
        #score .label { color: #888; }

        #downDistance {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40, 40, 40, 0.9);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        #downDistance .down { color: #ffa; }
        #downDistance .distance { color: #aef; }

        #viewButtons {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        #viewButtons button {
            background: rgba(60, 60, 60, 0.9);
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 14px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        #viewButtons button:hover {
            background: rgba(80, 80, 80, 0.9);
            color: #fff;
        }
        #viewButtons button.active {
            background: rgba(70, 90, 120, 0.9);
            border-color: #68a;
            color: #fff;
        }

        #debugInfo {
            position: absolute;
            top: calc(80px + env(safe-area-inset-top, 0px));
            right: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: left;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
            white-space: pre-wrap;
        }
        #catchDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #catchDisplay.visible {
            opacity: 1;
        }
        #catchDisplay .catch-header {
            font-size: 11px;
            font-weight: bold;
        }
        #catchDisplay .catch-header.success { color: #4f4; }
        #catchDisplay .catch-header.fail { color: #f66; }
        #catchDisplay .catch-bar {
            position: relative;
            width: 100px;
            height: 14px;
            background: #222;
            border-radius: 2px;
            overflow: visible;
        }
        #catchDisplay .catch-bar-base {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #3a3, #4b4);
            border-radius: 2px;
        }
        #catchDisplay .catch-bar-penalty {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
            border-left: 1px solid #f55;
        }
        #catchDisplay .catch-bar-roll {
            position: absolute;
            top: -1px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            transform: translateX(-50%);
            line-height: 14px;
        }
        #catchDisplay .catch-bar-roll.success { color: #4f4; }
        #catchDisplay .catch-bar-roll.fail { color: #f44; }
        #catchDisplay .defender-info {
            font-size: 10px;
            color: #f99;
        }
        #catchDisplay .throw-rating-info {
            font-size: 10px;
            color: #9cf;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="topBar">
        <div id="downDistance">
            <span class="down">1st</span> & <span class="distance">10</span>
            <span class="field-pos" style="margin-left: 12px; color: #8cf;"></span>
        </div>
        <div id="score">
            <span><span class="label">Catches</span> <span class="catches">0/0</span></span>
            <span><span class="label">TD</span> <span class="touchdowns">0</span></span>
        </div>
        <div id="catchDisplay">
            <div class="catch-header">CATCH</div>
            <div class="catch-bar">
                <div class="catch-bar-base"></div>
                <div class="catch-bar-penalty"></div>
                <div class="catch-bar-roll">üèà</div>
            </div>
            <div class="defender-info"></div>
            <div class="throw-rating-info"></div>
        </div>
    </div>
    <div id="viewButtons">
        <button id="btnHeatMap">Heat Map: OFF</button>
    </div>
    <button id="btnSimRest" style="
        display: none;
        position: fixed;
        top: calc(46px + env(safe-area-inset-top, 0px));
        right: 10px;
        padding: 8px 12px;
        font-size: 12px;
        font-family: 'Courier New', monospace;
        background: #36a;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        z-index: 100;
    ">SIM REST</button>
    <div id="debugInfo"></div>

    <!-- Training Mode UI -->
    <div id="trainingModeUI" style="display: none;">
        <button id="btnExitTraining" style="
            position: fixed;
            top: calc(46px + env(safe-area-inset-top, 0px));
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
            color: #ccc;
            border: 1px solid #444;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            z-index: 1001;
        ">‚Üê</button>
        <div id="trainingTitle" style="
            position: fixed;
            top: calc(50px + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translateX(-50%);
            color: #4a4;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1001;
        ">SCRIMMAGE</div>
        <div id="throwRating" style="
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.92);
            padding: 20px 28px;
            border-radius: 12px;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1000;
            display: none;
            min-width: 260px;
            cursor: pointer;
        ">
            <div id="throwGrade" style="font-size: 48px; font-weight: bold; color: #4f4;"></div>
            <div id="throwDetails" style="font-size: 13px; color: #aaa; margin-top: 5px;"></div>
            <div id="throwCatchInfo" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid #444;">
                <div id="popupCatchHeader" style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">CATCH</div>
                <div id="popupCatchBar" style="position: relative; width: 200px; height: 18px; background: #222; border-radius: 4px; margin: 0 auto 12px auto; overflow: visible;">
                    <div id="popupCatchBase" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 4px;"></div>
                    <div id="popupCatchPenalty" style="position: absolute; top: 0; height: 100%; background: rgba(0, 0, 0, 0.55); border-left: 2px solid #f55;"></div>
                    <div id="popupCatchRoll" style="position: absolute; top: -2px; font-size: 16px; font-weight: bold; transform: translateX(-50%); line-height: 18px;">üèà</div>
                </div>
                <div id="popupModifierList" style="text-align: left; font-size: 13px; margin-top: 10px;"></div>
            </div>
            <div id="popupTapToContinue" style="margin-top: 16px; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px;">tap to continue</div>
        </div>
        <!-- Settings Button -->
        <button id="btnTrainingSettings" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            font-size: 22px;
            background: rgba(0,0,0,0.7);
            color: #888;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1001;
        ">‚öô</button>
        <!-- Settings Panel -->
        <div id="trainingSettingsPanel" style="
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(0,0,0,0.92);
            padding: 16px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 1002;
            font-family: 'Courier New', monospace;
            min-width: 220px;
            max-height: 70vh;
            overflow-y: auto;
        ">
            <div style="color: #fff; font-size: 14px; font-weight: bold; margin-bottom: 12px; border-bottom: 1px solid #444; padding-bottom: 8px;">Training Settings</div>

            <!-- Difficulty -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">TRAINING DIFFICULTY</div>
                <div style="display: flex; gap: 4px;">
                    <button class="difficulty-btn" data-difficulty="easy" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Easy</button>
                    <button class="difficulty-btn" data-difficulty="medium" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Medium</button>
                    <button class="difficulty-btn" data-difficulty="hard" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Hard</button>
                </div>
            </div>

            <!-- Game Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">GAME SPEED</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="btnGameSpeedDown" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">-</button>
                    <span id="gameSpeedDisplay" style="color: #4f4; font-size: 14px; min-width: 45px; text-align: center;">1.5x</span>
                    <button id="btnGameSpeedUp" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">+</button>
                </div>
            </div>

            <!-- Ball Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">BALL SPEED</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="btnBallSpeedDown" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">-</button>
                    <span id="ballSpeedDisplay" style="color: #4f4; font-size: 14px; min-width: 45px; text-align: center;">1.2x</span>
                    <button id="btnBallSpeedUp" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">+</button>
                </div>
            </div>

            <!-- Receiver Speed Preset -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">WR SPEED</div>
                <div style="display: flex; gap: 4px;">
                    <button class="rcvr-speed-btn" data-speed="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="rcvr-speed-btn" data-speed="80" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">80</button>
                    <button class="rcvr-speed-btn" data-speed="70" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="rcvr-speed-btn" data-speed="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- WR Awareness Preset (reaction delay) -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">WR REACTION <span style="color: #666; font-size: 9px;">(delay)</span></div>
                <div style="display: flex; gap: 4px;">
                    <button class="wr-awr-btn" data-awareness="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="wr-awr-btn" data-awareness="70" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="wr-awr-btn" data-awareness="50" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">50</button>
                    <button class="wr-awr-btn" data-awareness="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- WR Agility Preset (turn rate) -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">WR AGILITY <span style="color: #666; font-size: 9px;">(turn rate)</span></div>
                <div style="display: flex; gap: 4px;">
                    <button class="wr-agi-btn" data-agility="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="wr-agi-btn" data-agility="70" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="wr-agi-btn" data-agility="50" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">50</button>
                    <button class="wr-agi-btn" data-agility="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- DB Speed Preset -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">DB SPEED</div>
                <div style="display: flex; gap: 4px;">
                    <button class="db-speed-btn" data-speed="90" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">90</button>
                    <button class="db-speed-btn" data-speed="80" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">80</button>
                    <button class="db-speed-btn" data-speed="70" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">70</button>
                    <button class="db-speed-btn" data-speed="mixed" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Mix</button>
                </div>
            </div>

            <!-- Show Grade Popup Toggle -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="color: #888; font-size: 11px;">SHOW GRADE POPUP</span>
                <button id="btnToggleGradePopup" style="padding: 4px 12px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">ON</button>
            </div>

            <!-- Show Clash Flash Toggle -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <span style="color: #888; font-size: 11px;">CLASH FLASH</span>
                <button id="btnToggleClashFlash" style="padding: 4px 12px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">ON</button>
            </div>

            <!-- Camera Angle Slider -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">CAMERA ANGLE</span>
                    <span id="cameraAngleValue" style="color: #4f4; font-size: 11px;">50%</span>
                </div>
                <input type="range" id="cameraAngleSlider" min="0" max="100" value="50" style="width: 100%; cursor: pointer;">
                <div style="display: flex; justify-content: space-between; color: #555; font-size: 9px;">
                    <span>Top-Down</span>
                    <span>Horizontal</span>
                </div>
            </div>

            <!-- Camera Offset Slider -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">CAMERA OFFSET</span>
                    <span id="cameraOffsetValue" style="color: #4f4; font-size: 11px;">35%</span>
                </div>
                <input type="range" id="cameraOffsetSlider" min="0" max="100" value="35" style="width: 100%; cursor: pointer;">
                <div style="display: flex; justify-content: space-between; color: #555; font-size: 9px;">
                    <span>Centered</span>
                    <span>Forward</span>
                </div>
            </div>

            <!-- Player Size Slider -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">PLAYER SIZE</span>
                    <span id="playerSizeValue" style="color: #4f4; font-size: 11px;">1.3x</span>
                </div>
                <input type="range" id="playerSizeSlider" min="50" max="250" value="130" style="width: 100%; cursor: pointer;">
            </div>

            <!-- Ball Size Slider -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">BALL SIZE</span>
                    <span id="ballSizeValue" style="color: #4f4; font-size: 11px;">1.3x</span>
                </div>
                <input type="range" id="ballSizeSlider" min="50" max="250" value="130" style="width: 100%; cursor: pointer;">
            </div>
        </div>
    </div>

    <!-- Target Practice Mode UI -->
    <div id="targetPracticeModeUI" style="display: none;">
        <button id="btnExitTargetPractice" style="
            position: fixed;
            top: calc(46px + env(safe-area-inset-top, 0px));
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
            color: #ccc;
            border: 1px solid #444;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            z-index: 1001;
        ">&#8592;</button>
        <!-- Compact Score Bar at Top -->
        <div id="targetPracticeStats" style="
            position: fixed;
            top: calc(46px + env(safe-area-inset-top, 0px));
            left: 50px;
            right: 50px;
            background: rgba(0,0,0,0.75);
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
        ">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="color: #a4a; font-size: 14px; font-weight: bold;">ROUND <span id="targetRound" style="color: #fff;">1</span></div>
                <div style="color: #666;">|</div>
                <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #888; font-size: 10px;">SCORE</span>
                    <span id="targetScoreDisplay" style="color: #ffd700; font-size: 16px; font-weight: bold;">0</span>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 16px;">
                <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #888; font-size: 10px;">THROWS</span>
                    <span id="targetThrows" style="color: #4fc3f7; font-size: 16px; font-weight: bold;">0</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #888; font-size: 10px;">TIME</span>
                    <span id="targetTime" style="color: #ffd700; font-size: 16px; font-weight: bold;">0.0s</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px;">
                    <span id="targetMultiplier" style="color: #4fc3f7; font-size: 16px; font-weight: bold;">1x</span>
                </div>
                <div style="color: #666;">|</div>
                <div style="display: flex; align-items: center; gap: 2px;">
                    <span id="targetMissIcons" style="font-size: 14px; letter-spacing: 1px;"></span>
                    <span id="targetMisses" style="display: none;">5</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #888; font-size: 10px;">STREAK</span>
                    <span id="targetStreak" style="color: #4f4; font-size: 16px; font-weight: bold;">0</span>
                </div>
            </div>
        </div>
        <!-- Hit Popup (shows when you hit a target) -->
        <div id="targetHitPopup" style="
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.92);
            padding: 16px 24px;
            border-radius: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1000;
            display: none;
            min-width: 200px;
        ">
            <div id="hitPopupMain" style="font-size: 32px; font-weight: bold; color: #4f4;">HIT!</div>
            <div id="hitPopupPoints" style="font-size: 18px; color: #ffd700; margin-top: 4px;">+100</div>
            <div id="hitPopupBonuses" style="font-size: 12px; color: #aaa; margin-top: 6px;"></div>
        </div>
        <!-- Round History Display -->
        <div id="targetRoundHistory" style="
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 8px 14px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #888;
            z-index: 1001;
            max-width: 200px;
        ">
            <div style="color: #aaa; margin-bottom: 4px;">ROUND HISTORY</div>
            <div id="roundHistoryList" style="color: #666;"></div>
        </div>
        <!-- Round Complete Popup -->
        <div id="roundCompletePopup" style="
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 24px 36px;
            border-radius: 12px;
            border: 2px solid #4f4;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1002;
            display: none;
            min-width: 250px;
        ">
            <div id="roundCompleteTitle" style="font-size: 24px; font-weight: bold; color: #4f4;">ROUND COMPLETE!</div>
            <div style="margin-top: 16px; display: flex; justify-content: space-around;">
                <div>
                    <div style="color: #888; font-size: 10px;">THROWS</div>
                    <div id="roundCompleteThrows" style="color: #4fc3f7; font-size: 28px; font-weight: bold;">0</div>
                </div>
                <div>
                    <div style="color: #888; font-size: 10px;">TIME</div>
                    <div id="roundCompleteTime" style="color: #ffd700; font-size: 28px; font-weight: bold;">0.0s</div>
                </div>
            </div>
            <div id="roundScoreBreakdown" style="margin-top: 16px; padding: 12px; background: rgba(50,50,50,0.5); border-radius: 8px;">
                <div style="color: #888; font-size: 10px; margin-bottom: 6px;">ROUND SCORE</div>
                <div id="roundTimeBonus" style="color: #ffd700; font-size: 14px;">Time Bonus: +0</div>
                <div id="roundAccuracyBonus" style="color: #4fc3f7; font-size: 14px;">Accuracy Bonus: +0</div>
                <div id="roundTotalBonus" style="color: #4f4; font-size: 18px; font-weight: bold; margin-top: 6px;">Total: +0</div>
            </div>
            <div id="roundExtraMiss" style="margin-top: 10px; color: #ff6b6b; font-size: 14px; font-weight: bold;">+1 Extra Miss!</div>
            <div id="roundCompleteNext" style="margin-top: 12px; color: #aaa; font-size: 12px;">Next: Round <span id="nextRoundNum">2</span> - <span id="nextRoundTargets">6</span> targets</div>
            <div style="margin-top: 12px; color: #666; font-size: 11px;">Tap to continue</div>
        </div>
        <!-- Game Over Popup -->
        <div id="gameOverPopup" style="
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 24px 36px;
            border-radius: 12px;
            border: 2px solid #f44;
            color: white;
            font-family: 'Courier New', monospace;
            text-align: center;
            z-index: 1002;
            display: none;
            min-width: 280px;
        ">
            <div style="font-size: 28px; font-weight: bold; color: #f44;">GAME OVER</div>
            <div style="margin-top: 8px; color: #888; font-size: 12px;">Out of misses!</div>
            <div style="margin-top: 20px; display: flex; justify-content: space-around;">
                <div>
                    <div style="color: #888; font-size: 10px;">FINAL SCORE</div>
                    <div id="gameOverScore" style="color: #ffd700; font-size: 32px; font-weight: bold;">0</div>
                </div>
                <div>
                    <div style="color: #888; font-size: 10px;">ROUND</div>
                    <div id="gameOverRound" style="color: #a4a; font-size: 32px; font-weight: bold;">1</div>
                </div>
            </div>
            <div style="margin-top: 16px;">
                <div style="color: #888; font-size: 10px;">BEST STREAK</div>
                <div id="gameOverBestStreak" style="color: #4f4; font-size: 24px; font-weight: bold;">0</div>
            </div>
            <div id="gameOverNewBest" style="margin-top: 12px; color: #ffd700; font-size: 16px; font-weight: bold; display: none;">NEW BEST SCORE!</div>
            <div style="margin-top: 20px; display: flex; gap: 12px; justify-content: center;">
                <button id="btnPlayAgain" style="
                    padding: 12px 24px;
                    font-size: 14px;
                    background: #4f4;
                    color: #000;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                ">PLAY AGAIN</button>
                <button id="btnExitGameOver" style="
                    padding: 12px 24px;
                    font-size: 14px;
                    background: #444;
                    color: #ccc;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                ">EXIT</button>
            </div>
        </div>
        <!-- Settings Button -->
        <button id="btnTargetPracticeSettings" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            font-size: 22px;
            background: rgba(0,0,0,0.7);
            color: #888;
            border: 1px solid #555;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1001;
        ">&#9881;</button>
        <!-- Settings Panel -->
        <div id="targetPracticeSettingsPanel" style="
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: rgba(0,0,0,0.92);
            padding: 16px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 1002;
            font-family: 'Courier New', monospace;
            min-width: 220px;
            max-height: 60vh;
            overflow-y: auto;
        ">
            <div style="color: #fff; font-size: 14px; font-weight: bold; margin-bottom: 12px; border-bottom: 1px solid #444; padding-bottom: 8px;">Target Practice Settings</div>
            <!-- Mode Display -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">MODE</div>
                <div id="tpModeDisplay" style="color: #4fc3f7; font-size: 14px;">MISSES MODE</div>
                <div style="color: #666; font-size: 10px; margin-top: 4px;">4 targets per round</div>
            </div>
            <!-- Target Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">TARGET SPEED</div>
                <div style="display: flex; gap: 4px;">
                    <button class="target-speed-btn" data-speed="slow" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Slow</button>
                    <button class="target-speed-btn" data-speed="normal" style="flex: 1; padding: 6px; background: #4a4; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Normal</button>
                    <button class="target-speed-btn" data-speed="fast" style="flex: 1; padding: 6px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 11px;">Fast</button>
                </div>
            </div>
            <!-- Ball Speed -->
            <div style="margin-bottom: 12px;">
                <div style="color: #888; font-size: 11px; margin-bottom: 4px;">BALL SPEED</div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="btnTPBallSpeedDown" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">-</button>
                    <span id="tpBallSpeedDisplay" style="color: #4f4; font-size: 14px; min-width: 45px; text-align: center;">1.2x</span>
                    <button id="btnTPBallSpeedUp" style="width: 28px; height: 28px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">+</button>
                </div>
            </div>
            <!-- Camera Angle Slider -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">CAMERA ANGLE</span>
                    <span id="tpCameraAngleValue" style="color: #4f4; font-size: 11px;">50%</span>
                </div>
                <input type="range" id="tpCameraAngleSlider" min="0" max="100" value="50" style="width: 100%; cursor: pointer;">
            </div>
            <!-- Camera Offset Slider -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px;">CAMERA OFFSET</span>
                    <span id="tpCameraOffsetValue" style="color: #4f4; font-size: 11px;">35%</span>
                </div>
                <input type="range" id="tpCameraOffsetSlider" min="0" max="100" value="35" style="width: 100%; cursor: pointer;">
            </div>
        </div>
    </div>

    <!-- Game Mode Play Result Popup (outside trainingModeUI so it's visible in games) -->
    <div id="playResultPopup" style="
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.92);
        padding: 20px 28px;
        border-radius: 12px;
        color: white;
        font-family: 'Courier New', monospace;
        text-align: center;
        z-index: 1000;
        display: none;
        min-width: 220px;
        cursor: pointer;
    ">
        <div id="playResultMain" style="font-size: 42px; font-weight: bold;"></div>
        <div id="playResultDetail" style="font-size: 14px; color: #aaa; margin-top: 6px;"></div>
        <div id="playResultCatchInfo" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid #444; display: none;">
            <div id="playResultCatchHeader" style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">CATCH</div>
            <div id="playResultCatchBar" style="position: relative; width: 200px; height: 18px; background: #222; border-radius: 4px; margin: 0 auto 12px auto; overflow: visible;">
                <div id="playResultCatchBase" style="position: absolute; left: 0; top: 0; height: 100%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 4px;"></div>
                <div id="playResultCatchPenalty" style="position: absolute; top: 0; height: 100%; background: rgba(0, 0, 0, 0.55); border-left: 2px solid #f55;"></div>
                <div id="playResultCatchRoll" style="position: absolute; top: -2px; font-size: 16px; font-weight: bold; transform: translateX(-50%); line-height: 18px;">üèà</div>
            </div>
            <div id="playResultModifierList" style="text-align: left; font-size: 13px; margin-top: 10px;"></div>
        </div>
        <div id="playResultDown" style="font-size: 14px; color: #8cf; margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;"></div>
        <div id="playResultFieldPos" style="font-size: 12px; color: #888; margin-top: 4px;"></div>
        <div id="playResultTap" style="margin-top: 14px; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px;">tap to continue</div>
    </div>

    <!-- Management UI Overlay -->
    <div id="managementOverlay">
        <!-- Main Menu -->
        <div id="mainMenuScreen" class="mgmt-screen">
            <h1>SMASHBALL</h1>
            <p class="subtitle">Medieval Football Management</p>
            <button id="btnNewGame" class="mgmt-btn">NEW GAME</button>
            <button id="btnContinue" class="mgmt-btn">CONTINUE</button>
            <button id="btnHowToPlay" class="mgmt-btn" style="margin-top: 30px; background: #2a3a4a; border-color: #4a9fff;">HOW TO PLAY</button>
            <button id="btnTrainingMode" class="mgmt-btn" style="background: #2a4a2a;">TRAINING</button>
        </div>

        <!-- Hub Screen -->
        <div id="hubScreen" class="mgmt-screen hub-screen" style="display:none;">
            <button id="btnHubBack" class="mgmt-btn back-btn">‚Üê</button>
            <button id="btnHubManual" class="mgmt-btn back-btn" style="right: 10px; left: auto;">?</button>
            <button id="btnHubSettings" class="mgmt-btn back-btn" style="right: 50px; left: auto;">‚öô</button>
            <div class="hub-status" id="hubStatus">Fame: 1,000 | Week 1</div>
            <h2>TEAM HUB</h2>
            <div class="hub-buttons">
                <button id="btnPlayGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnRoster" class="mgmt-btn">ROSTER</button>
                <button id="btnFreeAgency" class="mgmt-btn">FREE AGENCY</button>
                <button id="btnSchedule" class="mgmt-btn">SCHEDULE</button>
                <button id="btnFacilities" class="mgmt-btn">FACILITIES</button>
                <button id="btnHubTraining" class="mgmt-btn" style="background: #2a4a2a;">TRAINING</button>
            </div>
            <p id="hubRecord" class="hub-record">Record: 0-0</p>
            <p id="hubNextGame" class="hub-next"></p>
            <button id="btnHubNewGame" class="mgmt-btn danger" style="margin-top: 30px;">NEW GAME</button>
        </div>

        <!-- Training Selection Screen -->
        <div id="trainingSelectionScreen" class="mgmt-screen" style="display:none;">
            <button id="btnTrainingSelectionBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>TRAINING</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 20px;">Select a training mode</p>
            <div style="max-width: 300px; margin: 0 auto;">
                <button id="btnSelectScrimmage" class="mgmt-btn" style="background: #2a4a2a; margin-bottom: 10px; width: 100%;">SCRIMMAGE</button>
                <p style="color: #666; font-size: 11px; margin-bottom: 20px;">Practice with receivers vs defenders</p>

                <div style="border-top: 1px solid #444; padding-top: 15px; margin-top: 5px;">
                    <div style="color: #a4a; font-size: 12px; font-weight: bold; margin-bottom: 10px;">TARGET PRACTICE</div>
                    <button id="btnSelectTPMisses" class="mgmt-btn" style="background: #4a2a4a; margin-bottom: 8px; width: 100%;">MISSES MODE</button>
                    <p style="color: #666; font-size: 11px; margin-bottom: 15px;">Limited misses - survive as long as you can</p>
                    <button id="btnSelectTPTimed" class="mgmt-btn" style="background: #4a2a4a; margin-bottom: 8px; width: 100%;">TIMED MODE</button>
                    <p style="color: #666; font-size: 11px; margin-bottom: 10px;">Race against the clock each round</p>
                </div>
            </div>
        </div>

        <!-- Game Settings Screen -->
        <div id="gameSettingsScreen" class="mgmt-screen" style="display:none;">
            <button id="btnSettingsBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>SETTINGS</h2>

            <div style="max-width: 300px; margin: 20px auto; text-align: left;">
                <!-- Difficulty -->
                <div style="margin-bottom: 20px;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 8px;">GAME DIFFICULTY</div>
                    <div style="color: #666; font-size: 11px; margin-bottom: 10px;">Affects how well receivers track and adjust to the ball</div>
                    <div style="display: flex; gap: 6px;">
                        <button class="game-difficulty-btn mgmt-btn" data-difficulty="easy" style="flex: 1; padding: 10px; font-size: 12px;">EASY</button>
                        <button class="game-difficulty-btn mgmt-btn" data-difficulty="medium" style="flex: 1; padding: 10px; font-size: 12px; background: #4a4;">MEDIUM</button>
                        <button class="game-difficulty-btn mgmt-btn" data-difficulty="hard" style="flex: 1; padding: 10px; font-size: 12px;">HARD</button>
                    </div>
                    <div style="color: #555; font-size: 10px; margin-top: 8px;">
                        <div>Easy: Receivers react quickly and turn sharply</div>
                        <div>Medium: Receivers need accurate throws</div>
                        <div>Hard: Receivers struggle to adjust to the ball</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Roster Screen -->
        <div id="rosterScreen" class="mgmt-screen" style="display:none;">
            <button id="btnRosterBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>ROSTER</h2>
            <div id="rosterList" class="roster-list"></div>
        </div>

        <!-- Free Agency Screen -->
        <div id="freeAgencyScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFABack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FREE AGENCY</h2>
            <p id="faStatus" class="fa-status"></p>
            <div id="freeAgentList" class="roster-list"></div>
        </div>

        <!-- Schedule Screen -->
        <div id="scheduleScreen" class="mgmt-screen" style="display:none;">
            <button id="btnScheduleBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>SCHEDULE</h2>
            <div id="teamStrength" class="team-strength">
                <h3>YOUR TEAM</h3>
                <div class="strength-ratings">
                    <div class="strength-item">
                        <div class="label">OVERALL</div>
                        <div class="value" id="strengthOverall">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">OFFENSE</div>
                        <div class="value" id="strengthOffense">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">DEFENSE</div>
                        <div class="value" id="strengthDefense">--</div>
                    </div>
                </div>
            </div>
            <div id="scheduleList" class="schedule-list"></div>
        </div>

        <!-- Facilities Screen -->
        <div id="facilitiesScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFacilitiesBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2>FACILITIES</h2>
            <p id="facCredits" class="fac-credits"></p>
            <div class="facility-item">
                <h3>ARENA</h3>
                <p id="arenaLevel">Level 1/5</p>
                <p class="fac-desc">Increases home game revenue</p>
                <button id="btnUpgradeArena" class="mgmt-btn">UPGRADE</button>
            </div>
            <div class="facility-item">
                <h3>TRAINING GROUNDS</h3>
                <p id="trainingLevel">Level 1/5</p>
                <p class="fac-desc">Boosts player development</p>
                <button id="btnUpgradeTraining" class="mgmt-btn">UPGRADE</button>
            </div>
        </div>

        <!-- Match End Screen -->
        <div id="matchEndScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <h1 id="matchResult">VICTORY!</h1>
            <p id="matchScore" class="match-score">21 - 14</p>
            <p id="matchRevenue" class="match-revenue"></p>
            <div id="postGameStats" class="post-game-stats"></div>
            <div class="match-end-buttons">
                <button id="btnMatchContinue" class="mgmt-btn primary">CONTINUE</button>
                <button id="btnShowSimLog" class="mgmt-btn secondary" style="display:none;">VIEW LOG</button>
            </div>
            <div id="simLogContainer" style="display:none;margin-top:15px;">
                <pre id="simLogContent" style="background:#1a1a2e;padding:10px;border-radius:4px;max-height:300px;overflow:auto;font-size:11px;white-space:pre-wrap;text-align:left;"></pre>
                <button id="btnCopySimLog" class="mgmt-btn" style="margin-top:8px;">COPY TO CLIPBOARD</button>
            </div>
        </div>

        <!-- Pre-Game Matchup Screen -->
        <div id="preGameScreen" class="mgmt-screen" style="display:none;max-width:500px;">
            <button id="btnPreGameBack" class="mgmt-btn back-btn">‚Üê</button>
            <h2 id="preGameOpponent">VS OPPONENT</h2>
            <div id="preGameTeamScores" class="pre-game-team-scores"></div>
            <div id="preGameQBScores" class="pre-game-qb-scores"></div>
            <div id="preGameMatchups" class="pre-game-matchups"></div>
            <div class="pre-game-buttons">
                <button id="btnStartGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnSimulateGame" class="mgmt-btn secondary">SIMULATE</button>
            </div>
        </div>

        <!-- Player Detail Modal -->
        <div id="playerDetailModal" class="mgmt-modal" style="display:none;">
            <div class="modal-content">
                <button id="btnCloseDetail" class="mgmt-btn back-btn">‚Üê</button>
                <h2 id="playerName">Player Name</h2>
                <div id="playerInfo" class="player-info"></div>
                <div id="playerStats" class="player-stats"></div>
                <div id="playerSeasonStats" class="player-season-stats"></div>
                <div id="playerCareerGraph" class="player-career-graph"></div>
                <div class="modal-actions">
                    <button id="btnTradePlayer" class="mgmt-btn primary">TRADE FOR FAME</button>
                    <button id="btnCutPlayer" class="mgmt-btn danger">CUT PLAYER</button>
                </div>
            </div>
        </div>

        <!-- Draft Screen -->
        <div id="draftScreen" class="mgmt-screen draft-screen" style="display:none;max-width:600px;">
            <!-- Header row with menu -->
            <div class="draft-header">
                <div id="draftLastPick" class="draft-last-pick">
                    <div id="draftLastPickLine1" class="draft-last-pick-line1">Draft starting...</div>
                    <div id="draftLastPickLine2" class="draft-last-pick-line2"></div>
                </div>
                <div class="draft-menu-container">
                    <button id="btnDraftMenu" class="draft-menu-btn">‚ãÆ</button>
                    <div id="draftMenuDropdown" class="draft-menu-dropdown" style="display:none;">
                        <button id="btnDraftOptions" class="draft-menu-item">‚öô Settings</button>
                        <button id="btnDraftBack" class="draft-menu-item">‚Üê Exit Draft</button>
                    </div>
                </div>
            </div>

            <!-- Computer Pick Reasoning -->
            <div id="draftPickReasoning" class="draft-pick-reasoning" style="display:none;"></div>

            <!-- On The Clock Section -->
            <div id="draftOnClock" class="draft-on-clock computer">
                <div class="clock-row">
                    <span id="draftRoundPick">Round 1 ‚Ä¢ Pick 1</span>
                    <span id="draftPoints">1500 pts</span>
                </div>
                <div class="clock-row clock-main">
                    <span id="draftTeamName">Team Name</span>
                    <button id="btnAcquirePick" class="trade-for-btn" style="display:none;">TRADE <span class="trade-cost">0/0</span></button>
                    <button id="btnTradeInPick" class="trade-in-btn" style="display:none;">TRADE PICK <span class="trade-value">+0 pts</span></button>
                </div>
            </div>

            <!-- Toggle Buttons -->
            <div class="draft-toggle-buttons">
                <button id="btnDraftPoolView" class="mgmt-btn toggle-btn active">DRAFT POOL</button>
                <button id="btnDraftRosterView" class="mgmt-btn toggle-btn">MY ROSTER</button>
            </div>

            <!-- Player Lists -->
            <div id="draftPlayerList" class="roster-list draft-list"></div>
            <div id="draftRosterList" class="roster-list draft-list" style="display:none;"></div>

            <!-- Status -->
            <p id="draftStatus" class="draft-status"></p>
            <button id="btnSkipRound" class="mgmt-btn secondary" style="display:none;">SKIP PICK</button>
            <button id="btnFinishDraft" class="mgmt-btn primary" style="display:none;">FINISH DRAFT</button>

            <!-- Fixed Bottom Nav Buttons -->
            <div id="draftNavButtons" class="draft-nav-buttons-fixed">
                <button id="btnNextPick" class="mgmt-btn nav-btn">NEXT PICK</button>
                <button id="btnSkipToYourPick" class="mgmt-btn nav-btn skip-btn">SKIP TO YOUR PICK ‚Üí</button>
            </div>
        </div>

        <!-- Draft Options Modal -->
        <div id="draftOptionsModal" class="modal" style="display:none;">
            <div class="modal-content" style="max-width:400px;">
                <h3 style="color:#ffd700;margin-bottom:20px;">DRAFT OPTIONS</h3>
                <div class="options-row">
                    <label for="pickTradeInPenalty">Trade In Penalty (pts):</label>
                    <input type="number" id="pickTradeInPenalty" min="0" max="500" value="50" style="width:80px;">
                </div>
                <div class="options-row">
                    <label for="pickAcquirePremium">Acquire Premium (%):</label>
                    <input type="number" id="pickAcquirePremium" min="0" max="100" value="10" style="width:80px;">
                </div>
                <div class="options-row" style="margin-top:15px;">
                    <label for="showPickReasoning" style="flex:1;">Show Computer Pick Reasoning:</label>
                    <input type="checkbox" id="showPickReasoning" checked style="width:20px;height:20px;">
                </div>
                <div class="options-info" style="color:#888;font-size:12px;margin:15px 0;">
                    <p>‚Ä¢ Trade In Penalty: Points deducted when trading your pick for draft points</p>
                    <p>‚Ä¢ Acquire Premium: Extra % cost when buying another team's pick</p>
                </div>
                <button id="btnSaveDraftOptions" class="mgmt-btn primary">SAVE</button>
                <button id="btnCloseDraftOptions" class="mgmt-btn secondary">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Game Manual Overlay -->
    <div id="manualOverlay" class="manual-overlay" style="display:none;">
        <div class="manual-container">
            <div class="manual-header">
                <button id="btnManualClose" class="manual-close">‚úï</button>
                <h2 id="manualTitle">How to Play</h2>
                <div class="manual-nav">
                    <button id="btnManualPrev" class="manual-nav-btn">‚Üê Prev</button>
                    <span id="manualPageNum">1 / 12</span>
                    <button id="btnManualNext" class="manual-nav-btn">Next ‚Üí</button>
                </div>
            </div>
            <div class="manual-content" id="manualContent">
                <!-- Content loaded dynamically -->
            </div>
            <div class="manual-index" id="manualIndex" style="display:none;">
                <!-- Index loaded dynamically -->
            </div>
            <div class="manual-footer">
                <button id="btnManualIndex" class="manual-index-btn">üìñ Index</button>
            </div>
        </div>
    </div>

    <style>
        #managementOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #0a0a14;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #managementOverlay.hidden { display: none; }
        .mgmt-screen {
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
            width: 100%;
            max-width: 400px;
        }
        .mgmt-screen h1 {
            color: #ffd700;
            font-size: 48px;
            margin: 0 0 10px 0;
        }
        .mgmt-screen h2 {
            color: #ffd700;
            font-size: 28px;
            margin: 50px 0 20px 0;
        }
        .mgmt-screen .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 40px;
        }
        .mgmt-btn {
            display: block;
            width: 100%;
            max-width: 280px;
            margin: 10px auto;
            padding: 16px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: #2a2a40;
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 8px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .mgmt-btn:active { background: #3a3a50; }
        .mgmt-btn:disabled { opacity: 0.5; }
        .mgmt-btn.primary { background: #3a3a60; }
        .mgmt-btn.secondary { background: #2a4a2a; }
        .pre-game-buttons, .match-end-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .pre-game-buttons .mgmt-btn, .match-end-buttons .mgmt-btn {
            flex: 1;
        }
        .mgmt-btn.back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: rgba(40, 40, 60, 0.8);
        }
        .hub-status {
            position: absolute;
            top: 10px;
            right: 15px;
            text-align: right;
            color: #ffd700;
            font-size: 14px;
        }
        .hub-record { font-size: 20px; margin-top: 30px; }
        .hub-next { color: #aaa; font-size: 14px; }
        .roster-list, .schedule-list {
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .roster-item, .schedule-item {
            background: #1a1a2a;
            padding: 12px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-item .name { font-size: 14px; }
        .roster-item .stats { font-size: 12px; color: #aaa; }
        .roster-item .ovr { color: #4f4; font-size: 16px; }
        .position-header {
            background: #2a2a40;
            color: #ffd700;
            padding: 8px 12px;
            margin-top: 12px;
            font-size: 14px;
        }
        .schedule-item.current { background: #2a3a2a; }
        .schedule-item.past { opacity: 0.6; }
        .schedule-item .result { font-weight: bold; }
        .schedule-item .result.win { color: #4f4; }
        .schedule-item .result.loss { color: #f44; }
        .facility-item {
            background: #1a1a2a;
            padding: 16px;
            margin: 12px 0;
            border-radius: 8px;
            text-align: left;
        }
        .facility-item h3 { color: #ffd700; margin: 0 0 8px 0; font-size: 16px; }
        .fac-desc { color: #888; font-size: 12px; margin: 8px 0; }
        .fac-credits { color: #ffd700; font-size: 18px; }
        .fa-status { color: #aaa; font-size: 14px; }
        .draft-budget { color: #4f4; font-size: 20px; font-weight: bold; margin-bottom: 5px; }
        .draft-status { color: #aaa; font-size: 14px; margin-bottom: 10px; }
        .draft-toggle-buttons { display: flex; gap: 10px; margin-bottom: 15px; justify-content: center; }
        .draft-toggle-buttons .toggle-btn { flex: 1; max-width: 150px; padding: 8px 12px; font-size: 12px; background: #2a2a3a; }
        .draft-toggle-buttons .toggle-btn.active { background: #4a4a6a; border-color: #ffd700; }
        .draft-list { max-height: 280px; overflow-y: auto; overflow-x: hidden; }
        .draft-list .roster-item { border-left: 3px solid #333; transition: border-color 0.2s; flex-wrap: nowrap; }
        .draft-list .roster-item:hover { border-left-color: #ffd700; background: #2a2a3a; }
        .draft-list .roster-item.drafted { opacity: 0.4; pointer-events: none; }
        .draft-list .roster-item.unaffordable { opacity: 0.5; border-left-color: #633; }
        .draft-list .roster-item.unaffordable:hover { border-left-color: #833; }
        .draft-cost { color: #4f4; font-size: 12px; font-weight: bold; }
        .draft-cost.expensive { color: #f84; }
        /* Draft Screen Layout */
        .draft-screen {
            padding-bottom: 70px; /* Space for fixed bottom buttons */
            align-self: flex-start; /* Align to top instead of center to prevent top cutoff */
        }
        .hub-screen {
            align-self: flex-start; /* Align to top instead of center to prevent top cutoff */
            padding-top: 40px; /* Space for the manual button */
        }
        .draft-header {
            display: flex;
            align-items: flex-start;
            background: #1a1a2a;
            margin: 0 -15px 5px -15px;
            padding: 8px 12px;
            border-bottom: 1px solid #333;
        }
        .draft-last-pick {
            flex: 1;
            font-size: 11px;
            color: #888;
            cursor: pointer;
            min-width: 0; /* Allow text truncation */
        }
        .draft-last-pick:hover {
            color: #aaa;
        }
        .draft-last-pick-line1 {
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .draft-last-pick-line2 {
            text-align: left;
            margin-top: 2px;
            font-size: 10px;
        }
        .draft-menu-container {
            position: relative;
            margin-left: 8px;
        }
        .draft-menu-btn {
            background: transparent;
            border: 1px solid #444;
            color: #888;
            font-size: 18px;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            line-height: 1;
        }
        .draft-menu-btn:hover {
            background: #333;
            color: #fff;
        }
        .draft-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: #1a1a2a;
            border: 1px solid #444;
            border-radius: 4px;
            margin-top: 4px;
            z-index: 100;
            min-width: 120px;
        }
        .draft-menu-item {
            display: block;
            width: 100%;
            background: transparent;
            border: none;
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
        }
        .draft-menu-item:hover {
            background: #333;
            color: #fff;
        }
        .draft-menu-item:first-child {
            border-radius: 4px 4px 0 0;
        }
        .draft-menu-item:last-child {
            border-radius: 0 0 4px 4px;
        }
        .draft-last-pick .player-name { color: #fff; font-weight: bold; }
        .draft-last-pick .team-name { color: #ffd700; }
        .draft-last-pick .overall { color: #4f4; }
        .draft-last-pick .predicted { color: #888; }
        .draft-last-pick .predicted.better { color: #f44; }
        .draft-last-pick .predicted.worse { color: #4f4; }
        .draft-last-pick .position { color: #aaa; }

        .draft-pick-reasoning {
            background: #151525;
            padding: 6px 12px;
            margin: 0 -15px 5px -15px;
            font-size: 10px;
            color: #aaa;
            border-bottom: 1px solid #333;
            text-align: left;
        }
        .draft-pick-reasoning .reason-label {
            color: #666;
            font-style: normal;
            margin-right: 5px;
        }
        .draft-pick-reasoning .reason-factor {
            display: inline-block;
            margin-right: 8px;
            color: #888;
        }
        .draft-pick-reasoning .reason-factor.positive { color: #4a4; }
        .draft-pick-reasoning .reason-factor.negative { color: #a44; }
        .draft-pick-reasoning .reason-factor.neutral { color: #888; }

        .draft-on-clock {
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            transition: background 0.3s;
        }
        .draft-on-clock.computer {
            background: #1a1a2a;
            border: 1px solid #444;
        }
        .draft-on-clock.player {
            background: #0a2a0a;
            border: 1px solid #4a4;
        }
        .clock-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .clock-row.clock-main {
            margin-top: 4px;
        }
        #draftRoundPick { color: #888; font-size: 11px; }
        #draftPoints { color: #ffd700; font-size: 11px; font-weight: bold; }
        #draftTeamName {
            font-size: 16px;
            font-weight: bold;
        }
        .draft-on-clock.computer #draftTeamName { color: #aaa; }
        .draft-on-clock.player #draftTeamName { color: #4f4; }
        .trade-for-btn, .trade-in-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            border: 1px solid;
        }
        .trade-for-btn {
            background: #3a2a2a;
            border-color: #a66;
            color: #faa;
        }
        .trade-for-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .trade-for-btn .trade-cost { color: #f88; margin-left: 4px; }
        .trade-in-btn {
            background: #2a3a2a;
            border-color: #6a6;
            color: #afa;
        }
        .trade-in-btn .trade-value { color: #4f4; font-weight: bold; }

        .draft-nav-buttons-fixed {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            gap: 10px;
            padding: 12px;
            background: #0a0a14;
            border-top: 1px solid #333;
            justify-content: center;
            z-index: 100;
        }
        .draft-nav-buttons-fixed .nav-btn {
            flex: 1;
            max-width: 180px;
            padding: 12px;
            font-size: 12px;
            background: #2a2a4a;
        }
        .draft-nav-buttons-fixed .nav-btn.skip-btn {
            background: #3a3a2a;
            border-color: #aa4;
        }
        .options-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            color: #fff;
        }
        .options-row label {
            font-size: 14px;
        }
        .options-row input {
            background: #2a2a40;
            border: 1px solid #444;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .fa-btn { padding: 8px 16px; font-size: 14px; }
        .match-score { font-size: 36px; margin: 20px 0; }
        .match-revenue { color: #4f4; font-size: 18px; margin-bottom: 15px; }
        #matchResult.win { color: #4f4; }
        #matchResult.loss { color: #f44; }

        /* Post-game stats - roster-like layout */
        .post-game-stats {
            max-height: 400px;
            overflow-y: auto;
            margin: 10px 0;
            text-align: left;
        }
        .post-game-player {
            background: #1a1a2a;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .post-game-player:hover {
            background: #252540;
        }
        .post-game-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .post-game-player-info {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .post-game-player-name {
            font-weight: bold;
            color: #fff;
        }
        .post-game-player-fame {
            color: #ffd700;
            font-size: 11px;
        }
        .post-game-player-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .post-game-player-change {
            font-size: 12px;
            min-width: 24px;
            text-align: right;
        }
        .post-game-player-change.positive {
            color: #4f4;
        }
        .post-game-player-ovr {
            font-weight: bold;
            color: #ffd700;
            font-size: 16px;
            min-width: 28px;
            text-align: right;
        }
        .post-game-player-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 11px;
            padding-left: 4px;
            color: #aaa;
        }
        .post-game-stat {
            display: flex;
            align-items: baseline;
            gap: 3px;
        }
        .post-game-stat-value {
            color: #4af;
            font-size: 13px;
            font-weight: bold;
        }
        .post-game-stat-label {
            font-size: 10px;
            color: #888;
        }
        .post-game-no-stats {
            color: #555;
            font-size: 11px;
            font-style: italic;
        }
        .post-game-stat.fame-stat .post-game-stat-value {
            color: #ffd700;
        }
        .post-game-stat.fame-stat .post-game-stat-label {
            color: #ffd700;
        }
        .post-game-player-growth {
            display: flex;
            gap: 4px;
        }
        .post-game-growth {
            color: #4f4;
            font-size: 10px;
            font-weight: bold;
            background: rgba(68, 255, 68, 0.15);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Pre-game matchups */
        .pre-game-matchups {
            margin: 15px 0;
            text-align: left;
        }
        .matchup-section {
            margin: 12px 0;
            padding: 10px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .matchup-section-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .matchup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .matchup-row:last-child { border-bottom: none; }
        .matchup-player {
            flex: 1;
            font-size: 13px;
        }
        .matchup-player.yours { color: #4af; }
        .matchup-player.theirs { color: #f66; text-align: right; }
        .matchup-vs {
            color: #666;
            padding: 0 8px;
            font-size: 11px;
        }
        .matchup-ovr {
            font-weight: bold;
            font-size: 14px;
        }
        .matchup-ovr.advantage { color: #4f4; }
        .matchup-ovr.disadvantage { color: #f44; }
        .matchup-ovr.even { color: #ff0; }

        /* Pre-game team scores */
        .pre-game-team-scores {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .team-score-block {
            text-align: center;
        }
        .team-score-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .team-score-value {
            font-size: 28px;
            font-weight: bold;
        }
        .team-score-value.yours { color: #4af; }
        .team-score-value.theirs { color: #f66; }
        .team-score-vs {
            font-size: 18px;
            color: #666;
            align-self: center;
        }

        /* Pre-game QB scores */
        .pre-game-qb-scores {
            display: flex;
            justify-content: space-around;
            margin: 10px 0 15px 0;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 8px;
        }
        .qb-stat-block {
            text-align: center;
        }
        .qb-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        .qb-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4af;
        }

        /* Player Detail Modal */
        .mgmt-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            overflow-y: auto;
        }
        .modal-content {
            background: #0a0a14;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .modal-content h2 {
            color: #ffd700;
            margin: 40px 0 10px 0;
            text-align: center;
        }
        .player-info {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .player-info .ovr-big {
            font-size: 48px;
            color: #4f4;
            font-weight: bold;
        }
        .player-info .season-change {
            font-size: 18px;
            margin-left: 10px;
        }
        .player-stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .stat-row {
            background: #1a1a2a;
            padding: 10px 12px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        .stat-row .stat-name { color: #aaa; }
        .stat-row .stat-values {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .stat-row .stat-value {
            font-weight: bold;
            min-width: 24px;
            text-align: right;
        }
        .stat-row .stat-change {
            font-size: 12px;
            min-width: 28px;
            text-align: right;
        }
        /* Stat color coding by value */
        .stat-elite { color: #4f4; }      /* 90+ green */
        .stat-good { color: #8f8; }       /* 80-89 light green */
        .stat-average { color: #ff0; }    /* 70-79 yellow */
        .stat-below { color: #f80; }      /* 60-69 orange */
        .stat-poor { color: #f44; }       /* <60 red */
        .stat-change.positive { color: #4f4; }
        .stat-change.negative { color: #f44; }

        /* Unified Stats Panel */
        .stats-panel {
            background: #1a1a2a;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        .stats-section {
            margin-bottom: 8px;
        }
        .stats-section:last-child {
            margin-bottom: 0;
        }
        .stats-section-title {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px 8px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }
        .stat-row-name {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #aaa;
            font-size: 11px;
        }
        .stat-row-value {
            font-weight: bold;
            font-size: 11px;
        }
        .stat-row.best-ability {
            background: #2a3a2a;
            border-radius: 3px;
            padding: 2px 4px;
            margin: -2px -4px;
        }
        /* Core attribute colors */
        .stat-row.str-row .stat-row-name { color: #ff6b6b; }
        .stat-row.spd-row .stat-row-name { color: #4dabf7; }
        .stat-row.agi-row .stat-row-name { color: #69db7c; }
        .stat-row.int-row .stat-row-name { color: #ffd43b; }
        /* Attribute indicator dots */
        .attr-dots {
            display: inline-flex;
            gap: 2px;
            margin-right: 2px;
        }
        .attr-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        .attr-dot.str { background: #ff6b6b; }
        .attr-dot.spd { background: #4dabf7; }
        .attr-dot.agi { background: #69db7c; }
        .attr-dot.int { background: #ffd43b; }

        /* Keep old styles for backwards compatibility but hide */
        .core-attributes-section, .abilities-section, .technique-section { display: none; }

        /* Tooltip System */
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #444;
            color: #aaa;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            flex-shrink: 0;
        }
        .tooltip-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .tooltip-content {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px 12px;
            min-width: 200px;
            max-width: 280px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            font-size: 12px;
            line-height: 1.4;
            color: #ddd;
            text-align: left;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #444;
        }
        .tooltip-wrapper:hover .tooltip-content,
        .tooltip-wrapper:focus .tooltip-content,
        .tooltip-wrapper:active .tooltip-content {
            opacity: 1;
            visibility: visible;
        }
        .tooltip-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 4px;
        }
        .tooltip-desc {
            color: #bbb;
            margin-bottom: 6px;
        }
        .tooltip-formula {
            font-size: 10px;
            color: #888;
            font-style: italic;
        }
        .tooltip-counters {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #333;
            font-size: 10px;
            color: #8f8;
        }

        /* Season stats section */
        .player-season-stats {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .season-stats-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .season-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        .season-stat-item {
            text-align: center;
        }
        .season-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4f4;
        }
        .season-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        /* Career graph section */
        .player-career-graph {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .career-graph-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .career-graph-container {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 4px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .career-bar {
            flex: 1;
            min-width: 20px;
            max-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .career-bar-fill {
            width: 100%;
            background: linear-gradient(to top, #4f4, #8f8);
            border-radius: 2px 2px 0 0;
            position: relative;
        }
        .career-bar-potential {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-size: 8px;
        }
        .career-bar-label {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }
        .career-bar-ovr {
            font-size: 10px;
            color: #fff;
            margin-bottom: 2px;
        }
        .modal-actions {
            margin-top: 20px;
            text-align: center;
        }
        .mgmt-btn.danger {
            background: #4a2020;
            border-color: #f44;
            color: #f44;
        }
        .roster-item { cursor: pointer; }
        .roster-item:active { background: #2a2a3a; }
        .roster-item .season-gain {
            font-size: 12px;
            margin-left: 8px;
        }
        .season-gain.positive { color: #4f4; }
        .season-gain.negative { color: #f44; }

        /* Team Strength Display */
        .team-strength {
            background: #1a1a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .team-strength h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .strength-ratings {
            display: flex;
            justify-content: space-around;
        }
        .strength-item {
            text-align: center;
        }
        .strength-item .label { color: #888; font-size: 11px; }
        .strength-item .value { color: #4f4; font-size: 20px; font-weight: bold; }

        /* Manual Overlay Styles */
        .manual-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        .manual-container {
            background: #12121f;
            border: 2px solid #4a9fff;
            border-radius: 12px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
        }
        .manual-header {
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            position: relative;
        }
        .manual-header h2 {
            color: #4a9fff;
            margin: 0;
            font-size: 20px;
            text-align: center;
        }
        .manual-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
        }
        .manual-close:hover { color: #fff; }
        .manual-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        .manual-nav-btn {
            background: #2a3a4a;
            border: 1px solid #4a9fff;
            color: #4a9fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        .manual-nav-btn:hover { background: #3a4a5a; }
        .manual-nav-btn:disabled { opacity: 0.3; cursor: default; }
        #manualPageNum { color: #888; font-size: 12px; }
        .manual-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            color: #ccc;
            font-size: 14px;
            line-height: 1.6;
        }
        .manual-content h3 {
            color: #ffd700;
            font-size: 18px;
            margin: 0 0 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .manual-content h4 {
            color: #4a9fff;
            font-size: 14px;
            margin: 15px 0 8px 0;
        }
        .manual-content p { margin: 10px 0; }
        .manual-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .manual-content li { margin: 5px 0; }
        .manual-content .highlight {
            background: #2a3a2a;
            border-left: 3px solid #4f4;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 0 6px 6px 0;
        }
        .manual-content .warning {
            background: #3a3a2a;
            border-left: 3px solid #fa4;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 0 6px 6px 0;
        }
        .manual-content .diagram {
            background: #1a1a2a;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .manual-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 12px;
        }
        .manual-content th, .manual-content td {
            padding: 8px;
            border: 1px solid #333;
            text-align: left;
        }
        .manual-content th {
            background: #2a2a40;
            color: #ffd700;
        }
        .manual-content .emoji-icon { font-size: 24px; }
        .manual-content .stat-bar {
            display: inline-block;
            height: 8px;
            background: #4a9fff;
            border-radius: 4px;
            margin-left: 5px;
        }
        .manual-footer {
            padding: 10px 20px;
            border-top: 1px solid #333;
            text-align: center;
        }
        .manual-index-btn {
            background: #2a2a40;
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }
        .manual-index-btn:hover { background: #3a3a50; }
        .manual-index {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .manual-index h3 {
            color: #ffd700;
            margin: 0 0 15px 0;
        }
        .manual-index-section {
            margin-bottom: 15px;
        }
        .manual-index-section h4 {
            color: #4a9fff;
            font-size: 12px;
            margin: 0 0 8px 0;
            text-transform: uppercase;
        }
        .manual-index-item {
            display: block;
            background: #1a1a2a;
            border: none;
            color: #ccc;
            padding: 10px 15px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            text-align: left;
            width: 100%;
        }
        .manual-index-item:hover { background: #2a2a3a; color: #fff; }
        .manual-index-item span { color: #888; font-size: 11px; margin-left: 8px; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        console.log('=== SMASHBALL SCRIPT LOADING ===');
        // Game State
        const gameState = {
            catches: 0,
            attempts: 0,            // Total catch attempts
            touchdowns: 0,          // Touchdowns scored
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            activePointerId: null,  // Track which pointer is dragging
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            offensiveLine: [],      // O-line players
            defensiveLine: [],      // D-line players
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0,  // Seconds between time-based clashes
            playStartTime: 0,  // When current play started (for label fading)
            ballCarrier: null,      // Receiver carrying the ball after catch
            playEnded: false,       // Track if play has ended (tackle/sack/TD)
            waitingForPossession: false, // Pause game during possession overlay
            playFrozen: true,       // Play frozen until player holds screen
            qbSacked: false,        // Track if QB was sacked
            qbStartZ: -6,           // QB's randomized starting position (set each play)
            currentView: 'iso',     // Camera view: 'iso', 'overhead', 'shoulder'
            // Game speed control
            gameSpeedMultiplier: 1.5, // Adjustable game speed (0.5 = slow, 1.0 = normal, 1.5 = fast)
            ballSpeedMultiplier: 1.2, // Adjustable ball speed
            showGradePopup: true,     // Whether to show the grade popup after throws
            showClashFlash: true,     // Whether to show red/green clash result flashes
            receiverSpeedPreset: 80,  // Receiver speed preset (90, 80, 70, or 'mixed')
            dbSpeedPreset: 80,        // DB speed preset (90, 80, 70, or 'mixed')
            receiverAwarenessPreset: 70, // Receiver awareness preset (controls ball reaction delay)
            receiverAgilityPreset: 70,   // Receiver agility preset (controls turn rate/route correction)
            gameDifficulty: 'medium',    // Main game difficulty: 'easy', 'medium', 'hard'
            trainingDifficulty: 'easy',  // Training mode difficulty (separate from main game)
            cameraAngle: 0.5,            // Camera angle: 0 = top-down, 1 = horizontal (default 0.5)
            cameraOffset: 0.35,          // Camera forward offset: 0 = centered on LOS, 1 = max forward (default 0.35)
            playerScale: 1.3,            // Player size multiplier (0.5 to 2.0)
            ballScale: 1.3,              // Ball size multiplier (0.5 to 2.0)
            // Down and distance tracking
            down: 1,                // Current down (1-4)
            yardsToGo: 10,          // Yards needed for first down
            lineOfScrimmage: -29,   // Current field position (Z coordinate) - opponent 40 yard line
            firstDownMarker: -19,   // Z position where first down is achieved (10 yards ahead)
            startingLineOfScrimmage: -29,  // Where drive started - opponent 40 yard line
            // Training mode
            trainingMode: false,    // Training mode: no defenders, throw ratings
            lastThrowRating: null,  // Last throw rating for display
            // Bonus zones (green catch zones)
            bonusZones: [],         // Array of bonus zone objects
            // Target Practice mode
            targetPracticeMode: false,  // Target practice: hit moving targets
            targetPracticeModeType: 'misses', // 'misses' or 'timed'
            targetPracticeScore: 0,     // Current score
            targetPracticeBestScore: 0, // Best score (persisted in localStorage)
            targetPracticeBestScoreTimed: 0, // Best score for timed mode
            targetPracticeStreak: 0,    // Current hit streak
            targetPracticeMultiplier: 1, // Score multiplier (increases with streak)
            targetPracticeTargets: [],  // Array of target meshes
            targetPracticeTargetCount: 4, // Number of targets on field (max 4 visible at a time)
            targetPracticeMaxActiveTargets: 4, // Maximum targets active at once
            targetPracticeSpeedSetting: 'normal', // 'slow', 'normal', 'fast'
            targetPracticeLastHitTime: 0, // For rapid fire bonus
            targetPracticeSpeedBonus: 1.0, // Increases with each hit for progressive difficulty
            // Round tracking
            targetPracticeRound: 1,           // Current round number
            targetPracticeRoundThrows: 0,     // Throws used this round
            targetPracticeRoundStartTime: 0,  // When round started (ms)
            targetPracticeRoundHistory: [],   // Array of {round, throws, time} for completed rounds
            targetPracticeTotalThrows: 0,     // Total throws across all rounds
            targetPracticeMissesRemaining: 5, // Misses before game over
            targetPracticeMaxMisses: 5,       // Starting misses (grows each round)
            targetPracticeBestStreak: 0,      // Best streak in current game
            // Timed mode tracking
            targetPracticeRoundTimeLimit: 30, // Seconds per round in timed mode
            targetPracticeTimeRemaining: 30,  // Time remaining in current round (timed mode)
            // Distance multiplier zone visualization
            distanceZoneMeshes: [],  // Array of meshes for distance zones
            // Debug visualization
            showThrowHeatMap: false,
            heatMapMeshes: []
        };

        // Base speed factors - all player speeds are relative to these
        const SPEED_CONSTANTS = {
            RECEIVER_FACTOR: 0.00064,   // Base: speed stat 80 = 0.0512 units/frame
            DEFENDER_FACTOR: 0.00064,   // Same as receivers for fair matchups
            O_LINE_FACTOR: 0.0004,      // Slower for linemen
            D_LINE_FACTOR: 0.0005       // Slightly faster rush
        };

        // Per-game stats tracking (reset each match)
        const gameStats = {
            players: {},  // Keyed by playerId

            // Initialize or get player stats
            getPlayer(playerId, name) {
                if (!this.players[playerId]) {
                    this.players[playerId] = {
                        name: name || 'Unknown',
                        // Catching
                        catches: 0,
                        drops: 0,
                        catchDifficulties: [],  // Array of difficulty values
                        yardsAfterCatch: 0,
                        receivingYards: 0,      // Total receiving yards
                        // Throwing (QB)
                        completions: 0,
                        incompletions: 0,
                        passingYards: 0,        // Total passing yards
                        throwDistances: [],     // Total distance
                        airDistances: [],       // In-air distance
                        // Clashes
                        clashesWon: 0,
                        clashesLost: 0,
                        clashDifficulties: [],  // Margin of win/loss
                        // Defense
                        sacks: 0,
                        tackles: 0,
                        passesDefended: 0,
                        // Touchdowns
                        touchdowns: 0
                    };
                }
                return this.players[playerId];
            },

            // Reset all stats for new game
            reset() {
                this.players = {};
            }
        };

        // Management mode flag - when false, game input is disabled
        let gameSceneActive = false;

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 1.8,           // Distance for clash detection (reduced for more separation time)
            SEPARATION_THRESHOLD: 3,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 3,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
        };

        // Line clash system constants
        const LINE_CLASH_CONSTANTS = {
            CLASH_RANGE: 1.5,           // Distance for line clash detection
            CLASH_INTERVAL: 0.5,        // Seconds between clash resolutions while engaged
            NEUTRAL_SPEED: 0.05,        // Near-zero speed on neutral clash
            OFFENSE_WIN_THRESHOLD: 5,   // Margin needed for O-line to win decisively
            DEFENSE_WIN_THRESHOLD: 5,   // Margin needed for D-line to win decisively
            KNOCKDOWN_DURATION: 1.0,    // Seconds knocked down
            SPEED_BURST_MULTIPLIER: 1.5,// Speed boost after D-line wins
            SPEED_BURST_DURATION: 1.5,  // Duration of speed burst
            TACKLE_RANGE: 1.2,          // Distance for QB sack
            SNAP_DELAY: 1.5,            // Seconds before D-line starts rushing (QB drop-back time)
        };

        // Receiver tackling constants
        const TACKLE_CONSTANTS = {
            TACKLE_RANGE: 1.0,          // Distance for tackle attempt
            TACKLE_INTERVAL: 0.3,       // Seconds between tackle attempts
            STUMBLE_DURATION: 0.5,      // How long defender stumbles after failed tackle
            BREAK_TACKLE_BOOST: 1.3,    // Speed boost after breaking tackle
            BREAK_TACKLE_DURATION: 0.8, // Duration of break tackle speed boost
        };

        // QB pocket constants
        const POCKET_CONSTANTS = {
            POCKET_CENTER_Z: -7,        // Ideal pocket depth (3 yards behind LOS)
            POCKET_MIN_X: -3,           // Pocket left boundary
            POCKET_MAX_X: 3,            // Pocket right boundary
            POCKET_MAX_DEPTH: -10,      // Don't go deeper than this
            LINE_OF_SCRIMMAGE: -4,      // Can't cross this going forward
            THREAT_RADIUS: 4,           // Start evading when defender this close
            EVADE_SPEED: 0.06,          // Speed when evading
            SETTLE_SPEED: 0.03,         // Speed when settling into pocket
        };

        // Stat weights for clash resolution
        // Note: speed, agility, strength now come from coreAttributes (merged with old stats)
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.35, acceleration: 0.15 },
                defender: { speed: 0.20, agility: 0.20, awareness: 0.25, pursuit: 0.20, tackling: 0.15 }
            },
            lineClash: {
                offense: { passBlock: 0.35, strength: 0.30, balance: 0.20, awareness: 0.15 },
                defense: { passRush: 0.35, strength: 0.30, acceleration: 0.20, speed: 0.15 }
            },
            tackle: {
                tackler: { tackling: 0.70, pursuit: 0.30 },
                ballCarrier: { agility: 0.35, speed: 0.30, evasion: 0.35 }
            }
        };

        // ========================================
        // ABILITY SELECTION SYSTEM
        // ========================================
        // Matchup matrix: DL ability effectiveness vs OL ability (multiplier)
        // > 1.0 = DL has advantage, < 1.0 = OL has advantage
        const ABILITY_MATCHUPS = {
            linemen: {
                bullRush:   { anchor: 0.85, handFighting: 1.00, footwork: 1.15, driveBlock: 0.95 },
                blockShed:  { anchor: 1.10, handFighting: 0.90, footwork: 1.05, driveBlock: 0.95 },
                spinMove:   { anchor: 1.20, handFighting: 1.05, footwork: 0.85, driveBlock: 1.10 },
                swimMove:   { anchor: 1.15, handFighting: 0.85, footwork: 0.95, driveBlock: 1.05 }
            },
            // WR/CB matchups: WR ability effectiveness vs CB ability
            receivers: {
                releaseMove:   { pressCoverage: 0.90, manCoverage: 1.10, zoneCoverage: 1.05, ballHawk: 1.00 },
                routeSharpness: { pressCoverage: 1.05, manCoverage: 0.90, zoneCoverage: 1.15, ballHawk: 1.00 }
            }
        };

        // Select ability based on 60/30/10 rule for highest/second/third
        function selectAbility(player, abilityType) {
            const abilities = calculateAbilities(player);
            if (!abilities) return null;

            // Get abilities sorted by value (highest first)
            const sorted = Object.entries(abilities)
                .sort((a, b) => b[1] - a[1]);

            if (sorted.length === 0) return null;

            // 60% highest, 30% second, 10% third (or lower if not enough abilities)
            const roll = Math.random() * 100;
            let selectedIndex = 0;

            if (roll < 60) {
                selectedIndex = 0;  // Highest (60%)
            } else if (roll < 90 && sorted.length > 1) {
                selectedIndex = 1;  // Second highest (30%)
            } else if (sorted.length > 2) {
                selectedIndex = 2;  // Third highest (10%)
            } else if (sorted.length > 1) {
                selectedIndex = 1;  // Fallback to second if no third
            }

            return { name: sorted[selectedIndex][0], value: sorted[selectedIndex][1] };
        }

        // Check if reacting player should use a counter ability
        // Returns the counter ability if they choose to use it, otherwise null
        function selectCounterAbility(reactingPlayer, initiatingAbility, matchupTable) {
            const abilities = calculateAbilities(reactingPlayer);
            if (!abilities || !matchupTable[initiatingAbility]) return null;

            const intelligence = reactingPlayer.coreAttributes?.intelligence || 50;
            const counterChance = Math.max(0, intelligence - 20) / 100;  // (INT - 20)%

            // Only attempt counter if roll succeeds
            if (Math.random() > counterChance) return null;

            // Find the ability that gives best matchup against initiating ability
            const matchups = matchupTable[initiatingAbility];
            let bestCounter = null;
            let bestAdvantage = 0;

            for (const [abilityName, multiplier] of Object.entries(matchups)) {
                if (abilities[abilityName]) {
                    // Lower multiplier = better for defender (OL) in linemen matchups
                    // For receivers table, we flip the logic
                    const advantage = 1 - multiplier;  // Positive = good for reacting player
                    const effectiveStrength = abilities[abilityName] * (1 + advantage * 0.5);

                    if (!bestCounter || effectiveStrength > bestAdvantage) {
                        bestCounter = { name: abilityName, value: abilities[abilityName] };
                        bestAdvantage = effectiveStrength;
                    }
                }
            }

            return bestCounter;
        }

        // Resolve ability clash between two players
        // Returns { initiator: ability, reactor: ability, matchupMultiplier }
        function resolveAbilityClash(initiator, reactor, matchupTable, isInitiatorAttacker = true) {
            // Initiator selects ability (60/30/10 rule)
            const initiatorAbility = selectAbility(initiator);
            if (!initiatorAbility) {
                return { initiator: null, reactor: null, matchupMultiplier: 1.0 };
            }

            // Reactor tries to counter (INT-20)% chance, otherwise uses 60/30/10
            let reactorAbility = selectCounterAbility(reactor, initiatorAbility.name, matchupTable);
            if (!reactorAbility) {
                reactorAbility = selectAbility(reactor);
            }

            // Get matchup multiplier
            let matchupMultiplier = 1.0;
            if (initiatorAbility && reactorAbility && matchupTable[initiatorAbility.name]) {
                matchupMultiplier = matchupTable[initiatorAbility.name][reactorAbility.name] || 1.0;
            }

            return {
                initiator: initiatorAbility,
                reactor: reactorAbility,
                matchupMultiplier: matchupMultiplier
            };
        }

        // Calculate core√óability multiplicative value for a player
        // Returns value scaled to be used in clash rolls
        // The core stat contribution is based on the ability's ABILITY_CORE_MAPPING
        function getCoreAbilityRoll(player, selectedAbility) {
            if (!player.coreAttributes || !selectedAbility) return 30; // Default fallback

            const mapping = ABILITY_CORE_MAPPING[selectedAbility.name];
            if (!mapping) return 30;

            // Calculate weighted core stat based on ability's core mapping
            let weightedCoreStat = 0;
            for (const [attr, weight] of Object.entries(mapping)) {
                const coreValue = player.coreAttributes[attr] || 50;
                weightedCoreStat += coreValue * weight;
            }

            // Multiplicative: (coreStat/100) √ó (ability/100) scaled to contribute 60% of total
            // If both are 90: (0.9 √ó 0.9) = 0.81 √ó 60 = 48.6
            // If both are 70: (0.7 √ó 0.7) = 0.49 √ó 60 = 29.4
            const coreNorm = weightedCoreStat / 100;
            const abilityNorm = selectedAbility.value / 100;
            const multiplicativeValue = coreNorm * abilityNorm * 60;

            return multiplicativeValue;
        }

        // Calculate technique-only roll (40% of total clash value)
        function getTechniqueRoll(stats, weights, coreAttributes = null) {
            // Filter to only non-core stats (technique stats)
            const coreStats = ['speed', 'agility', 'strength', 'intelligence'];
            let techniqueTotal = 0;
            let techniqueWeightSum = 0;

            for (const stat in weights) {
                if (!coreStats.includes(stat)) {
                    const statValue = stats[stat] || 50;
                    techniqueTotal += statValue * weights[stat];
                    techniqueWeightSum += weights[stat];
                }
            }

            // Normalize if we have technique stats, scale to 40% contribution
            if (techniqueWeightSum > 0) {
                // Normalize to 0-100 range, then scale to 40% of total
                const normalized = techniqueTotal / techniqueWeightSum;
                return normalized * 0.4;
            }

            return 20; // Default if no technique stats
        }

        // ========================================
        // ROUTE TEMPLATES FOR SIMULATION
        // ========================================
        // Each route has per-round depth (yards from LOS) and crossing (direction change)
        // When crossing = true, receiver moves horizontally so depth stays same or gains minimally
        // breakRound is when the route "breaks" - creates separation opportunity
        const ROUTE_TEMPLATES = {
            standard: {
                go: {
                    name: 'go',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 20, crossing: false },
                        { depth: 28, crossing: false },
                        { depth: 35, crossing: false }
                    ],
                    breakRound: null
                },
                slant: {
                    name: 'slant',
                    rounds: [
                        { depth: 3, crossing: false },  // Vertical stem past LOS first
                        { depth: 6, crossing: true },   // Then diagonal cross
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 9, crossing: false }
                    ],
                    breakRound: 2
                },
                out: {
                    name: 'out',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking out - no depth gain
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: 2
                },
                in: {
                    name: 'in',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: true },   // Breaking in - no depth gain
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 2
                },
                post: {
                    name: 'post',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking post - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                corner: {
                    name: 'corner',
                    rounds: [
                        { depth: 8, crossing: false },
                        { depth: 10, crossing: true },  // Breaking corner - slight diagonal
                        { depth: 18, crossing: false },
                        { depth: 25, crossing: false },
                        { depth: 30, crossing: false }
                    ],
                    breakRound: 2
                },
                curl: {
                    name: 'curl',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 10, crossing: true },  // Coming back - loses depth
                        { depth: 10, crossing: false },
                        { depth: 10, crossing: false }
                    ],
                    breakRound: 3
                },
                comeback: {
                    name: 'comeback',
                    rounds: [
                        { depth: 6, crossing: false },
                        { depth: 14, crossing: false },
                        { depth: 12, crossing: true },  // Coming back - loses depth
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 3
                },
                dig: {
                    name: 'dig',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: true },  // Crossing - no depth gain
                        { depth: 14, crossing: false },
                        { depth: 14, crossing: false }
                    ],
                    breakRound: 3
                },
                seam: {
                    name: 'seam',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 10, crossing: false },
                        { depth: 16, crossing: false },
                        { depth: 22, crossing: false },
                        { depth: 28, crossing: false }
                    ],
                    breakRound: null
                },
                flat: {
                    name: 'flat',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Then horizontal cross
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: false }
                    ],
                    breakRound: 2
                },
                wheel: {
                    name: 'wheel',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 3, crossing: true },   // Release horizontally
                        { depth: 8, crossing: false },  // Turn upfield
                        { depth: 16, crossing: false },
                        { depth: 24, crossing: false }
                    ],
                    breakRound: 2
                },
                hitch: {
                    name: 'hitch',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },  // Stop and wait
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 1
                }
            },
            redzone: {
                fade: {
                    name: 'fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 8, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 15, crossing: false },
                        { depth: 15, crossing: false }
                    ],
                    breakRound: null
                },
                back_shoulder: {
                    name: 'back_shoulder',
                    rounds: [
                        { depth: 5, crossing: false },
                        { depth: 9, crossing: false },
                        { depth: 8, crossing: true },   // Fading back - loses depth
                        { depth: 8, crossing: false },
                        { depth: 8, crossing: false }
                    ],
                    breakRound: 3
                },
                corner_fade: {
                    name: 'corner_fade',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 5, crossing: true },   // Breaking corner - minimal gain
                        { depth: 10, crossing: false },
                        { depth: 12, crossing: false },
                        { depth: 12, crossing: false }
                    ],
                    breakRound: 2
                },
                quick_slant: {
                    name: 'quick_slant',
                    rounds: [
                        { depth: 2, crossing: false },  // Short stem past LOS
                        { depth: 4, crossing: true },   // Then diagonal slant
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false },
                        { depth: 6, crossing: false }
                    ],
                    breakRound: 2
                },
                out_quick: {
                    name: 'out_quick',
                    rounds: [
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: true },   // Breaking out - no depth gain
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                }
            },
            goalline: {
                endzone_fade: {
                    name: 'endzone_fade',
                    rounds: [
                        { depth: 2, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false },
                        { depth: 7, crossing: false }
                    ],
                    breakRound: null
                },
                endzone_slant: {
                    name: 'endzone_slant',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step into endzone
                        { depth: 3, crossing: true },   // Then diagonal cross
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false },
                        { depth: 5, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_out: {
                    name: 'endzone_out',
                    rounds: [
                        { depth: 3, crossing: false },
                        { depth: 3, crossing: true },   // Breaking out - no depth gain
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false },
                        { depth: 4, crossing: false }
                    ],
                    breakRound: 2
                },
                endzone_flat: {
                    name: 'endzone_flat',
                    rounds: [
                        { depth: 1, crossing: false },  // Quick step forward
                        { depth: 2, crossing: true },   // Then horizontal cross
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false },
                        { depth: 2, crossing: false }
                    ],
                    breakRound: 2
                }
            }
        };

        // QB personality traits that affect decision making
        const QB_TRAITS = {
            gunslinger: {
                name: 'Gunslinger',
                description: 'Waits for big plays, takes risks',
                openThreshold: 60,       // Needs higher catch % to throw
                pressureMultiplier: 0.7, // Less affected by pressure
                firstDownBias: -10,      // Less likely to take short gains
                aggressiveness: 1.3      // More likely to throw into coverage
            },
            game_manager: {
                name: 'Game Manager',
                description: 'Takes safe throws, avoids mistakes',
                openThreshold: 45,       // Throws to first open receiver
                pressureMultiplier: 1.3, // More affected by pressure
                firstDownBias: 20,       // Heavily favors first down throws
                aggressiveness: 0.7      // Avoids risky throws
            },
            balanced: {
                name: 'Balanced',
                description: 'Adapts to situation',
                openThreshold: 52,
                pressureMultiplier: 1.0,
                firstDownBias: 5,
                aggressiveness: 1.0
            },
            scrambler: {
                name: 'Scrambler',
                description: 'Prefers to run when pressured',
                openThreshold: 55,
                pressureMultiplier: 0.5, // Much less affected by pressure
                firstDownBias: 0,
                aggressiveness: 0.9,
                scrambleBonus: 20        // Extra likelihood to scramble
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false,  // Show defender zone rings and fills
            showDebugInfo: false       // Show on-screen debug info for coverage/catch factors
        };

        // ========================================
        // MANAGEMENT LAYER - DATA MODELS
        // ========================================

        // Management state - persisted between sessions
        const managementState = {
            team: null,
            season: null,
            freeAgents: [],
            settings: {
                difficulty: 'normal',  // easy, normal, hard
                autoSave: true,
                pickTradeInPenalty: 50,    // Penalty points when trading in your pick
                pickAcquirePremium: 10     // Premium percentage when acquiring another team's pick
            },
            initialized: false,
            currentScreen: 'main_menu',  // main_menu, hub, roster, player_detail, free_agency, facilities, schedule, game, draft
            selectedPlayerId: null,
            matchInProgress: false,
            currentPossession: 0,
            matchScore: { player: 0, opponent: 0 },
            seasonJustEnded: false  // Flag to trigger draft after match end screen
        };

        // Position definitions with stat priorities
        // coreStats: from player.coreAttributes (strength, speed, agility, intelligence)
        // techniqueStats: from player.stats (position-specific skills)
        // Overall = weighted average based on simulation importance
        const POSITIONS = {
            WR: {
                name: 'Wide Receiver',
                shortName: 'WR',
                // WR simulation uses: speed for separation, agility for routes, catching for hands
                coreStats: ['speed', 'agility'],           // 40% of overall
                techniqueStats: ['catching', 'routeRunning', 'evasion'],  // 60% of overall
                primaryStats: ['speed', 'agility', 'catching', 'routeRunning', 'evasion'],
                count: 3
            },
            CB: {
                name: 'Cornerback',
                shortName: 'CB',
                // CB simulation uses: speed/agility for coverage, intelligence for reads
                coreStats: ['speed', 'agility', 'intelligence'],  // 50% of overall
                techniqueStats: ['awareness', 'tackling', 'pursuit'],      // 50% of overall
                primaryStats: ['speed', 'agility', 'intelligence', 'awareness', 'tackling', 'pursuit'],
                count: 4
            },
            OL: {
                name: 'Offensive Lineman',
                shortName: 'OL',
                // OL simulation uses: strength for blocking, intelligence for assignments
                coreStats: ['strength', 'intelligence'],   // 40% of overall
                techniqueStats: ['passBlock', 'balance', 'awareness'],     // 60% of overall
                primaryStats: ['strength', 'intelligence', 'passBlock', 'balance', 'awareness'],
                count: 5
            },
            DL: {
                name: 'Defensive Lineman',
                shortName: 'DL',
                // DL simulation uses: strength/speed for rush, agility for moves
                coreStats: ['strength', 'speed', 'agility'],  // 50% of overall
                techniqueStats: ['passRush', 'tackling', 'pursuit'],       // 50% of overall
                primaryStats: ['strength', 'speed', 'agility', 'passRush', 'tackling', 'pursuit'],
                count: 4
            },
            QB: {
                name: 'Quarterback',
                shortName: 'QB',
                // QB simulation uses: intelligence for reads, agility for mobility
                coreStats: ['intelligence', 'agility'],    // 30% of overall
                techniqueStats: ['shortPassAcc', 'longPassAcc', 'awareness'],  // 70% of overall
                primaryStats: ['intelligence', 'agility', 'shortPassAcc', 'longPassAcc', 'awareness'],
                count: 1
            }
        };

        // Tooltip data for all stats and abilities
        const STAT_TOOLTIPS = {
            // Core Attributes
            strength: {
                name: 'Strength',
                desc: 'Raw physical power. Affects blocking, tackling, and breaking through contact.',
                influences: 'passBlock, passRush, tackling, hitPower, balance',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            speed: {
                name: 'Speed',
                desc: 'Top-end running speed and acceleration.',
                influences: 'speed, acceleration, pursuit',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            agility: {
                name: 'Agility',
                desc: 'Quickness, balance, and change of direction ability.',
                influences: 'agility, routeRunning, release, balance',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            intelligence: {
                name: 'Intelligence',
                desc: 'Mental processing, awareness, and decision-making.',
                influences: 'awareness, routeRunning, field vision',
                growth: 'Core attribute - grows very rarely (2-8% per season until age 27)'
            },
            // DL Abilities
            bullRush: {
                name: 'Bull Rush',
                desc: 'Power through blockers with pure strength.',
                formula: 'Strength (60%) + Pass Rush (25%) + Intelligence (15%)',
                counters: 'Countered by: Anchor. Effective vs: Footwork'
            },
            blockShed: {
                name: 'Block Shed',
                desc: 'Quickly disengage from blocks.',
                formula: 'Strength (40%) + Agility (40%) + Pass Rush (20%)',
                counters: 'Countered by: Hand Fighting'
            },
            spinMove: {
                name: 'Spin Move',
                desc: 'Spin around blockers with finesse.',
                formula: 'Agility (55%) + Speed (25%) + Pass Rush (20%)',
                counters: 'Countered by: Footwork. Effective vs: Anchor, Drive Block'
            },
            swimMove: {
                name: 'Swim Move',
                desc: 'Swim over the blocker\'s arms.',
                formula: 'Agility (45%) + Speed (35%) + Pass Rush (20%)',
                counters: 'Countered by: Hand Fighting. Effective vs: Anchor'
            },
            // OL Abilities
            anchor: {
                name: 'Anchor',
                desc: 'Hold your ground against power rushes.',
                formula: 'Strength (55%) + Balance (25%) + Pass Block (20%)',
                counters: 'Counters: Bull Rush. Weak vs: Spin Move, Swim Move'
            },
            handFighting: {
                name: 'Hand Fighting',
                desc: 'Control and redirect pass rushers.',
                formula: 'Strength (40%) + Agility (35%) + Pass Block (25%)',
                counters: 'Counters: Block Shed, Swim Move'
            },
            footwork: {
                name: 'Footwork',
                desc: 'Mirror lateral moves of rushers.',
                formula: 'Agility (45%) + Intelligence (30%) + Pass Block (25%)',
                counters: 'Counters: Spin Move. Weak vs: Bull Rush'
            },
            driveBlock: {
                name: 'Drive Block',
                desc: 'Sustain blocks and create push.',
                formula: 'Strength (40%) + Intelligence (30%) + Pass Block (30%)',
                counters: 'Weak vs: Spin Move'
            },
            // CB Abilities
            pressCoverage: {
                name: 'Press Coverage',
                desc: 'Jam receivers at the line of scrimmage.',
                formula: 'Strength (45%) + Intelligence (35%) + Awareness (20%)',
                counters: 'Countered by: Release Move'
            },
            manCoverage: {
                name: 'Man Coverage',
                desc: 'Stick with receivers in man-to-man.',
                formula: 'Speed (40%) + Agility (40%) + Awareness (20%)',
                counters: 'Used vs: Route Sharpness'
            },
            zoneCoverage: {
                name: 'Zone Coverage',
                desc: 'Read routes and defend zone areas.',
                formula: 'Intelligence (45%) + Agility (35%) + Awareness (20%)',
                counters: 'Used vs: Route Sharpness'
            },
            ballHawk: {
                name: 'Ball Hawk',
                desc: 'Anticipate and intercept passes.',
                formula: 'Intelligence (40%) + Speed (35%) + Awareness (25%)',
                counters: 'Used in contested catch situations'
            },
            // WR Abilities
            releaseMove: {
                name: 'Release Move',
                desc: 'Beat press coverage at the line.',
                formula: 'Agility (45%) + Strength (35%) + Route Running (20%)',
                counters: 'Counters: Press Coverage'
            },
            routeSharpness: {
                name: 'Route Sharpness',
                desc: 'Create separation on routes.',
                formula: 'Agility (40%) + Speed (35%) + Route Running (25%)',
                counters: 'Used vs: Man/Zone Coverage'
            },
            contestedCatch: {
                name: 'Contested Catch',
                desc: 'Catch passes with defenders nearby.',
                formula: 'Strength (30%) + Intelligence (25%) + Catching (25%) + Focus (20%)',
                counters: 'Used vs: Ball Hawk'
            },
            yacAbility: {
                name: 'YAC Ability',
                desc: 'Gain yards after the catch.',
                formula: 'Speed (40%) + Agility (40%) + Balance (20%)',
                counters: 'Used for tackle evasion'
            },
            // QB Abilities
            armStrength: {
                name: 'Arm Strength',
                desc: 'Throw with power downfield.',
                formula: 'Strength (45%) + Throwing (35%) + Intelligence (20%)'
            },
            quickRelease: {
                name: 'Quick Release',
                desc: 'Fast delivery and touch passes.',
                formula: 'Agility (40%) + Throwing (35%) + Intelligence (25%)'
            },
            fieldVision: {
                name: 'Field Vision',
                desc: 'Read defenses and make decisions.',
                formula: 'Intelligence (55%) + Awareness (30%) + Throwing (15%)'
            },
            pocketPresence: {
                name: 'Pocket Presence',
                desc: 'Escape pressure and extend plays.',
                formula: 'Agility (45%) + Speed (35%) + Awareness (20%)'
            },
            // Technique Stats (trained skills)
            catching: {
                name: 'Catching',
                desc: 'Ability to secure the ball and concentrate under pressure.',
                influences: 'Base catch probability (0-100%), contested catch bonus, catch zone radius',
                growth: 'Technique - can improve through training and game reps'
            },
            routeRunning: {
                name: 'Route Running',
                desc: 'Precision in running routes and getting off the line against press coverage.',
                influences: 'Separation clash (35% weight), route sharpness ability, release move ability',
                growth: 'Technique - can improve through training and game reps'
            },
            tackling: {
                name: 'Tackling',
                desc: 'Form, technique, and hitting power in bringing down ball carriers.',
                influences: 'Tackle clash (70% weight), tackle success rate',
                growth: 'Technique - can improve through training and game reps'
            },
            awareness: {
                name: 'Awareness',
                desc: 'Field awareness and reading plays.',
                influences: 'Coverage abilities, line clash (OL), separation defense',
                growth: 'Technique - can improve through training and game reps'
            },
            pursuit: {
                name: 'Pursuit',
                desc: 'Chasing down ball carriers and closing on plays.',
                influences: 'Tackle clash (30% weight), pursuit speed boost',
                growth: 'Technique - can improve through training and game reps'
            },
            passBlock: {
                name: 'Pass Block',
                desc: 'Technique in protecting the quarterback.',
                influences: 'Line clash (35% weight), all OL abilities',
                growth: 'Technique - can improve through training and game reps'
            },
            passRush: {
                name: 'Pass Rush',
                desc: 'Technique in rushing the passer.',
                influences: 'Line clash (35% weight), all DL abilities',
                growth: 'Technique - can improve through training and game reps'
            },
            balance: {
                name: 'Balance',
                desc: 'Staying on feet during contact in the trenches.',
                influences: 'Line clash (OL 20%)',
                growth: 'Technique - can improve through training and game reps'
            },
            shortPassAcc: {
                name: 'Short Pass Acc',
                desc: 'Accuracy on short passes (under 12 yards). Combined with agility for throw accuracy.',
                influences: 'Lead bonus on short routes, catch probability',
                growth: 'Technique - can improve through training and game reps'
            },
            longPassAcc: {
                name: 'Long Pass Acc',
                desc: 'Accuracy on deep passes (12+ yards). Combined with agility for throw accuracy.',
                influences: 'Lead bonus on deep routes, catch probability',
                growth: 'Technique - can improve through training and game reps'
            },
            acceleration: {
                name: 'Acceleration',
                desc: 'Burst speed and explosiveness off the line.',
                influences: 'Separation clash (15%), line clash defense (20%), YAC (25%)',
                growth: 'Technique - can improve through training and game reps'
            },
            evasion: {
                name: 'Evasion',
                desc: 'Ability to avoid tackles and stay on feet during contact.',
                influences: 'Tackle evasion (35% weight), YAC ability',
                growth: 'Technique - can improve through training and game reps'
            }
        };

        // Helper to create tooltip HTML
        function createTooltip(key) {
            const data = STAT_TOOLTIPS[key];
            if (!data) return '';

            let html = `<div class="tooltip-wrapper" tabindex="0">
                <span class="tooltip-icon">i</span>
                <div class="tooltip-content">
                    <div class="tooltip-title">${data.name}</div>
                    <div class="tooltip-desc">${data.desc}</div>`;

            if (data.formula) {
                html += `<div class="tooltip-formula">${data.formula}</div>`;
            }
            if (data.influences) {
                html += `<div class="tooltip-formula">Influences: ${data.influences}</div>`;
            }
            if (data.growth) {
                html += `<div class="tooltip-formula">${data.growth}</div>`;
            }
            if (data.counters) {
                html += `<div class="tooltip-counters">${data.counters}</div>`;
            }

            html += '</div></div>';
            return html;
        }

        // Medieval-themed name pools
        const FIRST_NAMES = [
            'Aldric', 'Baldwin', 'Cedric', 'Duncan', 'Edmund', 'Fabian', 'Gareth', 'Harold',
            'Ivan', 'Jasper', 'Kendrick', 'Leopold', 'Magnus', 'Norbert', 'Oswald', 'Percival',
            'Quincy', 'Roderick', 'Sigmund', 'Thaddeus', 'Ulric', 'Victor', 'Wallace', 'Xavier',
            'Yorick', 'Zephyr', 'Arthur', 'Bernard', 'Conrad', 'Dorian', 'Edgar', 'Felix',
            'Geoffrey', 'Hugo', 'Ignatius', 'Julius', 'Klaus', 'Lionel', 'Marcus', 'Neville'
        ];

        const LAST_NAMES = [
            'Blackwood', 'Ironforge', 'Stoneheart', 'Thornfield', 'Winterbane', 'Ashford',
            'Brighthelm', 'Coldwell', 'Darkwater', 'Everhart', 'Foxworth', 'Grimshaw',
            'Hawthorne', 'Ironcrest', 'Jarvis', 'Kingsley', 'Lockwood', 'Montague',
            'Northwind', 'Oakenshield', 'Proudfoot', 'Queensbury', 'Ravenwood', 'Silverton',
            'Thunderstone', 'Underhill', 'Vanguard', 'Westbrook', 'Yarrow', 'Zephyrus',
            'Battleborn', 'Crossbow', 'Dragonbane', 'Eaglecrest', 'Flameheart', 'Goldmane'
        ];

        // Team name components
        const TEAM_CITIES = [
            'Ironhelm', 'Stormwall', 'Dragonfire', 'Shadowmere', 'Frostpeak', 'Sunspire',
            'Bloodstone', 'Thornwood', 'Goldcrest', 'Ravenmoor', 'Wolfhaven', 'Eaglekeep',
            'Lionhart', 'Bearhold', 'Hawkridge', 'Serpentine'
        ];

        const TEAM_NAMES = [
            'Crusaders', 'Sentinels', 'Legion', 'Knights', 'Warriors', 'Guardians',
            'Paladins', 'Champions', 'Defenders', 'Marauders', 'Vanguard', 'Templars',
            'Berserkers', 'Wardens', 'Lancers', 'Reavers'
        ];

        // Economy constants (salaries in millions)
        const ECONOMY = {
            STARTING_FAME: 1000,
            SALARY_CAP: 60,  // $60M salary cap
            MIN_SALARY: 1,   // $1M minimum salary
            MAX_SALARY: 30,  // $30M for 100 OVR player

            // Revenue
            HOME_GAME_BASE: 50,
            HOME_GAME_STADIUM_BONUS: 30,  // per level
            AWAY_GAME_REVENUE: 25,
            PLAYER_SALE_RATE: 0.5,  // get 50% of salary value

            // Facility costs by level (1->2, 2->3, etc)
            STADIUM_UPGRADE_COSTS: [200, 500, 1000, 2000, 4000],
            TRAINING_UPGRADE_COSTS: [150, 400, 800, 1500, 3000],

            // Other
            BRIBE_COST: 1000,
            BRIBE_CAP_BONUS: 3,  // $3M cap increase per bribe

            // Fame performance points
            FAME_POINTS: {
                CATCH: 5,
                TOUCHDOWN: 50,
                TACKLE: 3,
                SACK: 15,
                INTERCEPTION: 25,
                PASS_DEFENDED: 8,
                YARDS_GAINED: 0.5,
                COMPLETION: 3,
                CLASH_WON: 2
            },

            // Hype multiplier settings
            HYPE: {
                DECLINE_RATE_PER_YEAR: 0.25,  // 25% decline per year after cliff
                FLOOR: 0.1                     // Minimum multiplier
            }
        };

        // Calculate current hype multiplier for a player
        function getCurrentHypeMultiplier(player) {
            if (!player.hypeData) return 1.0;

            const cliffAge = player.peakAge - player.hypeData.yearsBeforePrimeCliff;

            // Before cliff: full multiplier
            if (player.age < cliffAge) {
                return player.hypeData.baseHypeMultiplier;
            }

            // After cliff: decline each year
            const yearsAfterCliff = player.age - cliffAge;
            const declinedMultiplier = player.hypeData.baseHypeMultiplier *
                Math.pow(1 - ECONOMY.HYPE.DECLINE_RATE_PER_YEAR, yearsAfterCliff);

            return Math.max(ECONOMY.HYPE.FLOOR, declinedMultiplier);
        }

        // Calculate fame earned from game stats for a player
        function calculateGameFame(player, pStats) {
            if (!pStats) return 0;

            const fp = ECONOMY.FAME_POINTS;
            let rawPoints = 0;

            // Receiver stats
            rawPoints += (pStats.catches || 0) * fp.CATCH;
            rawPoints += (pStats.touchdowns || 0) * fp.TOUCHDOWN;
            rawPoints += (pStats.yardsAfterCatch || 0) * fp.YARDS_GAINED;

            // QB stats
            rawPoints += (pStats.completions || 0) * fp.COMPLETION;

            // Defense stats
            rawPoints += (pStats.tackles || 0) * fp.TACKLE;
            rawPoints += (pStats.sacks || 0) * fp.SACK;
            rawPoints += (pStats.passesDefended || 0) * fp.PASS_DEFENDED;

            // Clash wins
            rawPoints += (pStats.clashesWon || 0) * fp.CLASH_WON;

            // Apply hype multiplier
            const multiplier = getCurrentHypeMultiplier(player);
            return Math.floor(rawPoints * multiplier);
        }

        // Progression constants
        const PROGRESSION = {
            // Growth is based purely on potential grade
            GROWTH_CHANCE_BASE: 0.20,           // 20% base chance per stat per week
            GROWTH_AMOUNT_MIN: 1,               // Minimum +1 when growth happens
            // Potential decay: chance for potential to drop each year
            POTENTIAL_DECAY_EARLY: 0.15,        // 15% chance years 1-3
            POTENTIAL_DECAY_LATE: 0.50,         // 50% chance after year 3
            POTENTIAL_DROP_TWO_CHANCE: 0.25,    // 25% chance to drop 2 levels instead of 1
            // Decline rates
            DECLINE_RATE: 0.3,                  // per year over peak (base)
            // Physical stats: grow less often, decline in phases
            PHYSICAL_STATS: ['speed', 'acceleration', 'agility', 'strength', 'stamina'],
            PHYSICAL_GROWTH_CHANCE_MULT: 0.50,  // 50% of normal growth chance
            PHYSICAL_DECLINE_EARLY_MULT: 0.5,   // Gentle decline years 1-3 after peak
            PHYSICAL_DECLINE_LATE_MULT: 3.0,    // Steep decline years 4+ after peak
            PHYSICAL_DECLINE_LATE_START: 4,     // When steep decline begins
            // Skill stats: decline very slowly
            SKILL_STATS: ['catching', 'routeRunning', 'blocking', 'runBlock', 'passBlock',
                          'tackling', 'manCoverage', 'zoneCoverage', 'passRush', 'awareness', 'focus'],
            SKILL_DECLINE_MULT: 0.1,            // Only 10% of normal decline
            MIN_STAT: 20,
            MIN_AVERAGE_STAT: 35,  // retire if average drops below
            MAX_AGE: 40
        };

        // Season constants
        const SEASON = {
            WEEKS: 16,
            POSSESSIONS_PER_GAME: 4  // 4 quarters, with possible 2-minute drill and overtime
        };

        // ========================================
        // MANAGEMENT LAYER - UTILITY FUNCTIONS
        // ========================================

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Random from array
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Random int between min and max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Format salary in millions (e.g., 5.5 -> "$5.5M", 10 -> "$10M")
        function formatSalary(amount) {
            if (amount % 1 === 0) {
                return `$${amount}M`;
            }
            return `$${amount.toFixed(1)}M`;
        }

        // Shuffle array (Fisher-Yates)
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // ========================================
        // MANAGEMENT LAYER - SAVE/LOAD SYSTEM
        // ========================================

        const SaveSystem = {
            SAVE_KEY: 'smashball_management_save',

            save() {
                if (!managementState.initialized) return false;

                const saveData = {
                    version: 2,
                    timestamp: Date.now(),
                    team: managementState.team,
                    season: managementState.season,
                    freeAgents: managementState.freeAgents,
                    settings: managementState.settings,
                    // Save draft state if active
                    draftState: draftState.active ? {
                        active: draftState.active,
                        round: draftState.round,
                        pick: draftState.pick,
                        picksRemaining: draftState.picksRemaining,
                        currentPickNumber: draftState.currentPickNumber,
                        isPlayersTurn: draftState.isPlayersTurn,
                        draftPool: draftState.draftPool,
                        draftedPlayers: draftState.draftedPlayers,
                        playerPicks: draftState.playerPicks,
                        isNewGame: draftState.isNewGame,
                        scoutLevels: draftState.scoutLevels
                    } : null
                };

                try {
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('Game saved successfully');
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            },

            load() {
                try {
                    const data = localStorage.getItem(this.SAVE_KEY);
                    if (!data) return null;

                    const saveData = JSON.parse(data);
                    console.log('Game loaded successfully, version:', saveData.version);
                    return saveData;
                } catch (e) {
                    console.error('Failed to load game:', e);
                    return null;
                }
            },

            exists() {
                return localStorage.getItem(this.SAVE_KEY) !== null;
            },

            clear() {
                localStorage.removeItem(this.SAVE_KEY);
                console.log('Save data cleared');
            },

            applySaveData(saveData) {
                if (!saveData) return false;

                managementState.team = saveData.team;
                managementState.season = saveData.season;
                managementState.freeAgents = saveData.freeAgents || [];
                managementState.settings = saveData.settings || managementState.settings;
                managementState.initialized = true;

                // Migrate old saves: credits -> fame
                if (managementState.team && managementState.team.credits !== undefined) {
                    managementState.team.fame = Math.round(managementState.team.credits / 10);
                    delete managementState.team.credits;
                }

                // Restore draft state if saved
                if (saveData.draftState && saveData.draftState.active) {
                    draftState.active = saveData.draftState.active;
                    draftState.round = saveData.draftState.round;
                    draftState.pick = saveData.draftState.pick;
                    draftState.picksRemaining = saveData.draftState.picksRemaining;
                    draftState.currentPickNumber = saveData.draftState.currentPickNumber;
                    draftState.isPlayersTurn = saveData.draftState.isPlayersTurn;
                    draftState.draftPool = saveData.draftState.draftPool;
                    draftState.draftedPlayers = saveData.draftState.draftedPlayers;
                    draftState.playerPicks = saveData.draftState.playerPicks;
                    draftState.isNewGame = saveData.draftState.isNewGame;
                    draftState.scoutLevels = saveData.draftState.scoutLevels || {};
                    draftState.usingExtraPick = false;
                    draftState.simulatingPicks = false;
                    draftState.lastComputerPick = null;
                    draftState.viewingRoster = false;
                    draftState.selectedDraftPlayer = null;
                }

                return true;
            }
        };

        // ========================================
        // MANAGEMENT LAYER - PLAYER GENERATION
        // ========================================

        // Generate base stats for a tier
        function getBaseStatsForTier(tier) {
            // Note: Primary stats get +10 bonus in generatePositionStats
            // So actual overall = base + 10 for primary stats
            // Tier -> approximate overall after +10 bonus:
            // rookie: 55-72 -> ~63 OVR
            // below_average: 60-78 -> ~69 OVR
            // average: 68-85 -> ~76 OVR
            // veteran: 78-92 -> ~85 OVR
            // star: 88-99 -> ~93 OVR
            // elite: 98-99 -> ~99 OVR
            const ranges = {
                rookie: { min: 45, max: 62 },        // ~63 OVR
                below_average: { min: 50, max: 68 }, // ~69 OVR
                average: { min: 58, max: 75 },       // ~76 OVR
                veteran: { min: 68, max: 82 },       // ~85 OVR
                star: { min: 78, max: 90 },          // ~93 OVR
                elite: { min: 88, max: 99 }          // ~99 OVR
            };
            const range = ranges[tier] || ranges.average;
            return { min: range.min, max: range.max };
        }

        // Get base stat range for a target overall rating
        // Accounts for the +10 primary stat bonus
        function getBaseRangeForTargetOverall(targetOverall, variance = 5) {
            // Primary stats get +10 bonus, so base should be lower
            const targetPrimaryBase = targetOverall - 10;

            // Add variance for realistic spread
            const minBase = targetPrimaryBase - variance;
            const maxBase = targetPrimaryBase + variance;

            // Clamp to valid ranges (40-89 base -> 50-99 with bonus)
            return {
                min: Math.max(40, minBase),
                max: Math.min(89, maxBase)
            };
        }

        // Roll age based on tier
        function rollAge(tier) {
            switch(tier) {
                case 'rookie': return randomInt(20, 23);
                case 'below_average': return randomInt(22, 30);
                case 'average': return randomInt(23, 28);
                case 'veteran': return randomInt(27, 33);
                case 'star': return randomInt(24, 30);
                case 'elite': return randomInt(25, 31);
                default: return randomInt(22, 28);
            }
        }

        // Roll potential grade based on age and tier (0-3 scale)
        // Distribution: max (3) 15%, average (2) 35%, low (1) 35%, very low (0) 15%
        function rollPotential(age, tier) {
            // Base weighted distribution
            const roll = Math.random() * 100;
            let potential;
            if (roll < 15) potential = 3;        // 15% max
            else if (roll < 50) potential = 2;   // 35% average
            else if (roll < 85) potential = 1;   // 35% low
            else potential = 0;                   // 15% very low

            // Age modifier: older players lose potential
            if (age > 28) potential = Math.max(0, potential - 1);
            if (age > 32) potential = Math.max(0, potential - 1);

            // Tier bonus for young elite/rookie players
            if ((tier === 'elite' || tier === 'rookie') && age <= 24) {
                potential = Math.min(3, potential + 1);
            }

            return potential;
        }

        // Core attribute ranges by tier
        const CORE_ATTRIBUTE_RANGES = {
            elite: { min: 75, max: 95 },
            star: { min: 70, max: 90 },
            veteran: { min: 65, max: 85 },
            average: { min: 50, max: 75 },
            below_average: { min: 40, max: 65 },
            rookie: { min: 45, max: 80 },
            backup: { min: 35, max: 55 }
        };

        // Generate core attributes for a player
        function generateCoreAttributes(position, tier) {
            const range = CORE_ATTRIBUTE_RANGES[tier] || CORE_ATTRIBUTE_RANGES.average;

            const generateAttr = () => {
                const base = randomInt(range.min, range.max);
                return Math.max(30, Math.min(99, base + randomInt(-3, 3)));
            };

            let strength = generateAttr();
            let speed = generateAttr();
            let agility = generateAttr();
            let intelligence = generateAttr();

            // Position-based tendencies
            switch (position) {
                case 'OL':
                case 'DL':
                    strength = Math.min(99, strength + randomInt(3, 8));
                    speed = Math.max(30, speed - randomInt(3, 8));
                    break;
                case 'WR':
                case 'CB':
                    speed = Math.min(99, speed + randomInt(3, 8));
                    agility = Math.min(99, agility + randomInt(2, 5));
                    break;
                case 'QB':
                    intelligence = Math.min(99, intelligence + randomInt(3, 8));
                    break;
            }

            return { strength, speed, agility, intelligence };
        }

        // Generate stored ability stats for a position (these can grow like technique stats)
        function generateAbilities(position, tier) {
            const range = CORE_ATTRIBUTE_RANGES[tier] || CORE_ATTRIBUTE_RANGES.average;

            const generateAbility = () => {
                const base = randomInt(range.min, range.max);
                return Math.max(30, Math.min(99, base + randomInt(-5, 5)));
            };

            switch (position) {
                case 'DL':
                    return {
                        bullRush: generateAbility(),
                        blockShed: generateAbility(),
                        spinMove: generateAbility(),
                        swimMove: generateAbility()
                    };
                case 'OL':
                    return {
                        anchor: generateAbility(),
                        handFighting: generateAbility(),
                        footwork: generateAbility(),
                        driveBlock: generateAbility()
                    };
                case 'CB':
                    return {
                        pressCoverage: generateAbility(),
                        manCoverage: generateAbility(),
                        zoneCoverage: generateAbility(),
                        ballHawk: generateAbility()
                    };
                case 'WR':
                    return {
                        releaseMove: generateAbility(),
                        routeSharpness: generateAbility(),
                        contestedCatch: generateAbility(),
                        yacAbility: generateAbility()
                    };
                case 'QB':
                    return {
                        armStrength: generateAbility(),
                        quickRelease: generateAbility(),
                        fieldVision: generateAbility(),
                        pocketPresence: generateAbility()
                    };
                default:
                    return {};
            }
        }

        // Calculate effective abilities from stored ability stats and core attributes
        // The stored ability acts as a scaling factor on how well the player uses their core stats
        // Formula: effective = storedAbility * (coreStatsWeighted / 100)
        // This means a 90 ability with 70 core stats = 90 * 0.70 = 63 effective
        // And a 60 ability with 70 core stats = 60 * 0.70 = 42 effective
        function calculateAbilities(player) {
            const core = player.coreAttributes;
            if (!core) return null;

            const clamp = (val) => Math.max(0, Math.min(99, Math.round(val)));

            // Get stored abilities, fall back to 70 if not present (for legacy/AI players)
            const stored = player.abilities || {};

            // Use positionType for mesh objects (linemen), position for roster players
            const pos = player.positionType || player.position;

            // Helper: effective = storedAbility * (weightedCoreAvg / 100)
            const calcEffective = (storedVal, ...coreVals) => {
                const ability = storedVal || 70;
                const coreAvg = coreVals.reduce((a, b) => a + b, 0) / coreVals.length;
                return clamp(ability * (coreAvg / 100));
            };

            switch (pos) {
                case 'DL':
                    // Bull Rush: STR + SPD, Swim Move: STR + INT, Spin Move: AGI + STR
                    return {
                        bullRush: calcEffective(stored.bullRush, core.strength, core.speed),
                        blockShed: calcEffective(stored.blockShed, core.strength, core.agility),
                        spinMove: calcEffective(stored.spinMove, core.agility, core.strength),
                        swimMove: calcEffective(stored.swimMove, core.strength, core.intelligence)
                    };
                case 'OL':
                    return {
                        anchor: calcEffective(stored.anchor, core.strength),
                        handFighting: calcEffective(stored.handFighting, core.strength, core.agility),
                        footwork: calcEffective(stored.footwork, core.agility, core.intelligence),
                        driveBlock: calcEffective(stored.driveBlock, core.strength, core.intelligence)
                    };
                case 'CB':
                    return {
                        pressCoverage: calcEffective(stored.pressCoverage, core.strength, core.intelligence),
                        manCoverage: calcEffective(stored.manCoverage, core.speed, core.agility),
                        zoneCoverage: calcEffective(stored.zoneCoverage, core.intelligence, core.agility),
                        ballHawk: calcEffective(stored.ballHawk, core.intelligence, core.speed)
                    };
                case 'WR':
                    return {
                        releaseMove: calcEffective(stored.releaseMove, core.agility, core.strength),
                        routeSharpness: calcEffective(stored.routeSharpness, core.agility, core.speed),
                        contestedCatch: calcEffective(stored.contestedCatch, core.strength, core.intelligence),
                        yacAbility: calcEffective(stored.yacAbility, core.speed, core.agility)
                    };
                case 'QB':
                    return {
                        armStrength: calcEffective(stored.armStrength, core.strength),
                        quickRelease: calcEffective(stored.quickRelease, core.agility),
                        fieldVision: calcEffective(stored.fieldVision, core.intelligence),
                        pocketPresence: calcEffective(stored.pocketPresence, core.agility, core.intelligence)
                    };
                default:
                    return null;
            }
        }

        // Get best ability for a player
        function getBestAbility(player) {
            const abilities = calculateAbilities(player);
            if (!abilities) return null;

            let best = { name: '', value: 0 };
            for (const [name, value] of Object.entries(abilities)) {
                if (value > best.value) {
                    best = { name, value };
                }
            }
            return best;
        }

        // Core attribute colors for visual display
        const CORE_ATTR_COLORS = {
            strength: '#ff6b6b',     // Red
            speed: '#4dabf7',        // Blue
            agility: '#69db7c',      // Green
            intelligence: '#ffd43b'  // Gold
        };

        // Ability to core attribute mapping (core stats only, normalized to 100%)
        const ABILITY_CORE_MAPPING = {
            // DL abilities - Bull Rush: STR+SPD, Swim Move: STR+INT, Spin Move: AGI+STR
            bullRush:       { strength: 0.50, speed: 0.50 },
            blockShed:      { strength: 0.50, agility: 0.50 },
            spinMove:       { agility: 0.50, strength: 0.50 },
            swimMove:       { strength: 0.50, intelligence: 0.50 },
            // OL abilities
            anchor:         { strength: 1.00 },
            handFighting:   { strength: 0.50, agility: 0.50 },
            footwork:       { agility: 0.50, intelligence: 0.50 },
            driveBlock:     { strength: 0.50, intelligence: 0.50 },
            // CB abilities
            pressCoverage:  { strength: 0.50, intelligence: 0.50 },
            manCoverage:    { speed: 0.50, agility: 0.50 },
            zoneCoverage:   { intelligence: 0.50, agility: 0.50 },
            ballHawk:       { intelligence: 0.50, speed: 0.50 },
            // WR abilities
            releaseMove:    { agility: 0.50, strength: 0.50 },
            routeSharpness: { agility: 0.50, speed: 0.50 },
            contestedCatch: { strength: 0.50, intelligence: 0.50 },
            yacAbility:     { speed: 0.50, agility: 0.50 },
            // QB abilities
            armStrength:    { strength: 1.00 },
            quickRelease:   { agility: 1.00 },
            fieldVision:    { intelligence: 1.00 },
            pocketPresence: { agility: 0.50, intelligence: 0.50 }
        };

        // Generate attribute indicator dots for an ability
        function getAbilityDots(abilityKey) {
            const mapping = ABILITY_CORE_MAPPING[abilityKey];
            if (!mapping) return '';

            // Map attribute names to CSS classes
            const attrToClass = {
                strength: 'str',
                speed: 'spd',
                agility: 'agi',
                intelligence: 'int'
            };

            // Sort by percentage descending and generate dots
            const sortedAttrs = Object.entries(mapping).sort((a, b) => b[1] - a[1]);
            const dots = sortedAttrs.map(([attr]) =>
                `<span class="attr-dot ${attrToClass[attr]}"></span>`
            ).join('');

            return `<span class="attr-dots">${dots}</span>`;
        }

        // Get display name for ability
        function getAbilityDisplayName(abilityKey) {
            return abilityKey.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
        }

        // Generate position-specific stats
        function generatePositionStats(position, baseRange) {
            const stats = {};
            const positionData = POSITIONS[position];

            // Technique stats only - core attributes (speed, agility, strength, intelligence)
            // are stored separately in player.coreAttributes
            const techniqueStats = [
                'acceleration', 'balance', 'evasion',
                'catching', 'shortPassAcc', 'longPassAcc', 'routeRunning', 'jumping',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'pursuit', 'awareness',
                'passBlock', 'passRush'
            ];

            // Generate technique stats
            techniqueStats.forEach(stat => {
                // Primary stats get bonus
                const isPrimary = positionData.primaryStats.includes(stat);
                const bonus = isPrimary ? 10 : 0;

                stats[stat] = Math.min(99, Math.max(1,
                    randomInt(baseRange.min, baseRange.max) + bonus
                ));
            });

            return stats;
        }

        // Calculate overall rating from coreAttributes + technique stats
        // Weighted based on simulation importance per position
        function calculateOverall(player) {
            const positionData = POSITIONS[player.position];
            const core = player.coreAttributes || {};
            const stats = player.stats || {};

            // Get core attribute values
            const coreStats = positionData.coreStats || [];
            const coreTotal = coreStats.reduce((sum, stat) => sum + (core[stat] || 50), 0);
            const coreAvg = coreStats.length > 0 ? coreTotal / coreStats.length : 50;

            // Get technique stat values
            const techniqueStats = positionData.techniqueStats || [];
            const techTotal = techniqueStats.reduce((sum, stat) => sum + (stats[stat] || 50), 0);
            const techAvg = techniqueStats.length > 0 ? techTotal / techniqueStats.length : 50;

            // Weight: technique matters more for most positions
            // QB: 30% core, 70% technique (accuracy is everything)
            // WR: 40% core, 60% technique (need both speed and hands)
            // CB: 50% core, 50% technique (athleticism + instincts)
            // OL: 40% core, 60% technique (technique trumps raw strength)
            // DL: 50% core, 50% technique (need both power and moves)
            const coreWeight = player.position === 'QB' ? 0.3 :
                               player.position === 'CB' ? 0.5 :
                               player.position === 'DL' ? 0.5 : 0.4;

            return Math.round(coreAvg * coreWeight + techAvg * (1 - coreWeight));
        }

        // Calculate salary based on overall rating (exponential scaling in $M)
        // 60 OVR = $1M, 80 OVR = $8M, 100 OVR = $30M
        // Can pass a player object or just stats+position for backwards compatibility
        function calculateSalary(statsOrPlayer, position = 'WR') {
            let overall;

            // Check if we got a player object with overall already calculated
            if (statsOrPlayer && statsOrPlayer.overall !== undefined) {
                overall = statsOrPlayer.overall;
            } else if (statsOrPlayer && statsOrPlayer.coreAttributes) {
                // Player object without overall - calculate it
                overall = calculateOverall(statsOrPlayer);
            } else {
                // Legacy: just stats passed, estimate from technique stats average
                const stats = statsOrPlayer || {};
                const positionData = POSITIONS[position];
                const techniqueStats = positionData.techniqueStats || [];
                const total = techniqueStats.reduce((sum, stat) => sum + (stats[stat] || 50), 0);
                overall = techniqueStats.length > 0 ? Math.round(total / techniqueStats.length) : 50;
            }

            // Exponential scaling: salary = MIN + (MAX - MIN) * ((OVR - 60) / 40)^2
            const minOvr = 60;
            const maxOvr = 100;
            const normalizedOvr = Math.max(0, Math.min(1, (overall - minOvr) / (maxOvr - minOvr)));
            const rawSalary = ECONOMY.MIN_SALARY + (ECONOMY.MAX_SALARY - ECONOMY.MIN_SALARY) * Math.pow(normalizedOvr, 2);

            // Round to nearest 0.5M for cleaner numbers
            return Math.round(rawSalary * 2) / 2;
        }

        // Calculate trade value (fame received for trading a player)
        function calculateTradeValue(player) {
            const overall = player.overall;
            if (overall < 80) return 0;
            if (overall < 90) {
                // 80-89: linear scaling, 0 to 150
                return Math.floor((overall - 80) * 15);
            }
            // 90+: exponential scaling
            // 90 = 150, 92 = 250, 95 = 775, 99 = 2175
            return Math.floor(150 + Math.pow(overall - 90, 2) * 25);
        }

        // Generate a player
        function generatePlayer(position, tier = 'average') {
            const baseRange = getBaseStatsForTier(tier);
            const age = rollAge(tier);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Years in league based on age (rookies start at 0)
            const yearsInLeague = tier === 'rookie' ? 0 : Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, tier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats, position),
                seasonStartStats: { ...stats },
                // Core attributes - foundational traits that rarely change
                coreAttributes: generateCoreAttributes(position, tier),
                seasonStartCoreAttributes: null, // Set after coreAttributes is generated
                // Abilities - stored skill stats that scale core attribute contributions
                abilities: generateAbilities(position, tier),
                seasonStartAbilities: null, // Set after abilities is generated
                // Season stats
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                // Fame/Hype system
                hypeData: {
                    baseHypeMultiplier: Math.max(0.1, 1.0 + (Math.random() - 0.5) * 0.4), // Normal-ish distribution around 1.0
                    yearsBeforePrimeCliff: randomInt(0, 5), // Secret: when decline starts
                    accumulatedFameBank: 0, // Total fame earned over career
                    seasonFameEarnings: 0   // Fame earned this season
                },
                // Career history (array of season snapshots)
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, tier)
                }]
            };

            player.overall = calculateOverall(player);

            // Set seasonStartCoreAttributes now that coreAttributes exists
            player.seasonStartCoreAttributes = { ...player.coreAttributes };
            // Set seasonStartAbilities now that abilities exists
            player.seasonStartAbilities = { ...player.abilities };

            // Assign QB trait based on stats
            if (position === 'QB') {
                // Weight trait selection based on QB's style
                // High awareness + low agility = game_manager
                // High agility + speed = scrambler
                // High pass accuracy = gunslinger
                // Otherwise balanced
                const awareness = stats.awareness || 70;
                const agility = stats.agility || 70;
                const speed = stats.speed || 70;
                const passAcc = ((stats.shortPassAcc || 70) + (stats.longPassAcc || 70)) / 2;

                if (agility > 78 && speed > 75) {
                    player.qbTrait = 'scrambler';
                } else if (awareness > 80 && passAcc < 75) {
                    player.qbTrait = 'game_manager';
                } else if (passAcc > 82) {
                    player.qbTrait = 'gunslinger';
                } else {
                    player.qbTrait = 'balanced';
                }
            }

            return player;
        }

        // Generate a player targeting a specific overall rating
        function generatePlayerWithTargetOverall(position, targetOverall, variance = 5) {
            const baseRange = getBaseRangeForTargetOverall(targetOverall, variance);
            const age = randomInt(22, 32);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Estimate tier based on target for age/potential logic
            let estimatedTier = 'average';
            if (targetOverall >= 93) estimatedTier = 'elite';
            else if (targetOverall >= 85) estimatedTier = 'star';
            else if (targetOverall >= 78) estimatedTier = 'veteran';
            else if (targetOverall >= 72) estimatedTier = 'average';
            else if (targetOverall >= 65) estimatedTier = 'below_average';
            else estimatedTier = 'rookie';

            const yearsInLeague = Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, estimatedTier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats, position),
                seasonStartStats: { ...stats },
                coreAttributes: generateCoreAttributes(position, estimatedTier),
                abilities: generateAbilities(position, estimatedTier),
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                hypeData: {
                    baseHypeMultiplier: Math.max(0.1, 1.0 + (Math.random() - 0.5) * 0.4),
                    yearsBeforePrimeCliff: randomInt(0, 5),
                    accumulatedFameBank: 0,
                    seasonFameEarnings: 0
                },
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, estimatedTier)
                }]
            };

            player.overall = calculateOverall(player);

            // Set seasonStartCoreAttributes and seasonStartAbilities now that they exist
            player.seasonStartCoreAttributes = { ...player.coreAttributes };
            player.seasonStartAbilities = { ...player.abilities };

            // Assign QB trait
            if (position === 'QB') {
                const awareness = stats.awareness || 70;
                const agility = stats.agility || 70;
                const speed = stats.speed || 70;
                const passAcc = ((stats.shortPassAcc || 70) + (stats.longPassAcc || 70)) / 2;

                if (agility > 78 && speed > 75) {
                    player.qbTrait = 'scrambler';
                } else if (awareness > 80 && passAcc < 75) {
                    player.qbTrait = 'game_manager';
                } else if (passAcc > 82) {
                    player.qbTrait = 'gunslinger';
                } else {
                    player.qbTrait = 'balanced';
                }
            }

            return player;
        }

        // Generate initial roster for new game
        function generateInitialRoster() {
            const roster = [];

            // WRs: 1 good, 2 average
            roster.push(generatePlayer('WR', 'veteran'));
            roster.push(generatePlayer('WR', 'average'));
            roster.push(generatePlayer('WR', 'average'));

            // CBs: 1 good, 3 average
            roster.push(generatePlayer('CB', 'veteran'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));

            // OL: 1 good, 4 average
            roster.push(generatePlayer('OL', 'veteran'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));

            // DL: 1 good, 3 average
            roster.push(generatePlayer('DL', 'veteran'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));

            // QB
            roster.push(generatePlayer('QB', 'average'));

            return roster;
        }

        // Auto-assign depth chart based on overall ratings
        function autoAssignDepthChart(team) {
            const roster = team.roster;

            // Group by position and sort by overall
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            Object.keys(byPosition).forEach(pos => {
                byPosition[pos].sort((a, b) => b.overall - a.overall);
            });

            // Assign to depth chart
            const depthChart = {
                WR1: byPosition.WR?.[0]?.id || null,
                WR2: byPosition.WR?.[1]?.id || null,
                WR3: byPosition.WR?.[2]?.id || null,
                CB1: byPosition.CB?.[0]?.id || null,
                CB2: byPosition.CB?.[1]?.id || null,
                CB3: byPosition.CB?.[2]?.id || null,
                CB4: byPosition.CB?.[3]?.id || null,
                OL: (byPosition.OL || []).slice(0, 5).map(p => p.id),
                DL: (byPosition.DL || []).slice(0, 4).map(p => p.id),
                QB: byPosition.QB?.[0]?.id || null
            };

            // Pad OL and DL if needed
            while (depthChart.OL.length < 5) depthChart.OL.push(null);
            while (depthChart.DL.length < 4) depthChart.DL.push(null);

            team.depthChart = depthChart;
        }

        // Create a new team
        function createNewTeam(name = 'Your Team') {
            // New teams get last-place draft budget (best picks available)
            const defaultRank = DRAFT.NUM_TEAMS;
            const team = {
                name,
                fame: ECONOMY.STARTING_FAME,
                salaryCap: ECONOMY.SALARY_CAP,
                salaryCapModifier: 0,
                roster: generateInitialRoster(),
                depthChart: {},
                facilities: {
                    stadium: { level: 1, maxLevel: 5 },
                    trainingCenter: { level: 1, maxLevel: 5 }
                },
                record: { wins: 0, losses: 0 },
                draftPoints: calculateDraftBudget(defaultRank)
            };

            autoAssignDepthChart(team);
            return team;
        }

        // ========================================
        // MANAGEMENT LAYER - OPPONENT GENERATION
        // ========================================

        // Generate a roster targeting a specific team overall rating
        // Creates diverse rosters: key players above average, role players below
        function generateRosterWithTargetOverall(teamOverall) {
            // Position slots with their offset from team average and importance weight
            // Key players (QB, WR1, CB1, edge) get boosted, depth players get reduced
            // This creates realistic roster diversity while hitting the target average
            const positionSlots = [
                // Offense
                { pos: 'QB', offset: +6, weight: 3.0 },   // Franchise QB, most important
                { pos: 'WR', offset: +4, weight: 2.0 },   // WR1 - primary target
                { pos: 'WR', offset: 0, weight: 1.0 },    // WR2 - solid contributor
                { pos: 'WR', offset: -4, weight: 1.0 },   // WR3 - depth
                { pos: 'OL', offset: +2, weight: 1.5 },   // LT - protects blind side
                { pos: 'OL', offset: -2, weight: 1.0 },   // LG
                { pos: 'OL', offset: -2, weight: 1.0 },   // C
                { pos: 'OL', offset: -3, weight: 1.0 },   // RG/RT
                // Defense
                { pos: 'CB', offset: +4, weight: 2.0 },   // CB1 - shutdown corner
                { pos: 'CB', offset: 0, weight: 1.0 },    // CB2
                { pos: 'CB', offset: -3, weight: 1.0 },   // CB3 - nickel
                { pos: 'CB', offset: -5, weight: 1.0 },   // CB4 - safety/zone
                { pos: 'DL', offset: +4, weight: 1.5 },   // Edge rusher
                { pos: 'DL', offset: 0, weight: 1.0 },    // DT
                { pos: 'DL', offset: -2, weight: 1.0 },   // DT
                { pos: 'DL', offset: -4, weight: 1.0 },   // Rotational
            ];

            const roster = [];
            for (const slot of positionSlots) {
                // Calculate target overall for this position
                // Clamp between 60 (minimum viable) and 99 (maximum)
                const targetOvr = Math.max(60, Math.min(99, teamOverall + slot.offset));
                // Use variance of 4 for some natural spread
                const player = generatePlayerWithTargetOverall(slot.pos, targetOvr, 4);
                roster.push(player);
            }

            return roster;
        }

        // Legacy function for backward compatibility - maps difficulty to target overall
        function generateOpponentRoster(difficulty) {
            const targetOveralls = {
                'easy': 72,    // Low 70s team
                'medium': 77,  // High 70s team
                'hard': 83,    // Low 80s team
                'elite': 91    // Elite team
            };
            const target = targetOveralls[difficulty] || 77;
            return generateRosterWithTargetOverall(target);
        }

        // Calculate team ratings from roster (weighted by key positions)
        function calculateTeamRatings(roster) {
            // Weight key positions more heavily
            const getPositionWeight = (player, index, position) => {
                if (position === 'QB') return 3.0;        // QB is most important
                if (position === 'WR' && index === 0) return 2.0;  // WR1
                if (position === 'CB' && index === 0) return 2.0;  // CB1
                if (position === 'DL' && index === 0) return 1.5;  // Pass rusher
                if (position === 'OL' && index === 0) return 1.5;  // LT
                return 1.0;  // Role players
            };

            const offense = roster.filter(p => ['QB', 'WR', 'OL'].includes(p.position));
            const defense = roster.filter(p => ['CB', 'DL'].includes(p.position));

            // Group by position for index-based weighting
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            let offenseWeightedSum = 0, offenseWeightTotal = 0;
            let defenseWeightedSum = 0, defenseWeightTotal = 0;

            Object.entries(byPosition).forEach(([pos, players]) => {
                players.sort((a, b) => b.overall - a.overall); // Best first
                players.forEach((p, i) => {
                    const weight = getPositionWeight(p, i, pos);
                    if (['QB', 'WR', 'OL'].includes(pos)) {
                        offenseWeightedSum += p.overall * weight;
                        offenseWeightTotal += weight;
                    } else {
                        defenseWeightedSum += p.overall * weight;
                        defenseWeightTotal += weight;
                    }
                });
            });

            const offenseRating = offenseWeightTotal > 0
                ? Math.round(offenseWeightedSum / offenseWeightTotal)
                : 60;
            const defenseRating = defenseWeightTotal > 0
                ? Math.round(defenseWeightedSum / defenseWeightTotal)
                : 60;

            return { offenseRating, defenseRating };
        }

        // Pre-defined opponents with varying difficulty
        function generateOpponents() {
            const opponents = [];
            const usedNames = new Set();

            // Team overall targets: 8 teams in 70s (half), rest spread across 80s and 90s
            // Distribution: 4 low-70s, 4 high-70s, 4 low-80s, 2 mid-80s, 2 elite
            const teamOveralls = [
                // Low 70s (4 teams)
                70, 71, 72, 73,
                // High 70s (4 teams)
                75, 76, 78, 79,
                // Low 80s (4 teams)
                81, 82, 83, 84,
                // Mid-high 80s (2 teams)
                86, 88,
                // Elite (2 teams)
                91, 94
            ];

            // Shuffle target overalls for variety
            const shuffledOveralls = shuffleArray([...teamOveralls]);

            // Map overall to difficulty label for display
            const getDifficulty = (ovr) => {
                if (ovr <= 74) return 'easy';
                if (ovr <= 79) return 'medium';
                if (ovr <= 85) return 'hard';
                return 'elite';
            };

            // Generate 16 unique opponents
            let overallIndex = 0;
            while (opponents.length < 16) {
                const city = randomFrom(TEAM_CITIES);
                const teamName = randomFrom(TEAM_NAMES);
                const fullName = `${city} ${teamName}`;

                if (usedNames.has(fullName)) continue;
                usedNames.add(fullName);

                const targetOverall = shuffledOveralls[overallIndex++];
                const difficulty = getDifficulty(targetOverall);

                // Generate roster targeting this overall
                const roster = generateRosterWithTargetOverall(targetOverall);
                const ratings = calculateTeamRatings(roster);

                opponents.push({
                    id: generateUUID(),
                    name: fullName,
                    difficulty,
                    targetOverall,  // Store for debugging/display
                    roster,
                    offenseRating: ratings.offenseRating,
                    defenseRating: ratings.defenseRating,
                    record: { wins: 0, losses: 0 }
                });
            }

            return shuffleArray(opponents);
        }

        // Generate season schedule
        function generateSchedule(opponents) {
            const schedule = [];
            const shuffledOpponents = shuffleArray([...opponents]);

            for (let week = 1; week <= SEASON.WEEKS; week++) {
                const opponent = shuffledOpponents[(week - 1) % shuffledOpponents.length];
                schedule.push({
                    week,
                    opponent,
                    isHome: Math.random() > 0.5,
                    result: null  // { playerScore, opponentScore, win }
                });
            }

            return schedule;
        }

        // Create a new season
        function createNewSeason() {
            const opponents = generateOpponents();
            return {
                week: 1,
                opponents,
                schedule: generateSchedule(opponents)
            };
        }

        // ========================================
        // MANAGEMENT LAYER - ECONOMY SYSTEM
        // ========================================

        // Calculate current team salary
        function calculateTeamSalary(team) {
            return team.roster.reduce((sum, p) => sum + p.salaryCost, 0);
        }

        // Check if can sign player (under cap)
        function canSignPlayer(team, player) {
            const currentSalary = calculateTeamSalary(team);
            const cap = team.salaryCap + team.salaryCapModifier;
            return currentSalary + player.salaryCost <= cap;
        }

        // Sign a free agent
        function signFreeAgent(playerId) {
            const player = managementState.freeAgents.find(p => p.id === playerId);
            if (!player) return { success: false, error: 'Player not found' };

            if (!canSignPlayer(managementState.team, player)) {
                return { success: false, error: 'Over salary cap' };
            }

            managementState.team.roster.push(player);
            managementState.freeAgents = managementState.freeAgents.filter(p => p.id !== playerId);

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true };
        }

        // Cut/release a player
        function cutPlayer(playerId) {
            const playerIndex = managementState.team.roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return { success: false, error: 'Player not found' };

            const player = managementState.team.roster[playerIndex];
            const payout = Math.floor(player.salaryCost * ECONOMY.PLAYER_SALE_RATE);

            managementState.team.fame += payout;
            managementState.team.roster.splice(playerIndex, 1);

            // Remove from depth chart
            const dc = managementState.team.depthChart;
            Object.keys(dc).forEach(slot => {
                if (Array.isArray(dc[slot])) {
                    const idx = dc[slot].indexOf(playerId);
                    if (idx !== -1) dc[slot][idx] = null;
                } else if (dc[slot] === playerId) {
                    dc[slot] = null;
                }
            });

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, payout };
        }

        // Award game revenue
        function awardGameRevenue(isHome) {
            let revenue;
            if (isHome) {
                revenue = ECONOMY.HOME_GAME_BASE +
                    (managementState.team.facilities.stadium.level * ECONOMY.HOME_GAME_STADIUM_BONUS);
            } else {
                revenue = ECONOMY.AWAY_GAME_REVENUE;
            }

            managementState.team.fame += revenue;
            return revenue;
        }

        // Upgrade facility
        function upgradeFacility(facilityType) {
            const facility = managementState.team.facilities[facilityType];
            if (!facility) return { success: false, error: 'Invalid facility' };

            if (facility.level >= facility.maxLevel) {
                return { success: false, error: 'Already at max level' };
            }

            const costs = facilityType === 'stadium'
                ? ECONOMY.STADIUM_UPGRADE_COSTS
                : ECONOMY.TRAINING_UPGRADE_COSTS;
            const cost = costs[facility.level - 1];

            if (managementState.team.fame < cost) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= cost;
            facility.level++;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newLevel: facility.level, cost };
        }

        // Bribe officials for more cap space
        function bribeOfficials() {
            if (managementState.team.fame < ECONOMY.BRIBE_COST) {
                return { success: false, error: 'Insufficient fame' };
            }

            managementState.team.fame -= ECONOMY.BRIBE_COST;
            managementState.team.salaryCapModifier += ECONOMY.BRIBE_CAP_BONUS;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newCap: managementState.team.salaryCap + managementState.team.salaryCapModifier };
        }

        // ========================================
        // MANAGEMENT LAYER - PROGRESSION SYSTEM
        // ========================================

        // Process growth for a player (weekly)
        // Growth is based purely on current potential grade
        function processPlayerGrowth(player) {
            if (player.age >= player.peakAge) {
                return [];
            }
            if (player.potentialGrade <= 0) {
                return []; // No growth potential left
            }

            // Potential grade affects growth chance (0-3 scale)
            const potentialMultiplier = 0.5 + (player.potentialGrade * 0.5); // 0.5x to 2.0x
            const baseGrowthChance = PROGRESSION.GROWTH_CHANCE_BASE * potentialMultiplier;

            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            // Core stats are stored in coreAttributes, technique stats in stats
            const coreStatNames = ['strength', 'speed', 'agility', 'intelligence'];

            const improvements = [];
            primaryStats.forEach(stat => {
                // Determine where this stat is stored
                const isCoreAttribute = coreStatNames.includes(stat);
                const statSource = isCoreAttribute ? player.coreAttributes : player.stats;

                if (!statSource || statSource[stat] === undefined) return;

                // Physical/core stats grow very rarely
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const growthChance = isPhysical
                    ? baseGrowthChance * PROGRESSION.PHYSICAL_GROWTH_CHANCE_MULT
                    : baseGrowthChance;

                if (Math.random() < growthChance) {
                    const oldVal = statSource[stat];
                    // Growth is always at least +1, with potential for more based on potential
                    const bonusGrowth = Math.floor(Math.random() * player.potentialGrade);
                    const growth = PROGRESSION.GROWTH_AMOUNT_MIN + bonusGrowth;
                    statSource[stat] = Math.min(99, statSource[stat] + growth);
                    if (statSource[stat] > oldVal) {
                        improvements.push({ stat, change: statSource[stat] - oldVal });
                    }
                }
            });

            // Process ability growth (abilities are stored in player.abilities)
            if (player.abilities) {
                Object.keys(player.abilities).forEach(abilityName => {
                    // Abilities grow at the same rate as technique stats
                    if (Math.random() < baseGrowthChance) {
                        const oldVal = player.abilities[abilityName];
                        const bonusGrowth = Math.floor(Math.random() * player.potentialGrade);
                        const growth = PROGRESSION.GROWTH_AMOUNT_MIN + bonusGrowth;
                        player.abilities[abilityName] = Math.min(99, player.abilities[abilityName] + growth);
                        if (player.abilities[abilityName] > oldVal) {
                            improvements.push({ stat: abilityName, change: player.abilities[abilityName] - oldVal });
                        }
                    }
                });
            }

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            return improvements;
        }

        // Process decline for a player (weekly)
        function processPlayerDecline(player) {
            if (player.age < player.peakAge) return [];

            const yearsOver = player.age - player.peakAge;
            const baseDeclineRate = yearsOver * PROGRESSION.DECLINE_RATE;

            const declines = [];
            const coreStatNames = ['strength', 'speed', 'agility', 'intelligence'];

            // Helper to process decline for a stat
            const processStatDecline = (stat, statSource) => {
                if (!statSource || statSource[stat] === undefined) return;

                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const isSkill = PROGRESSION.SKILL_STATS.includes(stat);

                let declineRate;
                let minStat = PROGRESSION.MIN_STAT;

                if (isPhysical) {
                    // Physical stats: gentle decline years 1-3, steep decline years 4+
                    const isLateDecline = yearsOver >= PROGRESSION.PHYSICAL_DECLINE_LATE_START;
                    const physicalMult = isLateDecline
                        ? PROGRESSION.PHYSICAL_DECLINE_LATE_MULT
                        : PROGRESSION.PHYSICAL_DECLINE_EARLY_MULT;
                    declineRate = baseDeclineRate * physicalMult;
                } else if (isSkill) {
                    // Skill stats barely decline (10% of normal)
                    declineRate = baseDeclineRate * PROGRESSION.SKILL_DECLINE_MULT;
                    minStat = PROGRESSION.MIN_STAT + 15; // Skills floor higher
                } else {
                    // Other stats decline normally
                    declineRate = baseDeclineRate;
                }

                // Apply decline with some randomness
                if (Math.random() < 0.5 + (yearsOver * 0.1)) { // More likely to decline as years pass
                    const oldVal = statSource[stat];
                    const actualDecline = declineRate * (0.5 + Math.random()); // 50-150% of rate
                    statSource[stat] = Math.max(minStat, statSource[stat] - actualDecline);
                    if (statSource[stat] < oldVal) {
                        declines.push({ stat, change: statSource[stat] - oldVal });
                    }
                }
            };

            // Process core attributes (strength, speed, agility, intelligence)
            if (player.coreAttributes) {
                coreStatNames.forEach(stat => processStatDecline(stat, player.coreAttributes));
            }

            // Process technique stats
            Object.keys(player.stats).forEach(stat => {
                if (!coreStatNames.includes(stat)) {
                    processStatDecline(stat, player.stats);
                }
            });

            // Process ability decline (abilities decline like skill stats - very slowly)
            if (player.abilities) {
                Object.keys(player.abilities).forEach(abilityName => {
                    const declineRate = baseDeclineRate * PROGRESSION.SKILL_DECLINE_MULT;
                    const minStat = PROGRESSION.MIN_STAT + 15;

                    if (Math.random() < 0.5 + (yearsOver * 0.1)) {
                        const oldVal = player.abilities[abilityName];
                        const actualDecline = declineRate * (0.5 + Math.random());
                        player.abilities[abilityName] = Math.max(minStat, player.abilities[abilityName] - actualDecline);
                        if (player.abilities[abilityName] < oldVal) {
                            declines.push({ stat: abilityName, change: player.abilities[abilityName] - oldVal });
                        }
                    }
                });
            }

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats, player.position);
            player.overall = calculateOverall(player);

            return declines;
        }

        // Check if player should retire
        function checkRetirement(player) {
            if (player.age > PROGRESSION.MAX_AGE) return true;

            const statValues = Object.values(player.stats);
            const avgStat = statValues.reduce((a, b) => a + b, 0) / statValues.length;

            return avgStat < PROGRESSION.MIN_AVERAGE_STAT;
        }

        // Process weekly progression for all players
        function processWeeklyProgression() {
            console.log(`[PROGRESSION] Processing weekly progression for ${managementState.team.roster.length} players`);
            const results = {
                improvements: [],
                declines: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                // Growth or decline
                const improvements = processPlayerGrowth(player);
                const declines = processPlayerDecline(player);

                if (improvements.length > 0) {
                    results.improvements.push({ player, improvements });
                }
                if (declines.length > 0) {
                    results.declines.push({ player, declines });
                }

                // Check retirement
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Also process opponent team progressions
            processOpponentProgression();

            return results;
        }

        // Process weekly progression for all opponent teams
        function processOpponentProgression() {
            if (!managementState.season || !managementState.season.opponents) return;

            managementState.season.opponents.forEach(opponent => {
                if (!opponent.roster) return;

                const toRemove = [];
                opponent.roster.forEach(player => {
                    // Apply growth/decline (simplified - no retirement tracking for opponents)
                    processPlayerGrowth(player);
                    processPlayerDecline(player);

                    // Simple retirement check - replace with new player
                    if (checkRetirement(player)) {
                        toRemove.push(player);
                    }
                });

                // Replace retired opponents with new players
                toRemove.forEach(oldPlayer => {
                    const idx = opponent.roster.indexOf(oldPlayer);
                    if (idx !== -1) {
                        const tierMap = {
                            'easy': 'average',
                            'medium': 'average',
                            'hard': 'veteran',
                            'elite': 'star'
                        };
                        opponent.roster[idx] = generatePlayer(oldPlayer.position, tierMap[opponent.difficulty] || 'average');
                    }
                });

                // Recalculate team ratings
                const ratings = calculateTeamRatings(opponent.roster);
                opponent.offenseRating = ratings.offenseRating;
                opponent.defenseRating = ratings.defenseRating;
            });
        }

        // Process end of season (age all players)
        function processEndOfSeason() {
            const results = {
                ageUps: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                player.age++;
                player.yearsInLeague = (player.yearsInLeague || 0) + 1;
                results.ageUps.push(player);

                // Potential decay: chance for potential to drop each year
                // Much higher chance after year 3
                if (player.potentialGrade > 0 && player.age < player.peakAge) {
                    const decayChance = player.yearsInLeague <= 3
                        ? PROGRESSION.POTENTIAL_DECAY_EARLY
                        : PROGRESSION.POTENTIAL_DECAY_LATE;

                    if (Math.random() < decayChance) {
                        // Chance to drop 2 levels instead of 1
                        const dropAmount = Math.random() < PROGRESSION.POTENTIAL_DROP_TWO_CHANCE ? 2 : 1;
                        player.potentialGrade = Math.max(0, player.potentialGrade - dropAmount);
                    }
                }

                // Record career history before resetting
                if (!player.careerHistory) player.careerHistory = [];
                player.careerHistory.push({
                    season: player.careerHistory.length,
                    overall: player.overall,
                    potential: player.potentialGrade,
                    gamesPlayed: player.gamesPlayed || 0,
                    tds: player.seasonTDs || 0,
                    catches: player.seasonCatches || 0,
                    targets: player.seasonTargets || 0,
                    tackles: player.seasonTackles || 0,
                    clashesWon: player.seasonClashesWon || 0,
                    clashesLost: player.seasonClashesLost || 0,
                    sacks: player.seasonSacks || 0,
                    passesDefended: player.seasonPassesDefended || 0
                });

                // Reset season stats
                player.seasonStartStats = { ...player.stats };
                player.seasonStartCoreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                player.seasonStartAbilities = player.abilities ? { ...player.abilities } : null;
                player.gamesPlayed = 0;
                player.seasonTDs = 0;
                player.seasonCatches = 0;
                player.seasonTargets = 0;
                player.seasonTackles = 0;
                player.seasonClashesWon = 0;
                player.seasonClashesLost = 0;
                player.seasonSacks = 0;
                player.seasonPassesDefended = 0;

                // Check retirement after aging
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Create new season
            managementState.season = createNewSeason();

            // Refresh free agents
            refreshFreeAgents();

            if (managementState.settings.autoSave) SaveSystem.save();

            return results;
        }

        // ========================================
        // MANAGEMENT LAYER - FREE AGENCY
        // ========================================

        // Roll tier for free agent (weighted towards average)
        function rollFreeAgentTier() {
            const roll = Math.random();
            if (roll < 0.1) return 'elite';      // 10%
            if (roll < 0.25) return 'veteran';   // 15%
            if (roll < 0.75) return 'average';   // 50%
            return 'rookie';                      // 25%
        }

        // Refresh free agent pool
        function refreshFreeAgents() {
            managementState.freeAgents = [];

            const count = randomInt(5, 8);
            const positions = ['WR', 'CB', 'OL', 'DL'];

            for (let i = 0; i < count; i++) {
                const position = randomFrom(positions);
                const tier = rollFreeAgentTier();
                managementState.freeAgents.push(generatePlayer(position, tier));
            }
        }

        // ========================================
        // MANAGEMENT LAYER - DRAFT SYSTEM
        // ========================================

        // Draft constants
        const DRAFT = {
            ROUNDS: 5,
            PLAYERS_PER_ROUND: 10,  // Players available each round (50 total)
            NUM_TEAMS: 12,          // Teams in the league for draft order calculation
            MIN_COST: 10,           // Minimum draft cost
            NEW_GAME_BUDGET: 1500,  // Starting draft points for new games
            // Exact costs for first 7 picks as specified
            EARLY_COSTS: [1000, 800, 700, 600, 520, 450, 390],
            ROUND_2_START: 13,      // First pick of round 2 (in 12-team league)
            ROUND_3_START: 25,      // First pick of round 3
            ROUND_DROP: 0.70,       // 30% drop at round boundaries
            // Pick trading defaults
            DEFAULT_TRADE_IN_PENALTY: 50,    // Penalty points when trading in your pick (like a round 5 pick cost)
            DEFAULT_ACQUIRE_PREMIUM: 0.10,   // 10% premium when acquiring another team's pick
            // Rookie contract salaries
            ROOKIE_SALARY: {
                PICK_1: 15,          // $15M/year for #1 pick
                PICK_2: 12,          // $12M/year for #2 pick
                MIN: 1               // $1M/year minimum for late round picks
            }
        };

        // Calculate rookie contract salary based on draft pick position
        // Pick 1: $15M, Pick 2: $12M, decreasing to ~$1M by round 3+
        function calculateRookieSalary(pickNumber) {
            if (pickNumber === 1) return DRAFT.ROOKIE_SALARY.PICK_1;
            if (pickNumber === 2) return DRAFT.ROOKIE_SALARY.PICK_2;

            const totalPicks = DRAFT.NUM_TEAMS * DRAFT.ROUNDS; // 60 picks
            const maxSalary = DRAFT.ROOKIE_SALARY.PICK_2;
            const minSalary = DRAFT.ROOKIE_SALARY.MIN;

            // Exponential decay from pick 2's value down to minimum
            const normalizedPick = (pickNumber - 1) / (totalPicks - 1);
            const decayFactor = Math.exp(-4 * normalizedPick);
            const salary = minSalary + (maxSalary - minSalary) * decayFactor;

            return Math.round(salary * 10) / 10; // Round to 1 decimal
        }

        // Calculate cost of a draft pick based on position in pool
        // Picks 1-7: Exact values from EARLY_COSTS
        // Picks 8-12: Continue with decreasing drops
        // Pick 13, 25: Sharp 30% drop at round boundaries
        function calculatePickCost(pickPosition) {
            // Picks 1-7: Use exact specified values
            if (pickPosition <= DRAFT.EARLY_COSTS.length) {
                return DRAFT.EARLY_COSTS[pickPosition - 1];
            }

            // Picks 8-12: Continue with decreasing drops from pick 7's value
            // Drops: ~45, 38, 32, 27, 23 (shrinking by ~15% each)
            if (pickPosition <= 12) {
                let cost = DRAFT.EARLY_COSTS[6]; // Start from 390
                let drop = 45;
                for (let i = 8; i <= pickPosition; i++) {
                    cost -= drop;
                    drop = Math.floor(drop * 0.85);
                }
                return Math.max(DRAFT.MIN_COST, cost);
            }

            // Get pick 12's cost as baseline
            let pick12Cost = DRAFT.EARLY_COSTS[6];
            let drop = 45;
            for (let i = 8; i <= 12; i++) {
                pick12Cost -= drop;
                drop = Math.floor(drop * 0.85);
            }
            // pick12Cost is ~254

            // Pick 13: Sharp drop at round 2 start
            if (pickPosition === DRAFT.ROUND_2_START) {
                return Math.max(DRAFT.MIN_COST, Math.floor(pick12Cost * DRAFT.ROUND_DROP));
            }

            // Picks 14-24: Gradual 94% decay
            if (pickPosition < DRAFT.ROUND_3_START) {
                let cost = Math.floor(pick12Cost * DRAFT.ROUND_DROP); // Start from pick 13 value
                for (let i = 14; i <= pickPosition; i++) {
                    cost = Math.floor(cost * 0.94);
                }
                return Math.max(DRAFT.MIN_COST, cost);
            }

            // Calculate pick 24's value
            let pick24Cost = Math.floor(pick12Cost * DRAFT.ROUND_DROP);
            for (let i = 14; i <= 24; i++) {
                pick24Cost = Math.floor(pick24Cost * 0.94);
            }

            // Pick 25: Sharp drop at round 3 start
            if (pickPosition === DRAFT.ROUND_3_START) {
                return Math.max(DRAFT.MIN_COST, Math.floor(pick24Cost * DRAFT.ROUND_DROP));
            }

            // Picks 26+: Gentler 96% decay
            let cost = Math.floor(pick24Cost * DRAFT.ROUND_DROP);
            for (let i = 26; i <= pickPosition; i++) {
                cost = Math.floor(cost * 0.96);
            }

            return Math.max(DRAFT.MIN_COST, cost);
        }

        // Calculate draft budget based on team's season finish ranking
        // Worse teams get more points (higher picks in each round)
        function calculateDraftBudget(teamRank, totalTeams = DRAFT.NUM_TEAMS) {
            // teamRank: 1 = best record, totalTeams = worst record
            // Worst team picks at position 1, 13, 25, 37, 49 (every 12 picks in 5 rounds)
            // Best team picks at position 12, 24, 36, 48, 60

            let budget = 0;
            const pickPosition = totalTeams - teamRank + 1;  // Convert rank to pick order (worst=1st pick)

            for (let round = 0; round < DRAFT.ROUNDS; round++) {
                const overallPick = round * totalTeams + pickPosition;
                budget += calculatePickCost(overallPick);
            }

            return budget;
        }

        // Get team's rank based on record (1 = best, NUM_TEAMS = worst)
        function getTeamSeasonRank() {
            if (!managementState.team || !managementState.season) {
                // Default to middle ranking for new games
                return Math.ceil(DRAFT.NUM_TEAMS / 2);
            }

            const teamWins = managementState.team.record.wins;
            const teamLosses = managementState.team.record.losses;

            // Compare against other teams in schedule
            const schedule = managementState.season.schedule || [];
            let betterTeams = 0;

            const opponents = new Set();
            schedule.forEach(game => {
                if (game.opponent && !opponents.has(game.opponent.id)) {
                    opponents.add(game.opponent.id);
                    const oppWins = game.opponent.record?.wins || 0;
                    const oppLosses = game.opponent.record?.losses || 0;

                    // Higher wins = better rank (lower number)
                    if (oppWins > teamWins || (oppWins === teamWins && oppLosses < teamLosses)) {
                        betterTeams++;
                    }
                }
            });

            // Rank is 1 + number of teams with better records
            return Math.min(betterTeams + 1, DRAFT.NUM_TEAMS);
        }

        // Draft state
        const draftState = {
            active: false,
            round: 1,
            pick: 1,
            picksRemaining: 0,  // How many picks the player has left
            currentPickNumber: 1,  // Overall pick number in the draft (1-60)
            isPlayersTurn: false,  // True when it's the player's turn to pick
            usingExtraPick: false,  // True when player is using a purchased extra pick
            simulatingPicks: false,  // True when computer picks are being animated
            lastComputerPick: null,  // Last computer pick for display { team, player }
            draftPool: [],
            draftedPlayers: [],  // IDs of all drafted players (by any team)
            playerPicks: [],     // IDs of players drafted by the user
            computerTeamRosters: {},  // Track what each computer team has drafted: { teamIndex: [players] }
            computerTeamStrategies: {},  // Each team's draft strategy: { teamIndex: 'contender'|'balanced'|'rebuilder' }
            isNewGame: false,
            viewingRoster: false,
            selectedDraftPlayer: null,
            scoutLevels: {}  // Track scouting level per player: { playerId: 0-3 }
        };

        // Scouting constants
        const SCOUTING = {
            MAX_LEVEL: 3,           // Maximum times a player can be scouted
            MIN_COST: 5,            // Minimum scouting cost
            MAX_COST: 50,           // Maximum scouting cost
            RANGE_UNSCOUTED: 22,    // Rating range for unscouted players (¬±22, was ¬±50)
            RANGE_PER_LEVEL: 5,     // Range reduction per scout level (22 -> 17 -> 12 -> 7)
            MAX_OFFSET: 10          // Maximum offset from center at level 0
        };

        // Generate combine stats for a draft player based on their core attributes
        // Stats are correlated but not perfectly deterministic - significant variance
        function generateCombineStats(player) {
            const core = player.coreAttributes || {};
            const str = core.strength || 50;
            const spd = core.speed || 50;
            const agi = core.agility || 50;
            const intel = core.intelligence || 50;

            // Use player ID for consistent random variance (¬±15-25% variance for imperfect correlation)
            let hash = 0;
            for (let i = 0; i < player.id.length; i++) {
                hash = ((hash << 5) - hash) + player.id.charCodeAt(i);
                hash = hash & hash;
            }
            const variance = (stat, range = 0.20) => {
                hash = ((hash << 5) - hash) + stat;
                return ((Math.abs(hash) % 1000) - 500) / 500 * range; // ¬±range variance
            };

            // Calculate raw values - calibrated for actual stat range (55 min to 100 max)
            // 40-yard: 100 attr ‚Üí 4.35s (elite), 55 attr ‚Üí 4.95s (poor)
            const fortyRaw = (5.55 - (spd * 0.0098) - (agi * 0.0022)) * (1 + variance(1, 0.03));

            // Bench: 100 attr ‚Üí 34 reps, 55 attr ‚Üí 18 reps
            const benchRaw = (-2 + (str * 0.36)) * (1 + variance(2, 0.18));

            // Vertical: 100 attr ‚Üí 41", 55 attr ‚Üí 32"
            const vertRaw = (21 + (spd * 0.13) + (agi * 0.07)) * (1 + variance(3, 0.06));

            // Broad jump: 100 attr ‚Üí 130" (10'10"), 55 attr ‚Üí 112" (9'4")
            const broadRaw = (90 + (str * 0.23) + (spd * 0.17)) * (1 + variance(4, 0.05));

            // 3-cone: 100 attr ‚Üí 6.70s, 55 attr ‚Üí 7.30s
            const threeRaw = (8.03 - (agi * 0.011) - (spd * 0.0023)) * (1 + variance(5, 0.03));

            // Shuttle: 100 attr ‚Üí 3.95s, 55 attr ‚Üí 4.40s
            const shuttleRaw = (4.90 - (agi * 0.0067) - (spd * 0.0033)) * (1 + variance(6, 0.03));

            // Wonderlic: 100 attr ‚Üí 42, 55 attr ‚Üí 22
            const wonderRaw = (-2.5 + (intel * 0.445)) * (1 + variance(7, 0.12));

            // Clamp to realistic ranges (slightly beyond the 55-100 range for variance)
            const forty = Math.max(4.30, Math.min(5.05, fortyRaw));
            const bench = Math.max(15, Math.min(45, Math.round(benchRaw)));
            const vert = Math.max(30, Math.min(44, vertRaw));
            const broad = Math.max(108, Math.min(136, Math.round(broadRaw)));
            const three = Math.max(6.65, Math.min(7.40, threeRaw));
            const shuttle = Math.max(3.90, Math.min(4.50, shuttleRaw));
            const wonder = Math.max(18, Math.min(46, Math.round(wonderRaw)));

            // Elite benchmarks - aligned with clamp limits for full range
            const ELITE = {
                forty: 4.30,    // matches clamp min
                bench: 45,      // matches clamp max
                vert: 44,       // matches clamp max
                broad: 136,     // matches clamp max
                three: 6.65,    // matches clamp min
                shuttle: 3.90,  // matches clamp min
                wonder: 46      // matches clamp max
            };

            // Poor benchmarks - aligned with clamp limits so worst possible = ~5%, not 0%
            // This accounts for variance pushing 55-attr players below baseline
            const WORST = {
                forty: 5.05,    // matches clamp max
                bench: 15,      // matches clamp min
                vert: 30,       // matches clamp min
                broad: 108,     // matches clamp min
                three: 7.40,    // matches clamp max
                shuttle: 4.50,  // matches clamp max
                wonder: 18      // matches clamp min
            };

            // Calculate percentiles (100 = elite level, 0 = worst)
            const calcPercentile = (val, elite, worst, lowerBetter = false) => {
                if (lowerBetter) {
                    return Math.max(0, Math.min(99, Math.round(100 * (worst - val) / (worst - elite))));
                }
                return Math.max(0, Math.min(99, Math.round(100 * (val - worst) / (elite - worst))));
            };

            return {
                fortyYard: forty.toFixed(2),
                fortyPct: calcPercentile(forty, ELITE.forty, WORST.forty, true),

                benchPress: bench,
                benchPct: calcPercentile(bench, ELITE.bench, WORST.bench),

                verticalJump: vert.toFixed(1),
                vertPct: calcPercentile(vert, ELITE.vert, WORST.vert),

                broadJump: broad,
                broadFeetInches: `${Math.floor(broad / 12)}'${broad % 12}"`,
                broadPct: calcPercentile(broad, ELITE.broad, WORST.broad),

                threeCone: three.toFixed(2),
                threePct: calcPercentile(three, ELITE.three, WORST.three, true),

                shuttle: shuttle.toFixed(2),
                shuttlePct: calcPercentile(shuttle, ELITE.shuttle, WORST.shuttle, true),

                wonderlic: wonder,
                wonderPct: calcPercentile(wonder, ELITE.wonder, WORST.wonder),

                // Film study/football IQ grade
                filmGrade: getLetterGrade((intel * 0.65 + agi * 0.18 + spd * 0.17) * (1 + variance(8, 0.15))),

                // Position drills grade (technique + learning ability)
                drillGrade: getLetterGrade((intel * 0.35 + agi * 0.35 + spd * 0.30) * (1 + variance(9, 0.15)))
            };
        }

        // Generate college stats for a draft player based on position and skills
        // Stats are single numbers with percentiles, correlated but not deterministic
        function generateCollegeStats(player) {
            const stats = player.stats || {};
            const core = player.coreAttributes || {};
            const pos = player.position;

            // Use player ID for consistent random variance
            let hash = 0;
            for (let i = 0; i < player.id.length; i++) {
                hash = ((hash << 5) - hash) + player.id.charCodeAt(i);
                hash = hash & hash;
            }
            const variance = (stat, range = 0.15) => {
                hash = ((hash << 5) - hash) + stat;
                return ((Math.abs(hash) % 100) - 50) / 50 * range;
            };

            const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

            // Calculate percentile: higher is better
            const calcPct = (val, worst, elite) => Math.round(Math.max(0, Math.min(100, ((val - worst) / (elite - worst)) * 100)));
            // Calculate percentile: lower is better (inverted)
            const calcPctInv = (val, worst, elite) => Math.round(Math.max(0, Math.min(100, ((worst - val) / (worst - elite)) * 100)));

            switch (pos) {
                case 'QB':
                    const accuracy = stats.accuracy || 55;
                    const armStr = stats.armStrength || 55;
                    const decision = stats.decisionMaking || core.intelligence || 55;
                    const pocket = stats.pocketPresence || 55;

                    // Elite (100 attr) and Worst benchmarks (aligned with clamps)
                    const QB_ELITE = { compPct: 72, tdInt: 4.0, ypa: 10.5, sackPct: 2.0 };
                    const QB_WORST = { compPct: 52, tdInt: 0.8, ypa: 5.5, sackPct: 12.0 };

                    const compPct = clamp((50 + accuracy * 0.25 + decision * 0.08) * (1 + variance(10, 0.08)), 52, 74);
                    const tdInt = clamp((0.8 + decision * 0.025 + accuracy * 0.012) * (1 + variance(11, 0.2)), 0.8, 4.5);
                    const ypa = clamp((5.5 + armStr * 0.03 + accuracy * 0.02 + decision * 0.015) * (1 + variance(12, 0.12)), 5.5, 11.0);
                    const sackPct = clamp((12 - pocket * 0.08 - decision * 0.03) * (1 + variance(13, 0.15)), 2.0, 12.0);

                    return {
                        completionPct: compPct.toFixed(1),
                        compPctPct: calcPct(compPct, QB_WORST.compPct, QB_ELITE.compPct),
                        tdIntRatio: tdInt.toFixed(1),
                        tdIntPct: calcPct(tdInt, QB_WORST.tdInt, QB_ELITE.tdInt),
                        yardsPerAttempt: ypa.toFixed(1),
                        ypaPct: calcPct(ypa, QB_WORST.ypa, QB_ELITE.ypa),
                        sackPct: sackPct.toFixed(1),
                        sackPctPct: calcPctInv(sackPct, QB_WORST.sackPct, QB_ELITE.sackPct)
                    };

                case 'WR':
                    const hands = stats.catching || stats.hands || 55;
                    const routes = stats.routeRunning || 55;
                    const spd = core.speed || 55;
                    const jump = stats.jumping || 55;

                    // Elite and Worst benchmarks for WR (aligned with clamps)
                    const WR_ELITE = { ypc: 20, catchRate: 78, contested: 70, yac: 8.5, dropRate: 1.5 };
                    const WR_WORST = { ypc: 9, catchRate: 50, contested: 35, yac: 2.5, dropRate: 12 };

                    const ypc = clamp((10 + spd * 0.06 + routes * 0.04) * (1 + variance(20, 0.12)), 9, 20);
                    const catchRate = clamp((45 + hands * 0.25 + routes * 0.12) * (1 + variance(21, 0.1)), 50, 78);
                    const contested = clamp((30 + hands * 0.2 + jump * 0.15 + (core.strength || 55) * 0.1) * (1 + variance(22, 0.15)), 35, 70);
                    const yac = clamp((2.5 + spd * 0.04 + (core.agility || 55) * 0.03) * (1 + variance(23, 0.15)), 2.5, 8.5);
                    const dropRate = clamp((15 - hands * 0.12 - (core.intelligence || 55) * 0.03) * (1 + variance(24, 0.2)), 1.5, 12);

                    return {
                        yardsPerCatch: ypc.toFixed(1),
                        ypcPct: calcPct(ypc, WR_WORST.ypc, WR_ELITE.ypc),
                        catchRate: catchRate.toFixed(1),
                        catchRatePct: calcPct(catchRate, WR_WORST.catchRate, WR_ELITE.catchRate),
                        contestedCatchPct: contested.toFixed(1),
                        contestedPct: calcPct(contested, WR_WORST.contested, WR_ELITE.contested),
                        yardsAfterCatch: yac.toFixed(1),
                        yacPct: calcPct(yac, WR_WORST.yac, WR_ELITE.yac),
                        dropRate: dropRate.toFixed(1),
                        dropRatePct: calcPctInv(dropRate, WR_WORST.dropRate, WR_ELITE.dropRate)
                    };

                case 'CB':
                    const coverage = stats.coverage || stats.manCoverage || 55;
                    const ballSkills = stats.ballSkills || 55;
                    const tackling = stats.tackling || 55;
                    const cbSpd = core.speed || 55;

                    // Elite and Worst benchmarks for CB (aligned with clamps)
                    const CB_ELITE = { ints: 10, pbu: 22, prAllow: 55, compAllow: 42, tackles: 85 };
                    const CB_WORST = { ints: 0, pbu: 3, prAllow: 120, compAllow: 68, tackles: 20 };

                    const ints = clamp(Math.round((ballSkills * 0.06 + coverage * 0.03 + cbSpd * 0.02) * (1 + variance(30, 0.3))), 0, 10);
                    const pbu = clamp(Math.round((coverage * 0.12 + cbSpd * 0.06 + (core.agility || 55) * 0.04) * (1 + variance(31, 0.25))), 3, 22);
                    const prAllow = clamp((130 - coverage * 0.5 - cbSpd * 0.2 - (core.intelligence || 55) * 0.15) * (1 + variance(32, 0.12)), 55, 120);
                    const compAllow = clamp((75 - coverage * 0.22 - cbSpd * 0.08) * (1 + variance(33, 0.1)), 42, 68);
                    const cbTackles = clamp(Math.round((25 + tackling * 0.35 + cbSpd * 0.15) * (1 + variance(34, 0.2))), 20, 85);

                    return {
                        interceptions: ints,
                        intsPct: calcPct(ints, CB_WORST.ints, CB_ELITE.ints),
                        passBreakups: pbu,
                        pbuPct: calcPct(pbu, CB_WORST.pbu, CB_ELITE.pbu),
                        passerRatingAllowed: prAllow.toFixed(1),
                        prAllowPct: calcPctInv(prAllow, CB_WORST.prAllow, CB_ELITE.prAllow),
                        completionPctAllowed: compAllow.toFixed(1),
                        compAllowPct: calcPctInv(compAllow, CB_WORST.compAllow, CB_ELITE.compAllow),
                        tackles: cbTackles,
                        tacklesPct: calcPct(cbTackles, CB_WORST.tackles, CB_ELITE.tackles)
                    };

                case 'OL':
                    const passBlock = stats.passBlocking || 55;
                    const runBlock = stats.runBlocking || 55;
                    const olStr = core.strength || 55;
                    const olAgi = core.agility || 55;
                    const olInt = core.intelligence || 55;

                    // Elite and Worst benchmarks for OL (aligned with clamps)
                    const OL_ELITE = { sacksAllow: 0, pressAllow: 4, pancakes: 60, penalties: 1 };
                    const OL_WORST = { sacksAllow: 10, pressAllow: 35, pancakes: 8, penalties: 14 };

                    const sacksAllow = clamp(Math.round((8 - passBlock * 0.07 - olInt * 0.02) * (1 + variance(40, 0.3))), 0, 10);
                    const pressAllow = clamp(Math.round((30 - passBlock * 0.2 - olStr * 0.08) * (1 + variance(41, 0.25))), 4, 35);
                    const pancakes = clamp(Math.round((runBlock * 0.4 + olStr * 0.25) * (1 + variance(42, 0.25))), 8, 60);
                    const olPenalties = clamp(Math.round((10 - olInt * 0.06 - olAgi * 0.03) * (1 + variance(43, 0.3))), 1, 14);
                    const runGradeVal = (runBlock * 0.6 + olStr * 0.25 + olInt * 0.15) * (1 + variance(44, 0.1));

                    return {
                        sacksAllowed: sacksAllow,
                        sacksAllowPct: calcPctInv(sacksAllow, OL_WORST.sacksAllow, OL_ELITE.sacksAllow),
                        pressuresAllowed: pressAllow,
                        pressAllowPct: calcPctInv(pressAllow, OL_WORST.pressAllow, OL_ELITE.pressAllow),
                        pancakeBlocks: pancakes,
                        pancakesPct: calcPct(pancakes, OL_WORST.pancakes, OL_ELITE.pancakes),
                        penalties: olPenalties,
                        penaltiesPct: calcPctInv(olPenalties, OL_WORST.penalties, OL_ELITE.penalties),
                        runBlockGrade: getLetterGrade(runGradeVal),
                        runGradeVal: Math.round(runGradeVal) // For percentile display
                    };

                case 'DL':
                    const passRush = stats.passRush || 55;
                    const runDef = stats.runDefense || 55;
                    const dlStr = core.strength || 55;
                    const dlSpd = core.speed || 55;
                    const dlBallSkills = stats.ballSkills || 40;

                    // Elite and Worst benchmarks for DL (aligned with clamps)
                    const DL_ELITE = { sacks: 18, tfl: 25, hurries: 50, runStops: 55, ff: 6 };
                    const DL_WORST = { sacks: 1, tfl: 3, hurries: 8, runStops: 12, ff: 0 };

                    const dlSacks = clamp((passRush * 0.1 + dlSpd * 0.04 + dlStr * 0.02) * (1 + variance(50, 0.3)), 1, 18);
                    const tfl = clamp(Math.round((runDef * 0.12 + dlSpd * 0.08 + dlStr * 0.06) * (1 + variance(51, 0.25))), 3, 25);
                    const hurries = clamp(Math.round((passRush * 0.3 + dlSpd * 0.15 + (core.agility || 55) * 0.08) * (1 + variance(52, 0.25))), 8, 50);
                    const runStops = clamp(Math.round((runDef * 0.35 + dlStr * 0.2 + (core.intelligence || 55) * 0.1) * (1 + variance(53, 0.2))), 12, 55);
                    const ff = clamp(Math.round((dlBallSkills * 0.03 + dlStr * 0.025 + dlSpd * 0.015) * (1 + variance(54, 0.4))), 0, 6);

                    return {
                        sacks: dlSacks.toFixed(1),
                        sacksPct: calcPct(dlSacks, DL_WORST.sacks, DL_ELITE.sacks),
                        tacklesForLoss: tfl,
                        tflPct: calcPct(tfl, DL_WORST.tfl, DL_ELITE.tfl),
                        qbHurries: hurries,
                        hurriesPct: calcPct(hurries, DL_WORST.hurries, DL_ELITE.hurries),
                        runStops: runStops,
                        runStopsPct: calcPct(runStops, DL_WORST.runStops, DL_ELITE.runStops),
                        forcedFumbles: ff,
                        ffPct: calcPct(ff, DL_WORST.ff, DL_ELITE.ff)
                    };

                default:
                    return {};
            }
        }

        // Helper to convert numeric grade to letter
        function getLetterGrade(value) {
            if (value >= 90) return 'A+';
            if (value >= 85) return 'A';
            if (value >= 80) return 'A-';
            if (value >= 77) return 'B+';
            if (value >= 73) return 'B';
            if (value >= 70) return 'B-';
            if (value >= 67) return 'C+';
            if (value >= 63) return 'C';
            if (value >= 60) return 'C-';
            if (value >= 55) return 'D+';
            if (value >= 50) return 'D';
            return 'D-';
        }

        // Format combine/college stat with scouting uncertainty
        // Shows a range that narrows with higher scout levels
        function formatCombineStat(value, scoutLevel, suffix = '', lowerIsBetter = false) {
            const numVal = parseFloat(value);
            if (isNaN(numVal)) return value + suffix; // Return as-is if not a number (e.g., letter grade)

            // Variance decreases with scout level: 8% -> 6% -> 5% -> 4%
            const variancePct = [0.08, 0.06, 0.05, 0.04][scoutLevel] || 0.08;
            const variance = numVal * variancePct;

            // For integer stats, round appropriately
            const isInteger = Number.isInteger(numVal);
            const low = isInteger ? Math.round(numVal - variance) : (numVal - variance).toFixed(1);
            const high = isInteger ? Math.round(numVal + variance) : (numVal + variance).toFixed(1);

            // Color coding based on whether lower or higher is better
            let color = '#aaa'; // Default neutral
            if (scoutLevel >= 2) {
                // Only show color hints with decent scouting
                if (lowerIsBetter) {
                    if (numVal <= 4) color = '#4CAF50';      // Good (low)
                    else if (numVal >= 8) color = '#f44336'; // Bad (high)
                } else {
                    // Higher is better - use relative thresholds based on typical ranges
                    color = '#aaa'; // Keep neutral for now, could enhance later
                }
            }

            if (scoutLevel >= 3) {
                // Fully scouted: show tight range
                return `<span style="color:${color}">${low}-${high}${suffix}</span>`;
            }

            return `<span style="color:${color}">${low}-${high}${suffix}</span>`;
        }

        // Calculate scouting cost based on current pick value
        // Scales from 5-50 based on pick value (early picks cost more to scout)
        function calculateScoutingCost(pickNumber) {
            const pickValue = calculatePickCost(pickNumber);
            // Pick 1 (1000 value) should cost ~50, late picks (~10 value) should cost ~5
            const maxPickValue = DRAFT.EARLY_COSTS[0]; // 1000
            const normalizedValue = pickValue / maxPickValue;
            const cost = SCOUTING.MIN_COST + (SCOUTING.MAX_COST - SCOUTING.MIN_COST) * normalizedValue;
            return Math.round(cost);
        }

        // Get the scout level for a player (0-3)
        function getPlayerScoutLevel(playerId) {
            return draftState.scoutLevels[playerId] || 0;
        }

        // Calculate rating range based on scout level
        // Level 0: ¬±50, Level 1: ¬±36, Level 2: ¬±22, Level 3: ¬±8
        function getRatingRange(scoutLevel) {
            return SCOUTING.RANGE_UNSCOUTED - (scoutLevel * SCOUTING.RANGE_PER_LEVEL);
        }

        // Calculate deterministic offset for a stat (so ranges aren't centered on actual value)
        // Returns offset that decreases as scout level increases
        function getStatOffset(playerId, statName, scoutLevel) {
            // Create hash from player ID and stat name
            let hash = 0;
            const seed = playerId + (statName || '');
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                hash = hash & hash;
            }

            // Convert to offset between -MAX_OFFSET and +MAX_OFFSET
            const normalizedHash = (Math.abs(hash) % 1000) / 1000; // 0-1
            const maxOffset = SCOUTING.MAX_OFFSET * (1 - scoutLevel / SCOUTING.MAX_LEVEL);
            const offset = (normalizedHash * 2 - 1) * maxOffset; // -maxOffset to +maxOffset

            return Math.round(offset);
        }

        // Get display value for a rating with uncertainty
        // Returns { display: string, min: number, max: number }
        function getScoutedRating(actualValue, scoutLevel) {
            const range = getRatingRange(scoutLevel);
            if (range <= 3) {
                // Level 3: show exact value
                return { display: String(actualValue), min: actualValue, max: actualValue, isExact: true };
            }
            const min = Math.max(1, actualValue - range);
            const max = Math.min(99, actualValue + range);
            return { display: `${min}-${max}`, min, max, isExact: false };
        }

        // Create visual range indicator HTML for a rating
        // Shows a bar with the possible range highlighted - never shows exact numbers
        // playerId and statName are used to create consistent but varied offsets
        // Visual scale uses 55-99 since players can't have stats below ~55
        function createRangeIndicator(actualValue, scoutLevel, playerId, statName, width = 60) {
            const STAT_MIN = 55;  // Players can't have stats below this
            const STAT_MAX = 99;
            const STAT_RANGE = STAT_MAX - STAT_MIN; // 44

            const range = getRatingRange(scoutLevel);
            const offset = getStatOffset(playerId || '', statName || '', scoutLevel);

            // Apply offset - the range isn't centered on actual value
            const center = actualValue + offset;
            const min = Math.max(STAT_MIN, center - range);
            const max = Math.min(STAT_MAX, center + range);

            // Calculate positions as percentages of the 55-99 range
            const leftPct = ((min - STAT_MIN) / STAT_RANGE) * 100;
            const widthPct = Math.max(5, ((max - min) / STAT_RANGE) * 100);

            // Color based on the midpoint value
            const mid = (min + max) / 2;
            let color;
            if (mid >= 85) color = '#1B5E20';      // Elite - dark green
            else if (mid >= 75) color = '#4CAF50'; // Good - green
            else if (mid >= 65) color = '#8BC34A'; // Above avg - light green
            else if (mid >= 55) color = '#FFC107'; // Average - yellow
            else color = '#f44336';                // Poor - red (shouldn't happen with 55 min)

            return `<div class="range-indicator" style="width:${width}px;height:12px;background:#333;border-radius:3px;position:relative;display:inline-block;vertical-align:middle;">
                <div style="position:absolute;left:${leftPct}%;width:${widthPct}%;height:100%;background:${color};border-radius:3px;opacity:0.9;"></div>
            </div>`;
        }

        // Create a compact range indicator for list views - never shows exact numbers
        // Visual scale uses 55-99 since players can't have stats below ~55
        function createCompactRangeIndicator(actualValue, scoutLevel, playerId) {
            const STAT_MIN = 55;
            const STAT_MAX = 99;

            const range = getRatingRange(scoutLevel);
            const offset = getStatOffset(playerId || '', 'overall', scoutLevel);

            // Apply offset - the range isn't centered on actual value
            const center = actualValue + offset;
            const min = Math.max(STAT_MIN, center - range);
            const max = Math.min(STAT_MAX, center + range);
            const mid = (min + max) / 2;

            // Color based on midpoint
            let color;
            if (mid >= 85) color = '#1B5E20';      // Elite - dark green
            else if (mid >= 75) color = '#4CAF50'; // Good - green
            else if (mid >= 65) color = '#8BC34A'; // Above avg - light green
            else if (mid >= 55) color = '#FFC107'; // Average - yellow
            else color = '#f44336';                // Poor - red

            // Show narrower bar for higher certainty, minimum width so always visible
            const barWidth = Math.max(8, Math.min(50, (max - min) * 1.0));

            return `<div style="display:inline-flex;align-items:center;">
                <div style="width:${barWidth}px;height:8px;background:${color};border-radius:2px;"></div>
            </div>`;
        }

        // Convert a numeric rating to a letter grade
        function ratingToGrade(rating) {
            if (rating >= 90) return 'A+';
            if (rating >= 85) return 'A';
            if (rating >= 80) return 'A-';
            if (rating >= 75) return 'B+';
            if (rating >= 70) return 'B';
            if (rating >= 65) return 'B-';
            if (rating >= 60) return 'C+';
            if (rating >= 55) return 'C';
            if (rating >= 50) return 'C-';
            if (rating >= 45) return 'D+';
            if (rating >= 40) return 'D';
            return 'F';
        }

        // Grade steps for variance calculation
        const GRADE_STEPS = ['F', 'D', 'D+', 'C-', 'C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+'];

        // Get a "scouted" letter grade for draft list display
        // Usually accurate but sometimes off - creates uncertainty without ranges
        // Rough gems have grades several steps below their actual
        function getScoutedListGrade(player) {
            const actualGrade = ratingToGrade(player.overall);
            const actualIndex = GRADE_STEPS.indexOf(actualGrade);

            // Check if this is a rough gem (marked during draft generation)
            if (player.isRoughGem) {
                // Show grade 3-5 steps below actual
                const gemOffset = 3 + Math.abs(hashString(player.id + 'gem') % 3); // 3-5 steps
                const gemIndex = Math.max(0, actualIndex - gemOffset);
                return { grade: GRADE_STEPS[gemIndex], isRoughGem: true };
            }

            // Use player ID hash for consistent but varied offset
            const hash = hashString(player.id + 'grade');
            const roll = (hash % 100) / 100;

            let offset = 0;
            if (roll < 0.40) {
                // 40% - exactly right
                offset = 0;
            } else if (roll < 0.60) {
                // 20% - off by 1 step (could be higher or lower)
                offset = (hash % 2 === 0) ? 1 : -1;
            } else if (roll < 0.75) {
                // 15% - off by 2 steps (could be higher or lower)
                offset = (hash % 2 === 0) ? 2 : -2;
            } else if (roll < 0.85) {
                // 10% - underrated (rough gem territory - looks worse than they are)
                offset = -1 - (hash % 2);  // -1 or -2
            } else if (roll < 0.95) {
                // 10% - overrated (fool's gold - looks better than they are)
                offset = 1 + (hash % 2);  // +1 or +2
            } else {
                // 5% - significantly overrated (fool's gold trap)
                offset = 2 + (hash % 2);  // +2 or +3
            }

            // Apply offset and clamp to valid range
            const newIndex = Math.max(0, Math.min(GRADE_STEPS.length - 1, actualIndex + offset));
            return { grade: GRADE_STEPS[newIndex], isRoughGem: false };
        }

        // Simple string hash for deterministic randomness
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // Get color for a letter grade (consistent with range indicator colors)
        function getGradeColor(grade) {
            const index = GRADE_STEPS.indexOf(grade);
            if (index >= 10) return '#1B5E20';      // A, A+ - dark green (elite)
            if (index >= 7) return '#4CAF50';       // B+, A- - green (good)
            if (index >= 5) return '#8BC34A';       // C+, B, B- - light green (above avg)
            if (index >= 3) return '#FFC107';       // C-, C - yellow (average)
            return '#f44336';                        // D range, F - red (poor)
        }

        // Get letter grade display for overall rating based on scout level
        // Returns { display: string, isExact: boolean }
        function getOverallGrade(actualValue, scoutLevel) {
            if (scoutLevel >= 3) {
                // Fully scouted - show exact grade
                return { display: ratingToGrade(actualValue), isExact: true };
            }

            const range = getRatingRange(scoutLevel);
            const min = Math.max(1, actualValue - range);
            const max = Math.min(99, actualValue + range);
            const minGrade = ratingToGrade(min);
            const maxGrade = ratingToGrade(max);

            if (minGrade === maxGrade) {
                // Same grade even with uncertainty
                return { display: minGrade, isExact: false };
            }

            // Show grade range (lower to higher, e.g., "C-B" or "B-A")
            return { display: `${minGrade}‚Äì${maxGrade}`, isExact: false };
        }

        // Get growth estimate based on potential grade and scout level
        // Shows a single description that may be inaccurate; scouting improves accuracy
        // Uses player ID to deterministically generate consistent "scouting error"
        function getGrowthEstimate(potentialGrade, scoutLevel, playerId) {
            const labels = ['Low', 'Average', 'High', 'Elite'];

            // Generate a consistent "error" based on player ID
            // This ensures the same player always shows the same estimate until scouted more
            let hash = 0;
            if (playerId) {
                for (let i = 0; i < playerId.length; i++) {
                    hash = ((hash << 5) - hash) + playerId.charCodeAt(i);
                    hash = hash & hash;
                }
            }

            // Determine potential error based on scout level
            // Even fully scouted players have small chance of being wrong
            let maxError, errorChance;
            if (scoutLevel === 0) {
                maxError = 1;
                errorChance = 0.25;  // 25% chance of being wrong (was 70%)
            } else if (scoutLevel === 1) {
                maxError = 1;
                errorChance = 0.20;  // 20% chance of being wrong
            } else if (scoutLevel === 2) {
                maxError = 1;
                errorChance = 0.17; // 17% chance of being wrong
            } else {
                maxError = 1;
                errorChance = 0.15; // 15% chance of surprise even fully scouted
            }

            // Use hash to deterministically decide if there's an error and which direction
            const hashNorm = Math.abs(hash % 100) / 100;
            let displayGrade = potentialGrade;

            if (hashNorm < errorChance) {
                // Apply error - use another part of hash to determine direction and magnitude
                const errorDir = (Math.abs(hash >> 8) % 2 === 0) ? 1 : -1;
                const errorMag = (Math.abs(hash >> 4) % maxError) + 1;
                displayGrade = potentialGrade + (errorDir * errorMag);
                // Clamp to valid range
                displayGrade = Math.max(0, Math.min(3, displayGrade));
            }

            return { display: labels[displayGrade], isExact: false };
        }

        // Simple toast notification for scouting feedback
        function showNotification(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 12px 24px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out forwards;
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            `;
            toast.textContent = message;

            // Add animation style if not exists
            if (!document.getElementById('toastAnimation')) {
                const style = document.createElement('style');
                style.id = 'toastAnimation';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        15% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        85% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // Scout a player (spend points to reduce uncertainty)
        // Exposed globally for onclick handlers
        window.scoutPlayer = function(playerId) {
            try {
                console.log('scoutPlayer called:', playerId);
                const currentLevel = getPlayerScoutLevel(playerId);
                console.log('Current scout level:', currentLevel);

                if (currentLevel >= SCOUTING.MAX_LEVEL) {
                    console.log('Already at max level');
                    showNotification('Player fully scouted!', 'info');
                    return false;
                }

                const cost = calculateScoutingCost(draftState.currentPickNumber);
                console.log('Scout cost:', cost, 'Available points:', managementState.team.draftPoints);

                if (managementState.team.draftPoints < cost) {
                    console.log('Not enough draft points');
                    showNotification(`Need ${cost} draft points to scout!`, 'error');
                    return false;
                }

                // Deduct points and increase scout level
                managementState.team.draftPoints -= cost;
                draftState.scoutLevels[playerId] = currentLevel + 1;
                console.log('Scouted! New level:', draftState.scoutLevels[playerId], 'Remaining points:', managementState.team.draftPoints);

                showNotification(`Scouted player! (Level ${currentLevel + 1}/${SCOUTING.MAX_LEVEL})`, 'success');

                // Refresh the views
                console.log('About to refresh. selectedDraftPlayer:', draftState.selectedDraftPlayer ? draftState.selectedDraftPlayer.id : 'null');
                window._rangeIndicatorLogCount = 0; // Reset so we see new range indicator values
                refreshDraftScreen();
                console.log('refreshDraftScreen completed');

                if (draftState.selectedDraftPlayer && draftState.selectedDraftPlayer.id === playerId) {
                    console.log('Refreshing player detail modal');
                    showDraftPlayerDetail(playerId);
                    console.log('showDraftPlayerDetail completed');
                } else {
                    console.log('Not refreshing modal - selectedDraftPlayer mismatch or null');
                }

                return true;
            } catch (error) {
                console.error('Error in scoutPlayer:', error);
                return false;
            }
        }

        // Ideal roster composition per position
        const IDEAL_ROSTER = {
            QB: 1,
            WR: 3,
            CB: 4,
            OL: 5,
            DL: 4
        };

        // Calculate positional needs for a team based on what they've drafted
        // Considers both roster gaps AND quality of existing players
        function calculatePositionalNeeds(teamRoster) {
            const roster = teamRoster || [];
            const positionData = {};

            // Initialize position data
            Object.keys(IDEAL_ROSTER).forEach(pos => {
                positionData[pos] = {
                    players: [],
                    count: 0,
                    bestOverall: 0,
                    avgOverall: 0
                };
            });

            // Gather data for each position
            roster.forEach(player => {
                if (positionData[player.position]) {
                    positionData[player.position].players.push(player);
                    positionData[player.position].count++;
                }
            });

            // Calculate best and average overall for each position
            Object.keys(positionData).forEach(pos => {
                const players = positionData[pos].players;
                if (players.length > 0) {
                    positionData[pos].bestOverall = Math.max(...players.map(p => p.overall));
                    positionData[pos].avgOverall = players.reduce((sum, p) => sum + p.overall, 0) / players.length;
                }
            });

            // Calculate need scores (higher = more needed)
            const needs = [];
            Object.keys(IDEAL_ROSTER).forEach(pos => {
                const ideal = IDEAL_ROSTER[pos];
                const data = positionData[pos];
                const spotsNeeded = ideal - data.count;

                let urgency = 0;

                if (data.count === 0) {
                    // Position completely empty - critical need
                    urgency = 5;
                } else if (spotsNeeded > 0) {
                    // Have some players but not enough
                    // Base urgency from spots needed (1-4)
                    urgency = Math.min(4, spotsNeeded);

                    // Bonus if current players are weak (best player < 75)
                    if (data.bestOverall < 75) {
                        urgency += 2;
                    } else if (data.bestOverall < 80) {
                        urgency += 1;
                    }
                } else {
                    // At ideal count - might still want to upgrade if players are weak
                    if (data.bestOverall < 70) {
                        urgency = 2; // Weak starter, consider upgrading
                    } else if (data.bestOverall < 75) {
                        urgency = 1; // Below average, slight interest
                    }
                    // Otherwise urgency stays 0 - position is filled with good players
                }

                if (urgency > 0) {
                    needs.push({
                        position: pos,
                        need: spotsNeeded,
                        urgency: urgency,
                        bestOverall: data.bestOverall
                    });
                }
            });

            // Sort by urgency (highest first)
            needs.sort((a, b) => b.urgency - a.urgency);

            return needs;
        }

        // Get top N positional needs as a display string
        function getPositionalNeedsDisplay(teamRoster, count = 2) {
            const needs = calculatePositionalNeeds(teamRoster);
            if (needs.length === 0) return '';

            const topNeeds = needs.slice(0, count).map(n => n.position);
            return topNeeds.join(', ');
        }

        // Team draft strategies - affects how they value players
        const DRAFT_STRATEGIES = {
            contender: {
                name: 'Contender',
                icon: 'üèÜ',
                overallWeight: 1.3,      // Values high overall more
                growthWeight: 0.5,       // Less interested in potential
                description: 'Win-now mode, wants immediate contributors'
            },
            balanced: {
                name: 'Balanced',
                icon: '‚öñÔ∏è',
                overallWeight: 1.0,
                growthWeight: 1.0,
                description: 'Balances current ability with future upside'
            },
            rebuilder: {
                name: 'Rebuilder',
                icon: 'üìà',
                overallWeight: 0.7,      // Less focused on current overall
                growthWeight: 1.6,       // Highly values youth and potential
                description: 'Building for the future, wants young talent'
            }
        };

        // Assign random strategies to computer teams at draft start
        function assignTeamStrategies() {
            const strategies = {};
            const strategyTypes = ['contender', 'balanced', 'rebuilder'];

            for (let i = 0; i < DRAFT.NUM_TEAMS - 1; i++) {
                // Weighted distribution: 30% contender, 40% balanced, 30% rebuilder
                const roll = Math.random();
                if (roll < 0.3) {
                    strategies[i] = 'contender';
                } else if (roll < 0.7) {
                    strategies[i] = 'balanced';
                } else {
                    strategies[i] = 'rebuilder';
                }
            }

            return strategies;
        }

        // Calculate player value for draft selection
        // Weighs overall rating, growth potential, and positional need
        // Strategy affects the balance between overall and growth
        function calculateDraftValue(player, teamRoster, strategy = 'balanced') {
            const strat = DRAFT_STRATEGIES[strategy] || DRAFT_STRATEGIES.balanced;

            // Base value from overall (0-100 scale), weighted by strategy
            let value = player.overall * strat.overallWeight;

            // Growth potential bonus (age + potential grade), weighted by strategy
            // Young players with high potential are more valuable to rebuilders
            const ageBonus = Math.max(0, (24 - player.age) * 2); // Up to +6 for age 21
            const potentialBonus = player.potentialGrade * 4; // Up to +12 for 3-star potential
            value += (ageBonus + potentialBonus) * strat.growthWeight;

            // Positional need multiplier
            const needs = calculatePositionalNeeds(teamRoster);
            const posNeed = needs.find(n => n.position === player.position);

            if (posNeed) {
                // Multiply value based on need (1.0 to 1.5)
                const needMultiplier = 1 + (posNeed.urgency * 0.1);
                value *= Math.min(1.5, needMultiplier);
            } else {
                // Position already filled - reduce value significantly
                value *= 0.5;
            }

            return value;
        }

        // Smart computer team selection - returns { player, reasoning }
        function selectBestPlayerForTeam(available, teamRoster, strategy = 'balanced') {
            if (available.length === 0) return { player: null, reasoning: '' };

            const strat = DRAFT_STRATEGIES[strategy] || DRAFT_STRATEGIES.balanced;
            const needs = calculatePositionalNeeds(teamRoster);

            // Score all available players with detailed breakdown
            const scored = available.map(player => {
                const posNeed = needs.find(n => n.position === player.position);
                const ageBonus = Math.max(0, (24 - player.age) * 2);
                const potentialBonus = player.potentialGrade * 4;
                const growthValue = (ageBonus + potentialBonus) * strat.growthWeight;
                const baseValue = player.overall * strat.overallWeight;
                const needMultiplier = posNeed ? Math.min(1.5, 1 + (posNeed.urgency * 0.1)) : 0.5;
                const fillsNeed = posNeed && posNeed.urgency >= 3;

                return {
                    player,
                    value: calculateDraftValue(player, teamRoster, strategy),
                    fillsNeed,
                    needUrgency: posNeed ? posNeed.urgency : 0,
                    baseValue: Math.round(baseValue),
                    growthValue: Math.round(growthValue),
                    needMultiplier,
                    ageBonus,
                    potentialBonus
                };
            });

            // Sort by value (highest first)
            scored.sort((a, b) => b.value - a.value);

            // Add some randomness: pick from top 3 candidates with weighted probability
            const topCandidates = scored.slice(0, Math.min(3, scored.length));

            // Weight towards higher value picks but allow some variance
            const totalValue = topCandidates.reduce((sum, c) => sum + c.value, 0);
            let roll = Math.random() * totalValue;
            let selectedCandidate = topCandidates[0];

            for (const candidate of topCandidates) {
                roll -= candidate.value;
                if (roll <= 0) {
                    selectedCandidate = candidate;
                    break;
                }
            }

            // Generate reasoning with weights
            const player = selectedCandidate.player;
            const sc = selectedCandidate;
            const parts = [];

            // Strategy
            parts.push(`${strat.icon} ${strat.name}`);

            // Board position
            const rank = scored.findIndex(s => s.player.id === player.id) + 1;
            if (rank === 1) {
                parts.push('BPA');
            } else {
                parts.push(`#${rank} on board`);
            }

            // Value breakdown
            const valueBreakdown = [];
            valueBreakdown.push(`OVR:${sc.baseValue}`);
            if (sc.growthValue > 0) {
                valueBreakdown.push(`Growth:+${sc.growthValue}`);
            }
            if (sc.needMultiplier !== 1.0) {
                const needPct = Math.round((sc.needMultiplier - 1) * 100);
                const needSign = needPct >= 0 ? '+' : '';
                valueBreakdown.push(`Need:${needSign}${needPct}%`);
            }
            parts.push(valueBreakdown.join(' '));

            // Total value
            parts.push(`= ${Math.round(sc.value)}`);

            const reasoning = parts.join(' ¬∑ ');

            return { player, reasoning };
        }

        // Generate draft class with realistic ratings
        // Guaranteed: 1-3 elite (90+), 6+ standouts (85-89), rest are developmental
        function generateDraftClass() {
            const draftClass = [];
            const totalPlayers = DRAFT.ROUNDS * DRAFT.PLAYERS_PER_ROUND;
            const positions = ['QB', 'WR', 'WR', 'WR', 'CB', 'CB', 'OL', 'DL'];

            // First, generate guaranteed elite players (90+)
            const numElite = randomInt(1, 3);
            for (let i = 0; i < numElite; i++) {
                const position = positions[randomInt(0, positions.length - 1)];
                const player = generatePlayer(position, 'elite');
                player.age = randomInt(21, 22);
                player.yearsInLeague = 0;

                // Ensure 90+ overall
                if (player.overall < 90) {
                    const boost = (90 + randomInt(0, 2)) / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.min(99, Math.floor(player.stats[stat] * boost));
                    });
                    if (player.coreAttributes) {
                        Object.keys(player.coreAttributes).forEach(attr => {
                            player.coreAttributes[attr] = Math.min(99, Math.floor(player.coreAttributes[attr] * boost));
                        });
                    }
                    player.overall = calculateOverall(player);
                    // Sync seasonStartStats with modified stats
                    player.seasonStartStats = { ...player.stats };
                }
                // Cap at 92
                if (player.overall > 92) {
                    const scale = 92 / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.floor(player.stats[stat] * scale);
                    });
                    player.overall = calculateOverall(player);
                    // Sync seasonStartStats with modified stats
                    player.seasonStartStats = { ...player.stats };
                }
                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Generate standout players (85-89) - at least 6
            const numStandouts = randomInt(6, 9);
            for (let i = 0; i < numStandouts; i++) {
                const position = positions[randomInt(0, positions.length - 1)];
                const player = generatePlayer(position, 'star');
                player.age = randomInt(21, 23);
                player.yearsInLeague = 0;

                // Ensure 85-89 overall
                const targetOverall = randomInt(85, 89);
                if (player.overall !== targetOverall) {
                    const scale = targetOverall / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.min(99, Math.max(40, Math.floor(player.stats[stat] * scale)));
                    });
                    if (player.coreAttributes) {
                        Object.keys(player.coreAttributes).forEach(attr => {
                            player.coreAttributes[attr] = Math.min(99, Math.max(40, Math.floor(player.coreAttributes[attr] * scale)));
                        });
                    }
                    player.overall = calculateOverall(player);
                    // Sync seasonStartStats with modified stats
                    player.seasonStartStats = { ...player.stats };
                }
                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Fill remaining slots with regular prospects
            const remainingSlots = totalPlayers - draftClass.length;
            for (let i = 0; i < remainingSlots; i++) {
                const position = positions[i % positions.length];

                // Regular tier distribution for remaining players
                const roll = Math.random();
                let tier;
                if (roll < 0.40) tier = 'rookie';        // 40% - developmental (60-73)
                else if (roll < 0.75) tier = 'average';  // 35% - solid prospect (68-78)
                else if (roll < 0.90) tier = 'below_average'; // 15% - raw talent (58-68)
                else tier = 'veteran';                    // 10% - contributor (78-84)

                const player = generatePlayer(position, tier);
                player.age = randomInt(21, 23);
                player.yearsInLeague = 0;

                // Cap regular prospects at 84 (these aren't the guaranteed standouts)
                if (player.overall > 84) {
                    const scale = randomInt(78, 84) / player.overall;
                    Object.keys(player.stats).forEach(stat => {
                        player.stats[stat] = Math.floor(player.stats[stat] * scale);
                    });
                    player.overall = calculateOverall(player);
                    // Sync seasonStartStats with modified stats
                    player.seasonStartStats = { ...player.stats };
                }

                player.salaryCost = calculateSalary(player.stats, player.position);
                draftClass.push(player);
            }

            // Sort by overall rating descending
            const sorted = draftClass.sort((a, b) => b.overall - a.overall);

            // Mark 1-2 rough gems in the later half of the draft
            // These are good players (75+ overall) who will show lower grades
            const laterHalf = sorted.slice(Math.floor(sorted.length / 2));
            const goodInLaterHalf = laterHalf.filter(p => p.overall >= 75);
            const numGems = Math.min(goodInLaterHalf.length, randomInt(1, 2));

            // Shuffle and pick rough gems
            const shuffled = goodInLaterHalf.sort(() => Math.random() - 0.5);
            for (let i = 0; i < numGems; i++) {
                shuffled[i].isRoughGem = true;
            }

            // Assign draft cost and generate scouting data
            sorted.forEach((player, index) => {
                player.draftCost = calculatePickCost(index + 1);
                // Generate combine and college stats for scouting
                player.combineStats = generateCombineStats(player);
                player.collegeStats = generateCollegeStats(player);
            });

            return sorted;
        }

        // Computer team names for draft display
        const COMPUTER_TEAM_NAMES = [
            'Storm', 'Titans', 'Wolves', 'Hawks', 'Dragons', 'Knights',
            'Vipers', 'Cobras', 'Bears', 'Eagles', 'Sharks'
        ];

        // Start the draft
        function startDraft(isNewGame = false) {
            draftState.active = true;
            draftState.round = 1;
            draftState.pick = 1;
            draftState.picksRemaining = DRAFT.ROUNDS;  // Player gets one pick per round
            draftState.currentPickNumber = 1;  // Start at pick 1
            draftState.isPlayersTurn = false;  // Other teams pick first
            draftState.usingExtraPick = false;
            draftState.simulatingPicks = false;
            draftState.lastComputerPick = null;
            draftState.draftPool = generateDraftClass();
            draftState.draftedPlayers = [];
            draftState.playerPicks = [];
            draftState.computerTeamRosters = {};  // Reset computer team rosters for new draft
            draftState.computerTeamStrategies = assignTeamStrategies();  // Assign draft strategies
            draftState.isNewGame = isNewGame;
            draftState.viewingRoster = false;
            draftState.selectedDraftPlayer = null;
            draftState.scoutLevels = {};  // Reset scouting data for new draft

            // Calculate and set draft budget based on season ranking
            if (isNewGame && managementState.team) {
                // New games get fixed starting budget
                managementState.team.draftPoints = DRAFT.NEW_GAME_BUDGET;
            } else if (!isNewGame && managementState.team) {
                // Returning seasons calculate budget based on ranking
                const teamRank = getTeamSeasonRank();
                managementState.team.draftPoints = calculateDraftBudget(teamRank);
            } else if (managementState.team && !managementState.team.draftPoints) {
                // Fallback
                managementState.team.draftPoints = DRAFT.NEW_GAME_BUDGET;
            }

            showScreen('draft');
            refreshDraftScreen();

            // Save game at start of draft so progress isn't lost on reload
            if (managementState.settings.autoSave) SaveSystem.save();
        }

        // Check if it's the player's turn based on current pick number
        function isPlayersTurnNow() {
            if (!draftState.currentPickNumber || !DRAFT.NUM_TEAMS) return false;
            const pickInRound = ((draftState.currentPickNumber - 1) % DRAFT.NUM_TEAMS) + 1;
            return pickInRound === DRAFT.NUM_TEAMS;
        }

        // Simulate a single computer team pick (called when user clicks Next Pick)
        function simulateNextComputerPick() {
            const available = getAvailableDraftPlayers();

            // Check if it's player's turn
            if (isPlayersTurnNow()) {
                draftState.isPlayersTurn = true;
                draftState.lastComputerPick = null;
                refreshDraftScreen();
                return;
            }

            if (available.length === 0) {
                draftState.isPlayersTurn = true;
                refreshDraftScreen();
                return;
            }

            // Get the current team's roster and strategy for smart selection
            const teamIndex = (draftState.currentPickNumber - 1) % (DRAFT.NUM_TEAMS - 1);
            const teamRoster = draftState.computerTeamRosters[teamIndex] || [];
            const teamStrategy = draftState.computerTeamStrategies[teamIndex] || 'balanced';

            // Smart selection based on overall, growth potential, positional need, and team strategy
            const { player: picked, reasoning } = selectBestPlayerForTeam(available, teamRoster, teamStrategy);

            if (picked) {
                draftState.draftedPlayers.push(picked.id);

                // Track this pick in the team's roster
                if (!draftState.computerTeamRosters[teamIndex]) {
                    draftState.computerTeamRosters[teamIndex] = [];
                }
                draftState.computerTeamRosters[teamIndex].push(picked);

                // Store the pick for display
                draftState.lastComputerPick = {
                    teamName: COMPUTER_TEAM_NAMES[teamIndex],
                    teamIndex: teamIndex,
                    player: picked,
                    pickNumber: draftState.currentPickNumber,
                    reasoning: reasoning
                };

                draftState.currentPickNumber++;

                // Update display (user will click Next Pick to continue)
                refreshDraftScreen();
            }
        }

        // Skip all computer picks and go directly to player's turn
        function skipToPlayerTurn() {
            let available = getAvailableDraftPlayers();

            while (!isPlayersTurnNow() && available.length > 0) {
                // Get the current team's roster and strategy for smart selection
                const teamIndex = (draftState.currentPickNumber - 1) % (DRAFT.NUM_TEAMS - 1);
                const teamRoster = draftState.computerTeamRosters[teamIndex] || [];
                const teamStrategy = draftState.computerTeamStrategies[teamIndex] || 'balanced';

                // Smart selection based on overall, growth potential, positional need, and team strategy
                const { player: picked } = selectBestPlayerForTeam(available, teamRoster, teamStrategy);

                if (picked) {
                    draftState.draftedPlayers.push(picked.id);

                    // Track this pick in the team's roster
                    if (!draftState.computerTeamRosters[teamIndex]) {
                        draftState.computerTeamRosters[teamIndex] = [];
                    }
                    draftState.computerTeamRosters[teamIndex].push(picked);

                    draftState.currentPickNumber++;

                    // Remove picked player from available list
                    available = available.filter(p => p.id !== picked.id);
                }
            }

            draftState.isPlayersTurn = true;
            draftState.lastComputerPick = null;
            refreshDraftScreen();
        }

        // Legacy function - no longer auto-plays, user uses Next Pick button
        function simulateOtherTeamsPicks() {
            // No-op - user navigates manually now
        }

        // Get all available (undrafted) players
        function getAvailableDraftPlayers() {
            return draftState.draftPool
                .filter(p => !draftState.draftedPlayers.includes(p.id));
        }

        // Check if team can afford a player
        function canAffordDraftPlayer(playerId) {
            const player = draftState.draftPool.find(p => p.id === playerId);
            if (!player || !managementState.team) return false;
            return (managementState.team.draftPoints || 0) >= player.draftCost;
        }

        // Draft a player
        function draftPlayer(playerId) {
            console.log('draftPlayer called with:', playerId);
            console.log('draftState:', {
                active: draftState.active,
                picksRemaining: draftState.picksRemaining,
                isPlayersTurn: draftState.isPlayersTurn,
                usingExtraPick: draftState.usingExtraPick,
                draftedPlayers: draftState.draftedPlayers
            });

            const player = draftState.draftPool.find(p => p.id === playerId);
            console.log('Found player:', player);

            if (!player) {
                console.log('FAIL: Player not found in draft pool');
                return false;
            }
            if (draftState.draftedPlayers.includes(playerId)) {
                console.log('FAIL: Player already drafted');
                return false;
            }

            // Check if it's the player's turn (or using a traded pick)
            if (!draftState.isPlayersTurn && !draftState.usingExtraPick) {
                console.log('FAIL: Not your turn to draft');
                return false;
            }

            // If using a traded pick, it works like your own pick (FREE to draft)
            if (draftState.usingExtraPick) {
                // Add to team roster (no draft cost - picks are free)
                managementState.team.roster.push(player);
                draftState.draftedPlayers.push(playerId);
                draftState.playerPicks.push(playerId);
                draftState.currentPickNumber++;
                draftState.usingExtraPick = false;  // Reset traded pick flag

                // Update depth chart
                autoAssignDepthChart(managementState.team);

                // Save progress
                if (managementState.settings.autoSave) SaveSystem.save();

                // Just refresh - modal shows feedback
                refreshDraftScreen();
                return true;
            }

            // Normal draft pick - check if player has picks remaining
            if (draftState.picksRemaining <= 0) {
                console.log('FAIL: No picks remaining');
                return false;
            }

            console.log('SUCCESS: Drafting player...');

            // Add to team roster (no draft cost - picks are free to use)
            managementState.team.roster.push(player);
            draftState.draftedPlayers.push(playerId);
            draftState.playerPicks.push(playerId);
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;
            console.log('State updated. Picks remaining:', draftState.picksRemaining, 'Round:', draftState.round);

            // Update depth chart
            autoAssignDepthChart(managementState.team);
            console.log('Depth chart updated');

            // Check if draft is complete
            if (draftState.picksRemaining <= 0) {
                console.log('Draft complete, calling finishDraft');
                finishDraft();
                return true;
            }

            // Save progress
            if (managementState.settings.autoSave) SaveSystem.save();

            // Just refresh the screen - no animation needed since modal shows feedback
            draftState.lastComputerPick = null;
            console.log('Calling refreshDraftScreen...');
            refreshDraftScreen();
            console.log('refreshDraftScreen completed');

            return true;
        }

        // Skip current pick (use pick without selecting a player)
        function skipDraftPick() {
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;
            draftState.lastComputerPick = null;

            if (draftState.picksRemaining <= 0) {
                finishDraft();
                return;
            }

            // Just refresh - user will click Next Pick to continue
            refreshDraftScreen();
        }

        // Legacy function - now just completes draft
        function advanceDraft() {
            // No longer needed - draft advances after each pick

            if (draftState.round > DRAFT.ROUNDS) {
                // Draft complete
                finishDraft();
                return;
            }

            refreshDraftScreen();
        }

        // Finish the draft
        function finishDraft() {
            draftState.active = false;

            // Save game
            if (managementState.settings.autoSave) SaveSystem.save();

            // Show hub
            showScreen('hub');
        }

        // ========================================
        // PICK TRADING SYSTEM
        // ========================================

        // Get value of the current pick based on its position in the draft order
        // This is static - pick 1 = 1000, pick 2 = 800, etc. (uses calculatePickCost)
        function getCurrentPickValue() {
            return calculatePickCost(draftState.currentPickNumber);
        }

        // Get value player receives when trading in their pick
        function getTradeInValue() {
            const pickValue = getCurrentPickValue();
            const penalty = managementState.settings.pickTradeInPenalty || DRAFT.DEFAULT_TRADE_IN_PENALTY;
            return Math.max(0, pickValue - penalty);
        }

        // Get cost to acquire the current pick from another team
        function getAcquireCost() {
            const pickValue = getCurrentPickValue();
            const premiumPercent = managementState.settings.pickAcquirePremium || (DRAFT.DEFAULT_ACQUIRE_PREMIUM * 100);
            return Math.ceil(pickValue * (1 + premiumPercent / 100));
        }

        // Check if player can afford to acquire the current pick
        function canAffordAcquirePick() {
            if (!managementState.team) return false;
            return (managementState.team.draftPoints || 0) >= getAcquireCost();
        }

        // Trade in the player's current pick for draft points
        function tradeInPick() {
            if (!draftState.active || draftState.picksRemaining <= 0) return false;

            const tradeValue = getTradeInValue();

            // Add draft points
            managementState.team.draftPoints += tradeValue;

            // Use up the pick without drafting a player
            draftState.picksRemaining--;
            draftState.round++;
            draftState.currentPickNumber++;
            draftState.isPlayersTurn = false;

            if (draftState.picksRemaining <= 0) {
                finishDraft();
                return true;
            }

            // Simulate other teams picking for next round
            simulateOtherTeamsPicks();
            refreshDraftScreen();
            return true;
        }

        // Trade for a pick by paying the premium cost
        // This gives the player the current pick without using their regular pick slot
        function acquireCurrentPick() {
            if (!draftState.active || !canAffordAcquirePick()) return false;

            const acquireCost = getAcquireCost();

            // Deduct the cost
            managementState.team.draftPoints -= acquireCost;

            // Mark that player is using an extra pick
            draftState.usingExtraPick = true;

            refreshDraftScreen();
            return true;
        }

        // Toggle draft view between pool and roster
        function toggleDraftView(showRoster) {
            draftState.viewingRoster = showRoster;
            refreshDraftScreen();
        }

        // Show player detail for draft player
        function showDraftPlayerDetail(playerId) {
            console.log('showDraftPlayerDetail called:', playerId);
            const player = draftState.draftPool.find(p => p.id === playerId);
            if (!player) {
                console.log('Player not found in pool');
                return;
            }

            draftState.selectedDraftPlayer = player;

            // Get scouting info
            const scoutLevel = getPlayerScoutLevel(playerId);
            console.log('showDraftPlayerDetail using scoutLevel:', scoutLevel, 'for player:', playerId);
            const gradeInfo = getOverallGrade(player.overall, scoutLevel);
            const growthInfo = getGrowthEstimate(player.potentialGrade, scoutLevel, playerId);
            const scoutCost = calculateScoutingCost(draftState.currentPickNumber);
            const canScout = scoutLevel < SCOUTING.MAX_LEVEL && managementState.team.draftPoints >= scoutCost;

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Calculate rookie salary based on current pick number
            const rookieSalary = calculateRookieSalary(draftState.currentPickNumber);

            // Scout button HTML - use id and attach event listener after
            const scoutBtnId = `scoutBtn_${playerId.replace(/-/g, '')}`;
            const scoutBtnHtml = scoutLevel >= SCOUTING.MAX_LEVEL
                ? `<span style="color:#4CAF50;font-size:12px;">Fully Scouted ${'‚óè'.repeat(SCOUTING.MAX_LEVEL)}</span>`
                : `<button id="${scoutBtnId}" style="background:${canScout ? '#2196F3' : '#666'};color:white;border:none;padding:6px 12px;border-radius:4px;cursor:${canScout ? 'pointer' : 'not-allowed'};font-size:12px;" ${canScout ? '' : 'disabled'}>
                    SCOUT (${scoutCost} pts) ${'‚óè'.repeat(scoutLevel)}${'‚óã'.repeat(SCOUTING.MAX_LEVEL - scoutLevel)}
                   </button>`;

            // Create large overall range indicator
            const ovrRangeIndicator = createRangeIndicator(player.overall, scoutLevel, playerId, 'overall', 120);

            // Player info - draft version showing rookie contract salary with visual range
            const infoHtml = `
                <div style="display:flex;align-items:center;justify-content:center;gap:12px;">
                    <span class="ovr-big" style="font-size:${gradeInfo.isExact ? '48px' : '32px'};">${gradeInfo.display}</span>
                    ${ovrRangeIndicator}
                </div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age}<br>
                    Rookie Contract: $${rookieSalary}M/yr | Growth: <span style="color:#ffd700;">${growthInfo.display}</span>
                </div>
                <div style="margin-top:10px;">
                    ${scoutBtnHtml}
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // Attach scout button event listener after innerHTML is set
            if (scoutLevel < SCOUTING.MAX_LEVEL) {
                const scoutBtn = document.getElementById(scoutBtnId);
                console.log('Looking for scout button:', scoutBtnId, 'found:', !!scoutBtn);
                if (scoutBtn) {
                    scoutBtn.addEventListener('click', (e) => {
                        console.log('Scout button clicked');
                        e.stopPropagation();
                        window.scoutPlayer(playerId);
                    });
                }
            }

            // Hide cut button, show draft button
            const tradeBtn = document.getElementById('btnTradePlayer');
            const cutBtn = document.getElementById('btnCutPlayer');
            const alreadyDrafted = draftState.draftedPlayers.includes(playerId);
            const canDraftNow = draftState.isPlayersTurn || draftState.usingExtraPick;

            if (alreadyDrafted) {
                tradeBtn.textContent = 'ALREADY DRAFTED';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            } else if (!canDraftNow) {
                tradeBtn.textContent = 'NOT YOUR TURN';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            } else {
                tradeBtn.textContent = 'DRAFT';
                tradeBtn.disabled = false;
                tradeBtn.style.opacity = '1';
            }
            cutBtn.style.display = 'none';

            // Helper to get color class based on the middle of the range
            const getColorClass = (val) => val >= 90 ? 'stat-elite' : val >= 80 ? 'stat-good' : val >= 70 ? 'stat-average' : val >= 60 ? 'stat-below' : 'stat-poor';
            const getColorClassFromRange = (info) => getColorClass(Math.floor((info.min + info.max) / 2));

            // Build unified stats panel
            const core = player.coreAttributes;
            const abilities = calculateAbilities(player);
            const bestAbility = getBestAbility(player);
            const techniqueStats = POSITIONS[player.position].techniqueStats || [];

            let statsHtml = '<div class="stats-panel">';

            // Core Attributes section with visual range indicators
            if (core) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Core</div>
                        <div class="stats-grid">
                            <div class="stat-row str-row"><span class="stat-row-name">STR</span><span class="stat-row-value">${createRangeIndicator(core.strength, scoutLevel, playerId, 'strength')}</span></div>
                            <div class="stat-row spd-row"><span class="stat-row-name">SPD</span><span class="stat-row-value">${createRangeIndicator(core.speed, scoutLevel, playerId, 'speed')}</span></div>
                            <div class="stat-row agi-row"><span class="stat-row-name">AGI</span><span class="stat-row-value">${createRangeIndicator(core.agility, scoutLevel, playerId, 'agility')}</span></div>
                            <div class="stat-row int-row"><span class="stat-row-name">INT</span><span class="stat-row-value">${createRangeIndicator(core.intelligence, scoutLevel, playerId, 'intelligence')}</span></div>
                        </div>
                    </div>
                `;
            }

            // Abilities section with visual range indicators
            if (abilities) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Abilities</div>
                        <div class="stats-grid">
                            ${Object.entries(abilities).map(([key, value]) => {
                                const isBest = bestAbility && bestAbility.name === key;
                                const dots = getAbilityDots(key);
                                const name = getAbilityDisplayName(key);
                                return `<div class="stat-row ${isBest ? 'best-ability' : ''}"><span class="stat-row-name">${dots}${name}</span><span class="stat-row-value">${createRangeIndicator(value, scoutLevel, playerId, key)}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Technique section with visual range indicators
            if (techniqueStats.length > 0) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Technique</div>
                        <div class="stats-grid">
                            ${techniqueStats.map(stat => {
                                const current = Math.floor(player.stats[stat] || 0);
                                const displayName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                                return `<div class="stat-row"><span class="stat-row-name">${displayName}</span><span class="stat-row-value">${createRangeIndicator(current, scoutLevel, playerId, stat)}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Combine Stats section - Athletic Testing
            if (player.combineStats) {
                const cs = player.combineStats;
                // Helper to format stat with percentile coloring (dark green for elite)
                const pctColor = (pct) => pct >= 85 ? '#1B5E20' : pct >= 70 ? '#4CAF50' : pct >= 50 ? '#8BC34A' : pct >= 30 ? '#FFC107' : '#f44336';
                const formatWithPct = (val, pct, suffix = '') => `<span style="color:${pctColor(pct)}">${val}${suffix}</span> <span style="opacity:0.6;font-size:10px;">(${pct}%)</span>`;

                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Athletic Testing</div>
                        <div class="stats-grid" style="font-size:12px;">
                            <div class="stat-row"><span class="stat-row-name">40-Yard</span><span class="stat-row-value">${formatWithPct(cs.fortyYard, cs.fortyPct, 's')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Vertical</span><span class="stat-row-value">${formatWithPct(cs.verticalJump, cs.vertPct, '"')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">3-Cone</span><span class="stat-row-value">${formatWithPct(cs.threeCone, cs.threePct, 's')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Shuttle</span><span class="stat-row-value">${formatWithPct(cs.shuttle, cs.shuttlePct, 's')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Bench</span><span class="stat-row-value">${formatWithPct(cs.benchPress, cs.benchPct, ' reps')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Broad</span><span class="stat-row-value">${formatWithPct(cs.broadFeetInches, cs.broadPct, '')}</span></div>
                        </div>
                    </div>
                    <div class="stats-section">
                        <div class="stats-section-title">Mental/Interview</div>
                        <div class="stats-grid" style="font-size:12px;">
                            <div class="stat-row"><span class="stat-row-name">Wonderlic</span><span class="stat-row-value">${formatWithPct(cs.wonderlic, cs.wonderPct, '/50')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Film Study</span><span class="stat-row-value" style="color:#ffd700;">${cs.filmGrade}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Pos. Drills</span><span class="stat-row-value" style="color:#ffd700;">${cs.drillGrade}</span></div>
                        </div>
                    </div>
                `;
            }

            // College Stats section (position-specific)
            if (player.collegeStats) {
                const cs = player.collegeStats;
                let collegeHtml = '';
                // Use same pctColor and formatWithPct helper as combine stats (dark green for elite)
                const collegePctColor = (pct) => pct >= 85 ? '#1B5E20' : pct >= 70 ? '#4CAF50' : pct >= 50 ? '#8BC34A' : pct >= 30 ? '#FFC107' : '#f44336';
                const collegeFormatWithPct = (val, pct, suffix = '') => `<span style="color:${collegePctColor(pct)}">${val}${suffix}</span> <span style="opacity:0.6;font-size:10px;">(${pct}%)</span>`;

                switch (player.position) {
                    case 'QB':
                        collegeHtml = `
                            <div class="stat-row"><span class="stat-row-name">Comp %</span><span class="stat-row-value">${collegeFormatWithPct(cs.completionPct, cs.compPctPct, '%')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">TD:INT</span><span class="stat-row-value">${collegeFormatWithPct(cs.tdIntRatio, cs.tdIntPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Y/A</span><span class="stat-row-value">${collegeFormatWithPct(cs.yardsPerAttempt, cs.ypaPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Sack %</span><span class="stat-row-value">${collegeFormatWithPct(cs.sackPct, cs.sackPctPct, '%')}</span></div>
                        `;
                        break;
                    case 'WR':
                        collegeHtml = `
                            <div class="stat-row"><span class="stat-row-name">Y/Rec</span><span class="stat-row-value">${collegeFormatWithPct(cs.yardsPerCatch, cs.ypcPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Catch %</span><span class="stat-row-value">${collegeFormatWithPct(cs.catchRate, cs.catchRatePct, '%')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Contested</span><span class="stat-row-value">${collegeFormatWithPct(cs.contestedCatchPct, cs.contestedPct, '%')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">YAC</span><span class="stat-row-value">${collegeFormatWithPct(cs.yardsAfterCatch, cs.yacPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Drop %</span><span class="stat-row-value">${collegeFormatWithPct(cs.dropRate, cs.dropRatePct, '%')}</span></div>
                        `;
                        break;
                    case 'CB':
                        collegeHtml = `
                            <div class="stat-row"><span class="stat-row-name">INTs</span><span class="stat-row-value">${collegeFormatWithPct(cs.interceptions, cs.intsPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">PBUs</span><span class="stat-row-value">${collegeFormatWithPct(cs.passBreakups, cs.pbuPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">PR Allowed</span><span class="stat-row-value">${collegeFormatWithPct(cs.passerRatingAllowed, cs.prAllowPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Comp% Alw</span><span class="stat-row-value">${collegeFormatWithPct(cs.completionPctAllowed, cs.compAllowPct, '%')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Tackles</span><span class="stat-row-value">${collegeFormatWithPct(cs.tackles, cs.tacklesPct, '')}</span></div>
                        `;
                        break;
                    case 'OL':
                        collegeHtml = `
                            <div class="stat-row"><span class="stat-row-name">Sacks Alw</span><span class="stat-row-value">${collegeFormatWithPct(cs.sacksAllowed, cs.sacksAllowPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Press Alw</span><span class="stat-row-value">${collegeFormatWithPct(cs.pressuresAllowed, cs.pressAllowPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Pancakes</span><span class="stat-row-value">${collegeFormatWithPct(cs.pancakeBlocks, cs.pancakesPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Penalties</span><span class="stat-row-value">${collegeFormatWithPct(cs.penalties, cs.penaltiesPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Run Block</span><span class="stat-row-value" style="color:#ffd700;">${cs.runBlockGrade}</span></div>
                        `;
                        break;
                    case 'DL':
                        collegeHtml = `
                            <div class="stat-row"><span class="stat-row-name">Sacks</span><span class="stat-row-value">${collegeFormatWithPct(cs.sacks, cs.sacksPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">TFLs</span><span class="stat-row-value">${collegeFormatWithPct(cs.tacklesForLoss, cs.tflPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Hurries</span><span class="stat-row-value">${collegeFormatWithPct(cs.qbHurries, cs.hurriesPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">Run Stops</span><span class="stat-row-value">${collegeFormatWithPct(cs.runStops, cs.runStopsPct, '')}</span></div>
                            <div class="stat-row"><span class="stat-row-name">FF</span><span class="stat-row-value">${collegeFormatWithPct(cs.forcedFumbles, cs.ffPct, '')}</span></div>
                        `;
                        break;
                }

                if (collegeHtml) {
                    statsHtml += `
                        <div class="stats-section">
                            <div class="stats-section-title">College Stats</div>
                            <div class="stats-grid" style="font-size:12px;">
                                ${collegeHtml}
                            </div>
                        </div>
                    `;
                }
            }

            // Debug section - shows actual stats (toggle with button)
            const debugId = `debug_${playerId.replace(/-/g, '')}`;
            const actualGrade = ratingToGrade(player.overall);
            const scoutedGradeInfo = getScoutedListGrade(player);

            // Build debug stats HTML
            let debugStatsHtml = '';
            if (core) {
                debugStatsHtml += `<div><strong>Core:</strong> STR:${core.strength} SPD:${core.speed} AGI:${core.agility} INT:${core.intelligence}</div>`;
            }
            debugStatsHtml += `<div><strong>Technique:</strong> `;
            techniqueStats.forEach(stat => {
                debugStatsHtml += `${stat}:${player.stats[stat] || '?'} `;
            });
            debugStatsHtml += `</div>`;
            debugStatsHtml += `<div><strong>Overall:</strong> ${player.overall} (${actualGrade})</div>`;
            debugStatsHtml += `<div><strong>Scouted Grade:</strong> ${scoutedGradeInfo.grade}${scoutedGradeInfo.isRoughGem ? ' (ROUGH GEM!)' : ''}</div>`;
            debugStatsHtml += `<div><strong>Potential:</strong> ${player.potentialGrade} stars</div>`;

            // Debug combine stats with expected values and rolls
            if (player.combineStats && core) {
                const cs = player.combineStats;
                const str = core.strength || 50;
                const spd = core.speed || 50;
                const agi = core.agility || 50;
                const intel = core.intelligence || 50;

                // Calculate expected values (without variance)
                const expectedForty = 5.55 - (spd * 0.0098) - (agi * 0.0022);
                const expectedBench = -2 + (str * 0.36);
                const expectedVert = 21 + (spd * 0.13) + (agi * 0.07);
                const expectedBroad = 90 + (str * 0.23) + (spd * 0.17);
                const expectedThree = 8.03 - (agi * 0.011) - (spd * 0.0023);
                const expectedShuttle = 4.90 - (agi * 0.0067) - (spd * 0.0033);
                const expectedWonder = -2.5 + (intel * 0.445);

                // Format roll as percentage difference
                const formatRoll = (actual, expected) => {
                    const roll = ((actual / expected) - 1) * 100;
                    const sign = roll >= 0 ? '+' : '';
                    const color = Math.abs(roll) < 1 ? '#888' : roll > 0 ? '#4f4' : '#f44';
                    return `<span style="color:${color}">${sign}${roll.toFixed(1)}%</span>`;
                };
                // For inverted stats (lower is better), positive roll means worse
                const formatRollInv = (actual, expected) => {
                    const roll = ((actual / expected) - 1) * 100;
                    const sign = roll >= 0 ? '+' : '';
                    const color = Math.abs(roll) < 1 ? '#888' : roll < 0 ? '#4f4' : '#f44';
                    return `<span style="color:${color}">${sign}${roll.toFixed(1)}%</span>`;
                };

                debugStatsHtml += `<div style="margin-top:8px;border-top:1px solid #333;padding-top:6px;"><strong>Combine Debug:</strong></div>`;
                debugStatsHtml += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;font-size:10px;">`;
                debugStatsHtml += `<div>40yd: ${cs.fortyYard}s (exp: ${expectedForty.toFixed(2)}s) ${formatRollInv(parseFloat(cs.fortyYard), expectedForty)}</div>`;
                debugStatsHtml += `<div>Bench: ${cs.benchPress} (exp: ${expectedBench.toFixed(0)}) ${formatRoll(cs.benchPress, expectedBench)}</div>`;
                debugStatsHtml += `<div>Vert: ${cs.verticalJump}" (exp: ${expectedVert.toFixed(1)}") ${formatRoll(parseFloat(cs.verticalJump), expectedVert)}</div>`;
                debugStatsHtml += `<div>Broad: ${cs.broadJump}" (exp: ${expectedBroad.toFixed(0)}") ${formatRoll(cs.broadJump, expectedBroad)}</div>`;
                debugStatsHtml += `<div>3cone: ${cs.threeCone}s (exp: ${expectedThree.toFixed(2)}s) ${formatRollInv(parseFloat(cs.threeCone), expectedThree)}</div>`;
                debugStatsHtml += `<div>Shuttle: ${cs.shuttle}s (exp: ${expectedShuttle.toFixed(2)}s) ${formatRollInv(parseFloat(cs.shuttle), expectedShuttle)}</div>`;
                debugStatsHtml += `<div>Wonderlic: ${cs.wonderlic} (exp: ${expectedWonder.toFixed(0)}) ${formatRoll(cs.wonderlic, expectedWonder)}</div>`;
                debugStatsHtml += `</div>`;
            }

            // Debug college stats with expected values and rolls
            if (player.collegeStats && player.stats) {
                const cs = player.collegeStats;
                const stats = player.stats;
                const pos = player.position;

                debugStatsHtml += `<div style="margin-top:8px;border-top:1px solid #333;padding-top:6px;"><strong>College Debug:</strong></div>`;
                debugStatsHtml += `<div style="font-size:10px;">`;

                const formatRoll = (actual, expected) => {
                    const roll = ((actual / expected) - 1) * 100;
                    const sign = roll >= 0 ? '+' : '';
                    const color = Math.abs(roll) < 1 ? '#888' : roll > 0 ? '#4f4' : '#f44';
                    return `<span style="color:${color}">${sign}${roll.toFixed(1)}%</span>`;
                };
                const formatRollInv = (actual, expected) => {
                    const roll = ((actual / expected) - 1) * 100;
                    const sign = roll >= 0 ? '+' : '';
                    const color = Math.abs(roll) < 1 ? '#888' : roll < 0 ? '#4f4' : '#f44';
                    return `<span style="color:${color}">${sign}${roll.toFixed(1)}%</span>`;
                };

                switch (pos) {
                    case 'QB':
                        const qbAcc = stats.accuracy || 55;
                        const qbDec = stats.decisionMaking || core.intelligence || 55;
                        const qbArm = stats.armStrength || 55;
                        const qbPocket = stats.pocketPresence || 55;
                        const expCompPct = 50 + qbAcc * 0.25 + qbDec * 0.08;
                        const expTdInt = 0.8 + qbDec * 0.025 + qbAcc * 0.012;
                        const expYpa = 5.5 + qbArm * 0.03 + qbAcc * 0.02 + qbDec * 0.015;
                        const expSackPct = 12 - qbPocket * 0.08 - qbDec * 0.03;
                        debugStatsHtml += `Comp%: ${cs.completionPct} (exp: ${expCompPct.toFixed(1)}) ${formatRoll(parseFloat(cs.completionPct), expCompPct)}<br>`;
                        debugStatsHtml += `TD:INT: ${cs.tdIntRatio} (exp: ${expTdInt.toFixed(1)}) ${formatRoll(parseFloat(cs.tdIntRatio), expTdInt)}<br>`;
                        debugStatsHtml += `YPA: ${cs.yardsPerAttempt} (exp: ${expYpa.toFixed(1)}) ${formatRoll(parseFloat(cs.yardsPerAttempt), expYpa)}<br>`;
                        debugStatsHtml += `Sack%: ${cs.sackPct} (exp: ${expSackPct.toFixed(1)}) ${formatRollInv(parseFloat(cs.sackPct), expSackPct)}`;
                        break;
                    case 'WR':
                        const wrHands = stats.catching || stats.hands || 55;
                        const wrRoutes = stats.routeRunning || 55;
                        const wrSpd = core.speed || 55;
                        const expYpc = 10 + wrSpd * 0.06 + wrRoutes * 0.04;
                        const expCatchRate = 45 + wrHands * 0.25 + wrRoutes * 0.12;
                        const expContested = 30 + wrHands * 0.2 + (stats.jumping || 55) * 0.15 + (core.strength || 55) * 0.1;
                        const expYac = 2.5 + wrSpd * 0.04 + (core.agility || 55) * 0.03;
                        const expDropRate = 15 - wrHands * 0.12 - (core.intelligence || 55) * 0.03;
                        debugStatsHtml += `YPC: ${cs.yardsPerCatch} (exp: ${expYpc.toFixed(1)}) ${formatRoll(parseFloat(cs.yardsPerCatch), expYpc)}<br>`;
                        debugStatsHtml += `Catch%: ${cs.catchRate} (exp: ${expCatchRate.toFixed(1)}) ${formatRoll(parseFloat(cs.catchRate), expCatchRate)}<br>`;
                        debugStatsHtml += `Contested: ${cs.contestedCatchPct} (exp: ${expContested.toFixed(1)}) ${formatRoll(parseFloat(cs.contestedCatchPct), expContested)}<br>`;
                        debugStatsHtml += `YAC: ${cs.yardsAfterCatch} (exp: ${expYac.toFixed(1)}) ${formatRoll(parseFloat(cs.yardsAfterCatch), expYac)}<br>`;
                        debugStatsHtml += `Drop%: ${cs.dropRate} (exp: ${expDropRate.toFixed(1)}) ${formatRollInv(parseFloat(cs.dropRate), expDropRate)}`;
                        break;
                    case 'CB':
                        const cbCov = stats.coverage || stats.manCoverage || 55;
                        const cbSpd = core.speed || 55;
                        const cbAgi = core.agility || 55;
                        const cbAware = stats.awareness || 55;
                        const expCompAllowed = 72 - cbCov * 0.2 - cbSpd * 0.05;
                        const expIntRate = 0.5 + cbAware * 0.02 + (core.intelligence || 55) * 0.015;
                        const expPbu = 4 + cbCov * 0.06 + cbAgi * 0.04;
                        const expYardsAllowed = 18 - cbCov * 0.08 - cbSpd * 0.04;
                        debugStatsHtml += `Comp%: ${cs.completionAllowed} (exp: ${expCompAllowed.toFixed(1)}) ${formatRollInv(parseFloat(cs.completionAllowed), expCompAllowed)}<br>`;
                        debugStatsHtml += `INT: ${cs.intRate} (exp: ${expIntRate.toFixed(1)}) ${formatRoll(parseFloat(cs.intRate), expIntRate)}<br>`;
                        debugStatsHtml += `PBU: ${cs.passBreakups} (exp: ${expPbu.toFixed(1)}) ${formatRoll(parseFloat(cs.passBreakups), expPbu)}<br>`;
                        debugStatsHtml += `Yds/T: ${cs.yardsPerTarget} (exp: ${expYardsAllowed.toFixed(1)}) ${formatRollInv(parseFloat(cs.yardsPerTarget), expYardsAllowed)}`;
                        break;
                    case 'OL':
                        const olPass = stats.passBlock || 55;
                        const olStr = core.strength || 55;
                        const olAware = stats.awareness || 55;
                        const expSacksAllowed = 8 - olPass * 0.05 - olStr * 0.025;
                        const expPressRate = 20 - olPass * 0.12 - olAware * 0.05;
                        const expPenalties = 8 - olAware * 0.05 - (core.intelligence || 55) * 0.02;
                        debugStatsHtml += `Sacks: ${cs.sacksAllowed} (exp: ${expSacksAllowed.toFixed(1)}) ${formatRollInv(parseFloat(cs.sacksAllowed), expSacksAllowed)}<br>`;
                        debugStatsHtml += `Press%: ${cs.pressureRate} (exp: ${expPressRate.toFixed(1)}) ${formatRollInv(parseFloat(cs.pressureRate), expPressRate)}<br>`;
                        debugStatsHtml += `Penalties: ${cs.penalties} (exp: ${expPenalties.toFixed(1)}) ${formatRollInv(parseFloat(cs.penalties), expPenalties)}`;
                        break;
                    case 'DL':
                        const dlRush = stats.passRush || 55;
                        const dlStr = core.strength || 55;
                        const dlSpd = core.speed || 55;
                        const dlAgi = core.agility || 55;
                        const expSacks = 2 + dlRush * 0.08 + dlSpd * 0.03;
                        const expTfl = 5 + dlStr * 0.06 + dlRush * 0.04;
                        const expHurries = 8 + dlRush * 0.12 + dlAgi * 0.05;
                        debugStatsHtml += `Sacks: ${cs.sacks} (exp: ${expSacks.toFixed(1)}) ${formatRoll(parseFloat(cs.sacks), expSacks)}<br>`;
                        debugStatsHtml += `TFL: ${cs.tacklesForLoss} (exp: ${expTfl.toFixed(1)}) ${formatRoll(parseFloat(cs.tacklesForLoss), expTfl)}<br>`;
                        debugStatsHtml += `Hurries: ${cs.qbHurries} (exp: ${expHurries.toFixed(1)}) ${formatRoll(parseFloat(cs.qbHurries), expHurries)}`;
                        break;
                }
                debugStatsHtml += `</div>`;
            }

            statsHtml += `
                <div class="stats-section" style="border-top:1px solid #444;margin-top:10px;padding-top:10px;">
                    <button id="${debugId}_btn" style="background:#333;color:#888;border:1px solid #555;padding:4px 8px;border-radius:4px;font-size:10px;cursor:pointer;">
                        Show Debug Info
                    </button>
                    <div id="${debugId}_content" style="display:none;margin-top:8px;font-size:11px;color:#aaa;font-family:monospace;">
                        ${debugStatsHtml}
                    </div>
                </div>
            `;

            statsHtml += '</div>';

            // Show all stats in main area
            document.getElementById('playerStats').innerHTML = statsHtml;
            document.getElementById('playerSeasonStats').innerHTML = '';
            document.getElementById('playerCareerGraph').innerHTML = '';

            document.getElementById('playerDetailModal').style.display = 'flex';

            // Attach debug toggle event listener
            const debugBtn = document.getElementById(`${debugId}_btn`);
            const debugContent = document.getElementById(`${debugId}_content`);
            if (debugBtn && debugContent) {
                debugBtn.addEventListener('click', () => {
                    const isHidden = debugContent.style.display === 'none';
                    debugContent.style.display = isHidden ? 'block' : 'none';
                    debugBtn.textContent = isHidden ? 'Hide Debug Info' : 'Show Debug Info';
                });
            }
        }

        // Refresh draft screen
        function refreshDraftScreen() {
            const lastPickEl = document.getElementById('draftLastPick');
            const lastPickLine1El = document.getElementById('draftLastPickLine1');
            const lastPickLine2El = document.getElementById('draftLastPickLine2');
            const onClockEl = document.getElementById('draftOnClock');
            const roundPickEl = document.getElementById('draftRoundPick');
            const pointsEl = document.getElementById('draftPoints');
            const teamNameEl = document.getElementById('draftTeamName');
            const statusEl = document.getElementById('draftStatus');
            const poolListEl = document.getElementById('draftPlayerList');
            const rosterListEl = document.getElementById('draftRosterList');
            const skipBtn = document.getElementById('btnSkipRound');
            const finishBtn = document.getElementById('btnFinishDraft');
            const poolBtn = document.getElementById('btnDraftPoolView');
            const rosterBtn = document.getElementById('btnDraftRosterView');
            const tradeInBtn = document.getElementById('btnTradeInPick');
            const acquireBtn = document.getElementById('btnAcquirePick');
            const navButtonsEl = document.getElementById('draftNavButtons');

            // Safety check for missing elements
            if (!onClockEl || !statusEl || !poolListEl || !navButtonsEl) {
                console.error('Draft screen elements not found');
                return;
            }

            const draftPoints = managementState.team?.draftPoints || 0;
            const pickValue = getCurrentPickValue();
            const tradeInValue = getTradeInValue();
            const acquireCost = getAcquireCost();
            const isComputerTurn = !isPlayersTurnNow();
            const available = getAvailableDraftPlayers();

            // Update toggle button states
            poolBtn.classList.toggle('active', !draftState.viewingRoster);
            rosterBtn.classList.toggle('active', draftState.viewingRoster);

            // Show/hide appropriate list
            poolListEl.style.display = draftState.viewingRoster ? 'none' : 'block';
            rosterListEl.style.display = draftState.viewingRoster ? 'block' : 'none';

            if (!draftState.active) {
                finishBtn.style.display = 'block';
                skipBtn.style.display = 'none';
                onClockEl.style.display = 'none';
                lastPickEl.style.display = 'none';
                navButtonsEl.style.display = 'none';
                statusEl.textContent = 'Draft Complete!';
                poolListEl.innerHTML = '<p style="color:#4f4;">Your draft picks have been added to the roster.</p>';
                return;
            }

            // Update last pick notification bar
            if (draftState.lastComputerPick) {
                const pick = draftState.lastComputerPick;
                const player = pick.player;
                const pickTeamRoster = draftState.computerTeamRosters[pick.teamIndex] || [];
                const pickStrategy = draftState.computerTeamStrategies[pick.teamIndex] || 'balanced';
                const pickStrategyIcon = DRAFT_STRATEGIES[pickStrategy]?.icon || '';
                const pickNeedsDisplay = getPositionalNeedsDisplay(pickTeamRoster, 2);
                const needsSpan = pickNeedsDisplay
                    ? ` <span style="font-size:10px;font-style:italic;opacity:0.7;">(${pickNeedsDisplay})</span>`
                    : '';

                // Get the scouted grade that was shown before the pick
                const scoutLevel = getPlayerScoutLevel(player.id);
                const scoutedGradeInfo = getScoutedListGrade(player);
                const actualGrade = ratingToGrade(player.overall);
                const predictedGrade = scoutedGradeInfo.grade;

                // Determine if prediction was accurate, better, or worse than actual
                const actualIdx = GRADE_STEPS.indexOf(actualGrade);
                const predictedIdx = GRADE_STEPS.indexOf(predictedGrade);
                let predictedClass = 'predicted';
                if (predictedIdx > actualIdx + 1) predictedClass = 'predicted better';  // Predicted better than actual (fool's gold)
                else if (predictedIdx < actualIdx - 1) predictedClass = 'predicted worse';  // Predicted worse than actual (gem)

                // Line 1: Pick info and player name
                lastPickLine1El.innerHTML = `Pick #${pick.pickNumber}: <span class="team-name">${pickStrategyIcon} ${pick.teamName}</span>${needsSpan} ‚Üí <span class="player-name">${player.firstName} ${player.lastName}</span>`;

                // Line 2: Position, predicted grade, actual grade, growth stars
                const growthStars = player.potentialGrade > 0 ? ` <span style="color:#ffd700;">` + '‚òÖ'.repeat(player.potentialGrade) + `</span>` : '';
                lastPickLine2El.innerHTML = `<span class="position">${player.position}</span> ¬∑ Predicted: <span class="${predictedClass}">${predictedGrade}</span> ¬∑ Actual: <span class="overall">${actualGrade} (${player.overall})</span>${growthStars}`;

                // Make clickable to show player detail
                lastPickEl.onclick = () => showDraftPlayerDetail(player.id);
                lastPickEl.style.cursor = 'pointer';

                // Show reasoning if enabled
                const reasoningEl = document.getElementById('draftPickReasoning');
                const showReasoning = managementState.settings.showPickReasoning !== false;
                if (showReasoning && pick.reasoning) {
                    reasoningEl.innerHTML = `<span class="reason-label">Why:</span> ${pick.reasoning}`;
                    reasoningEl.style.display = 'block';
                } else {
                    reasoningEl.style.display = 'none';
                }
            } else {
                lastPickLine1El.textContent = 'Draft in progress...';
                lastPickLine2El.textContent = '';
                lastPickEl.onclick = null;
                lastPickEl.style.cursor = 'default';
                document.getElementById('draftPickReasoning').style.display = 'none';
            }

            // Update round/pick info
            roundPickEl.textContent = `Round ${draftState.round} ‚Ä¢ Pick ${draftState.currentPickNumber}`;
            pointsEl.textContent = `${draftPoints} pts`;

            // Update on-the-clock section
            if (draftState.usingExtraPick) {
                onClockEl.className = 'draft-on-clock player';
                teamNameEl.innerHTML = 'YOUR PICK';
                navButtonsEl.style.display = 'none';
            } else if (draftState.isPlayersTurn || !isComputerTurn) {
                if (!draftState.isPlayersTurn) draftState.isPlayersTurn = true;
                onClockEl.className = 'draft-on-clock player';
                teamNameEl.innerHTML = 'YOUR TURN';
                navButtonsEl.style.display = 'none';
            } else {
                onClockEl.className = 'draft-on-clock computer';
                // Show actual team name on the clock with strategy icon and positional needs
                const teamIndex = (draftState.currentPickNumber - 1) % (DRAFT.NUM_TEAMS - 1);
                const teamRoster = draftState.computerTeamRosters[teamIndex] || [];
                const teamStrategy = draftState.computerTeamStrategies[teamIndex] || 'balanced';
                const strategyIcon = DRAFT_STRATEGIES[teamStrategy]?.icon || '';
                const needsDisplay = getPositionalNeedsDisplay(teamRoster, 2);
                const teamName = COMPUTER_TEAM_NAMES[teamIndex] || 'Team';
                teamNameEl.innerHTML = `${strategyIcon} ${teamName}` +
                    (needsDisplay ? ` <span style="font-size:12px;font-style:italic;opacity:0.8;">(${needsDisplay})</span>` : '');
                navButtonsEl.style.display = 'flex';
            }

            // Update trade buttons
            if (draftState.viewingRoster || draftState.simulatingPicks || draftState.usingExtraPick) {
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'none';
            } else if (draftState.isPlayersTurn) {
                // Player's turn: Show TRADE PICK option
                acquireBtn.style.display = 'none';
                if (draftState.picksRemaining > 0 && available.length > 0) {
                    tradeInBtn.style.display = 'inline-block';
                    tradeInBtn.innerHTML = `TRADE PICK <span class="trade-value">+${tradeInValue} pts</span>`;
                } else {
                    tradeInBtn.style.display = 'none';
                }
            } else if (isComputerTurn && available.length > 0) {
                // Computer's turn: Show TRADE FOR only
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'inline-block';
                acquireBtn.innerHTML = `TRADE <span class="trade-cost">${acquireCost}</span>`;
                acquireBtn.disabled = !canAffordAcquirePick();
            } else {
                tradeInBtn.style.display = 'none';
                acquireBtn.style.display = 'none';
            }

            // Update status line
            const playerDrafted = draftState.playerPicks.length;
            if (draftState.usingExtraPick) {
                statusEl.textContent = `Select a player | Drafted: ${playerDrafted}`;
                skipBtn.style.display = 'none';
            } else if (draftState.isPlayersTurn) {
                statusEl.textContent = `Picks remaining: ${draftState.picksRemaining} | Drafted: ${playerDrafted}`;
                skipBtn.style.display = draftState.viewingRoster ? 'none' : 'block';
            } else {
                statusEl.textContent = `Drafted: ${playerDrafted}`;
                skipBtn.style.display = 'none';
            }
            finishBtn.style.display = 'none';

            if (draftState.viewingRoster) {
                refreshDraftRosterView(rosterListEl);
            } else {
                refreshDraftPoolView(poolListEl);
            }
        }

        // Refresh draft pool view
        function refreshDraftPoolView(listEl) {
            const available = getAvailableDraftPlayers();
            listEl.innerHTML = '';

            if (available.length === 0) {
                listEl.innerHTML = '<p style="color:#888;">No more players available.</p>';
                return;
            }

            available.forEach(player => {
                const scoutLevel = getPlayerScoutLevel(player.id);
                const growthInfo = getGrowthEstimate(player.potentialGrade, scoutLevel, player.id);

                // Get scouted grade (may be inaccurate) or exact grade if fully scouted
                let displayGrade, gradeColor;
                if (scoutLevel >= 3) {
                    // Fully scouted - show actual grade
                    displayGrade = ratingToGrade(player.overall);
                    gradeColor = getGradeColor(displayGrade);
                } else {
                    // Not fully scouted - show potentially inaccurate grade
                    const scoutedInfo = getScoutedListGrade(player);
                    displayGrade = scoutedInfo.grade;
                    gradeColor = getGradeColor(displayGrade);
                }

                // Show scout indicator if player has been scouted
                const scoutIndicator = scoutLevel > 0 ? `<span style="color:#4CAF50;font-size:10px;margin-left:4px;">` + '‚óè'.repeat(scoutLevel) + `</span>` : '';

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div style="flex:1;">
                        <div class="name">${player.firstName} ${player.lastName}${scoutIndicator}</div>
                        <div class="stats">${POSITIONS[player.position].name}</div>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span style="font-weight:bold;font-size:14px;color:${gradeColor};min-width:28px;text-align:center;">${displayGrade}</span>
                        <span class="potential-ind" style="min-width:45px;color:#4CAF50;font-size:11px;text-align:right;">${growthInfo.display}</span>
                    </div>
                `;
                item.addEventListener('click', () => showDraftPlayerDetail(player.id));
                listEl.appendChild(item);
            });
        }

        // Refresh draft roster view
        function refreshDraftRosterView(listEl) {
            listEl.innerHTML = '';

            if (!managementState.team || managementState.team.roster.length === 0) {
                listEl.innerHTML = '<p style="color:#888;">No players on roster yet.</p>';
                return;
            }

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                listEl.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    let potentialDisplay = '';
                    if (player.potentialGrade > 0) {
                        potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                    }

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName}</div>
                            <div class="stats">Age ${player.age} | ${formatSalary(player.salaryCost)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:#ffd700;font-size:14px;">${potentialDisplay}</span>
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    listEl.appendChild(item);
                });
            });
        }

        // ========================================
        // MANAGEMENT LAYER - MATCH SIMULATION
        // ========================================

        // Calculate team defense rating
        function calculateTeamDefenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // CBs
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.manCoverage + player.stats.zoneCoverage + player.stats.tackling) / 3;
                        count++;
                    }
                }
            });

            // DL
            dc.DL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passRush + player.stats.tackling) / 2;
                        count++;
                    }
                }
            });

            return count > 0 ? total / count : 50;
        }

        // Calculate team offense rating
        function calculateTeamOffenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // WRs
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        const spd = player.coreAttributes?.speed || 70;
                        total += (spd + player.stats.catching + player.stats.routeRunning) / 3;
                        count++;
                    }
                }
            });

            // OL
            dc.OL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        const str = player.coreAttributes?.strength || 70;
                        total += (player.stats.passBlock + str) / 2;
                        count++;
                    }
                }
            });

            // QB
            if (dc.QB) {
                const qb = roster.find(p => p.id === dc.QB);
                if (qb) {
                    const passAcc = ((qb.stats.shortPassAcc || 70) + (qb.stats.longPassAcc || 70)) / 2;
                    total += (passAcc + qb.stats.awareness) / 2;
                    count++;
                }
            }

            return count > 0 ? total / count : 50;
        }

        // ========================================
        // REALISTIC ENEMY DRIVE SIMULATION
        // ========================================

        // Weighted roll using stat weights (same formula as real game)
        // Uses coreAttributes for speed, agility, strength (merged stats)
        function weightedStatRoll(stats, weights, coreAttributes = null) {
            let weightedTotal = 0;
            const coreStats = ['speed', 'agility', 'strength'];
            for (const stat in weights) {
                let statValue;
                // Use coreAttributes for speed, agility, strength if available
                if (coreStats.includes(stat) && coreAttributes && coreAttributes[stat] !== undefined) {
                    statValue = coreAttributes[stat];
                } else {
                    statValue = stats[stat] || 50;
                }
                weightedTotal += statValue * weights[stat];
            }
            // Add ¬±20% variance
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);
            return roll;
        }

        // Get player's full name
        function getPlayerFullName(player) {
            if (!player) return 'Unknown';
            const first = player.firstName || 'Player';
            const last = player.lastName || '';
            return `${first} ${last.charAt(0) || ''}.`.trim();
        }

        // ========================================
        // HIGH-FIDELITY ROUND-BASED SIMULATION
        // ========================================

        // Select routes for receivers based on field position and situation
        function selectRoutesForPlay(receivers, yardsFromGoal, yardsToGo, down) {
            const routeAssignments = {};

            // Determine field zone
            const zone = yardsFromGoal <= 8 ? 'goalline' :
                         yardsFromGoal <= 20 ? 'redzone' : 'standard';

            const availableRoutes = Object.values(ROUTE_TEMPLATES[zone]);

            // Identify crossing/comeback routes (have crossing round or specific route types)
            const isCrossingRoute = (route) => {
                const crossingNames = ['slant', 'dig', 'comeback', 'curl', 'out', 'in', 'flat', 'quick_slant', 'endzone_slant'];
                if (crossingNames.some(name => route.name?.includes(name))) return true;
                // Or has a round with crossing: true after round 1
                return route.rounds?.some((r, i) => i > 0 && r.crossing);
            };

            const crossingRoutes = availableRoutes.filter(isCrossingRoute);

            // Categorize routes by depth
            const quickRoutes = availableRoutes.filter(r => r.rounds[1].depth <= 6);
            const mediumRoutes = availableRoutes.filter(r => r.rounds[1].depth > 6 && r.rounds[2].depth <= 12);
            const deepRoutes = availableRoutes.filter(r => r.rounds[2].depth > 12);

            // Randomly pick which receiver gets the guaranteed crossing route (usually slot/WR3)
            const crossingReceiverIndex = Math.random() < 0.6 ? 2 : (Math.random() < 0.5 ? 1 : 0);

            // Select based on situation
            receivers.forEach((wr, index) => {
                let routePool;

                // Ensure one receiver always runs a crossing/comeback route
                if (index === crossingReceiverIndex && crossingRoutes.length > 0) {
                    routePool = crossingRoutes;
                } else if (down >= 3 && yardsToGo > 7) {
                    // 3rd/4th and long - need deep routes
                    routePool = index === 0 ? deepRoutes : (index === 1 ? mediumRoutes : quickRoutes);
                } else if (down >= 3 && yardsToGo <= 3) {
                    // 3rd/4th and short - quick routes
                    routePool = index === 0 ? quickRoutes : (index === 1 ? mediumRoutes : deepRoutes);
                } else {
                    // Normal downs - mix it up
                    routePool = index === 0 ? mediumRoutes : (index === 1 ? deepRoutes : quickRoutes);
                }

                // Fallback if pool is empty
                if (routePool.length === 0) routePool = availableRoutes;

                // Pick random route from pool
                const route = routePool[Math.floor(Math.random() * routePool.length)];
                routeAssignments[wr.id || index] = route;
            });

            return routeAssignments;
        }

        // Initialize play state for round-based simulation
        function initializePlayState(offense, defense, fieldPosition) {
            const routes = selectRoutesForPlay(
                offense.receivers,
                fieldPosition.yardsFromGoal,
                fieldPosition.yardsToGo,
                fieldPosition.down
            );

            return {
                round: 0,
                maxRounds: 5,

                // Field state
                yardsFromGoal: fieldPosition.yardsFromGoal,
                yardsToGo: fieldPosition.yardsToGo,
                down: fieldPosition.down,

                // Pressure tracking
                totalPressure: 0,
                sacked: false,
                sackingPlayer: null,
                lineMatchups: [],  // Track OL/DL clashes for display

                // Receiver states
                receivers: offense.receivers.map((wr, index) => ({
                    id: wr.id || index,
                    player: wr,
                    stats: wr.stats,
                    route: routes[wr.id || index],
                    currentDepth: 0,
                    separation: 0,
                    catchProbability: 0,
                    effectiveCatchPct: 0,
                    rollMean: 79,
                    // Momentum tracking
                    lastDirection: 'vertical',  // 'vertical' or 'horizontal'
                    momentum: 0                  // Built up over consecutive same-direction rounds
                })),

                // Defender states (DBs)
                defenders: defense.dbs.map((db, index) => ({
                    id: db.id || index,
                    player: db,
                    stats: db.stats,
                    position: db.position || 'CB',
                    // Momentum tracking for defenders
                    lastDirection: 'vertical',
                    momentum: 0
                })),

                // O-Line states
                oLine: offense.oLine.map((ol, index) => ({
                    id: ol.id || index,
                    player: ol,
                    stats: ol.stats,
                    knockedDown: false
                })),

                // D-Line states
                dLine: defense.dLine.map((dl, index) => ({
                    id: dl.id || index,
                    player: dl,
                    stats: dl.stats,
                    knockedDown: false,
                    pressureContribution: 0
                })),

                // QB state
                qb: {
                    player: offense.qb,
                    stats: offense.qb.stats,
                    coreAttributes: offense.qb.coreAttributes || null,
                    trait: offense.qb.qbTrait || 'balanced',
                    hasThrown: false
                },

                // Result tracking
                result: null
            };
        }

        // Process OL/DL clashes for a single round
        function processLineClashesRound(state) {
            const roundBonus = (state.round - 1) * 3;  // DL gets +3 per round (was +5)
            let totalPressure = 0;

            // Reset pressure contributions
            state.dLine.forEach(dl => { dl.pressureContribution = 0; });

            // Clear matchups for this round (we'll keep the latest round's matchups)
            state.lineMatchups = [];

            for (let i = 0; i < state.dLine.length; i++) {
                const dl = state.dLine[i];

                if (dl.knockedDown) {
                    continue;
                }

                // Find corresponding OL (or closest available non-knocked-down)
                let ol = state.oLine[i];
                if (!ol || ol.knockedDown) {
                    ol = state.oLine.find(o => !o.knockedDown);
                }

                if (!ol) {
                    // Unblocked rusher - maximum pressure
                    dl.pressureContribution = 40;
                    totalPressure += 40;

                    // Record matchup
                    state.lineMatchups.push({
                        dl: dl.player,
                        ol: null,
                        dlRoll: 99,
                        olRoll: 0,
                        result: 'unblocked',
                        pressure: 40
                    });

                    // Sack chance for unblocked rusher (reduced from 35%)
                    if (Math.random() < 0.20) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    continue;
                }

                // Ability selection - DL initiates, OL reacts
                const abilityResult = resolveAbilityClash(dl.player, ol.player, ABILITY_MATCHUPS.linemen, true);

                // Calculate technique rolls (40% of total)
                const olTechRoll = getTechniqueRoll(ol.stats, CLASH_WEIGHTS.lineClash.offense);
                const dlTechRoll = getTechniqueRoll(dl.stats, CLASH_WEIGHTS.lineClash.defense);

                // Calculate core√óability multiplicative rolls (60% of total)
                const olCoreAbilityRoll = getCoreAbilityRoll(ol.player, abilityResult.reactor);
                const dlCoreAbilityRoll = getCoreAbilityRoll(dl.player, abilityResult.initiator);

                // Combined rolls with variance (¬±20%)
                const variance = 0.2;
                const olRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;
                const dlRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;

                const adjustedOlRoll = (olTechRoll + olCoreAbilityRoll) * olRollVariance;
                // Apply matchup multiplier and round bonus to DL
                const adjustedDlRoll = ((dlTechRoll + dlCoreAbilityRoll) * dlRollVariance + roundBonus) * abilityResult.matchupMultiplier;

                const margin = adjustedDlRoll - adjustedOlRoll;

                let result = 'held';
                // Determine outcome based on margin
                if (margin > 18) {
                    // DL dominant win - sack chance (reduced from 25%)
                    dl.pressureContribution = 35;
                    result = 'beaten badly';
                    if (Math.random() < 0.15) {
                        state.sacked = true;
                        state.sackingPlayer = dl.player;
                    }
                    // OL might get knocked down
                    if (Math.random() < 0.3) {
                        ol.knockedDown = true;
                    }
                } else if (margin > 10) {
                    dl.pressureContribution = 25;
                    result = 'beaten';
                } else if (margin > 5) {
                    dl.pressureContribution = 15;
                    result = 'pressured';
                } else if (margin > 2) {
                    dl.pressureContribution = 10;
                    result = 'pressured';
                } else if (margin > -2) {
                    dl.pressureContribution = 3;
                    result = 'held';
                } else if (margin > -10) {
                    dl.pressureContribution = 0;
                    result = 'blocked';
                } else {
                    // OL dominant win - DL might get knocked down
                    dl.pressureContribution = 0;
                    result = 'pancaked';
                    if (Math.random() < 0.2) {
                        dl.knockedDown = true;
                    }
                }

                // Record matchup for display
                state.lineMatchups.push({
                    dl: dl.player,
                    ol: ol.player,
                    dlRoll: Math.round(adjustedDlRoll),
                    olRoll: Math.round(adjustedOlRoll),
                    result: result,
                    pressure: dl.pressureContribution
                });

                totalPressure += dl.pressureContribution;
            }

            state.totalPressure = Math.min(totalPressure, 100);
        }

        // Process WR/DB separation clashes for a single round
        // Momentum mechanics - both players have same physics, but DB must REACT while WR pre-plans
        function processReceiverClashesRound(state) {
            for (let i = 0; i < state.receivers.length; i++) {
                const receiver = state.receivers[i];
                const routeRound = receiver.route.rounds[state.round - 1];
                const isCrossing = routeRound.crossing;
                const isBreakRound = receiver.route.breakRound === state.round;

                // Determine current direction
                const currentDirection = isCrossing ? 'horizontal' : 'vertical';
                const directionChanged = currentDirection !== receiver.lastDirection;

                // Update receiver depth
                receiver.currentDepth = routeRound.depth;

                // Find covering defender
                const defender = state.defenders[i] || state.defenders[0];

                if (!defender) {
                    receiver.separation = 30;  // Wide open
                    receiver.momentum = directionChanged ? 1 : Math.min(receiver.momentum + 1, 5);
                    receiver.lastDirection = currentDirection;
                    receiver.momentumAdvantage = 0;
                    continue;
                }

                // ========================================
                // MOMENTUM MECHANICS (UNIFIED PHYSICS)
                // ========================================
                // Both players have the same momentum physics when changing direction
                // The difference: WR pre-plans the cut, DB must REACT

                // Agility determines how well a player changes direction
                const wrAgility = receiver.coreAttributes?.agility || 70;
                const dbAgility = defender.coreAttributes?.agility || 70;

                // DB reaction time based on awareness (0-100)
                // Low awareness = slow to recognize the cut = still moving wrong way
                const dbAwareness = defender.stats.awareness || 70;
                // Reaction frames: 100 awareness = 0 frames, 50 awareness = 2.5 frames delay
                const reactionFrames = (100 - dbAwareness) / 20;

                // Momentum effect multiplier (same physics for both)
                // Higher momentum = harder to change direction
                const momentumPenaltyPerLevel = 8;  // Strong effect

                let wrMomentumEffect = 0;
                let dbMomentumEffect = 0;
                let momentumAdvantage = 0;

                if (directionChanged) {
                    // WR changes direction instantly (pre-planned)
                    // Penalty based on their momentum, reduced by agility
                    const wrAgilityFactor = wrAgility / 100;
                    wrMomentumEffect = receiver.momentum * momentumPenaltyPerLevel * (1 - wrAgilityFactor * 0.5);

                    // DB must REACT - they keep moving wrong way during reaction time
                    // Then they change direction with same physics
                    const dbAgilityFactor = dbAgility / 100;

                    // Reaction delay: DB's momentum CONTINUES building during reaction time
                    const effectiveMomentum = defender.momentum + reactionFrames;
                    dbMomentumEffect = effectiveMomentum * momentumPenaltyPerLevel * (1 - dbAgilityFactor * 0.5);

                    // Momentum advantage = how much the WR gained from the cut
                    momentumAdvantage = dbMomentumEffect - wrMomentumEffect;

                    // Store for display
                    receiver.momentumAdvantage = Math.round(momentumAdvantage);
                    receiver.dbReactionDelay = reactionFrames;
                } else {
                    receiver.momentumAdvantage = 0;
                    receiver.dbReactionDelay = 0;
                }

                // ========================================
                // BASE SEPARATION ROLL
                // ========================================
                // Use stats (visible to player) for separation, not coreAttributes
                // This ensures the simulation matches what players see on their roster
                let receiverRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver, null);

                // Crossing route bonus - route running helps execute cuts cleanly
                // Reduced from 0.3 to 0.10 for better balance
                if (isCrossing) {
                    const crossingBonus = receiver.stats.routeRunning * 0.10;
                    receiverRoll += crossingBonus;
                }

                // Break round bonus (the "snap" of the route creates separation)
                // Reduced from 0.25 to 0.08 for better balance
                if (isBreakRound) {
                    const breakBonus = receiver.stats.routeRunning * 0.08;
                    receiverRoll += breakBonus;
                }

                // ========================================
                // DEFENDER ROLL
                // ========================================
                // Use stats (visible to player) for separation, not coreAttributes
                let defenderRoll = weightedStatRoll(defender.stats, CLASH_WEIGHTS.separation.defender, null);

                // Defender counter-bonuses to balance WR route bonuses
                // Awareness helps read the route and anticipate breaks
                const awarenessBonus = (defender.stats.awareness || 70) * 0.08;
                defenderRoll += awarenessBonus;

                // Awareness also helps track the receiver through cuts
                if (isCrossing || isBreakRound) {
                    const trackingBonus = (defender.stats.awareness || 70) * 0.06;
                    defenderRoll += trackingBonus;
                }

                // ========================================
                // APPLY MOMENTUM ADVANTAGE
                // ========================================
                // The momentum advantage goes directly to separation
                // Positive = WR gained separation from the cut
                receiverRoll += momentumAdvantage;

                // ========================================
                // UPDATE MOMENTUM FOR NEXT ROUND
                // ========================================
                if (directionChanged) {
                    // Both reset to 1 after direction change
                    receiver.momentum = 1;
                    defender.momentum = 1;
                } else {
                    // Build momentum in current direction (cap at 5 for stronger effect)
                    receiver.momentum = Math.min(receiver.momentum + 1, 5);
                    defender.momentum = Math.min(defender.momentum + 1, 5);
                }

                receiver.lastDirection = currentDirection;
                defender.lastDirection = currentDirection;

                // Calculate separation margin
                receiver.separation = receiverRoll - defenderRoll;
            }
        }

        // Calculate catch probabilities using exponential distribution
        function simCalculateCatchProbabilities(state) {
            const pressure = state.totalPressure;
            const qbAgility = state.qb.coreAttributes?.agility || 70;

            for (const receiver of state.receivers) {
                // Use short or long pass accuracy based on depth (12 yards = break point)
                const isShortPass = receiver.currentDepth < 12;
                const passAccStat = isShortPass
                    ? (state.qb.stats.shortPassAcc || state.qb.stats.throwing || 70)
                    : (state.qb.stats.longPassAcc || state.qb.stats.throwing || 70);

                // Multiplicative accuracy: agility √ó passAcc
                const qbAccuracy = (qbAgility / 100) * (passAccStat / 100) * 100;

                // QB throw quality - rollMean determines accuracy distribution
                const rollMean = 79 + (75 - qbAccuracy) * 1.7 + pressure * 0.5;

                let catchProb = receiver.stats.catching;

                // Separation bonus/penalty
                if (receiver.separation >= 20) {
                    catchProb += 15;
                } else if (receiver.separation >= 10) {
                    catchProb += 8;
                } else if (receiver.separation >= 3) {
                    catchProb += 3;
                } else if (receiver.separation >= -3) {
                    catchProb += 0;
                } else if (receiver.separation >= -10) {
                    catchProb -= 15;
                } else {
                    catchProb -= 30;
                }

                // Contested catch bonus from catching skill
                if (receiver.separation < 5) {
                    const contestedBonus = (receiver.stats.catching - 70) * 0.2;
                    catchProb += contestedBonus;
                }

                // Depth penalty for longer throws (reduced by good long pass accuracy)
                const depthPenalty = Math.max(0, (receiver.currentDepth - 15) * 0.3);
                catchProb -= depthPenalty;

                // Bonus zone catch boost (check if receiver is in a bonus zone)
                const bonusZone = checkBonusZones(receiver.position);
                if (bonusZone) {
                    catchProb += bonusZone.config.catchBonus;
                    receiver.inBonusZone = bonusZone.config.name;
                } else {
                    receiver.inBonusZone = null;
                }

                // Clamp
                catchProb = Math.max(5, Math.min(95, catchProb));

                // Calculate effective catch % with exponential
                const effectiveCatchPct = (1 - Math.exp(-catchProb / rollMean)) * 100;

                receiver.catchProbability = catchProb;
                receiver.effectiveCatchPct = effectiveCatchPct;
                receiver.rollMean = rollMean;
                receiver.qbAccuracy = qbAccuracy;  // Store for display
            }
        }

        // QB decision: should throw, and to whom?
        function processQBDecision(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;
            const qbStats = state.qb.stats;

            // Step 1: Vision check - can QB see each receiver?
            const visibleReceivers = [];
            for (const receiver of state.receivers) {
                const qbInt = state.qb.coreAttributes?.intelligence || 70;
                const visionRoll = weightedStatRoll(qbStats, {
                    awareness: 0.70
                }, state.qb.coreAttributes) * 0.7 + qbInt * 0.3;

                // Easier to notice more open receivers
                const noticeThreshold = 70 - receiver.separation;
                const noticeRoll = visionRoll + (Math.random() * 20 - 10);

                if (noticeRoll >= noticeThreshold) {
                    visibleReceivers.push(receiver);
                }
            }

            // Step 2: Evaluate throw options
            let throwLikelihood = 0;
            let bestTarget = null;
            let bestScore = -999;

            for (const receiver of visibleReceivers) {
                let score = receiver.effectiveCatchPct;

                // First down consideration
                const wouldGetFirstDown = receiver.currentDepth >= state.yardsToGo;
                if (wouldGetFirstDown) {
                    score += trait.firstDownBias;
                } else {
                    score -= state.round * 3;  // Penalty for short throws late
                }

                // Down urgency
                if (state.down >= 3 && !wouldGetFirstDown) {
                    score -= 15;
                }

                // Trait threshold
                if (receiver.effectiveCatchPct < trait.openThreshold) {
                    score -= 20;
                }

                // Aggressiveness for contested
                if (receiver.separation < 5) {
                    score *= trait.aggressiveness;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = receiver;
                }
            }

            // Step 3: Calculate throw likelihood
            if (bestTarget) {
                throwLikelihood = bestScore;

                // Pressure urgency
                const pressureUrgency = state.totalPressure * trait.pressureMultiplier;
                throwLikelihood += pressureUrgency * 0.5;

                // Round urgency
                throwLikelihood += state.round * 8;

                // Very high pressure = must throw
                if (state.totalPressure > 70) {
                    throwLikelihood += 30;
                }
            } else {
                // No visible targets
                throwLikelihood = state.totalPressure * 0.5 + state.round * 10;
            }

            // Step 4: Roll to throw
            const throwRoll = Math.random() * 100;
            const shouldThrow = throwRoll < throwLikelihood;

            return {
                shouldThrow,
                target: bestTarget,
                throwLikelihood,
                visibleReceivers
            };
        }

        // Resolve a throw attempt
        function simResolveThrow(state, target) {
            if (!target) {
                return {
                    type: 'throwaway',
                    yardsGained: 0,
                    description: 'QB throws the ball away',
                    _targetReceiver: null,
                    _qbRoll: 0,
                    _catchSuccess: false
                };
            }

            // Exponential roll for throw quality
            const qbRoll = -target.rollMean * Math.log(Math.random());
            const caught = qbRoll < target.catchProbability;

            let result;
            if (caught) {
                result = simResolveCatchAndRun(state, target);
            } else {
                result = simResolveIncompletions(state, target, qbRoll);
            }

            // Attach tracking info for legacy display
            result._targetReceiver = target;
            result._qbRoll = qbRoll;
            result._catchSuccess = caught;

            return result;
        }

        // Resolve incomplete pass (check for INT)
        function simResolveIncompletions(state, receiver, qbRoll) {
            const defenderIndex = state.receivers.indexOf(receiver);
            const defender = state.defenders[defenderIndex] || state.defenders[0];

            if (defender && receiver.separation < 0) {
                const throwBadness = qbRoll - receiver.catchProbability;

                let intChance = Math.min(throwBadness * 0.4, 25);
                intChance += (defender.stats.awareness - 60) * 0.2;
                intChance += ((defender.stats.catching || 50) - 50) * 0.1;

                if (receiver.separation < -10) {
                    intChance += 5;
                }

                intChance = Math.max(5, Math.min(35, intChance));

                if (Math.random() * 100 < intChance) {
                    return {
                        type: 'interception',
                        yardsGained: 0,
                        interceptedBy: defender.player,
                        description: `Intercepted by ${getPlayerFullName(defender.player)}!`
                    };
                }
            }

            return {
                type: 'incomplete',
                yardsGained: 0,
                description: 'Pass incomplete'
            };
        }

        // Resolve catch and YAC
        function simResolveCatchAndRun(state, receiver) {
            let totalYards = receiver.currentDepth;
            const yacEvents = [];

            // Find nearest defender for tackle
            const defenderIndex = state.receivers.indexOf(receiver);
            const nearestDB = state.defenders[defenderIndex] || state.defenders[0];

            // Immediate tackle attempt if tightly covered (separation < 5)
            // Separation 5-15: chance to avoid immediate tackle based on separation
            // Separation 15+: skip immediate tackle, go straight to YAC
            const skipImmediateTackle = receiver.separation >= 15 ||
                (receiver.separation >= 5 && Math.random() * 100 < receiver.separation * 5);

            if (nearestDB && !skipImmediateTackle) {
                // Separation gives evasion bonus (less covered = harder to tackle)
                const separationBonus = Math.max(0, receiver.separation * 0.5);
                const tackleResult = simResolveTackleAttempt(receiver, nearestDB, -separationBonus);

                if (tackleResult.tackled) {
                    return {
                        type: 'complete',
                        yardsGained: totalYards,
                        caughtBy: receiver.player,
                        tackledBy: nearestDB.player,
                        yac: 0,
                        description: `Caught for ${totalYards} yards, tackled immediately`
                    };
                }
                yacEvents.push(tackleResult);
            }

            // YAC phase - up to 3 tackle attempts
            let tackled = false;
            for (let attempt = 0; attempt < 3 && !tackled; attempt++) {
                // YAC yards proportional to receiver stats
                const yacRoll = weightedStatRoll(receiver.stats, {
                    speed: 0.35,
                    acceleration: 0.25,
                    agility: 0.25,
                    evasion: 0.15
                }, receiver.player.coreAttributes);
                const segmentYards = Math.floor(2 + (yacRoll / 100) * 10);

                // Find next tackler (cycle through defenders, safety gets bonus)
                const tacklerIndex = (defenderIndex + attempt + 1) % state.defenders.length;
                const tackler = state.defenders[tacklerIndex];

                if (!tackler) {
                    totalYards += segmentYards;
                    continue;
                }

                // Safety bonus on later attempts
                const safetyBonus = (tackler.position === 'S' || attempt > 0) ? (10 + attempt * 5) : 0;
                const tackleResult = simResolveTackleAttempt(receiver, tackler, safetyBonus);

                if (tackleResult.tackled) {
                    totalYards += Math.floor(segmentYards * 0.5);
                    tackled = true;
                    yacEvents.push(tackleResult);
                } else {
                    totalYards += segmentYards;
                    yacEvents.push(tackleResult);
                }
            }

            // Check for TD
            const isTouchdown = totalYards >= state.yardsFromGoal;

            return {
                type: isTouchdown ? 'touchdown' : 'complete',
                yardsGained: isTouchdown ? state.yardsFromGoal : totalYards,
                caughtBy: receiver.player,
                tackledBy: yacEvents.find(e => e.tackled)?.tackler || null,
                yac: totalYards - receiver.currentDepth,
                description: isTouchdown ?
                    `TOUCHDOWN! ${totalYards} yard catch and run!` :
                    `Caught for ${receiver.currentDepth} yards, ${totalYards - receiver.currentDepth} YAC`
            };
        }

        // Resolve a tackle attempt
        function simResolveTackleAttempt(receiver, tackler, safetyBonus) {
            const evasionRoll = weightedStatRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier, receiver.player.coreAttributes);
            let tackleRoll = weightedStatRoll(tackler.stats, CLASH_WEIGHTS.tackle.tackler, tackler.player.coreAttributes);

            // Tackler advantage: WRs have natural +7 advantage from primary stat bonuses
            // on speed/agility, while CBs don't get bonuses on tackling/pursuit/hitPower.
            // Add a base tackler bonus to compensate and make tackling realistic.
            const tacklerBonus = 10;
            tackleRoll += tacklerBonus + safetyBonus;

            const margin = tackleRoll - evasionRoll;
            const breakTackleThreshold = -12;

            if (margin > breakTackleThreshold) {
                return {
                    type: 'tackle',
                    tackled: true,
                    tackler: tackler.player,
                    margin
                };
            } else {
                return {
                    type: 'broken_tackle',
                    tackled: false,
                    tackler: tackler.player,
                    margin
                };
            }
        }

        // Resolve sack
        function simResolveSack(state) {
            const sackYards = 5 + Math.floor(Math.random() * 6);
            return {
                type: 'sack',
                yardsGained: -sackYards,
                tackler: state.sackingPlayer,
                description: `Sacked for a loss of ${sackYards} yards`
            };
        }

        // Resolve desperation play (max rounds exceeded)
        function simResolveDesperationPlay(state) {
            const trait = QB_TRAITS[state.qb.trait] || QB_TRAITS.balanced;

            if (state.totalPressure > 60 && Math.random() < 0.4) {
                return {
                    type: 'sack',
                    yardsGained: -Math.floor(5 + Math.random() * 5),
                    description: 'Sacked after holding the ball too long'
                };
            }

            // Scrambler might run
            if (trait.scrambleBonus && Math.random() < 0.3) {
                const qbSpeed = state.qb.coreAttributes?.speed || 70;
                const qbAgility = state.qb.coreAttributes?.agility || 70;
                const scrambleYards = Math.floor(
                    (qbSpeed * 0.1) +
                    (qbAgility * 0.05) +
                    Math.random() * 5
                );
                return {
                    type: 'scramble',
                    yardsGained: scrambleYards,
                    description: `QB scrambles for ${scrambleYards} yards`
                };
            }

            // Heave to best available
            const bestReceiver = state.receivers.reduce((best, r) =>
                r.effectiveCatchPct > (best?.effectiveCatchPct || 0) ? r : best, null
            );

            if (bestReceiver && bestReceiver.effectiveCatchPct > 20) {
                bestReceiver.catchProbability *= 0.7;
                return simResolveThrow(state, bestReceiver);
            }

            return {
                type: 'throwaway',
                yardsGained: 0,
                description: 'QB throws it away under pressure'
            };
        }

        // Main play simulation loop
        function simulatePlayRoundBased(offense, defense, fieldPosition) {
            const state = initializePlayState(offense, defense, fieldPosition);

            // Track round-by-round events for debugging display
            state.roundEvents = [];

            while (state.round < state.maxRounds && !state.result) {
                state.round++;
                const roundEvent = { round: state.round, events: [] };

                // Phase 1: OL/DL Clashes
                processLineClashesRound(state);

                // Track line clash results
                if (state.lineMatchups && state.lineMatchups.length > 0) {
                    const lastMatchup = state.lineMatchups[state.lineMatchups.length - 1];
                    if (lastMatchup && lastMatchup.result !== 'held' && lastMatchup.result !== 'stonewalled') {
                        roundEvent.events.push({
                            type: 'pressure',
                            player: lastMatchup.dl?.firstName || 'DL',
                            result: lastMatchup.result,
                            pressure: state.totalPressure
                        });
                    }
                }

                // Check for sack
                if (state.sacked) {
                    roundEvent.events.push({ type: 'sack', player: state.sackingPlayer?.firstName || 'DL' });
                    state.roundEvents.push(roundEvent);
                    state.result = simResolveSack(state);
                    break;
                }

                // Phase 2: WR/DB Separation
                processReceiverClashesRound(state);

                // Track separation changes for each receiver
                state.receivers.forEach((rec, i) => {
                    const sep = Math.round(rec.separation || 0);
                    const status = sep > 15 ? 'open' : sep > 5 ? 'space' : sep > -5 ? 'contested' : 'covered';
                    if (rec.momentumAdvantage && rec.momentumAdvantage > 5) {
                        roundEvent.events.push({
                            type: 'route_break',
                            wr: i + 1,
                            momentum: rec.momentumAdvantage,
                            status: status
                        });
                    }
                });

                // Phase 3: Calculate catch probabilities
                simCalculateCatchProbabilities(state);

                // Phase 4: QB Decision
                const decision = processQBDecision(state);

                if (decision.shouldThrow) {
                    roundEvent.events.push({
                        type: 'throw',
                        target: decision.targetIndex + 1,
                        catchProb: Math.round(decision.target?.catchProbability || 0)
                    });
                    state.roundEvents.push(roundEvent);
                    state.result = simResolveThrow(state, decision.target);
                    break;
                }

                // Only add round if something notable happened
                if (roundEvent.events.length > 0) {
                    state.roundEvents.push(roundEvent);
                }
            }

            // Desperation if no throw
            if (!state.result) {
                state.result = simResolveDesperationPlay(state);
            }

            state.result.roundsElapsed = state.round;
            state.result.finalPressure = state.totalPressure;
            state.result.roundEvents = state.roundEvents || [];

            // ========================================
            // BUILD LEGACY-COMPATIBLE DISPLAY PROPERTIES
            // ========================================

            // Attach QB
            state.result.qb = state.qb.player;

            // Attach sackingPlayer for sacks
            if (state.result.type === 'sack') {
                state.result.sackingPlayer = state.sackingPlayer;
            }

            // Build pressureInfo (legacy format)
            const pressureLevel = state.totalPressure >= 70 ? 'heavy' :
                                  state.totalPressure >= 50 ? 'moderate' :
                                  state.totalPressure >= 25 ? 'light' : 'none';

            state.result.pressureInfo = {
                totalPressure: state.totalPressure,
                pressureLevel: pressureLevel,
                matchups: state.lineMatchups,
                sackingDL: state.sackingPlayer || null
            };

            // Build catchInfo for pass plays
            const targetReceiver = state.result._targetReceiver;
            if (targetReceiver) {
                const receiverIndex = state.receivers.indexOf(targetReceiver);
                const defender = state.defenders[receiverIndex] || state.defenders[0];

                // Calculate display values
                const wrRoll = Math.round(targetReceiver.separation + 50);
                const cbRoll = Math.round(50 - targetReceiver.separation);
                const separationMargin = targetReceiver.separation;
                const coverageCloseness = Math.max(0, Math.min(1, 1 - (separationMargin + 30) / 60));
                const defenderPenalty = Math.round(Math.pow(coverageCloseness, 3) * (defender?.stats?.coverage || 70) * 0.8);
                const baseCatch = targetReceiver.player?.stats?.catching || 70;
                const focusMod = (targetReceiver.player?.stats?.focus || 70) - 60;
                const catchProb = Math.round(targetReceiver.catchProbability);
                const qbAccuracy = state.qb.player?.stats?.accuracy || 70;

                state.result.catchInfo = {
                    receiver: targetReceiver.player,
                    cb: defender?.player || null,
                    wrRoll: wrRoll,
                    cbRoll: cbRoll,
                    separationMargin: Math.round(separationMargin),
                    coverageCloseness: Math.round(coverageCloseness * 100) / 100,
                    defenderPenalty: defenderPenalty,
                    baseCatch: baseCatch,
                    focusMod: focusMod > 0 ? focusMod : 0,
                    catchProb: catchProb,
                    qbAccuracy: qbAccuracy,
                    pressure: Math.round(state.totalPressure),
                    rollMean: Math.round(targetReceiver.rollMean),
                    qbRoll: Math.round(state.result._qbRoll),
                    catchSuccess: state.result._catchSuccess,
                    throwGood: state.result._qbRoll < targetReceiver.rollMean * 1.5,
                    cbCoverage: defender?.stats?.coverage || 70,
                    effectiveCatchPct: Math.round(targetReceiver.effectiveCatchPct || catchProb),
                    // Momentum tracking for display
                    momentumAdvantage: targetReceiver.momentumAdvantage || 0,
                    dbReactionDelay: targetReceiver.dbReactionDelay || 0,
                    dbAwareness: defender?.stats?.awareness || 70
                };

                // Attach target slot
                state.result.targetSlot = ['WR1', 'WR2', 'WR3'][receiverIndex] || 'WR';
            }

            // Clean up internal tracking properties
            delete state.result._targetReceiver;
            delete state.result._qbRoll;
            delete state.result._catchSuccess;

            return state.result;
        }

        // Full drive simulation using round-based plays
        function simulateDriveRoundBased(offense, defense, startingFieldPosition) {
            let fieldPosition = { ...startingFieldPosition };
            const plays = [];
            let driveResult = null;

            const maxPlays = 15;

            while (!driveResult && plays.length < maxPlays) {
                // Store the pre-play situation
                const prePlayDown = fieldPosition.down;
                const prePlayYardsToGo = fieldPosition.yardsToGo;
                const prePlayYardsFromGoal = fieldPosition.yardsFromGoal;

                const playResult = simulatePlayRoundBased(offense, defense, fieldPosition);

                // Attach pre-play situation to the result for display
                playResult.down = prePlayDown;
                playResult.yardsToGo = prePlayYardsToGo;
                playResult.yardsFromGoal = prePlayYardsFromGoal;

                plays.push(playResult);

                // Update field position
                const newYardsFromGoal = fieldPosition.yardsFromGoal - playResult.yardsGained;
                const yardsGainedTowardFirst = playResult.yardsGained;

                // Check first down
                if (yardsGainedTowardFirst >= fieldPosition.yardsToGo) {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: 10,
                        down: 1
                    };
                } else {
                    fieldPosition = {
                        yardsFromGoal: Math.max(0, newYardsFromGoal),
                        yardsToGo: fieldPosition.yardsToGo - yardsGainedTowardFirst,
                        down: fieldPosition.down + 1
                    };
                }

                // Attach post-play situation
                playResult.newYardsFromGoal = fieldPosition.yardsFromGoal;
                playResult.newYardsToGo = fieldPosition.yardsToGo;
                playResult.newDown = fieldPosition.down;

                // Check for drive-ending results
                if (playResult.type === 'touchdown') {
                    driveResult = { points: 7, type: 'touchdown', plays };
                } else if (playResult.type === 'interception') {
                    driveResult = { points: 0, type: 'turnover', plays };
                } else if (fieldPosition.down > 4) {
                    if (fieldPosition.yardsFromGoal <= 40) {
                        const fgDistance = fieldPosition.yardsFromGoal + 17;
                        const fgSuccess = Math.random() < (0.95 - fgDistance * 0.01);

                        // Mark the last play as a field goal attempt for display
                        playResult.fieldGoalAttempt = true;
                        playResult.fieldGoalSuccess = fgSuccess;

                        driveResult = {
                            points: fgSuccess ? 3 : 0,
                            type: fgSuccess ? 'field_goal' : 'missed_fg',
                            plays
                        };
                    } else {
                        driveResult = { points: 0, type: 'punt', plays };
                    }
                }
            }

            if (!driveResult) {
                driveResult = { points: 0, type: 'punt', plays };
            }

            return driveResult;
        }

        // Simulate player's offensive drive using high-fidelity system
        // Can be used for "auto-play" or "simulate" option
        function simulatePlayerDriveHighFidelity(playerTeam, opponent) {
            // Get player offense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            let playerQB = dc.QB ? roster.find(p => p.id === dc.QB) : null;
            if (!playerQB) playerQB = generateWalkOn('QB');

            const playerWRs = [];
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerWRs.push(player);
                }
            });

            const playerOL = [];
            (dc.OL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerOL.push(player);
                }
            });

            // Get opponent defense
            const oppCBs = opponent.roster.filter(p => p.position === 'CB').sort((a, b) => b.overall - a.overall);
            const oppDL = opponent.roster.filter(p => p.position === 'DL').sort((a, b) => b.overall - a.overall);

            // Fill walk-ons if needed
            while (playerWRs.length < 3) playerWRs.push(generateWalkOn('WR'));
            while (playerOL.length < 5) playerOL.push(generateWalkOn('OL'));
            while (oppCBs.length < 4) oppCBs.push(generateWalkOn('CB'));
            while (oppDL.length < 4) oppDL.push(generateWalkOn('DL'));

            // Build offense/defense objects
            const offense = {
                qb: playerQB,
                receivers: playerWRs.slice(0, 3),
                oLine: playerOL.slice(0, 5)
            };

            const defense = {
                dbs: oppCBs.slice(0, 4),
                dLine: oppDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Record offensive stats for player's team
            if (result.plays && roster) {
                result.plays.forEach(play => {
                    // QB stats - completions/incompletions and passing yards
                    if (playerQB && playerQB.id) {
                        const qbStats = gameStats.getPlayer(playerQB.id, `${playerQB.firstName} ${playerQB.lastName}`);
                        if (play.type === 'complete' || play.type === 'touchdown') {
                            qbStats.completions++;
                            qbStats.passingYards += (play.yardsGained || 0);
                        } else if (play.type === 'incomplete' || play.type === 'interception') {
                            qbStats.incompletions++;
                        }
                    }

                    // Receiver stats - catches, yards, TDs
                    if ((play.type === 'complete' || play.type === 'touchdown') && play.catchInfo && play.catchInfo.receiver) {
                        const receiver = play.catchInfo.receiver;
                        if (receiver.id) {
                            const rosterPlayer = roster.find(p => p.id === receiver.id);
                            if (rosterPlayer) {
                                const rStats = gameStats.getPlayer(rosterPlayer.id, `${rosterPlayer.firstName} ${rosterPlayer.lastName}`);
                                rStats.catches++;
                                rStats.receivingYards += (play.yardsGained || 0);
                                rStats.yardsAfterCatch += (play.yac || 0);
                                if (play.type === 'touchdown') {
                                    rStats.touchdowns++;
                                }
                                // Update season stats
                                if (rosterPlayer.seasonCatches === undefined) rosterPlayer.seasonCatches = 0;
                                rosterPlayer.seasonCatches++;
                                if (play.type === 'touchdown') {
                                    if (rosterPlayer.seasonTDs === undefined) rosterPlayer.seasonTDs = 0;
                                    rosterPlayer.seasonTDs++;
                                }
                            }
                        }
                    }

                    // OL clash stats
                    if (play.pressureInfo && play.pressureInfo.matchups) {
                        play.pressureInfo.matchups.forEach(matchup => {
                            if (matchup.ol && matchup.ol.id) {
                                const olPlayer = roster.find(p => p.id === matchup.ol.id);
                                if (olPlayer) {
                                    const olStats = gameStats.getPlayer(olPlayer.id, `${olPlayer.firstName} ${olPlayer.lastName}`);
                                    if (matchup.margin < -2) {
                                        olStats.clashesWon++;
                                    } else if (matchup.margin > 5) {
                                        olStats.clashesLost++;
                                    }
                                }
                            }
                        });
                    }
                });
            }

            // Add team reference
            result.team = playerTeam;

            return result;
        }

        // Adapter to use new round-based simulation for enemy possessions
        function simulateEnemyDriveHighFidelity(opponent, playerTeam) {
            // Get opponent offense
            let oppQB = opponent.roster.find(p => p.position === 'QB');
            if (!oppQB) oppQB = generateWalkOn('QB');

            const oppWRs = opponent.roster.filter(p => p.position === 'WR').sort((a, b) => b.overall - a.overall);
            const oppOL = opponent.roster.filter(p => p.position === 'OL').sort((a, b) => b.overall - a.overall);

            // Get player defense from depth chart
            const dc = playerTeam.depthChart;
            const roster = playerTeam.roster;

            const playerCBs = [];
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const id = dc[slot];
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerCBs.push(player);
                }
            });

            const playerDL = [];
            (dc.DL || []).forEach(id => {
                if (id) {
                    const player = roster.find(p => p.id === id);
                    if (player) playerDL.push(player);
                }
            });

            // Fill walk-ons if needed (4 CBs to match opponent defense setup)
            while (playerCBs.length < 4) playerCBs.push(generateWalkOn('CB'));
            while (playerDL.length < 4) playerDL.push(generateWalkOn('DL'));
            while (oppWRs.length < 3) oppWRs.push(generateWalkOn('WR'));
            while (oppOL.length < 5) oppOL.push(generateWalkOn('OL'));

            // Build offense/defense objects for new simulation
            const offense = {
                qb: oppQB,
                receivers: oppWRs.slice(0, 3),
                oLine: oppOL.slice(0, 5)
            };

            const defense = {
                dbs: playerCBs.slice(0, 4),
                dLine: playerDL.slice(0, 4)
            };

            const startingFieldPosition = {
                yardsFromGoal: 75,  // Own 25
                yardsToGo: 10,
                down: 1
            };

            // Run the new high-fidelity simulation
            const result = simulateDriveRoundBased(offense, defense, startingFieldPosition);

            // Record defensive stats for player's team
            if (result.plays && roster) {
                result.plays.forEach(play => {
                    // Sack - credit DL player
                    if (play.type === 'sack' && play.sackingPlayer && play.sackingPlayer.id) {
                        const dlPlayer = roster.find(p => p.id === play.sackingPlayer.id);
                        if (dlPlayer) {
                            if (dlPlayer.seasonSacks === undefined) dlPlayer.seasonSacks = 0;
                            dlPlayer.seasonSacks++;
                            gameStats.getPlayer(dlPlayer.id, `${dlPlayer.firstName} ${dlPlayer.lastName}`).sacks++;
                        }
                    }

                    // DL clash stats from pressure info
                    if (play.pressureInfo && play.pressureInfo.matchups) {
                        play.pressureInfo.matchups.forEach(matchup => {
                            if (matchup.dl && matchup.dl.id) {
                                const dlPlayer = roster.find(p => p.id === matchup.dl.id);
                                if (dlPlayer) {
                                    const dlStats = gameStats.getPlayer(dlPlayer.id, `${dlPlayer.firstName} ${dlPlayer.lastName}`);
                                    // DL wins if margin is positive (dl beat ol)
                                    if (matchup.margin > 2) {
                                        dlStats.clashesWon++;
                                        dlStats.clashDifficulties.push(matchup.margin);
                                    } else if (matchup.margin < -2) {
                                        dlStats.clashesLost++;
                                        dlStats.clashDifficulties.push(matchup.margin);
                                    }
                                }
                            }
                        });
                    }

                    // Pass defended - credit CB
                    if (play.type === 'incomplete' && play.catchInfo && play.catchInfo.cb && play.catchInfo.cb.id) {
                        const cbPlayer = roster.find(p => p.id === play.catchInfo.cb.id);
                        if (cbPlayer) {
                            if (cbPlayer.seasonPassesDefended === undefined) cbPlayer.seasonPassesDefended = 0;
                            cbPlayer.seasonPassesDefended++;
                            gameStats.getPlayer(cbPlayer.id, `${cbPlayer.firstName} ${cbPlayer.lastName}`).passesDefended++;
                        }
                    }

                    // Tackle - credit CB when completion is not a TD
                    if (play.type === 'complete' && play.catchInfo && play.catchInfo.cb && play.catchInfo.cb.id) {
                        const cbPlayer = roster.find(p => p.id === play.catchInfo.cb.id);
                        if (cbPlayer) {
                            if (cbPlayer.seasonTackles === undefined) cbPlayer.seasonTackles = 0;
                            cbPlayer.seasonTackles++;
                            gameStats.getPlayer(cbPlayer.id, `${cbPlayer.firstName} ${cbPlayer.lastName}`).tackles++;
                        }
                    }
                });
            }

            // Add opponent reference for compatibility
            result.opponent = opponent;

            return result;
        }

        // Simulate enemy possession using high-fidelity simulation
        function simulateEnemyPossession(opponent) {
            try {
                console.log('Starting enemy drive simulation (high-fidelity) for:', opponent?.name);
                console.log('Opponent roster size:', opponent?.roster?.length);
                console.log('Player team exists:', !!managementState.team);
                console.log('Player depthChart exists:', !!managementState.team?.depthChart);

                // Generate roster if missing
                if (opponent && !opponent.roster) {
                    console.log('Generating missing roster for opponent:', opponent.name);
                    // Use targetOverall if available, otherwise fall back to difficulty-based
                    if (opponent.targetOverall) {
                        opponent.roster = generateRosterWithTargetOverall(opponent.targetOverall);
                    } else {
                        opponent.roster = generateOpponentRoster(opponent.difficulty || 'medium');
                    }
                }

                // Validate required data
                if (!opponent || !opponent.roster || !managementState.team || !managementState.team.depthChart) {
                    throw new Error('Missing required simulation data');
                }

                // Use the new high-fidelity round-based simulation
                const driveResult = simulateEnemyDriveHighFidelity(opponent, managementState.team);

                console.log('Drive result:', driveResult.type, 'with', driveResult.plays?.length, 'plays');

                // Format narrative from new play format
                const narrative = driveResult.plays.map((p, i) => {
                    const down = Math.min(4, Math.floor(i / 3) + 1);
                    if (p.type === 'sack') {
                        return `Sack! ${p.description}`;
                    } else if (p.type === 'interception') {
                        return `INTERCEPTION! ${p.description}`;
                    } else if (p.type === 'touchdown') {
                        return `TOUCHDOWN! ${p.description}`;
                    } else if (p.type === 'complete') {
                        return `Complete! ${p.yardsGained} yards${p.yac > 0 ? ` (${p.yac} YAC)` : ''}`;
                    } else if (p.type === 'incomplete') {
                        return 'Pass incomplete';
                    } else if (p.type === 'throwaway') {
                        return 'QB throws it away';
                    } else if (p.type === 'scramble') {
                        return p.description;
                    }
                    return `${p.type}: ${p.yardsGained} yards`;
                });

                return {
                    points: driveResult.points,
                    type: driveResult.type,
                    plays: driveResult.plays,
                    opponent: driveResult.opponent,
                    narrative
                };
            } catch (error) {
                console.error('Enemy drive simulation error:', error);
                console.error('Error stack:', error.stack);
                // Fallback to simple result on error
                const roll = Math.random() * 100;
                const points = roll < 50 ? 7 : roll < 70 ? 3 : 0;
                const type = points === 7 ? 'TD' : points === 3 ? 'FG' : 'STOP';
                return {
                    points,
                    type,
                    plays: [],
                    opponent,
                    narrative: [type === 'TD' ? 'Touchdown!' : type === 'FG' ? 'Field goal!' : 'Defensive stop!']
                };
            }
        }

        // Format a play into narrative text
        function formatPlayNarrative(play, opponent) {
            const teamShort = opponent.name.split(' ')[0];
            const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

            if (play.type === 'sack') {
                const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your defense';
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${dlName} breaks through! SACK for ${Math.abs(play.yardsGained)} yard loss!`;
            }

            if (play.fieldGoalAttempt) {
                const distance = play.yardsFromGoal + 17; // Add end zone
                if (play.fieldGoalSuccess) {
                    return `Field goal attempt from ${distance} yards... GOOD!`;
                } else {
                    return `Field goal attempt from ${distance} yards... NO GOOD!`;
                }
            }

            const wrName = play.catchInfo?.receiver ? getPlayerFullName(play.catchInfo.receiver) : `${teamShort} WR`;
            const cbName = play.catchInfo?.cb ? getPlayerFullName(play.catchInfo.cb) : 'Your CB';

            if (play.type === 'complete') {
                if (play.isTouchdown) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} finds ${wrName}... TOUCHDOWN ${opponent.name}!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} hits ${wrName} for ${play.yardsGained} yards.`;
            } else {
                if (!play.catchInfo?.throwGood) {
                    return `${getDownString(play.down)} & ${play.yardsToGo}: ${qbName} under pressure, throws it away!`;
                }
                return `${getDownString(play.down)} & ${play.yardsToGo}: Pass to ${wrName} broken up by ${cbName}!`;
            }
        }

        function getDownString(down) {
            const ordinals = ['1st', '2nd', '3rd', '4th'];
            return ordinals[down - 1] || `${down}th`;
        }

        // Get display text for current game phase
        function getGamePhaseDisplay(result) {
            const phase = result.gamePhase || managementState.gamePhase || 'regulation';
            const possession = result.possession + 1;

            if (phase === 'overtime') {
                const otPossession = managementState.overtimePossession || 1;
                return `OVERTIME - Possession ${otPossession}`;
            } else if (phase === 'twoMinuteDrill') {
                return '2-MINUTE DRILL';
            } else {
                // Regulation - show as quarters
                const quarter = Math.min(possession, 4);
                const quarterNames = ['1st Quarter', '2nd Quarter', '3rd Quarter', '4th Quarter'];
                return quarterNames[quarter - 1] || `Quarter ${quarter}`;
            }
        }

        // Start a match
        function startMatch() {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                return { success: false, error: 'Season is over' };
            }

            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) {
                return { success: false, error: 'Game already played' };
            }

            managementState.matchInProgress = true;
            managementState.currentPossession = 0;
            managementState.matchScore = { player: 0, opponent: 0 };
            managementState.simulationLog = null;  // Clear sim log for regular games
            managementState.currentScreen = 'game';
            managementState.gamePhase = 'regulation';  // regulation, twoMinuteDrill, overtime
            managementState.overtimePossession = 0;
            managementState.fameAddedThisGame = false;  // Track if fame was already added

            // Reset per-game stats (critical: prevents stats from accumulating across games)
            Object.keys(gameStats.players).forEach(key => delete gameStats.players[key]);

            return { success: true, opponent: game.opponent, isHome: game.isHome };
        }

        // Simulate entire game without playing arcade mode
        function simulateFullGame() {
            try {
                if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                    return { success: false, error: 'Season is over' };
                }

                const game = managementState.season.schedule[managementState.season.week - 1];
                if (game.result) {
                    return { success: false, error: 'Game already played' };
                }

                const playerTeam = managementState.team;
                const opponent = game.opponent;

                // Generate opponent roster if missing
                if (!opponent.roster) {
                    console.log('[SIMULATE] Generating missing opponent roster');
                    if (opponent.targetOverall) {
                        opponent.roster = generateRosterWithTargetOverall(opponent.targetOverall);
                    } else {
                        opponent.roster = generateOpponentRoster(opponent.difficulty || 'medium');
                    }
                }

            // Initialize simulation log
            managementState.simulationLog = [];
            const log = (msg) => managementState.simulationLog.push(msg);

            log(`=== GAME SIMULATION: ${playerTeam.name} vs ${opponent.name} ===`);
            log(`Player Team OVR: ${Math.round(playerTeam.roster.reduce((s,p) => s + p.overall, 0) / playerTeam.roster.length)}`);
            log(`Opponent OVR: ${opponent.offenseRating}/${opponent.defenseRating}`);

            // Log team compositions for debugging
            const getAvgOvr = (players) => players.length ? Math.round(players.reduce((s,p) => s + (p.overall || 70), 0) / players.length) : 0;
            const playerWRs = playerTeam.roster.filter(p => p.position === 'WR');
            const playerCBs = playerTeam.roster.filter(p => p.position === 'CB');
            const playerOL = playerTeam.roster.filter(p => p.position === 'OL');
            const playerDL = playerTeam.roster.filter(p => p.position === 'DL');
            const playerQB = playerTeam.roster.find(p => p.position === 'QB');
            const oppWRs = opponent.roster.filter(p => p.position === 'WR');
            const oppCBs = opponent.roster.filter(p => p.position === 'CB');
            const oppOL = opponent.roster.filter(p => p.position === 'OL');
            const oppDL = opponent.roster.filter(p => p.position === 'DL');
            const oppQB = opponent.roster.find(p => p.position === 'QB');

            log(`Player Offense: QB:${playerQB?.overall || 'walk-on'} WRs:${getAvgOvr(playerWRs)}(${playerWRs.length}) OL:${getAvgOvr(playerOL)}(${playerOL.length})`);
            log(`Player Defense: CBs:${getAvgOvr(playerCBs)}(${playerCBs.length}) DL:${getAvgOvr(playerDL)}(${playerDL.length})`);
            log(`Opp Offense: QB:${oppQB?.overall || 'walk-on'} WRs:${getAvgOvr(oppWRs)}(${oppWRs.length}) OL:${getAvgOvr(oppOL)}(${oppOL.length})`);
            log(`Opp Defense: CBs:${getAvgOvr(oppCBs)}(${oppCBs.length}) DL:${getAvgOvr(oppDL)}(${oppDL.length})`);
            log('');

            // Reset per-game stats
            Object.keys(gameStats.players).forEach(key => delete gameStats.players[key]);
            managementState.fameAddedThisGame = false;

            let playerScore = 0;
            let opponentScore = 0;
            const possessionResults = [];

            // Helper to log drive details
            const logDrive = (drive, team, driveNum) => {
                log(`--- ${team} Drive #${driveNum} ---`);
                log(`Result: ${drive.type} (${drive.points || 0} pts)`);
                if (drive.plays) {
                    drive.plays.forEach((play, idx) => {
                        const down = play.down || '?';
                        const toGo = play.yardsToGo || '?';
                        const fromGoal = play.yardsFromGoal || '?';
                        log(`  Play ${idx+1}: ${down}&${toGo} at ${fromGoal}yd - ${play.type} for ${play.yardsGained || 0} yds`);
                        if (play.description) log(`    ${play.description}`);
                        // Add catch details if available
                        if (play.catchInfo) {
                            const ci = play.catchInfo;
                            log(`    [Sep:${ci.separationMargin || 0} Catch%:${ci.effectiveCatchPct || ci.catchProb || 0}]`);
                        }
                    });
                }
                log('');
            };

            // Simulate regulation possessions
            for (let i = 0; i < SEASON.POSSESSIONS_PER_GAME; i++) {
                // Player offense
                const playerDrive = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                const playerPoints = playerDrive.type === 'touchdown' ? 7 :
                                    playerDrive.type === 'field_goal' ? 3 : 0;
                playerScore += playerPoints;
                possessionResults.push({ team: 'player', result: playerDrive, points: playerPoints });
                logDrive(playerDrive, 'PLAYER OFFENSE', i + 1);

                // Enemy offense
                const enemyDrive = simulateEnemyDriveHighFidelity(opponent, playerTeam);
                const enemyPoints = enemyDrive.type === 'touchdown' ? 7 :
                                   enemyDrive.type === 'field_goal' ? 3 : 0;
                opponentScore += enemyPoints;
                possessionResults.push({ team: 'opponent', result: enemyDrive, points: enemyPoints });
                logDrive(enemyDrive, 'OPPONENT OFFENSE', i + 1);

                log(`Score after possession ${i+1}: Player ${playerScore} - Opponent ${opponentScore}`);
                log('');
            }

            // Handle overtime if tied
            let overtime = false;
            while (playerScore === opponentScore) {
                overtime = true;
                // Player gets one possession
                const playerOT = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                const playerOTPoints = playerOT.type === 'touchdown' ? 7 :
                                       playerOT.type === 'field_goal' ? 3 : 0;
                playerScore += playerOTPoints;

                // Opponent gets one possession
                const enemyOT = simulateEnemyDriveHighFidelity(opponent, playerTeam);
                const enemyOTPoints = enemyOT.type === 'touchdown' ? 7 :
                                      enemyOT.type === 'field_goal' ? 3 : 0;
                opponentScore += enemyOTPoints;

                // Max 3 OT periods
                if (possessionResults.length > SEASON.POSSESSIONS_PER_GAME * 2 + 6) break;
            }

            // Set match state for showMatchEnd
            managementState.matchInProgress = true;
            managementState.matchScore = { player: playerScore, opponent: opponentScore };
            managementState.currentPossession = SEASON.POSSESSIONS_PER_GAME;

            log(`=== FINAL SCORE: Player ${playerScore} - Opponent ${opponentScore} ===`);
            if (overtime) log('(Overtime)');

            return {
                success: true,
                playerScore,
                opponentScore,
                overtime,
                possessionResults,
                opponent
            };
            } catch (e) {
                console.error('[SIMULATE] Error during simulation:', e);
                return { success: false, error: e.message };
            }
        }

        // Get simulation log as text
        function getSimulationLog() {
            return (managementState.simulationLog || []).join('\n');
        }

        // Record possession result (called after each arcade possession)
        function recordPossessionResult(points) {
            if (!managementState.matchInProgress) return;

            managementState.matchScore.player += points;

            // Enemy gets counter-possession
            const game = managementState.season.schedule[managementState.season.week - 1];
            const enemyResult = simulateEnemyPossession(game.opponent);
            managementState.matchScore.opponent += enemyResult.points;

            managementState.currentPossession++;

            const playerScore = managementState.matchScore.player;
            const oppScore = managementState.matchScore.opponent;
            const scoreDiff = playerScore - oppScore;

            // Check game state based on phase
            if (managementState.gamePhase === 'regulation') {
                if (managementState.currentPossession >= SEASON.POSSESSIONS_PER_GAME) {
                    // End of 4 quarters
                    if (scoreDiff === 0) {
                        // Tied - go to overtime
                        managementState.gamePhase = 'overtime';
                        managementState.overtimePossession = 0;
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'overtime',
                            message: 'Tied game! Heading to overtime!'
                        };
                    } else if (scoreDiff < 0 && scoreDiff >= -7) {
                        // Losing by 7 or less - 2 minute drill
                        managementState.gamePhase = 'twoMinuteDrill';
                        return {
                            ongoing: true,
                            possession: managementState.currentPossession,
                            score: managementState.matchScore,
                            enemyResult,
                            gamePhase: 'twoMinuteDrill',
                            message: `Down by ${Math.abs(scoreDiff)}! 2-minute drill to tie or win!`
                        };
                    } else {
                        // Game over (winning or losing by more than 7)
                        return endMatch();
                    }
                }
            } else if (managementState.gamePhase === 'twoMinuteDrill') {
                // After 2-minute drill possession
                if (scoreDiff === 0) {
                    // Tied - go to overtime
                    managementState.gamePhase = 'overtime';
                    managementState.overtimePossession = 0;
                    return {
                        ongoing: true,
                        possession: managementState.currentPossession,
                        score: managementState.matchScore,
                        enemyResult,
                        gamePhase: 'overtime',
                        message: 'Tied game! Heading to overtime!'
                    };
                } else {
                    // Game over (win or loss)
                    return endMatch();
                }
            } else if (managementState.gamePhase === 'overtime') {
                managementState.overtimePossession++;
                // In overtime, check after each possession pair
                if (scoreDiff !== 0) {
                    // Someone is ahead - game over
                    return endMatch();
                }
                // Still tied - continue overtime
                return {
                    ongoing: true,
                    possession: managementState.currentPossession,
                    score: managementState.matchScore,
                    enemyResult,
                    gamePhase: 'overtime',
                    message: `Overtime continues! Still tied ${playerScore}-${oppScore}`
                };
            }

            return {
                ongoing: true,
                possession: managementState.currentPossession,
                score: managementState.matchScore,
                enemyResult,
                gamePhase: managementState.gamePhase
            };
        }

        // End match
        function endMatch() {
            if (!managementState.matchInProgress) return null;

            const game = managementState.season.schedule[managementState.season.week - 1];
            const win = managementState.matchScore.player > managementState.matchScore.opponent;

            // Record result
            game.result = {
                playerScore: managementState.matchScore.player,
                opponentScore: managementState.matchScore.opponent,
                win
            };

            // Update records
            if (win) {
                managementState.team.record.wins++;
            } else {
                managementState.team.record.losses++;
            }

            // Award revenue
            const revenue = awardGameRevenue(game.isHome);

            // Process weekly progression
            const progressionResults = processWeeklyProgression();

            // Advance week
            managementState.season.week++;

            // Check end of season
            let seasonEnded = false;
            if (managementState.season.week > SEASON.WEEKS) {
                processEndOfSeason();
                seasonEnded = true;
                managementState.seasonJustEnded = true;  // Flag for draft trigger
            }

            managementState.matchInProgress = false;
            managementState.currentScreen = 'hub';

            if (managementState.settings.autoSave) SaveSystem.save();

            return {
                ongoing: false,
                result: game.result,
                revenue,
                progression: progressionResults,
                seasonEnded
            };
        }

        // ========================================
        // MANAGEMENT LAYER - GAME INTEGRATION
        // ========================================

        // Get player from depth chart slot
        function getDepthChartPlayer(slot) {
            if (!managementState.team || !managementState.team.depthChart) return null;

            const dc = managementState.team.depthChart;
            let playerId;

            if (Array.isArray(dc[slot])) {
                // For OL/DL arrays, slot should be like 'OL' with index
                return null;  // Handle differently
            } else {
                playerId = dc[slot];
            }

            if (!playerId) return null;
            return managementState.team.roster.find(p => p.id === playerId);
        }

        // Generate walk-on player (lower stats but not terrible) for empty slots
        function generateWalkOn(position) {
            const player = generatePlayer(position, 'average');
            // Reduce stats moderately - walk-ons should be below average but not terrible
            Object.keys(player.stats).forEach(stat => {
                player.stats[stat] = Math.max(55, player.stats[stat] - 10);
            });
            player.firstName = 'Recruit';
            player.lastName = position;
            player.salaryCost = 0;
            player.overall = calculateOverall(player);
            return player;
        }

        // Convert roster player to game receiver config
        function playerToReceiverConfig(player, index, startZ) {
            const xPositions = [-5, 0, 5];
            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                lastName: player.lastName,
                overall: player.overall || calculateOverall(player),
                playerId: player.id,
                start: new BABYLON.Vector3(xPositions[index], 0, startZ),
                route: [],  // Will be generated
                stats: { ...player.stats },
                coreAttributes: player.coreAttributes || null
            };
        }

        // Convert roster player to game defender config
        function playerToDefenderConfig(player, index, startZ, receiverIndex) {
            const aiTypes = ['man', 'man', 'man', 'zone'];
            const cushions = [2, 4, 3, 4];
            const zoneColors = [
                new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(1.0, 0.5, 0.1)   // Orange for zone
            ];

            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                playerId: player.id,
                aiType: aiTypes[index],
                assignedReceiver: receiverIndex !== undefined ? receiverIndex : index,
                cushion: cushions[index],
                zoneCenter: index === 3 ? new BABYLON.Vector3(0, 0, startZ + 8) : null,
                zoneRadius: index === 3 ? 6 : 0,
                zoneColor: zoneColors[index],
                overall: player.overall,
                stats: { ...player.stats },
                coreAttributes: player.coreAttributes || null
            };
        }

        // Get receiver configs from roster
        function getReceiverConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                let player = getDepthChartPlayer(slot);
                if (!player) {
                    player = generateWalkOn('WR');
                }
                configs.push(playerToReceiverConfig(player, index, RECEIVER_START_Z));
            });

            return configs;
        }

        // Get defender configs from opponent's roster
        function getDefenderConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            // Get opponent's CBs sorted by overall
            const oppCBs = opponent.roster
                .filter(p => p.position === 'CB')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppCBs[i];
                if (!player) {
                    player = generateWalkOn('CB');
                }
                configs.push(playerToDefenderConfig(player, i, RECEIVER_START_Z, i < 3 ? i : undefined));
            }

            return configs;
        }

        // Get OL configs from roster
        function getOLineConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;
            }

            const configs = [];
            const posLabels = ['C', 'LG', 'RG', 'LT', 'RT'];

            managementState.team.depthChart.OL.forEach((playerId, index) => {
                let player = playerId ? managementState.team.roster.find(p => p.id === playerId) : null;
                if (!player) {
                    player = generateWalkOn('OL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[index],
                    stats: { ...player.stats },
                    coreAttributes: player.coreAttributes || null
                });
            });

            return configs;
        }

        // Get DL configs from opponent's roster
        function getDLineConfigsFromRoster() {
            // Get current opponent from the match
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;

            if (!opponent || !opponent.roster) {
                return null;
            }

            const configs = [];
            const posLabels = ['LDE', 'LDT', 'RDT', 'RDE'];

            // Get opponent's DL sorted by overall
            const oppDL = opponent.roster
                .filter(p => p.position === 'DL')
                .sort((a, b) => b.overall - a.overall);

            for (let i = 0; i < 4; i++) {
                let player = oppDL[i];
                if (!player) {
                    player = generateWalkOn('DL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[i],
                    stats: { ...player.stats },
                    coreAttributes: player.coreAttributes || null
                });
            }

            return configs;
        }

        // Record a stat for a roster player by their in-game mesh
        function recordPlayerStat(gameMesh, statName, increment = 1) {
            if (!gameMesh || !gameMesh.playerId) return;
            if (!managementState.team || !managementState.team.roster) return;

            const player = managementState.team.roster.find(p => p.id === gameMesh.playerId);
            if (!player) return;

            // Initialize stat if it doesn't exist
            if (player[statName] === undefined) player[statName] = 0;
            player[statName] += increment;
        }

        // Initialize management system
        function initializeManagement() {
            // Try to load existing save
            if (SaveSystem.exists()) {
                const saveData = SaveSystem.load();
                if (saveData && SaveSystem.applySaveData(saveData)) {
                    console.log('Loaded existing save');
                    // Resume draft if one was in progress
                    if (draftState.active) {
                        console.log('Resuming draft in progress');
                        managementState.currentScreen = 'draft';
                    } else {
                        managementState.currentScreen = 'hub';
                    }
                    return;
                }
            }

            // No save - show main menu
            managementState.currentScreen = 'main_menu';
        }

        // Start new game
        function startNewGame(teamName = 'Your Knights') {
            managementState.team = createNewTeam(teamName);
            managementState.season = createNewSeason();
            refreshFreeAgents();
            managementState.initialized = true;

            // Start with the draft
            startDraft(true);
        }

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 70;  // Extended for full 65-yard drive from own 35
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true
        });
        // Set hardware scaling for sharp rendering on high-DPI screens
        engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Camera is view-only, no user controls
            scene.activeCamera = camera;

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback - link to roster QB
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';
            qb.scaling = new BABYLON.Vector3(gameState.playerScale, gameState.playerScale, gameState.playerScale);

            // Link QB to roster player
            const rosterQB = getDepthChartPlayer('QB1');
            if (rosterQB) {
                qb.playerId = rosterQB.id;
                qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                qb.stats = { ...rosterQB.stats };
            } else {
                // Fallback stats
                qb.stats = {
                    shortPassAcc: 75, longPassAcc: 72, awareness: 70, agility: 65, speed: 60,
                    strength: 65
                };
            }

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line

            // Try to get roster configs, fall back to defaults
            const rosterReceiverConfigs = getReceiverConfigsFromRoster();
            const receiverConfigs = rosterReceiverConfigs || [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 80, acceleration: 72, agility: 85,
                        routeRunning: 88, catching: 84,
                        jumping: 70, strength: 60, evasion: 75,
                        stamina: 80
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 80, acceleration: 92, agility: 78,
                        routeRunning: 68, catching: 80,
                        jumping: 75, strength: 50, evasion: 65,
                        stamina: 85
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 80, acceleration: 78, agility: 80,
                        routeRunning: 82, catching: 82,
                        jumping: 82, strength: 72, evasion: 78,
                        stamina: 82
                    }
                }
            ];

            // Defender configurations - try roster first
            const rosterDefenderConfigs = getDefenderConfigsFromRoster();
            const defenderConfigs = rosterDefenderConfigs || [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 70, agility: 75,
                        manCoverage: 80, zoneCoverage: 80, press: 78,
                        tackling: 85, pursuit: 75,
                        awareness: 72, strength: 82,
                        stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 85, agility: 82,
                        manCoverage: 80, zoneCoverage: 80, press: 60,
                        tackling: 72, pursuit: 90,
                        awareness: 75, strength: 65,
                        stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'man',
                    assignedReceiver: 2,  // Covers Baron Wyatt
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 68, agility: 70,
                        manCoverage: 80, zoneCoverage: 80, press: 72,
                        tackling: 90, pursuit: 72,
                        awareness: 85, strength: 88,
                        stamina: 75
                    }
                },
                {
                    name: "The Sentinel",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 6,
                    cushion: 4,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 80, acceleration: 72, agility: 78,
                        manCoverage: 80, zoneCoverage: 80, press: 65,
                        tackling: 80, pursuit: 80,
                        awareness: 88, strength: 75,
                        stamina: 82
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            // Store references for route regeneration
            gameState.scene = scene;
            gameState.routeMaterial = routeMat;

            receiverConfigs.forEach((config, i) => {
                // Clone material so each receiver can flash independently
                const receiverMat = materials.receiverMaterial.clone(`receiverMat_${i}`);
                const receiver = createKnight(scene, receiverMat, config.start.clone());
                receiver.name = `receiver_${i}`;
                receiver.scaling = new BABYLON.Vector3(gameState.playerScale, gameState.playerScale, gameState.playerScale);
                receiver.bodyMaterial = receiverMat;
                receiver.originalColor = receiverMat.diffuseColor.clone();

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.lastName = config.lastName || config.name.split(' ').pop();  // Extract last name from display name if not provided
                // Calculate overall from WR position stats
                const wrStats = POSITIONS.WR.primaryStats;
                receiver.overall = config.overall || Math.round(wrStats.reduce((sum, stat) => sum + (config.stats[stat] || 0), 0) / wrStats.length);
                receiver.playerId = config.playerId || null;  // Link to roster player
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;
                receiver.coreAttributes = config.coreAttributes || null;

                // Derive base speed from core attributes (normalized to game units)
                // Scale speed by playerScale so larger players move proportionally faster
                const baseSpeed = receiver.coreAttributes?.speed || 70;
                receiver.baseSpeed = baseSpeed * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier * gameState.playerScale;
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // Legacy - kept for compatibility
                receiver.clashSpeedPenaltyUntil = 0;  // Clash loser speed penalty timer
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;  // Track if WR/DB were apart before clashing
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);  // White
                fillMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                fillMat.alpha = 0.5;  // Base visibility
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);  // Start with base visible circle

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation
                receiver.clashTiltUntil = 0;  // For grappling tilt
                receiver.clashTiltAngle = 0;
                receiver.loserFlashUntil = 0;   // Red flash when losing clash
                receiver.winnerFlashUntil = 0;  // Green flash when winning clash
                receiver.clashSpeedBoostUntil = 0;  // Speed boost timer

                // Hide the outer ring - only show proximity-based fill
                zoneRing.setEnabled(false);

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders (skip in training mode)
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            if (!gameState.trainingMode) {
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                // Clone material so each defender can flash independently
                const defenderMat = materials.defenderMaterial.clone(`defenderMat_${i}`);
                const defender = createKnight(scene, defenderMat, startPos);
                defender.name = `defender_${i}`;
                defender.scaling = new BABYLON.Vector3(gameState.playerScale, gameState.playerScale, gameState.playerScale);
                defender.bodyMaterial = defenderMat;
                defender.originalColor = defenderMat.diffuseColor.clone();

                // Store config data on defender
                defender.displayName = config.name;
                defender.playerId = config.playerId || null;  // Link to roster player
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.coreAttributes = config.coreAttributes || null;
                // Calculate overall from CB position stats
                const cbStats = POSITIONS.CB.primaryStats;
                defender.overall = config.overall || Math.round(cbStats.reduce((sum, stat) => sum + (config.stats[stat] || 0), 0) / cbStats.length);
                defender.startPos = startPos.clone();

                // Derive base speed from core attributes
                // Scale speed by playerScale so larger players move proportionally faster
                const baseSpeed = defender.coreAttributes?.speed || 70;
                defender.baseSpeed = baseSpeed * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier * gameState.playerScale;
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact
                defender.clashSpeedPenaltyUntil = 0;  // Speed penalty from losing clash

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation
                defender.clashTiltUntil = 0;  // For grappling tilt
                defender.clashTiltAngle = 0;
                defender.loserFlashUntil = 0;   // Red flash when losing clash
                defender.winnerFlashUntil = 0;  // Green flash when winning clash

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });
            } // End of training mode skip for defenders

            // Offensive Line configurations (5 players) - skip in training mode
            if (!gameState.trainingMode) {
            const LINE_OF_SCRIMMAGE_Z = RECEIVER_START_Z;  // Same as receivers start
            const rosterOLineConfigs = getOLineConfigsFromRoster();
            const defaultOLineConfigs = [
                {
                    name: "Sir Bulwark",
                    position: 'C',
                    startX: 0,
                    stats: { passBlock: 82, strength: 80, balance: 85, awareness: 80, speed: 60, acceleration: 65 }
                },
                {
                    name: "Ironside",
                    position: 'LG',
                    startX: -1.5,
                    stats: { passBlock: 80, strength: 85, balance: 78, awareness: 75, speed: 58, acceleration: 62 }
                },
                {
                    name: "Stonewall",
                    position: 'RG',
                    startX: 1.5,
                    stats: { passBlock: 78, strength: 88, balance: 80, awareness: 72, speed: 55, acceleration: 60 }
                },
                {
                    name: "Rampart",
                    position: 'LT',
                    startX: -3.5,
                    stats: { passBlock: 85, strength: 78, balance: 82, awareness: 78, speed: 62, acceleration: 68 }
                },
                {
                    name: "Bastion",
                    position: 'RT',
                    startX: 3.5,
                    stats: { passBlock: 83, strength: 80, balance: 80, awareness: 76, speed: 60, acceleration: 65 }
                }
            ];
            // Merge roster configs with default positions/startX
            const oLineConfigs = rosterOLineConfigs ? rosterOLineConfigs.map((rc, i) => ({
                ...defaultOLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultOLineConfigs;

            // Create Offensive Line
            oLineConfigs.forEach((config, i) => {
                const oLineMat = materials.oLineMaterial.clone(`oLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z - 0.5);
                const oLineman = createLineman(scene, oLineMat, startPos, true);
                oLineman.name = `oline_${i}`;
                oLineman.scaling = new BABYLON.Vector3(gameState.playerScale, gameState.playerScale, gameState.playerScale);
                oLineman.displayName = config.name;
                oLineman.playerId = config.playerId || null;  // Link to roster player
                oLineman.position_label = config.position;
                oLineman.positionType = 'OL';  // For ability calculations (don't use 'position' - it's a Babylon.js Vector3!)
                oLineman.stats = config.stats;
                oLineman.coreAttributes = config.coreAttributes || null;
                oLineman.startPos = startPos.clone();
                // Derive base speed from core attributes
                // Scale speed by playerScale so larger players move proportionally faster
                const baseSpeed = oLineman.coreAttributes?.speed || 70;
                oLineman.baseSpeed = baseSpeed * SPEED_CONSTANTS.O_LINE_FACTOR * gameState.gameSpeedMultiplier * gameState.playerScale;
                oLineman.speed = oLineman.baseSpeed;

                // Blocking state
                oLineman.engagedWith = null;         // D-lineman currently blocking
                oLineman.lastClashTime = 0;
                oLineman.knockdownUntil = 0;
                oLineman.bodyMaterial = oLineMat;
                oLineman.originalColor = oLineMat.diffuseColor.clone();

                gameState.offensiveLine.push(oLineman);
            });

            // Defensive Line configurations (4 players) - try roster first
            const rosterDLineConfigs = getDLineConfigsFromRoster();
            const defaultDLineConfigs = [
                {
                    name: "Siege Breaker",
                    position: 'LDE',
                    startX: -3,
                    stats: { passRush: 82, strength: 80, acceleration: 78, speed: 72, awareness: 75, tackling: 80 }
                },
                {
                    name: "Crusher",
                    position: 'LDT',
                    startX: -1,
                    stats: { passRush: 78, strength: 90, acceleration: 70, speed: 65, awareness: 72, tackling: 82 }
                },
                {
                    name: "Devastator",
                    position: 'RDT',
                    startX: 1,
                    stats: { passRush: 80, strength: 88, acceleration: 72, speed: 68, awareness: 74, tackling: 80 }
                },
                {
                    name: "Ramraid",
                    position: 'RDE',
                    startX: 3,
                    stats: { passRush: 85, strength: 78, acceleration: 82, speed: 75, awareness: 78, tackling: 78 }
                }
            ];
            // Merge roster configs with default positions/startX
            const dLineConfigs = rosterDLineConfigs ? rosterDLineConfigs.map((rc, i) => ({
                ...defaultDLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultDLineConfigs;

            // Create Defensive Line
            dLineConfigs.forEach((config, i) => {
                const dLineMat = materials.dLineMaterial.clone(`dLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z + 0.5);
                const dLineman = createLineman(scene, dLineMat, startPos, false);
                dLineman.scaling = new BABYLON.Vector3(gameState.playerScale, gameState.playerScale, gameState.playerScale);
                dLineman.name = `dline_${i}`;
                dLineman.displayName = config.name;
                dLineman.playerId = config.playerId || null;  // Link to roster player
                dLineman.position_label = config.position;
                dLineman.positionType = 'DL';  // For ability calculations (don't use 'position' - it's a Babylon.js Vector3!)
                dLineman.stats = config.stats;
                dLineman.coreAttributes = config.coreAttributes || null;
                dLineman.startPos = startPos.clone();
                // Derive base speed from core attributes
                // Scale speed by playerScale so larger players move proportionally faster
                const baseSpeed = dLineman.coreAttributes?.speed || 70;
                dLineman.baseSpeed = baseSpeed * SPEED_CONSTANTS.D_LINE_FACTOR * gameState.gameSpeedMultiplier * gameState.playerScale;
                dLineman.speed = dLineman.baseSpeed;

                // Pass rush state
                dLineman.engagedWith = null;         // O-lineman currently engaged with
                dLineman.lastClashTime = 0;
                dLineman.knockdownUntil = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial = dLineMat;
                dLineman.originalColor = dLineMat.diffuseColor.clone();

                gameState.defensiveLine.push(dLineman);
            });
            } // End of training mode skip for OL/DL

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Get QB data from roster
            let qbPlayer = null;
            if (managementState.initialized && managementState.team && managementState.team.depthChart.QB) {
                qbPlayer = managementState.team.roster.find(p => p.id === managementState.team.depthChart.QB);
            }
            if (!qbPlayer) {
                qbPlayer = { firstName: 'Knight', lastName: 'Commander', overall: 80 };
            }
            qb.lastName = qbPlayer.lastName;
            qb.overall = qbPlayer.overall;
            qb.displayName = `${qbPlayer.firstName} ${qbPlayer.lastName.charAt(0)}.`;

            // Helper function to get rating indicator (stars) and styling for high-rated players
            const getRatingIndicator = (overall) => {
                if (overall >= 90) {
                    return { stars: '‚òÖ‚òÖ', starColor: '#ffd700', bgTint: 'rgba(80, 60, 0, 0.85)' };  // Gold double star
                } else if (overall >= 85) {
                    return { stars: '‚òÖ', starColor: '#ffd700', bgTint: 'rgba(50, 40, 0, 0.8)' };   // Gold single star
                }
                return { stars: '', starColor: '', bgTint: null };  // No indicator below 85
            };

            // Add name label to QB (stacked: name on top, OVR below bigger)
            const qbRating = getRatingIndicator(qb.overall);
            const qbLabelRect = new BABYLON.GUI.Rectangle();
            qbLabelRect.width = '140px';
            qbLabelRect.height = '70px';
            qbLabelRect.cornerRadius = 6;
            qbLabelRect.thickness = 0;
            qbLabelRect.background = qbRating.bgTint || 'rgba(0, 0, 0, 0.7)';

            const qbStack = new BABYLON.GUI.StackPanel();
            qbStack.isVertical = true;

            const qbNameText = new BABYLON.GUI.TextBlock();
            qbNameText.text = qb.lastName.toUpperCase();
            qbNameText.color = '#ffcc44';
            qbNameText.fontSize = 20;
            qbNameText.fontFamily = 'Courier New';
            qbNameText.fontWeight = 'bold';
            qbNameText.outlineWidth = 3;
            qbNameText.outlineColor = '#000000';
            qbNameText.height = '28px';

            const qbOvrText = new BABYLON.GUI.TextBlock();
            qbOvrText.text = qbRating.stars ? `${qb.overall} ${qbRating.stars}` : `${qb.overall}`;
            qbOvrText.color = '#ffffff';
            qbOvrText.fontSize = 28;
            qbOvrText.fontFamily = 'Courier New';
            qbOvrText.fontWeight = 'bold';
            qbOvrText.outlineWidth = 4;
            qbOvrText.outlineColor = '#000000';
            qbOvrText.height = '36px';

            qbStack.addControl(qbNameText);
            qbStack.addControl(qbOvrText);
            qbLabelRect.addControl(qbStack);

            advancedTexture.addControl(qbLabelRect);
            qbLabelRect.linkWithMesh(qb);
            qbLabelRect.linkOffsetY = -70;
            qbLabelRect.alpha = 1;  // Show when frozen

            qb.nameLabel = qbLabelRect;
            qb.nameTextBlock = qbNameText;
            qb.ovrTextBlock = qbOvrText;

            // Add name labels to receivers (stacked: name on top, OVR below bigger)
            gameState.receivers.forEach((receiver, i) => {
                const wrRating = getRatingIndicator(receiver.overall);
                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '130px';
                labelRect.height = '65px';
                labelRect.cornerRadius = 6;
                labelRect.thickness = 0;
                labelRect.background = wrRating.bgTint || 'rgba(0, 0, 0, 0.65)';

                const stack = new BABYLON.GUI.StackPanel();
                stack.isVertical = true;

                const nameText = new BABYLON.GUI.TextBlock();
                nameText.text = receiver.lastName.toUpperCase();
                nameText.color = '#88bbff';
                nameText.fontSize = 18;
                nameText.fontFamily = 'Courier New';
                nameText.fontWeight = 'bold';
                nameText.outlineWidth = 3;
                nameText.outlineColor = '#000000';
                nameText.height = '26px';

                const ovrText = new BABYLON.GUI.TextBlock();
                ovrText.text = wrRating.stars ? `${receiver.overall} ${wrRating.stars}` : `${receiver.overall}`;
                ovrText.color = '#ffffff';
                ovrText.fontSize = 26;
                ovrText.fontFamily = 'Courier New';
                ovrText.fontWeight = 'bold';
                ovrText.outlineWidth = 4;
                ovrText.outlineColor = '#000000';
                ovrText.height = '34px';

                stack.addControl(nameText);
                stack.addControl(ovrText);
                labelRect.addControl(stack);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -65;
                labelRect.alpha = 1;  // Show when frozen

                receiver.nameLabel = labelRect;
                receiver.nameTextBlock = nameText;
                receiver.ovrTextBlock = ovrText;
            });

            // Add name labels to defenders (DBs) - only if not in training mode
            if (!gameState.trainingMode) {
                // Defender-specific rating indicator with red theme
                const getDefenderRatingIndicator = (overall) => {
                    if (overall >= 90) {
                        return { stars: '‚òÖ‚òÖ', bgTint: 'rgba(100, 40, 40, 0.9)' };  // Elite - darker red with gold stars
                    } else if (overall >= 85) {
                        return { stars: '‚òÖ', bgTint: 'rgba(80, 35, 35, 0.85)' };   // Very good
                    }
                    return { stars: '', bgTint: 'rgba(40, 20, 20, 0.75)' };  // Default - no star below 85
                };

                gameState.defenders.forEach((defender, i) => {
                    const dbRating = getDefenderRatingIndicator(defender.overall);
                    const labelRect = new BABYLON.GUI.Rectangle();
                    labelRect.width = '130px';
                    labelRect.height = '65px';
                    labelRect.cornerRadius = 6;
                    labelRect.thickness = 0;
                    labelRect.background = dbRating.bgTint;

                    const stack = new BABYLON.GUI.StackPanel();
                    stack.isVertical = true;

                    const nameText = new BABYLON.GUI.TextBlock();
                    nameText.text = defender.displayName.toUpperCase();
                    nameText.color = '#ff6666';
                    nameText.fontSize = 16;
                    nameText.fontFamily = 'Courier New';
                    nameText.fontWeight = 'bold';
                    nameText.outlineWidth = 3;
                    nameText.outlineColor = '#000000';
                    nameText.height = '24px';

                    const ovrText = new BABYLON.GUI.TextBlock();
                    ovrText.text = dbRating.stars ? `${defender.overall} ${dbRating.stars}` : `${defender.overall}`;
                    ovrText.color = '#ffffff';
                    ovrText.fontSize = 24;
                    ovrText.fontFamily = 'Courier New';
                    ovrText.fontWeight = 'bold';
                    ovrText.outlineWidth = 4;
                    ovrText.outlineColor = '#000000';
                    ovrText.height = '32px';

                    stack.addControl(nameText);
                    stack.addControl(ovrText);
                    labelRect.addControl(stack);

                    advancedTexture.addControl(labelRect);
                    labelRect.linkWithMesh(defender);
                    labelRect.linkOffsetY = -65;
                    labelRect.alpha = 1;

                    defender.nameLabel = labelRect;
                    defender.nameTextBlock = nameText;
                    defender.ovrTextBlock = ovrText;
                });
            }

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.scaling = new BABYLON.Vector3(gameState.ballScale, gameState.ballScale, gameState.ballScale);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark gray enemies
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            defenderMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            // Offensive line material - similar to receivers (blue)
            const oLineMaterial = new BABYLON.StandardMaterial('oLineMat', scene);
            oLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            oLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            oLineMaterial.specularPower = 32;

            // Defensive line material - similar to defenders (dark gray)
            const dLineMaterial = new BABYLON.StandardMaterial('dLineMat', scene);
            dLineMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            dLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            dLineMaterial.specularPower = 32;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial, oLineMaterial, dLineMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Alternating turf stripes (10-yard sections with different shades of green)
            const lightGreen = new BABYLON.StandardMaterial('lightGreen', scene);
            lightGreen.diffuseColor = new BABYLON.Color3(0.18, 0.42, 0.18);
            lightGreen.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            const darkGreen = new BABYLON.StandardMaterial('darkGreen', scene);
            darkGreen.diffuseColor = new BABYLON.Color3(0.12, 0.32, 0.12);
            darkGreen.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            // Create alternating 10-yard turf sections from -70 to +20
            const stripeStart = -70;
            const stripeEnd = 20;
            const stripeDepth = 10;
            let stripeIndex = 0;

            for (let z = stripeStart; z < stripeEnd; z += stripeDepth) {
                const stripe = BABYLON.MeshBuilder.CreateGround(`turf_${stripeIndex}`, {
                    width: FIELD_WIDTH + 2,
                    height: stripeDepth
                }, scene);
                stripe.material = (stripeIndex % 2 === 0) ? lightGreen : darkGreen;
                stripe.position.set(0, 0, z + stripeDepth / 2);
                stripeIndex++;
            }

            // Yard lines - white 10-yard markers across the full field
            // From own territory (-60) to opponent's goal line (10)
            for (let i = -60; i <= 10; i += 10) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.15
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.012, i);
            }

            // End zone (30% deeper)
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 4
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 13);

            // Sideline boundaries (football-style white lines)
            const sidelinePositions = [
                { x: -FIELD_WIDTH/2 - 0.15, z: -25 },
                { x: FIELD_WIDTH/2 + 0.15, z: -25 }
            ];

            const sidelineMat = new BABYLON.StandardMaterial('sidelineMat', scene);
            sidelineMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            sidelineMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            sidelinePositions.forEach((sp, i) => {
                // Main sideline stripe
                const sideline = BABYLON.MeshBuilder.CreateBox(`sideline_${i}`, {
                    width: 0.3,
                    height: 0.02,
                    depth: FIELD_LENGTH + 12
                }, scene);
                sideline.material = sidelineMat;
                sideline.position.set(sp.x, 0.015, sp.z);
            });

            // Line of scrimmage marker (blue)
            const losLine = BABYLON.MeshBuilder.CreateBox('losLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const losMat = new BABYLON.StandardMaterial('losMat', scene);
            losMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.9);
            losMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
            losMat.alpha = 0.8;
            losLine.material = losMat;
            losLine.position.set(0, 0.02, gameState.lineOfScrimmage);
            scene.losLine = losLine;

            // First down marker (yellow)
            const firstDownLine = BABYLON.MeshBuilder.CreateBox('firstDownLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const fdMat = new BABYLON.StandardMaterial('fdMat', scene);
            fdMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.2);
            fdMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.1);
            fdMat.alpha = 0.8;
            firstDownLine.material = fdMat;
            firstDownLine.position.set(0, 0.02, gameState.firstDownMarker);
            scene.firstDownLine = firstDownLine;
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Lineman Figure (larger than receivers)
        const createLineman = (scene, material, position, isOffense) => {
            const lineman = new BABYLON.TransformNode('lineman', scene);
            const scale = 1.25;  // Linemen are 25% bigger than receivers

            // Body (larger than knight)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = lineman;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = lineman;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = lineman;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35 * scale,
                height: 0.45 * scale,
                depth: 0.08 * scale
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3 * scale, 0.5 * scale, 0.1 * scale);
            shield.parent = lineman;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4 * scale,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = lineman;

            lineman.position = position;
            lineman.idleTime = Math.random() * Math.PI * 2;

            return lineman;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football - larger and more visible
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.6,
                segments: 12
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.5, 0.5, 1.2);  // More elongated football shape
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces - scaled up to match larger ball
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.08,
                height: 0.03,
                depth: 0.25
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            laceMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);  // Glow for visibility
            laces.material = laceMat;
            laces.position.y = 0.14;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters with smoothing to prevent jerky aiming
        let lastValidAngle = 0;  // Store last valid angle for smoothing
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Get QB's arm strength (affects max throw distance)
            // Scales from 12 yards at 50 armStrength to 26 yards at 100 armStrength
            // Target practice mode gets extended range (40 yards max)
            const qb = gameState.scene?.qb;
            const armStrength = qb?.stats?.armStrength || 70;
            const baseMaxThrow = 12 + ((armStrength - 50) / 50) * 14;  // 12-26 range
            const qbMaxThrowDistance = gameState.targetPracticeMode ? 40 : baseMaxThrow;

            // Distance dragged determines throw power
            // Apply sensitivity boost based on camera offset (more offset = less space to drag = higher sensitivity)
            // At 0% offset: 1x sensitivity, at 100% offset: 3x sensitivity
            const offsetSensitivityBoost = 1 + (gameState.cameraOffset || 0) * 2;
            const rawDragDistance = Math.sqrt(dx * dx + dy * dy);
            const dragDistance = rawDragDistance * DRAG_SENSITIVITY * offsetSensitivityBoost;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), qbMaxThrowDistance);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            // Only update angle if drag distance is significant enough to be stable
            let angle;
            if (rawDragDistance > 5) {  // At least 5 pixels of drag for stable angle
                angle = Math.atan2(dx, -dy);
                lastValidAngle = angle;
            } else {
                angle = lastValidAngle;  // Use last valid angle for very small drags
            }

            // Get QB max throw distance for power calculation
            // Always use normal range for power so arcs feel consistent
            const qbForPower = gameState.scene?.qb;
            const armStrengthForPower = qbForPower?.stats?.armStrength || 70;
            const maxDistForPower = 12 + ((armStrengthForPower - 50) / 50) * 14;  // Always use normal range for arc calculation

            return {
                distance: throwDistance,
                angle: angle,
                power: Math.min(1.0, throwDistance / maxDistForPower)  // Cap at 1.0 for consistent arcs
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw distance
            // Short throws (power ~0.2) = low arc (1.5), long throws (power ~1.0) = high arc (6)
            const maxHeight = 1 + power * power * 5;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                return false; // Route complete
            }

            let target = receiver.route[receiver.routeIndex];
            let dx = target.x - receiver.position.x;
            let dz = target.z - receiver.position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);

            // Check if reached current waypoint
            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                if (receiver.routeIndex >= receiver.route.length) {
                    receiver.velocity = new BABYLON.Vector3(0, 0, 0); // Stopped
                    return false; // Route complete
                }
                // Continue toward new waypoint this frame (don't skip a frame)
                target = receiver.route[receiver.routeIndex];
                dx = target.x - receiver.position.x;
                dz = target.z - receiver.position.z;
                dist = Math.sqrt(dx * dx + dz * dz);
            }

            if (dist > 0.1) {
                // Calculate and store velocity
                const vx = (dx / dist) * runSpeed;
                const vz = (dz / dist) * runSpeed;
                receiver.velocity = new BABYLON.Vector3(vx, 0, vz);

                // Move toward target
                receiver.position.x += vx;
                receiver.position.z += vz;
                receiver.rotation.y = Math.atan2(dx, dz);

                // Track running momentum for forward lean
                receiver.runMomentum = Math.min((receiver.runMomentum || 0) + 0.15, 1);
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                receiver.velocity = new BABYLON.Vector3(0, 0, 0);
                // Decay forward lean when stopped
                receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                receiver.rotation.x = (receiver.runMomentum || 0) * 0.15;
            }
            return true;
        };

        // Apply forward lean to any player mesh when running
        const applyMomentumTilt = (player, dx, dz, dist, isMoving) => {
            if (isMoving && dist > 0.1) {
                // Track running momentum for forward lean
                player.runMomentum = Math.min((player.runMomentum || 0) + 0.15, 1);
                player.rotation.x = (player.runMomentum || 0) * 0.25; // Forward lean when running
            } else {
                // Decay forward lean when stopped
                player.runMomentum = (player.runMomentum || 0) * 0.95;
                player.rotation.x = (player.runMomentum || 0) * 0.15;
            }
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            // Reaction delay at start of play - defenders don't move immediately
            const timeSincePlayStart = gameState.gameTime - (gameState.playStartTime || 0);
            if (defender.reactionDelay && timeSincePlayStart < defender.reactionDelay) {
                return;  // Still reacting, don't move yet
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.2);
        };

        // Zone coverage AI - Safety plays deep, picks a side, backpedals until ball thrown
        const moveDefenderZoneCoverage = (defender, speed) => {
            const timeSincePlayStart = gameState.gameTime - (gameState.playStartTime || 0);
            const END_ZONE_BACK = 15;

            // Initialize safety's chosen side if not set (pick at play start)
            if (defender.chosenSide === undefined) {
                // Pick left (-1) or right (+1) side to favor
                defender.chosenSide = Math.random() > 0.5 ? 1 : -1;
                defender.sideCommitment = 0.3 + Math.random() * 0.2; // How far to drift (0.3-0.5 of field width)
            }

            // PHASE 1: Pre-throw - backpedal and drift to chosen side
            if (!gameState.ballInFlight) {
                const distToEndZone = END_ZONE_BACK - defender.position.z;

                // Keep backpedaling if there's room
                if (distToEndZone > 2) {
                    const backpedalSpeed = speed * 0.4;
                    defender.position.z += backpedalSpeed;
                }

                // Drift toward chosen side while staying relatively centered
                const targetSideX = defender.chosenSide * 4 * defender.sideCommitment; // Max ~2 yards to side
                const driftSpeed = speed * 0.15;
                const dxToSide = targetSideX - defender.position.x;

                if (Math.abs(dxToSide) > 0.3) {
                    defender.position.x += Math.sign(dxToSide) * driftSpeed;
                }

                // Face forward toward line of scrimmage (reading the play)
                defender.rotation.y = Math.PI;

                // Apply subtle tilt
                applyMomentumTilt(defender, dxToSide * 0.5, 0.5, 1, true);
                return;
            }

            // PHASE 2: Ball in flight - react to ball/receivers
            // Find nearest receiver (expanded radius since safety covers deep)
            const expandedRadius = defender.zoneRadius * 1.5;
            let nearestReceiver = null;
            let nearestDist = expandedRadius;

            gameState.receivers.forEach(receiver => {
                // Safety prioritizes receivers on their chosen side
                const dx = receiver.position.x - defender.position.x;
                const dz = receiver.position.z - defender.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Bonus for receivers on chosen side
                const sideFactor = (Math.sign(receiver.position.x) === defender.chosenSide) ? 0.8 : 1.0;
                const effectiveDist = dist * sideFactor;

                if (effectiveDist < nearestDist) {
                    nearestDist = effectiveDist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver, staying slightly behind
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;
            } else {
                // No receiver nearby - move toward ball
                const football = gameState.scene?.football;
                if (football) {
                    targetX = football.position.x;
                    targetZ = football.position.z;
                } else {
                    // Fallback to zone center
                    targetX = defender.zoneCenter.x;
                    targetZ = defender.zoneCenter.z;
                }
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                // Move faster when ball is in air (safety breaks on the ball)
                const reactSpeed = speed * 1.1;
                defender.position.x += (dx / dist) * reactSpeed;
                defender.position.z += (dz / dist) * reactSpeed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.5);
        };

        // ============================================
        // LINE MOVEMENT AND CLASH SYSTEM
        // ============================================

        // Move D-lineman - rush toward QB
        const moveDLineman = (dLineman) => {
            // Skip if knocked down
            if (dLineman.knockdownUntil > gameState.gameTime) {
                dLineman.position.y = 0;
                return;
            }

            // Wait for snap delay before D-line starts rushing (gives QB time to drop back)
            const timeSinceSnap = gameState.playStartTime ?
                (performance.now() * 0.001 - gameState.playStartTime) : 0;
            if (timeSinceSnap < LINE_CLASH_CONSTANTS.SNAP_DELAY) {
                // D-linemen hold position during snap delay
                return;
            }

            // Get QB position (use current QB position for evasion tracking)
            const qbPos = gameState.scene.qb.position;

            // Calculate speed with any boosts
            let speed = dLineman.baseSpeed;
            if (dLineman.speedBoostUntil > gameState.gameTime) {
                speed *= LINE_CLASH_CONSTANTS.SPEED_BURST_MULTIPLIER;
            }

            // Apply engagement slowdown
            if (dLineman.engagedWith && !dLineman.engagedWith.knockdownUntil) {
                speed *= dLineman.currentSpeedMultiplier;
            }

            // Rush toward QB
            const dx = qbPos.x - dLineman.position.x;
            const dz = qbPos.z - dLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                dLineman.position.x += (dx / dist) * speed;
                dLineman.position.z += (dz / dist) * speed;
                dLineman.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(dLineman, dx, dz, dist, dist > 0.3);
        };

        // Move O-lineman - stay between assigned D-lineman and QB
        const moveOLineman = (oLineman) => {
            // Skip if knocked down
            if (oLineman.knockdownUntil > gameState.gameTime) {
                oLineman.position.y = 0;
                return;
            }

            const qbPos = gameState.scene.qb.position;

            // Find best D-lineman to block
            const targetDLineman = findBlockingTarget(oLineman);

            if (!targetDLineman) {
                // No target - hold position
                return;
            }

            // Update engagement
            oLineman.engagedWith = targetDLineman;

            // Calculate ideal blocking position - between D-lineman and QB
            const dLinePos = targetDLineman.position;

            // Vector from D-lineman to QB
            const toQbX = qbPos.x - dLinePos.x;
            const toQbZ = qbPos.z - dLinePos.z;
            const toQbDist = Math.sqrt(toQbX * toQbX + toQbZ * toQbZ);

            if (toQbDist < 0.5) return;  // Too close, don't move

            // Position 0.8 units in front of D-lineman (toward QB)
            const blockDist = 0.8;
            const targetX = dLinePos.x + (toQbX / toQbDist) * blockDist;
            const targetZ = dLinePos.z + (toQbZ / toQbDist) * blockDist;

            const dx = targetX - oLineman.position.x;
            const dz = targetZ - oLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                const speed = oLineman.baseSpeed;
                oLineman.position.x += (dx / dist) * speed;
                oLineman.position.z += (dz / dist) * speed;
                // Face the D-lineman
                oLineman.rotation.y = Math.atan2(dLinePos.x - oLineman.position.x, dLinePos.z - oLineman.position.z);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(oLineman, dx, dz, dist, dist > 0.2);
        };

        // Find the best D-lineman for an O-lineman to block
        const findBlockingTarget = (oLineman) => {
            const qbPos = gameState.scene.qb.position;
            let bestTarget = null;
            let bestScore = -Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip knocked down D-linemen
                if (dLineman.knockdownUntil > gameState.gameTime) return;

                // Calculate threat level (closer to QB = more threatening)
                const distToQb = BABYLON.Vector3.Distance(dLineman.position, qbPos);
                const distToOLine = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);

                // Check if another O-lineman is already blocking this D-lineman
                let alreadyBlocked = false;
                let blockingOLineman = null;
                gameState.offensiveLine.forEach(other => {
                    if (other !== oLineman && other.engagedWith === dLineman &&
                        other.knockdownUntil <= gameState.gameTime) {
                        alreadyBlocked = true;
                        blockingOLineman = other;
                    }
                });

                // Scoring: prioritize unblocked D-linemen, close to self, close to QB
                let score = 0;

                // Heavily prioritize unblocked rushers
                if (!alreadyBlocked) {
                    score += 100;
                }

                // Prefer D-linemen close to this O-lineman (easier to reach)
                score -= distToOLine * 5;

                // Prefer D-linemen closer to QB (more threatening)
                score -= distToQb * 2;

                // If this O-lineman was already blocking this D-lineman, prefer to stay
                if (oLineman.engagedWith === dLineman) {
                    score += 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = dLineman;
                }
            });

            return bestTarget;
        };

        // Process line clashes between O-line and D-line
        const processLineClashes = () => {
            const currentTime = gameState.gameTime;

            // Skip clash processing during snap delay
            const timeSinceSnap = gameState.playStartTime ?
                (performance.now() * 0.001 - gameState.playStartTime) : 0;
            if (timeSinceSnap < LINE_CLASH_CONSTANTS.SNAP_DELAY) {
                return;
            }

            gameState.defensiveLine.forEach(dLineman => {
                // Skip if knocked down
                if (dLineman.knockdownUntil > currentTime) {
                    dLineman.currentSpeedMultiplier = 0;
                    return;
                }

                // Reset speed boost if expired
                if (dLineman.speedBoostUntil <= currentTime) {
                    dLineman.speedBoostUntil = 0;
                }

                // Find closest O-lineman
                let closestOLineman = null;
                let closestDist = LINE_CLASH_CONSTANTS.CLASH_RANGE;

                gameState.offensiveLine.forEach(oLineman => {
                    if (oLineman.knockdownUntil > currentTime) return;

                    const dist = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestOLineman = oLineman;
                    }
                });

                if (closestOLineman) {
                    // Engaged with O-lineman
                    dLineman.engagedWith = closestOLineman;
                    closestOLineman.engagedWith = dLineman;

                    // Check if it's time for a clash resolution
                    const timeSinceLastClash = currentTime - dLineman.lastClashTime;
                    if (timeSinceLastClash >= LINE_CLASH_CONSTANTS.CLASH_INTERVAL) {
                        resolveLineClash(closestOLineman, dLineman);
                    }
                } else {
                    // Not engaged - full speed
                    dLineman.engagedWith = null;
                    dLineman.currentSpeedMultiplier = 1.0;
                }
            });
        };

        // Resolve a clash between O-lineman and D-lineman
        const resolveLineClash = (oLineman, dLineman) => {
            const currentTime = gameState.gameTime;

            // Update clash timing
            oLineman.lastClashTime = currentTime;
            dLineman.lastClashTime = currentTime;

            // Ability selection - DL initiates (attacker), OL reacts (defender)
            const abilityResult = resolveAbilityClash(dLineman, oLineman, ABILITY_MATCHUPS.linemen, true);

            // Calculate technique rolls (40% of total)
            const oTechRoll = getTechniqueRoll(oLineman.stats, CLASH_WEIGHTS.lineClash.offense);
            const dTechRoll = getTechniqueRoll(dLineman.stats, CLASH_WEIGHTS.lineClash.defense);

            // Calculate core√óability multiplicative rolls (60% of total)
            const oCoreAbilityRoll = getCoreAbilityRoll(oLineman, abilityResult.reactor);
            const dCoreAbilityRoll = getCoreAbilityRoll(dLineman, abilityResult.initiator);

            // Combined rolls with variance (¬±20%)
            const variance = 0.2;
            const oRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;
            const dRollVariance = 1 + (Math.random() - 0.5) * 2 * variance;

            const adjustedOLineRoll = (oTechRoll + oCoreAbilityRoll) * oRollVariance;
            // Apply matchup multiplier to DL's roll (higher = better for DL)
            const adjustedDLineRoll = (dTechRoll + dCoreAbilityRoll) * dRollVariance * abilityResult.matchupMultiplier;

            const margin = adjustedOLineRoll - adjustedDLineRoll;

            if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD) {
                // O-line wins decisively - knock down D-lineman
                dLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                dLineman.currentSpeedMultiplier = 0;
                dLineman.engagedWith = null;

                // O-lineman is free to help another
                oLineman.engagedWith = null;

                // Record clash stats
                recordPlayerStat(oLineman, 'seasonClashesWon');
                recordPlayerStat(dLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesWon++;
                    oStats.clashDifficulties.push(margin);
                }
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD) {
                // D-line wins decisively - knock O-lineman aside, speed burst
                oLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                oLineman.engagedWith = null;

                // D-lineman gets speed burst
                dLineman.speedBoostUntil = currentTime + LINE_CLASH_CONSTANTS.SPEED_BURST_DURATION;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.engagedWith = null;

                // Knock O-lineman to the side
                const sideDir = Math.random() > 0.5 ? 1 : -1;
                oLineman.position.x += sideDir * 1.5;

                // Record clash stats
                recordPlayerStat(dLineman, 'seasonClashesWon');
                recordPlayerStat(oLineman, 'seasonClashesLost');

                // Record per-game clash stats
                if (dLineman.playerId) {
                    const dStats = gameStats.getPlayer(dLineman.playerId, dLineman.displayName);
                    dStats.clashesWon++;
                    dStats.clashDifficulties.push(-margin);
                }
                if (oLineman.playerId) {
                    const oStats = gameStats.getPlayer(oLineman.playerId, oLineman.displayName);
                    oStats.clashesLost++;
                    oStats.clashDifficulties.push(margin);
                }

            } else if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD / 2) {
                // O-line winning but not decisive - D-lineman very slow
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD / 2) {
                // D-line winning but not decisive - breaking through slowly
                dLineman.currentSpeedMultiplier = 0.5;

            } else {
                // Neutral - D-lineman nearly stopped
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;
            }
        };

        // Reset offensive line to starting positions
        const resetOffensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.offensiveLine.forEach((oLineman, i) => {
                oLineman.position.x = oLineman.startPos.x;
                oLineman.position.z = lineZ - 0.5;
                oLineman.position.y = 0;
                oLineman.rotation.y = 0;
                oLineman.rotation.x = 0;
                oLineman.knockdownUntil = 0;
                oLineman.engagedWith = null;
                oLineman.lastClashTime = 0;
                oLineman.bodyMaterial.diffuseColor = oLineman.originalColor;
                oLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // Reset defensive line to starting positions
        const resetDefensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.defensiveLine.forEach((dLineman, i) => {
                dLineman.position.x = dLineman.startPos.x;
                dLineman.position.z = lineZ + 0.5;
                dLineman.position.y = 0;
                dLineman.rotation.y = Math.PI;  // Face the offense
                dLineman.rotation.x = 0;
                dLineman.knockdownUntil = 0;
                dLineman.engagedWith = null;
                dLineman.lastClashTime = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial.diffuseColor = dLineman.originalColor;
                dLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // ============================================
        // QB MOVEMENT AND SACK SYSTEM
        // ============================================

        // Move QB based on pocket behavior and threats
        const moveQB = (scene) => {
            const qb = scene.qb;
            const currentTime = gameState.gameTime;

            // Don't move if play has ended or ball is being thrown
            if (gameState.playEnded || gameState.ballInFlight) return;

            // Skip QB movement/sack logic in training mode
            if (gameState.trainingMode) return;

            // Find closest threat (D-lineman)
            let closestThreat = null;
            let closestThreatDist = Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                if (dLineman.knockdownUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(dLineman.position, qb.position);
                if (dist < closestThreatDist) {
                    closestThreatDist = dist;
                    closestThreat = dLineman;
                }
            });

            // Check for sack
            if (closestThreatDist < LINE_CLASH_CONSTANTS.TACKLE_RANGE) {
                handleSack(scene, closestThreat);
                return;
            }

            // Calculate pocket position relative to line of scrimmage
            const losZ = gameState.lineOfScrimmage;
            const pocketCenterZ = losZ - 3;  // 3 yards behind LOS
            const maxDepthZ = losZ - 6;       // 6 yards behind LOS max

            let targetX = qb.position.x;
            let targetZ = pocketCenterZ;
            let speed = POCKET_CONSTANTS.SETTLE_SPEED;

            // If threat is close, evade
            if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                speed = POCKET_CONSTANTS.EVADE_SPEED;

                // Calculate evasion direction (away from threat)
                const threatDx = qb.position.x - closestThreat.position.x;
                const threatDz = qb.position.z - closestThreat.position.z;
                const threatDist = Math.sqrt(threatDx * threatDx + threatDz * threatDz);

                if (threatDist > 0.1) {
                    // Move away from threat
                    targetX = qb.position.x + (threatDx / threatDist) * 2;
                    targetZ = qb.position.z + (threatDz / threatDist) * 2;
                }
            }

            // Apply constraints
            // Don't cross line of scrimmage
            targetZ = Math.min(targetZ, losZ);

            // Don't go too deep
            targetZ = Math.max(targetZ, maxDepthZ);

            // Stay within pocket width (with some flexibility when evading)
            const maxX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MAX_X + 2 : POCKET_CONSTANTS.POCKET_MAX_X;
            const minX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MIN_X - 2 : POCKET_CONSTANTS.POCKET_MIN_X;
            targetX = Math.max(minX, Math.min(maxX, targetX));

            // Move toward target
            const dx = targetX - qb.position.x;
            const dz = targetZ - qb.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                qb.position.x += (dx / dist) * speed;
                qb.position.z += (dz / dist) * speed;

                // Face the threat or downfield
                if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                    const faceDx = closestThreat.position.x - qb.position.x;
                    const faceDz = closestThreat.position.z - qb.position.z;
                    qb.rotation.y = Math.atan2(faceDx, faceDz);
                }
            }
        };

        // Show play result popup (game mode - not training)
        const showPlayResult = (result) => {
            if (gameState.trainingMode) return;  // Training mode has its own popup

            const popup = document.getElementById('playResultPopup');
            const mainEl = document.getElementById('playResultMain');
            const detailEl = document.getElementById('playResultDetail');
            const downEl = document.getElementById('playResultDown');
            const fieldPosEl = document.getElementById('playResultFieldPos');
            const catchInfoEl = document.getElementById('playResultCatchInfo');

            if (result.type === 'incomplete') {
                mainEl.textContent = 'INCOMPLETE';
                mainEl.style.color = '#f66';
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'touchdown') {
                mainEl.textContent = 'TOUCHDOWN!';
                mainEl.style.color = '#4f4';
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'catch') {
                const yards = result.yards;
                if (yards > 0) {
                    mainEl.textContent = `+${yards} YDS`;
                    mainEl.style.color = '#4f4';
                } else if (yards < 0) {
                    mainEl.textContent = `${yards} YDS`;
                    mainEl.style.color = '#f66';
                } else {
                    mainEl.textContent = 'NO GAIN';
                    mainEl.style.color = '#ff4';
                }
                detailEl.textContent = result.detail || '';
            } else if (result.type === 'sack') {
                mainEl.textContent = `${result.yards} YDS`;
                mainEl.style.color = '#f66';
                detailEl.textContent = 'SACKED!';
            }

            // Show catch info if provided
            if (result.catchInfo && result.catchRoll !== undefined) {
                const catchInfo = result.catchInfo;
                const catchRoll = result.catchRoll;
                const success = result.catchSuccess;

                catchInfoEl.style.display = 'block';

                const headerEl = document.getElementById('playResultCatchHeader');
                const baseEl = document.getElementById('playResultCatchBase');
                const penaltyEl = document.getElementById('playResultCatchPenalty');
                const rollEl = document.getElementById('playResultCatchRoll');
                const modListEl = document.getElementById('playResultModifierList');

                headerEl.textContent = success ? 'CATCH!' : 'DROPPED';
                headerEl.style.color = success ? '#4f4' : '#f66';

                // Show wide open rate as base, with penalty overlay
                const baseWidth = catchInfo.wideOpenRate || 70;
                const penaltyWidth = Math.max(0, baseWidth - (catchInfo.probability || baseWidth));

                baseEl.style.width = `${baseWidth}%`;

                if (penaltyWidth > 0) {
                    penaltyEl.style.display = 'block';
                    penaltyEl.style.left = `${catchInfo.probability}%`;
                    penaltyEl.style.width = `${penaltyWidth}%`;
                } else {
                    penaltyEl.style.display = 'none';
                }

                rollEl.textContent = 'üèà';
                rollEl.style.filter = success ? 'none' : 'grayscale(100%)';
                rollEl.style.left = `${catchRoll}%`;

                // Build modifier list - simplified formula display
                const makeRow = (label, value, isPositive) => {
                    const color = isPositive ? '#4f4' : '#f66';
                    const sign = isPositive ? '+' : '';
                    return `<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#aaa;">${label}</span>
                        <span style="color:${color}; font-weight:bold;">${sign}${value}</span>
                    </div>`;
                };

                let modRows = [];

                // Show separation/coverage
                if (catchInfo.separation !== undefined) {
                    const sepYards = catchInfo.separation.toFixed(1);
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0; padding-bottom: 6px; border-bottom: 1px solid #333;">
                        <span style="color:#888;">Separation</span>
                        <span style="color:#fff;">${sepYards} yds - ${catchInfo.coverageLevel || 'open'}</span>
                    </div>`);
                }

                // Base catch rate (from catching stat)
                if (catchInfo.baseCatch !== undefined) {
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#aaa;">Base rate (${catchInfo.baseCatch} catch)</span>
                        <span style="color:#4f4; font-weight:bold;">${Math.round(catchInfo.wideOpenRate)}%</span>
                    </div>`);
                }

                // DB penalty (raw, before lead bonus reduction)
                if (catchInfo.isContested && catchInfo.dbPenalty > 0) {
                    modRows.push(makeRow('DB penalty', `-${catchInfo.dbPenalty}%`, false));
                }

                // Lead bonus (reduction of DB penalty based on throw quality)
                if (catchInfo.hasSideBonus && catchInfo.shoulderBonusSaved > 0) {
                    const leadLabel = catchInfo.leadQuality >= 80 ? 'perfect' :
                                     catchInfo.leadQuality >= 60 ? 'good' :
                                     catchInfo.leadQuality >= 40 ? 'ok' : 'poor';
                    modRows.push(makeRow(`Lead bonus (${leadLabel})`, `${catchInfo.shoulderBonusSaved}%`, true));
                }

                // Final probability
                const finalColor = catchInfo.probability >= 50 ? '#4f4' : (catchInfo.probability >= 25 ? '#ff4' : '#f66');
                modRows.push(`<div style="display:flex; justify-content:space-between; margin: 8px 0 0 0; padding-top: 6px; border-top: 1px solid #333;">
                    <span style="color:#fff; font-weight:bold;">Final catch rate</span>
                    <span style="color:${finalColor}; font-weight:bold; font-size: 15px;">${Math.round(catchInfo.probability)}%</span>
                </div>`);

                modListEl.innerHTML = modRows.join('');
            } else {
                catchInfoEl.style.display = 'none';
            }

            // Show next down info
            if (result.nextDown) {
                downEl.textContent = result.nextDown;
                downEl.style.display = 'block';
            } else {
                downEl.style.display = 'none';
            }

            // Calculate and show field position
            const END_ZONE_Z = 11;
            const yardsFromGoal = Math.round(END_ZONE_Z - gameState.lineOfScrimmage);
            let fieldPosText = '';
            if (yardsFromGoal <= 0) {
                fieldPosText = 'Ball at: GOAL LINE';
            } else if (yardsFromGoal <= 50) {
                fieldPosText = yardsFromGoal === 50 ? 'Ball at: MIDFIELD' : `Ball at: OPP ${yardsFromGoal}`;
            } else {
                const ownYardLine = 100 - yardsFromGoal;
                fieldPosText = `Ball at: OWN ${ownYardLine}`;
            }
            fieldPosEl.textContent = fieldPosText;

            popup.style.display = 'block';

            // Dismiss on any click anywhere on screen
            const dismissPopup = (e) => {
                popup.style.display = 'none';
                document.removeEventListener('click', dismissPopup);
                document.removeEventListener('touchstart', dismissPopup);
            };
            // Small delay to prevent immediate dismissal from the same click
            setTimeout(() => {
                document.addEventListener('click', dismissPopup);
                document.addEventListener('touchstart', dismissPopup);
            }, 100);
        };

        // Handle QB sack
        const handleSack = (scene, tackler) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.qbSacked = true;
            gameState.canThrow = false;

            // Calculate yards lost before updating
            const oldLOS = gameState.lineOfScrimmage;
            const yardsLost = Math.round(scene.qb.position.z - oldLOS);

            // Record sack for roster player
            recordPlayerStat(tackler, 'seasonSacks');

            // Record per-game sack stats
            if (tackler.playerId) {
                gameStats.getPlayer(tackler.playerId, tackler.displayName).sacks++;
            }

            // Move line of scrimmage back to sack location
            handleSackFieldPosition(scene.qb.position.z);

            updateMessage(`SACK by ${tackler.displayName}!`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'sack',
                yards: yardsLost,
                detail: `${tackler.displayName}`,
                nextDown: nextDownText
            });

            // QB falls down animation
            const qb = scene.qb;
            qb.rotation.x = Math.PI / 3;  // Fall forward

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // ============================================
        // RECEIVER TACKLING SYSTEM
        // ============================================

        // Move ball carrier (receiver with the ball) toward end zone
        const moveBallCarrier = (receiver) => {
            if (!receiver || receiver.knockdownUntil > gameState.gameTime) return;

            // Calculate effective speed with any boosts
            let speed = receiver.baseSpeed;
            if (receiver.breakTackleBoostUntil > gameState.gameTime) {
                speed *= TACKLE_CONSTANTS.BREAK_TACKLE_BOOST;
            }

            // Run toward back of end zone (positive Z direction)
            const targetZ = 15;  // Back of end zone
            const targetX = receiver.position.x;  // Maintain lane for now

            const dz = targetZ - receiver.position.z;
            const dx = targetX - receiver.position.x;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                receiver.position.z += (dz / dist) * speed;
                receiver.position.x += (dx / dist) * speed * 0.3;  // Slight drift
                receiver.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(receiver, dx, dz, dist, dist > 0.1);

            // Check for touchdown
            if (receiver.position.z >= 12) {
                handleTouchdown(receiver);
                return;
            }

            // Check for out of bounds
            if (Math.abs(receiver.position.x) > 8) {
                handleOutOfBounds(receiver);
                return;
            }
        };

        // Process tackle attempts by defenders on ball carrier
        const processTackles = () => {
            const receiver = gameState.ballCarrier;
            if (!receiver || gameState.playEnded) return;

            const currentTime = gameState.gameTime;

            // Check all defenders for tackle attempts
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > currentTime) return;
                if (defender.tackleStumbleUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(defender.position, receiver.position);

                if (dist < TACKLE_CONSTANTS.TACKLE_RANGE) {
                    // Check tackle cooldown
                    const timeSinceLastTackle = currentTime - (defender.lastTackleTime || 0);
                    if (timeSinceLastTackle < TACKLE_CONSTANTS.TACKLE_INTERVAL) return;

                    // Attempt tackle
                    resolveTackle(receiver, defender);
                }
            });
        };

        // Resolve a tackle attempt
        const resolveTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;
            defender.lastTackleTime = currentTime;

            // Roll for tackle
            let tackleRoll = weightedRoll(defender.stats, CLASH_WEIGHTS.tackle.tackler, defender.coreAttributes);
            const evasionRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier, receiver.coreAttributes);

            // Tackler advantage: WRs have natural +7 advantage from primary stat bonuses
            // on speed/agility, while CBs don't get bonuses on tackling/pursuit/hitPower.
            // Add a base tackler bonus to compensate and make tackling realistic.
            const tacklerBonus = 10;
            tackleRoll += tacklerBonus;

            const margin = tackleRoll - evasionRoll;

            // Tackling favors the defender - receiver needs to significantly outroll
            // to break a tackle (margin must be < -12, meaning receiver wins by 12+)
            if (margin > -12) {
                // Tackle successful!
                handleTackle(receiver, defender);
            } else {
                // Broken tackle! (rare - requires big evasion win)
                handleBrokenTackle(receiver, defender);
            }
        };

        // Handle successful tackle
        const handleTackle = (receiver, defender) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Calculate yards gained before advancing
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = Math.round(receiver.position.z - oldLOS);

            // Record tackle for roster player
            recordPlayerStat(defender, 'seasonTackles');

            // Record per-game tackle stats
            if (defender.playerId) {
                gameStats.getPlayer(defender.playerId, defender.displayName).tackles++;
            }

            // Record YAC for receiver
            if (receiver.playerId && receiver.catchPosition !== undefined) {
                const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                gameStats.getPlayer(receiver.playerId, receiver.displayName).yardsAfterCatch += yac;
            }

            // Advance ball to tackle location
            advanceBall(receiver.position.z);

            updateMessage(`TACKLED by ${defender.displayName}!`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'catch',
                yards: yardsGained,
                detail: `Tackled by ${defender.displayName}`,
                nextDown: nextDownText,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Receiver falls down
            receiver.rotation.x = Math.PI / 3;
            receiver.position.y = 0;

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Flash effects
            defender.bodyMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.5, 0.1);
            setTimeout(() => {
                defender.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 500);

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // Handle broken tackle
        const handleBrokenTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            updateMessage(`BROKEN TACKLE!`);

            // Defender stumbles
            defender.tackleStumbleUntil = currentTime + TACKLE_CONSTANTS.STUMBLE_DURATION;
            defender.rotation.x = Math.PI / 6;  // Lean forward stumbling

            // Receiver gets speed boost
            receiver.breakTackleBoostUntil = currentTime + TACKLE_CONSTANTS.BREAK_TACKLE_DURATION;

            // Flash receiver green
            receiver.bodyMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.1);
            setTimeout(() => {
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 300);

            // Reset defender stumble rotation
            setTimeout(() => {
                defender.rotation.x = 0;
            }, TACKLE_CONSTANTS.STUMBLE_DURATION * 1000);
        };

        // Reset the drive to starting position (after TD or turnover on downs)
        const resetDrive = () => {
            gameState.down = 1;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.lineOfScrimmage + 10;
            gameState.yardsToGo = 10;
        };

        // Advance the ball to a new position and handle down logic
        const advanceBall = (newPositionZ) => {
            const END_ZONE_Z = 11;  // Touchdown threshold (matches visual end zone start)
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = newPositionZ - oldLOS;

            // Update line of scrimmage
            gameState.lineOfScrimmage = newPositionZ;

            // Check for first down
            if (newPositionZ >= gameState.firstDownMarker) {
                // First down achieved!
                gameState.down = 1;
                gameState.firstDownMarker = newPositionZ + 10;
                gameState.yardsToGo = 10;

                // Cap first down marker at end zone
                if (gameState.firstDownMarker > END_ZONE_Z) {
                    gameState.yardsToGo = END_ZONE_Z - newPositionZ;
                    gameState.firstDownMarker = END_ZONE_Z;
                }

                updateMessage('FIRST DOWN!');
            } else {
                // No first down, advance to next down
                gameState.down++;
                gameState.yardsToGo = gameState.firstDownMarker - newPositionZ;

                if (gameState.down > 4) {
                    // Turnover on downs!
                    updateMessage('TURNOVER ON DOWNS!');
                    resetDrive();
                    // Management: record possession complete with 0 points (turnover)
                    if (managementState.matchInProgress) {
                        gameState.waitingForPossession = true;
                        setTimeout(() => {
                            onPossessionComplete(0);
                        }, 1500);
                    }
                }
            }
        };

        // Handle incomplete pass (same line of scrimmage, next down)
        const handleIncomplete = (detail) => {
            gameState.down++;

            // Show play result popup (before checking turnover so we can show correct down)
            if (gameState.down <= 4) {
                const downNames = ['1st', '2nd', '3rd', '4th'];
                showPlayResult({
                    type: 'incomplete',
                    detail: detail || '',
                    nextDown: `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}`,
                    catchInfo: gameState.lastCatchInfo,
                    catchRoll: gameState.lastCatchRoll,
                    catchSuccess: gameState.lastCatchSuccess
                });
            } else {
                showPlayResult({
                    type: 'incomplete',
                    detail: 'TURNOVER ON DOWNS',
                    catchInfo: gameState.lastCatchInfo,
                    catchRoll: gameState.lastCatchRoll,
                    catchSuccess: gameState.lastCatchSuccess
                });
            }

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle sack (move line back)
        const handleSackFieldPosition = (sackPositionZ) => {
            // Sack moves the line of scrimmage back
            const newLOS = Math.max(-8, sackPositionZ);  // Don't go too far back
            gameState.lineOfScrimmage = newLOS;
            gameState.yardsToGo = gameState.firstDownMarker - newLOS;
            gameState.down++;

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle touchdown
        const handleTouchdown = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.touchdowns++;
            updateScore();

            // Record TD for roster player
            recordPlayerStat(receiver, 'seasonTDs');

            // Record per-game TD stats
            if (receiver.playerId) {
                const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                rStats.touchdowns++;
                // Also record YAC for TD run
                if (receiver.catchPosition !== undefined) {
                    const yac = Math.max(0, Math.round((receiver.position.z - receiver.catchPosition) * 2));
                    rStats.yardsAfterCatch += yac;
                }
            }

            updateMessage(`TOUCHDOWN by ${receiver.displayName}!`);

            // Show play result popup
            showPlayResult({
                type: 'touchdown',
                detail: `${receiver.displayName} scores!`,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Celebration
            celebrateReceiver(receiver, gameState.scene);

            // Reset drive tracking (downs/yardage)
            resetDrive();

            // Management: record possession complete with 7 points
            if (managementState.matchInProgress) {
                // Pause game during possession overlay
                gameState.waitingForPossession = true;
                setTimeout(() => {
                    onPossessionComplete(7);
                }, 2500);
                return; // Don't reset play yet - wait for overlay to be dismissed
            }

            // Only reset play immediately if not in management match
            setTimeout(() => {
                resetPlay(gameState.scene);
            }, 3000);
        };

        // Handle out of bounds
        const handleOutOfBounds = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Calculate yards gained before advancing
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = Math.round(receiver.position.z - oldLOS);

            // Advance ball to where receiver went out
            advanceBall(receiver.position.z);

            updateMessage(`OUT OF BOUNDS`);

            // Show play result popup
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const nextDownText = gameState.down <= 4 ?
                `${downNames[gameState.down - 1]} & ${Math.round(gameState.yardsToGo)}` : '';
            showPlayResult({
                type: 'catch',
                yards: yardsGained,
                detail: 'Out of bounds',
                nextDown: nextDownText,
                catchInfo: gameState.lastCatchInfo,
                catchRoll: gameState.lastCatchRoll,
                catchSuccess: gameState.lastCatchSuccess
            });

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 1500);
        };

        // Move defenders to pursue ball carrier
        const moveDefenderPursuit = (defender, pursuitBoost = 1.0) => {
            const receiver = gameState.ballCarrier;
            if (!receiver || defender.knockdownUntil > gameState.gameTime) return;

            // Stumbling defenders can't move well
            if (defender.tackleStumbleUntil > gameState.gameTime) {
                return;
            }

            // Base pursuit speed with time-based boost
            const speed = defender.baseSpeed * 1.1 * pursuitBoost;

            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }

            // Apply momentum-based tilt
            applyMomentumTilt(defender, dx, dz, dist, dist > 0.3);
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            const lineZ = gameState.lineOfScrimmage;
            const END_ZONE_Z = 11;
            const END_ZONE_BACK = 15;  // Back of end zone - max Z position
            const SIDELINE = 8;  // Field boundary
            const distToGoal = END_ZONE_Z - lineZ;  // How far from goal line

            // Create shuffled receiver assignment for man coverage DBs
            const receiverIndices = [0, 1, 2];
            for (let i = receiverIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [receiverIndices[i], receiverIndices[j]] = [receiverIndices[j], receiverIndices[i]];
            }
            let manDefenderIndex = 0;

            gameState.defenders.forEach((defender, i) => {
                if (defender.aiType === 'man') {
                    // Man defenders cover receivers 1-to-1 (randomized assignment)
                    const receiverIndex = receiverIndices[manDefenderIndex % receiverIndices.length];
                    defender.assignedReceiver = receiverIndex;
                    const targetReceiver = gameState.receivers[receiverIndex];

                    // Cushion decreases near goal line (DBs play tighter in red zone)
                    // Far from goal: 4-7 yards, Near goal line: 1-3 yards
                    const baseCushion = Math.max(1, Math.min(4, distToGoal * 0.4));
                    const cushionVariance = Math.max(1, Math.min(3, distToGoal * 0.3));
                    defender.cushion = baseCushion + Math.random() * cushionVariance;

                    defender.startPos.x = Math.max(-SIDELINE, Math.min(SIDELINE, targetReceiver.startPos.x));
                    defender.startPos.z = Math.min(END_ZONE_BACK - 1, targetReceiver.startPos.z + defender.cushion);
                    defender.reactionDelay = 0.25;  // Quarter second before reacting
                    manDefenderIndex++;
                } else if (defender.aiType === 'zone') {
                    // Safety - starts deep and centered, picks side during play
                    const safetyDepth = 10 + Math.random() * 3;  // 10-13 yards deep (further back)
                    const clampedZoneZ = Math.min(END_ZONE_BACK - 1, lineZ + safetyDepth);
                    // Safety starts near center (will drift to chosen side during play)
                    const safetyX = (Math.random() - 0.5) * 2;  // -1 to +1 yards (mostly centered)
                    defender.zoneCenter = new BABYLON.Vector3(0, 0, clampedZoneZ);
                    defender.zoneRadius = 6 + Math.random() * 2;  // 6-8 yard radius (wider coverage)
                    defender.startPos.x = safetyX;
                    defender.startPos.z = Math.min(END_ZONE_BACK - 1, clampedZoneZ);
                    // Reset safety's chosen side so it picks fresh each play
                    defender.chosenSide = undefined;
                    defender.sideCommitment = undefined;
                }

                // Clamp final positions to field boundaries
                defender.position.x = Math.max(-SIDELINE, Math.min(SIDELINE, defender.startPos.x));
                defender.position.z = Math.min(END_ZONE_BACK - 1, defender.startPos.z);
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.clashTiltUntil = 0;
                defender.loserFlashUntil = 0;
                defender.winnerFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.clashSpeedPenaltyUntil = 0;
                defender.lastClashTime = 0;
                defender.rotation.x = 0;  // Reset tilt
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
                // Tackling state
                defender.tackleStumbleUntil = 0;
                defender.lastTackleTime = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            // Receivers line up at the line of scrimmage
            const receiverLineZ = gameState.lineOfScrimmage;

            // Slot receiver lines up just outside the offensive tackle (randomly left or right)
            const slotSide = Math.random() > 0.5 ? 1 : -1;  // Randomly pick left or right side
            const positions = [
                -(6 + Math.random() * 1.5),   // Wide left (-6 to -7.5)
                (6 + Math.random() * 1.5),    // Wide right (6 to 7.5)
                slotSide * (4 + Math.random() * 0.5)  // Slot: Just outside tackle (¬±4 to ¬±4.5)
            ];

            // Shuffle positions so receivers line up in random slots each play
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Rarely pick 0-1 receivers to run crossing routes (less overlap)
            const numCrossing = Math.random() < 0.3 ? 1 : 0;  // 30% chance of 1 crossing route
            const crossingIndices = [];
            while (crossingIndices.length < numCrossing && crossingIndices.length < gameState.receivers.length) {
                const idx = Math.floor(Math.random() * gameState.receivers.length);
                if (!crossingIndices.includes(idx)) {
                    crossingIndices.push(idx);
                }
            }

            gameState.receivers.forEach((receiver, i) => {
                // Assign spread position
                receiver.startPos.x = positions[i] || (Math.random() - 0.5) * 6;
                receiver.startPos.z = receiverLineZ;

                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiverLineZ;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.headingAngle = 0;  // Reset heading for turn-rate limiting
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.wasOutsideClashRange = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.clashTiltUntil = 0;
                receiver.loserFlashUntil = 0;
                receiver.winnerFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.clashSpeedPenaltyUntil = 0;
                receiver.clashSpeedBoostUntil = 0;
                receiver.rotation.x = 0;  // Reset tilt
                receiver.coverageAmount = 0;
                receiver.currentCatchProb = receiver.stats.catching;
                // Size based on base catching stat (80% = 0.3 + 0.9*0.8 = 1.02 scale)
                const baseScale = 0.3 + 0.9 * (receiver.stats.catching / 100);
                receiver.zoneFill.scaling = new BABYLON.Vector3(baseScale, baseScale, baseScale);
                receiver.fillMaterial.alpha = 0.5;
                // Always white
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // Reset body color to original (clear any flash effects from previous play)
                receiver.bodyMaterial.diffuseColor = receiver.originalColor.clone();
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();

                // Tackling state
                receiver.breakTackleBoostUntil = 0;

                // Generate new random route (force crossing for selected receivers)
                const isCrossing = crossingIndices.includes(i);
                generateRandomRoute(receiver, isCrossing);

                // Keep name labels hidden
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });

            // Reset play start time for label fading
            gameState.playStartTime = performance.now() * 0.001;
        };

        // Generate a random route for a receiver
        const generateRandomRoute = (receiver, forceCrossing = false) => {
            const startX = receiver.startPos.x;
            const startZ = receiver.startPos.z;
            const END_ZONE_Z = 11;  // End zone starts here
            const END_ZONE_BACK = 15;  // Back of end zone
            const SIDELINE = 8;  // Field boundary

            // Calculate available depth to end zone
            const depthToEndZone = END_ZONE_Z - startZ;
            const isVeryNearGoalLine = depthToEndZone < 2;  // Within 2 yards - need sideways cuts
            const isNearGoalLine = depthToEndZone < 8;  // Within 8 yards of end zone - use goal line routes
            const isOnSideline = Math.abs(startX) > 5;  // Near sideline
            const isInRedZone = depthToEndZone < 12;  // Inside the ~12 yard line

            // Determine lateral directions
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = startX > 0 ? 1 : -1;

            const route = [];
            let routeType;

            // Select route type based on field position
            if (isVeryNearGoalLine) {
                // Very close to goal line - routes must go into end zone then cut sideways
                if (isOnSideline) {
                    // Near sideline - cut toward middle of end zone
                    const types = ['endzone_in', 'endzone_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field - can cut either direction
                    const types = ['endzone_out', 'endzone_cross', 'endzone_corner'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isNearGoalLine) {
                // Goal line routes - short, quick, mostly crossing or corner fades
                if (isOnSideline || forceCrossing) {
                    // Near sideline + goal line = must cross toward middle
                    const types = ['quick_slant', 'corner_fade', 'flat_cross', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field near goal line - favor crossing routes
                    const types = ['quick_slant', 'flat_cross', 'back_shoulder', 'quick_slant', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isInRedZone) {
                // Red zone routes - medium depth, need to get into end zone
                if (isOnSideline) {
                    const types = ['corner', 'fade', 'comeback_corner', 'slant'];
                    routeType = forceCrossing ? 'slant' : types[Math.floor(Math.random() * types.length)];
                } else {
                    const types = ['post', 'dig', 'seam', 'out'];
                    routeType = forceCrossing ? 'dig' : types[Math.floor(Math.random() * types.length)];
                }
            } else {
                // Normal field position - full route tree
                if (forceCrossing) {
                    routeType = Math.random() > 0.5 ? 'crossing' : 'dig';
                } else if (isOnSideline) {
                    // Sideline receivers: go, corner, out, comeback
                    const types = ['go', 'corner', 'out', 'comeback', 'post'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Slot/middle receivers: slant, seam, dig, post
                    const types = ['slant', 'seam', 'dig', 'post', 'curl'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            }

            // Generate route points based on type
            switch(routeType) {
                // === END ZONE ROUTES (very close to goal line) ===
                case 'endzone_out':
                    // Go into end zone 2-3 yards, then cut sharply toward sideline
                    const ezOutDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezOutX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 3)));
                    route.push({ z: ezOutDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezOutDepth + 0.5, x: ezOutX });  // Cut sharply sideways
                    break;

                case 'endzone_in':
                    // Go into end zone 2-3 yards, then cut sharply toward middle
                    const ezInDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_BACK - 1);
                    const ezInX = Math.max(-5, Math.min(5, startX + towardMiddle * (4 + Math.random() * 3)));
                    route.push({ z: ezInDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezInDepth + 0.5, x: ezInX });  // Cut sharply toward middle
                    break;

                case 'endzone_cross':
                    // Go into end zone 2-3 yards, then run horizontally across
                    const ezCrossDepth = Math.min(startZ + 2 + Math.random() * 1.5, END_ZONE_BACK - 1);
                    const ezCrossX = Math.max(-6, Math.min(6, startX + towardMiddle * (6 + Math.random() * 4)));
                    route.push({ z: ezCrossDepth, x: startX });  // Go forward into end zone
                    route.push({ z: ezCrossDepth, x: (startX + ezCrossX) / 2 });  // Start crossing
                    route.push({ z: ezCrossDepth + 0.5, x: ezCrossX });  // Continue across
                    break;

                case 'endzone_corner':
                    // Go into end zone 2-3 yards, then angle to back corner
                    const ezCornerDepth = Math.min(startZ + 2 + Math.random(), END_ZONE_Z + 2);
                    const ezCornerX = Math.max(-7, Math.min(7, startX + towardSideline * (3 + Math.random() * 2)));
                    route.push({ z: ezCornerDepth, x: startX + towardSideline * 0.5 });  // Slight angle in
                    route.push({ z: Math.min(ezCornerDepth + 2, END_ZONE_BACK), x: ezCornerX });  // Break to corner
                    break;

                // === GOAL LINE ROUTES ===
                case 'quick_slant':
                    // Quick slant toward middle - 2-3 yards then cut, go to end zone
                    const qsDepth = startZ + 2;
                    const qsEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (4 + Math.random() * 2)));
                    route.push({ z: qsDepth, x: startX });
                    route.push({ z: qsDepth + 3, x: qsEndX });
                    route.push({ z: END_ZONE_BACK, x: qsEndX });
                    break;

                case 'flat_cross':
                    // Push 2-3 yards past LOS then cross across the formation, go to end zone
                    const fcStem = startZ + 2 + Math.random();  // 2-3 yards forward first
                    const fcX = startX + towardMiddle * (6 + Math.random() * 3);
                    route.push({ z: fcStem, x: startX });  // Vertical stem past LOS
                    route.push({ z: fcStem + 1, x: Math.max(-6, Math.min(6, fcX)) });  // Then cross
                    route.push({ z: END_ZONE_BACK, x: Math.max(-6, Math.min(6, fcX + towardMiddle * 2)) });
                    break;

                case 'back_shoulder':
                    // Straight then slight fade back - for back shoulder throw, extend to end zone
                    route.push({ z: startZ + 3, x: startX });
                    route.push({ z: startZ + 5, x: startX + towardSideline * 1.5 });
                    route.push({ z: END_ZONE_BACK, x: startX + towardSideline * 2 });
                    break;

                case 'corner_fade':
                    // Quick move to corner of end zone
                    const cfX = Math.max(-7, Math.min(7, startX + towardSideline * 3));
                    route.push({ z: startZ + 2, x: cfX });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, cfX + towardSideline * 2)) });
                    break;

                case 'out_and_up':
                    // Fake out, then go vertical to end zone
                    const oauOutX = startX + towardSideline * 2;
                    route.push({ z: startZ + 2, x: oauOutX });
                    route.push({ z: END_ZONE_BACK, x: oauOutX });
                    break;

                // === RED ZONE ROUTES ===
                case 'corner':
                    // Break toward corner of end zone - break at 3-5 yards, go to back corner
                    const cornerBreak = startZ + 3 + Math.random() * 2;
                    const cornerX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: cornerBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: cornerX });
                    break;

                case 'comeback_corner':
                    // Go 4-5 yards, comeback, then break to corner and go to end zone
                    const ccBreak = startZ + 4 + Math.random();
                    route.push({ z: ccBreak, x: startX });
                    route.push({ z: ccBreak - 1, x: startX });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + towardSideline * 4)) });
                    break;

                // === STANDARD ROUTES ===
                case 'go':
                case 'fade':
                    // Straight up the field with slight fade - go to back of end zone
                    const fadeAmount = towardSideline * (1 + Math.random() * 2);
                    route.push({ z: startZ + 8, x: startX + fadeAmount * 0.3 });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-7, Math.min(7, startX + fadeAmount)) });
                    break;

                case 'slant':
                    // Quick slant across the middle - break at 2-3 yards, then go deep
                    const slantBreak = startZ + 2 + Math.random() * 1;
                    const slantX = startX + towardMiddle * (5 + Math.random() * 3);
                    route.push({ z: slantBreak, x: startX });
                    route.push({ z: slantBreak + 5, x: Math.max(-5, Math.min(5, slantX)) });
                    route.push({ z: END_ZONE_BACK, x: Math.max(-5, Math.min(5, slantX)) });
                    break;

                case 'out':
                    // Break to sideline - break at 3-5 yards, then continue deep
                    const outBreak = startZ + 3 + Math.random() * 2;
                    const outX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: outBreak, x: startX });
                    route.push({ z: outBreak + 1, x: outX });
                    route.push({ z: END_ZONE_BACK, x: outX });
                    break;

                case 'post':
                    // Break toward the goalpost - break at 4-6 yards, go to back of end zone
                    const postBreak = startZ + 4 + Math.random() * 2;
                    route.push({ z: postBreak, x: startX });
                    route.push({ z: END_ZONE_BACK, x: towardMiddle * (2 + Math.random() * 2) });
                    break;

                case 'dig':
                case 'crossing':
                    // Cross route - break at 4-6 yards then go deep
                    const digBreak = startZ + 4 + Math.random() * 2;
                    const digEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (8 + Math.random() * 4)));
                    route.push({ z: digBreak, x: startX });
                    route.push({ z: digBreak + 2, x: digEndX });
                    route.push({ z: END_ZONE_BACK, x: digEndX });
                    break;

                case 'seam':
                    // Straight up the seam - slight angle at 3 yards, go deep
                    const seamTarget = startX > 0 ? 3 : -3;  // Stay in seam
                    route.push({ z: startZ + 3, x: (startX + seamTarget) / 2 });
                    route.push({ z: startZ + 10, x: seamTarget });
                    route.push({ z: END_ZONE_BACK, x: seamTarget });
                    break;

                case 'curl':
                case 'comeback':
                    // Run up 5-7 yards, curl back toward QB, then cross horizontally to opposite sideline
                    const curlDepth = startZ + 5 + Math.random() * 2;
                    const oppositeSideline = startX > 0 ? -6 : 6;  // Go to opposite side of field
                    route.push({ z: curlDepth, x: startX });
                    route.push({ z: curlDepth - 2, x: startX + towardMiddle * 1 });  // Curl back
                    route.push({ z: curlDepth - 1, x: oppositeSideline });  // Cross horizontally to other sideline
                    break;

                default:
                    // Fallback: simple go route to end zone
                    route.push({ z: startZ + 8, x: startX });
                    route.push({ z: END_ZONE_BACK, x: startX });
            }

            // Ensure all route points move forward (no backwards routes)
            let lastZ = startZ;
            route.forEach(point => {
                if (point.z < lastZ) {
                    point.z = lastZ + 0.5;  // Force forward movement
                }
                lastZ = point.z;
                // Clamp to field boundaries
                point.z = Math.min(point.z, END_ZONE_BACK);
                point.x = Math.max(-SIDELINE, Math.min(SIDELINE, point.x));
            });

            // Post-process: ensure routes extend into end zone if close enough
            if (route.length > 0) {
                const lastPoint = route[route.length - 1];
                const distToEndZone = END_ZONE_Z - lastPoint.z;

                // If within 8 yards of end zone and route doesn't reach it, extend
                if (distToEndZone > 0 && distToEndZone < 8) {
                    route.push({
                        z: Math.min(END_ZONE_Z + 2, END_ZONE_BACK),
                        x: lastPoint.x
                    });
                }

                // If route ends near sideline, add crossing waypoint back toward middle
                // But only if we're still in the first 15 yards of the route (not in end zone)
                const finalPoint = route[route.length - 1];
                const routeDepth = finalPoint.z - startZ;  // How far into the route
                if (Math.abs(finalPoint.x) > 6 && routeDepth < 15 && finalPoint.z < END_ZONE_Z - 2) {
                    const crossDirection = finalPoint.x > 0 ? -1 : 1;  // Cross toward middle
                    route.push({
                        z: Math.min(finalPoint.z + 2, END_ZONE_BACK),
                        x: finalPoint.x + crossDirection * 4  // Cross 4 yards toward middle
                    });
                }
            }

            receiver.route = route;

            // Update route line visual
            if (receiver.routeLine) {
                receiver.routeLine.dispose();
            }

            const routePoints = [receiver.startPos.clone()];
            routePoints[0].y = 0.05;
            route.forEach(point => {
                routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
            });

            // Need to access scene - store reference on gameState
            if (gameState.scene && gameState.routeMaterial) {
                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + receiver.name, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, gameState.scene);
                routeLine.material = gameState.routeMaterial;
                receiver.routeLine = routeLine;
            }
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            // Track throws in target practice mode
            if (gameState.targetPracticeMode) {
                gameState.targetPracticeRoundThrows++;
                gameState.targetPracticeTotalThrows++;
                updateTargetPracticeUI();
            }

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');
            clearThrowHeatMap();

            // Capture receiver positions, velocities, speeds, and momentum at throw time for rating calculation
            gameState.receiverVelocitiesAtThrow = {};
            gameState.receiverPositionsAtThrow = {};
            gameState.receiverSpeedsAtThrow = {};
            gameState.receiverMomentumAtThrow = {};
            gameState.receivers.forEach(receiver => {
                gameState.receiverVelocitiesAtThrow[receiver.name] = receiver.velocity ? receiver.velocity.clone() : new BABYLON.Vector3(0, 0, 0);
                gameState.receiverPositionsAtThrow[receiver.name] = receiver.position.clone();
                // Capture current speed (includes any active boost)
                gameState.receiverSpeedsAtThrow[receiver.name] = receiver.speed || receiver.baseSpeed;
                // Capture runMomentum (smoothed 0-1 value indicating if at full running speed)
                gameState.receiverMomentumAtThrow[receiver.name] = receiver.runMomentum || 0;
            });
            gameState.throwStartTime = performance.now();

            // Record throw attempt for QB
            if (scene.qb && scene.qb.playerId) {
                const qbStats = gameStats.getPlayer(scene.qb.playerId, scene.qb.displayName || 'QB');
                qbStats.throwDistances.push(throwParams.distance);
                qbStats.airDistances.push(throwParams.distance * throwParams.power);
                gameState.currentThrowQbId = scene.qb.playerId;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            // Catch radius scales with catching stat: 0.8 at 50, 1.2 at 75, 1.8 at 100
            const baseCatchRadius = 1.2;

            let frameIndex = 0;
            // Ball flight speed - short throws faster, long throws slower for arc visibility
            // Short throws: quick (1.5), long throws: slower (0.7)
            // Apply ball speed multiplier from training settings
            // Scale by playerScale to match scaled player movement speeds
            const baseAnimationSpeed = 1.5 - (throwParams.power * 0.8);
            const animationSpeed = baseAnimationSpeed * gameState.ballSpeedMultiplier * gameState.playerScale;
            let accumulator = 0;
            const time = { value: 0 };

            // Spiral rotation tracking - fast visible spin for tight spiral effect
            let spiralAngle = 0;
            const spiralSpeed = 45 + (throwParams.power * 25);  // Fast visible spiral, increases with power

            // Create trail effect for ball
            const trailParticles = [];
            const trailMaterial = new BABYLON.StandardMaterial('trailMat', scene);
            trailMaterial.diffuseColor = new BABYLON.Color3(1, 0.8, 0.3);
            trailMaterial.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
            trailMaterial.alpha = 0.8;
            let lastTrailPos = null;
            const trailSpacing = 0.3; // Distance between trail particles

            // Create target circle at landing position (torus is horizontal by default in XZ plane)
            const targetCircle = BABYLON.MeshBuilder.CreateTorus('targetCircle', {
                diameter: 1.5,
                thickness: 0.15,
                tessellation: 32
            }, scene);
            targetCircle.position = new BABYLON.Vector3(landingPos.x, 0.05, landingPos.z);
            // No rotation needed - torus is already in XZ plane (horizontal)
            const targetMaterial = new BABYLON.StandardMaterial('targetMat', scene);
            targetMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0.3);
            targetMaterial.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
            targetMaterial.alpha = 0.7;
            targetCircle.material = targetMaterial;

            // Find closest receiver to ball landing and show optimal lead marker
            let optimalLeadMarker = null;
            let closestReceiver = null;
            let closestDist = Infinity;
            gameState.receivers.forEach(receiver => {
                const pos = gameState.receiverPositionsAtThrow[receiver.name];
                if (pos) {
                    const dist = Math.sqrt(
                        Math.pow(landingPos.x - pos.x, 2) +
                        Math.pow(landingPos.z - pos.z, 2)
                    );
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestReceiver = receiver;
                    }
                }
            });

            if (closestReceiver) {
                const throwPos = gameState.receiverPositionsAtThrow[closestReceiver.name];
                const throwVel = gameState.receiverVelocitiesAtThrow[closestReceiver.name];
                // Velocity is per-frame, convert to per-second by multiplying by 60
                const velPerSec = { x: throwVel.x * 60, z: throwVel.z * 60 };
                const velMag = Math.sqrt(velPerSec.x * velPerSec.x + velPerSec.z * velPerSec.z);

                if (velMag > 0.1) {
                    // Estimate flight time in seconds
                    const estFlightTime = path.length / (60 * animationSpeed);
                    // Ideal lead = where receiver will be at catch time (with 0.8 factor for catching room)
                    const idealLead = velMag * estFlightTime * 0.8;

                    // Optimal position = throw position + velocity direction * ideal lead
                    const optimalX = throwPos.x + (velPerSec.x / velMag) * idealLead;
                    const optimalZ = throwPos.z + (velPerSec.z / velMag) * idealLead;

                    // Create white X marker using two crossed cylinders
                    const xSize = 0.8;
                    const xThickness = 0.12;
                    const bar1 = BABYLON.MeshBuilder.CreateCylinder('optBar1', {
                        height: xSize, diameter: xThickness
                    }, scene);
                    const bar2 = BABYLON.MeshBuilder.CreateCylinder('optBar2', {
                        height: xSize, diameter: xThickness
                    }, scene);

                    // Rotate to form X shape lying flat on field
                    bar1.rotation.x = Math.PI / 2;
                    bar1.rotation.y = Math.PI / 4;
                    bar2.rotation.x = Math.PI / 2;
                    bar2.rotation.y = -Math.PI / 4;

                    bar1.position = new BABYLON.Vector3(optimalX, 0.08, optimalZ);
                    bar2.position = new BABYLON.Vector3(optimalX, 0.08, optimalZ);

                    const optimalMat = new BABYLON.StandardMaterial('optimalMat', scene);
                    optimalMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                    optimalMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                    bar1.material = optimalMat;
                    bar2.material = optimalMat;

                    optimalLeadMarker = { bar1, bar2 };
                }
            }

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path for proper orientation
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity (nose follows arc)
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Tight spiral rotation around the ball's long axis
                    spiralAngle += dt * spiralSpeed;
                    football.rotation.z = spiralAngle;

                    // Add trail particles
                    const currentPos = football.position.clone();
                    if (!lastTrailPos || BABYLON.Vector3.Distance(currentPos, lastTrailPos) > trailSpacing) {
                        const trailSphere = BABYLON.MeshBuilder.CreateSphere('trail', { diameter: 0.15, segments: 4 }, scene);
                        trailSphere.position = currentPos.clone();
                        trailSphere.material = trailMaterial;
                        trailParticles.push({ mesh: trailSphere, alpha: 0.8, createdAt: time.value });
                        lastTrailPos = currentPos.clone();
                    }

                    // Fade and remove old trail particles
                    for (let i = trailParticles.length - 1; i >= 0; i--) {
                        const particle = trailParticles[i];
                        const age = time.value - particle.createdAt;
                        particle.alpha = Math.max(0, 0.8 - age * 2);
                        particle.mesh.visibility = particle.alpha;
                        if (particle.alpha <= 0) {
                            particle.mesh.dispose();
                            trailParticles.splice(i, 1);
                        }
                    }

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Don't expire speed boosts during ball flight - keep speed locked for accurate throw rating
                        // Speed boosts will expire after the catch/incompletion

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // Calculate effective speed (apply initial clash slowdown if no outcome yet)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;
                        }

                        // Check if route is complete
                        const routeComplete = !receiver.route || receiver.routeIndex >= receiver.route.length;

                        // Calculate this receiver's catch radius based on catching stat
                        // Scales from 0.8 at 50 catching to 1.8 at 100 catching
                        // Scale by playerScale so larger players have proportionally larger catch radius
                        const receiverCatchRadius = (0.8 + ((receiver.stats.catching - 50) / 50) * 1.0) * gameState.playerScale;

                        // Larger adjustment range so receivers can adjust to the ball
                        const adjustmentRange = Math.max(5, receiverCatchRadius * 3);

                        // Apply difficulty scaling to awareness and agility
                        // Use training difficulty in training mode, game difficulty otherwise
                        // Easy: no change, Medium: -30 effective, Hard: -50 effective
                        const currentDifficulty = gameState.trainingMode ? gameState.trainingDifficulty : gameState.gameDifficulty;
                        const difficultyPenalty = currentDifficulty === 'easy' ? 0 :
                                                  currentDifficulty === 'hard' ? 50 : 30;

                        // Calculate reaction delay based on receiver's intelligence (awareness/field vision)
                        // Easy 90 INT = 3 frames, Medium 90 INT = 10 frames (like Easy 60)
                        const rawIntelligence = receiver.coreAttributes?.intelligence || 70;
                        const effectiveIntelligence = Math.max(20, rawIntelligence - difficultyPenalty);
                        const reactionFrames = Math.floor((100 - effectiveIntelligence) / 3);

                        // Agility stat controls max turn rate (radians per frame)
                        // Uses cubic scaling so low agility can barely turn at all
                        const rawAgility = receiver.coreAttributes?.agility || 70;
                        const effectiveAgility = Math.max(20, rawAgility - difficultyPenalty);
                        const agilityNorm = effectiveAgility / 100;
                        const maxTurnRate = 0.01 + (agilityNorm * agilityNorm * agilityNorm) * 0.26;  // cubic scaling

                        // Initialize heading direction if not set (use current rotation)
                        if (receiver.headingAngle === undefined) {
                            receiver.headingAngle = receiver.rotation.y || 0;
                        }

                        // First priority: continue running route if not complete
                        if (!routeComplete) {
                            // Ball is close - adjust toward it instead of following route
                            if (distToLanding < adjustmentRange && frameIndex > reactionFrames) {
                                if (distToLanding > 0.3) {
                                    // Calculate desired angle to ball
                                    const desiredAngle = Math.atan2(dx, dz);

                                    // Calculate angle difference (normalized to -PI to PI)
                                    let angleDiff = desiredAngle - receiver.headingAngle;
                                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                                    // Limit turn rate based on awareness
                                    const actualTurn = Math.max(-maxTurnRate, Math.min(maxTurnRate, angleDiff));
                                    receiver.headingAngle += actualTurn;

                                    // Move in heading direction (not directly toward ball)
                                    const catchAdjustSpeed = effectiveSpeed * 0.8;
                                    receiver.position.x += Math.sin(receiver.headingAngle) * catchAdjustSpeed;
                                    receiver.position.z += Math.cos(receiver.headingAngle) * catchAdjustSpeed;
                                    receiver.rotation.y = receiver.headingAngle;
                                    // Moving at full speed - maintain momentum (no change)
                                } else {
                                    // Waiting at landing spot - decay momentum
                                    receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                                }
                            } else {
                                // Keep running the route (moveReceiverAlongRoute updates momentum)
                                moveReceiverAlongRoute(receiver, effectiveSpeed);
                                // Update heading angle from route movement
                                receiver.headingAngle = receiver.rotation.y;
                            }
                        } else {
                            // Route complete - move toward ball landing spot with turn limits
                            if (distToLanding > 0.3) {
                                // Calculate desired angle to ball
                                const desiredAngle = Math.atan2(dx, dz);

                                // Calculate angle difference (normalized to -PI to PI)
                                let angleDiff = desiredAngle - receiver.headingAngle;
                                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                                // Limit turn rate based on awareness
                                const actualTurn = Math.max(-maxTurnRate, Math.min(maxTurnRate, angleDiff));
                                receiver.headingAngle += actualTurn;

                                // Move in heading direction
                                receiver.position.x += Math.sin(receiver.headingAngle) * effectiveSpeed;
                                receiver.position.z += Math.cos(receiver.headingAngle) * effectiveSpeed;
                                receiver.rotation.y = receiver.headingAngle;
                                // Moving at full speed - maintain momentum (no change)
                            } else {
                                // Waiting at landing spot - decay momentum
                                receiver.runMomentum = (receiver.runMomentum || 0) * 0.95;
                            }
                        }

                        // Apply momentum-based forward lean
                        receiver.rotation.x = (receiver.runMomentum || 0) * 0.25;

                        // Running animation (bob only, tilt handled by momentum system)
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Calculate effective speed with catch-up boost
                        let effectiveSpeed = defender.speed;
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running animation (bob only, tilt handled by momentum system)
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                    });

                    // Move linemen during ball flight (battle continues!)
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            return;
                        }
                        moveOLineman(oLineman);
                        oLineman.position.y = Math.abs(Math.sin(time.value * 4 + i * 0.5)) * 0.03;
                    });

                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            return;
                        }
                        moveDLineman(dLineman);
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        dLineman.position.y = Math.abs(Math.sin(time.value * (isRushing ? 8 : 4) + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes during ball flight
                    processLineClashes();

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    // Clean up trail particles, target circle, and optimal lead marker
                    trailParticles.forEach(p => p.mesh.dispose());
                    trailParticles.length = 0;
                    trailMaterial.dispose();
                    targetCircle.dispose();
                    targetMaterial.dispose();
                    if (optimalLeadMarker) {
                        optimalLeadMarker.bar1.dispose();
                        optimalLeadMarker.bar2.dispose();
                    }
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            // Target Practice Mode - check for target hits instead
            if (gameState.targetPracticeMode) {
                const hitTargets = checkTargetHits(ballPosition);
                const throwDistance = scene.qb ? BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(scene.qb.position.x, 0, scene.qb.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                ) : 10;

                // Show landing ripple effect
                showLandingRipple(scene, ballPosition, hitTargets.length > 0);

                handleTargetHit(hitTargets, throwDistance, ballPosition);

                // Quick reset for target practice (ball disappears, can throw again)
                scene.football.setEnabled(false);
                resetTargetPracticePlay();
                return;
            }

            let potentialCatcher = null;
            let closestDistance = Infinity;
            let catcherRadius = 1.2;  // Default

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                // Each receiver's catch radius depends on their catching stat
                // Scales from 0.8 at 50 catching to 1.8 at 100 catching
                // Scale by playerScale so larger players have proportionally larger catch radius
                const receiverCatchRadius = (0.8 + ((receiver.stats.catching - 50) / 50) * 1.0) * gameState.playerScale;

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                // Check if within this receiver's catch radius and closer than others
                if (distance < receiverCatchRadius && distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                    catcherRadius = receiverCatchRadius;
                }
            }

            if (potentialCatcher) {
                // Calculate throw rating first (need lead score for catch probability)
                const throwRating = calculateThrowRating(potentialCatcher, ballPosition, gameState.gameTime);

                // Calculate throw distance (from QB to ball) and accuracy
                const throwDistance = scene.qb ? BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(scene.qb.position.x, 0, scene.qb.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                ) : 10;
                const throwAccuracyMult = calculateThrowAccuracy(scene.qb, throwDistance);

                // Calculate catch probability (returns detailed info) - pass slowdown score (momentum-based) for lead bonus
                const catchInfo = calculateCatchProbability(potentialCatcher, ballPosition, throwRating.slowdownScore, throwAccuracyMult);
                const catchRoll = Math.random() * 100;
                const success = catchRoll < catchInfo.probability;

                // Track attempt
                gameState.attempts++;

                // Record target for roster player
                recordPlayerStat(potentialCatcher, 'seasonTargets');

                // Show the catch probability display with throw rating
                showCatchDisplay(catchInfo, catchRoll, success, throwRating);

                // Store catch info for game mode popup
                gameState.lastCatchInfo = catchInfo;
                gameState.lastCatchRoll = catchRoll;
                gameState.lastCatchSuccess = success;

                // Record per-game catch stats
                if (potentialCatcher.playerId) {
                    const pStats = gameStats.getPlayer(potentialCatcher.playerId, potentialCatcher.displayName);
                    pStats.catchDifficulties.push(catchInfo.probability);
                    if (success) {
                        pStats.catches++;
                    } else {
                        pStats.drops++;
                    }
                }

                // Record QB completion/incompletion
                if (gameState.currentThrowQbId) {
                    const qbStats = gameStats.getPlayer(gameState.currentThrowQbId, 'QB');
                    if (success) {
                        qbStats.completions++;
                    } else {
                        qbStats.incompletions++;
                    }
                }

                // In training mode, show throw rating
                if (gameState.trainingMode) {
                    gameState.lastThrowRating = throwRating;

                    // Update throw rating UI
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');

                    const gradeColors = {
                        'A+': '#0f0', 'A': '#4f4', 'B': '#af4',
                        'C': '#ff4', 'D': '#f84', 'F': '#f44'
                    };

                    gradeEl.textContent = throwRating.grade;
                    gradeEl.style.color = gradeColors[throwRating.grade] || '#fff';

                    // Build detailed breakdown for training feedback
                    detailsEl.textContent = throwRating.details;

                    // Build modifier list with right-aligned values and color coding
                    const modList = document.getElementById('popupModifierList');

                    // Helper to create a modifier row
                    const makeRow = (label, value, isPositive) => {
                        const color = isPositive ? '#4f4' : '#f66';
                        const sign = isPositive ? '+' : '';
                        return `<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#aaa;">${label}</span>
                            <span style="color:${color}; font-weight:bold;">${sign}${value}</span>
                        </div>`;
                    };

                    let modRows = [];

                    // === 1. BASE CATCH RATE ===
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#fff;">Base catch rate:</span>
                        <span style="color:#8f8; font-weight:bold;">${Math.round(catchInfo.wideOpenRate)}%</span>
                    </div>`);
                    modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                        catching: ${catchInfo.baseCatch}
                    </div>`);

                    // === 2. COVERAGE PENALTY ===
                    if (catchInfo.isContested && catchInfo.dbPenalty > 0) {
                        const sepYards = catchInfo.separation.toFixed(1);
                        // Find the closest defender's coverage stat
                        const defCoverage = catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0
                            ? catchInfo.defenderDetails[0].coverageStat : 0;
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Coverage penalty:</span>
                            <span style="color:#f66; font-weight:bold;">-${catchInfo.dbPenalty}%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            separation: ${sepYards}, coverage: ${defCoverage}
                        </div>`);
                    }

                    // === 3. LEAD BONUS ===
                    const momentumScore = throwRating.slowdownScore || 100;
                    const momentumLabel = momentumScore >= 90 ? 'in stride' : momentumScore >= 70 ? 'adjusted' : 'slowed down';
                    if (catchInfo.shoulderBonusSaved > 0) {
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Lead bonus:</span>
                            <span style="color:#4a4; font-weight:bold;">+${catchInfo.shoulderBonusSaved}%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            ${momentumLabel} (${Math.round(momentumScore)}% momentum)
                        </div>`);
                    } else if (catchInfo.isContested) {
                        modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                            <span style="color:#fff;">Lead bonus:</span>
                            <span style="color:#666;">0%</span>
                        </div>`);
                        modRows.push(`<div style="font-size: 11px; color:#666; margin-left: 12px; margin-bottom: 6px;">
                            ${momentumLabel} (${Math.round(momentumScore)}% momentum)
                        </div>`);
                    }

                    // === DIVIDER ===
                    modRows.push(`<div style="border-top: 1px solid #444; margin: 8px 0;"></div>`);

                    // === 4. FINAL CATCH RATE ===
                    const finalColor = catchInfo.probability >= 50 ? '#4f4' : (catchInfo.probability >= 25 ? '#ff4' : '#f66');
                    modRows.push(`<div style="display:flex; justify-content:space-between; margin: 4px 0;">
                        <span style="color:#fff; font-weight:bold;">Final catch rate:</span>
                        <span style="color:${finalColor}; font-weight:bold; font-size: 16px;">${Math.round(catchInfo.probability)}%</span>
                    </div>`);

                    modList.innerHTML = modRows.join('');

                    // Update visual catch bar in popup
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBase = document.getElementById('popupCatchBase');
                    const popupPenalty = document.getElementById('popupCatchPenalty');
                    const popupRoll = document.getElementById('popupCatchRoll');

                    popupHeader.textContent = success ? 'CATCH!' : 'DROPPED';
                    popupHeader.style.color = success ? '#4f4' : '#f66';

                    // Show wide open rate as base, with penalty overlay
                    const baseWidth = catchInfo.isContested ? catchInfo.wideOpenRate : catchInfo.wideOpenRate;
                    const penaltyWidth = Math.max(0, catchInfo.wideOpenRate - catchInfo.probability);

                    popupBase.style.width = `${baseWidth}%`;

                    if (penaltyWidth > 0) {
                        popupPenalty.style.display = 'block';
                        popupPenalty.style.left = `${catchInfo.probability}%`;
                        popupPenalty.style.width = `${penaltyWidth}%`;
                    } else {
                        popupPenalty.style.display = 'none';
                    }

                    popupRoll.textContent = 'üèà';
                    popupRoll.style.filter = success ? 'none' : 'grayscale(100%)';
                    popupRoll.style.left = `${catchRoll}%`;

                    // Only show popup if setting is enabled
                    if (gameState.showGradePopup) {
                        ratingEl.style.display = 'block';

                        // Dismiss on any click anywhere on screen
                        const dismissPopup = () => {
                            ratingEl.style.display = 'none';
                            document.removeEventListener('click', dismissPopup);
                            document.removeEventListener('touchstart', dismissPopup);
                        };
                        // Small delay to prevent immediate dismissal from the same click
                        setTimeout(() => {
                            document.addEventListener('click', dismissPopup);
                            document.addEventListener('touchstart', dismissPopup);
                        }, 100);
                    }
                }

                if (success) {
                    // Successful catch! Set up ball carrier
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}! RUN!`);

                    // Record catch for roster player
                    recordPlayerStat(potentialCatcher, 'seasonCatches');

                    // Store catch position for YAC tracking
                    potentialCatcher.catchPosition = potentialCatcher.position.z;

                    // Attach ball to receiver
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    // Set up ball carrier state - play continues!
                    gameState.ballCarrier = potentialCatcher;
                    potentialCatcher.breakTackleBoostUntil = 0;

                    // Clean up any speed effects that expired during ball flight
                    cleanupExpiredSpeedEffects();

                    // Start the run-after-catch phase
                    startRunAfterCatch(scene);
                } else {
                    // Dropped or defended - incomplete pass
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    handleIncomplete(wasDefended ? 'Pass defended' : 'Dropped');
                    updateScore();
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');

                    // Clean up any speed effects that expired during ball flight
                    cleanupExpiredSpeedEffects();

                    // Record pass defended for nearest defender if it was defended
                    if (wasDefended) {
                        let closestDefender = null;
                        let closestDist = Infinity;
                        for (const def of gameState.defenders) {
                            const dist = BABYLON.Vector3.Distance(def.position, potentialCatcher.position);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestDefender = def;
                            }
                        }
                        if (closestDefender) {
                            recordPlayerStat(closestDefender, 'seasonPassesDefended');
                            // Record per-game pass defended
                            if (closestDefender.playerId) {
                                gameStats.getPlayer(closestDefender.playerId, closestDefender.displayName).passesDefended++;
                            }
                        }
                    }

                    bounceBall(scene, ballPosition);
                }
            } else {
                // No receiver nearby - incomplete pass
                handleIncomplete('Overthrown');
                updateMessage('Incomplete...');

                // In training mode, show incomplete grade (if popup enabled)
                if (gameState.trainingMode && gameState.showGradePopup) {
                    const ratingEl = document.getElementById('throwRating');
                    const gradeEl = document.getElementById('throwGrade');
                    const detailsEl = document.getElementById('throwDetails');
                    const popupHeader = document.getElementById('popupCatchHeader');
                    const popupBar = document.getElementById('popupCatchBar');
                    const modList = document.getElementById('popupModifierList');

                    gradeEl.textContent = 'INCOMPLETE';
                    gradeEl.style.color = '#f66';
                    gradeEl.style.fontSize = '32px';
                    detailsEl.textContent = 'No receiver in range';

                    popupHeader.textContent = '';
                    popupBar.style.display = 'none';
                    modList.innerHTML = '';

                    ratingEl.style.display = 'block';

                    // Dismiss on any click anywhere on screen
                    const dismissPopup = () => {
                        ratingEl.style.display = 'none';
                        gradeEl.style.fontSize = '48px'; // Reset font size
                        popupBar.style.display = 'block'; // Reset bar visibility
                        document.removeEventListener('click', dismissPopup);
                        document.removeEventListener('touchstart', dismissPopup);
                    };
                    // Small delay to prevent immediate dismissal from the same click
                    setTimeout(() => {
                        document.addEventListener('click', dismissPopup);
                        document.addEventListener('touchstart', dismissPopup);
                    }, 100);
                }

                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Start the run-after-catch phase with animation loop
        const startRunAfterCatch = (scene) => {
            const timeSinceCatch = { value: 0 };

            const runAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                timeSinceCatch.value += dt;
                gameState.gameTime = performance.now() * 0.001;

                // Check if play has ended
                if (gameState.playEnded) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                const ballCarrier = gameState.ballCarrier;
                if (!ballCarrier) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                // Move ball carrier
                moveBallCarrier(ballCarrier);

                // Running animation for ball carrier (bob only, tilt handled by momentum system)
                ballCarrier.position.y = Math.abs(Math.sin(timeSinceCatch.value * 10)) * 0.1;

                // Calculate pursuit boost based on time since catch
                // After 1 second: 10% boost, after 2 seconds: 20% boost
                let pursuitBoost = 1.0;
                if (timeSinceCatch.value >= 2.0) {
                    pursuitBoost = 1.2;  // 20% boost after 2 seconds
                } else if (timeSinceCatch.value >= 1.0) {
                    // Interpolate from 10% to 20% between 1 and 2 seconds
                    const t = timeSinceCatch.value - 1.0;  // 0 to 1
                    pursuitBoost = 1.1 + (t * 0.1);  // 1.1 to 1.2
                }

                // Move all defenders in pursuit with speed boost
                gameState.defenders.forEach((defender, i) => {
                    if (defender.knockdownUntil <= gameState.gameTime) {
                        moveDefenderPursuit(defender, pursuitBoost);

                        // Running animation (bob only, tilt handled by momentum system)
                        const animSpeed = 10 + (pursuitBoost - 1.0) * 20;
                        defender.position.y = Math.abs(Math.sin(timeSinceCatch.value * animSpeed + i)) * 0.08;
                    }
                });

                // Process tackle attempts
                processTackles();
            });
        };

        // Calculate QB throw accuracy based on distance
        // Uses agility √ó (shortPassAcc or longPassAcc) multiplicatively
        // Returns multiplier for lead bonus: 1.2 at 100, 1.0 at 80, 0.8 at 70, 0.7 at 60
        const calculateThrowAccuracy = (qb, throwDistance) => {
            if (!qb || !qb.stats) return 1.0;

            const agility = qb.coreAttributes?.agility || 70;

            // Use short pass accuracy for <12 yards, long pass for 12+ yards
            const isShortPass = throwDistance < 12;
            const passAccStat = isShortPass
                ? (qb.stats.shortPassAcc || qb.stats.throwing || 70)
                : (qb.stats.longPassAcc || qb.stats.throwing || 70);

            // Multiplicative: (agility/100) √ó (passAcc/100) ‚Üí normalized 0-1
            const accuracy = (agility / 100) * (passAccStat / 100) * 100;

            // Scale to lead bonus multiplier:
            // 100 ‚Üí 1.2, 80 ‚Üí 1.0, 70 ‚Üí 0.8, 60 ‚Üí 0.7
            // Linear interpolation between these points
            if (accuracy >= 80) {
                // 80-100 maps to 1.0-1.2
                return 1.0 + (accuracy - 80) / 100;
            } else if (accuracy >= 70) {
                // 70-80 maps to 0.8-1.0
                return 0.8 + (accuracy - 70) / 50;
            } else {
                // 60-70 maps to 0.7-0.8, below 60 caps at 0.7
                return Math.max(0.7, 0.7 + (accuracy - 60) / 100);
            }
        };

        // Calculate catch probability based on receiver stats and proximity to defenders
        // NEW SIMPLIFIED FORMULA:
        // baseCatchRate = (catching - 50) √ó 2 + 20  -> 70‚Üí60%, 80‚Üí80%, 90‚Üí100%
        // dbPenalty = dbCoverage √ó 0.7 √ó proximity¬≤
        // leadBonus = up to 50% reduction of DB penalty based on momentum (slowdownScore)
        // finalRate = baseCatchRate - effectiveDbPenalty
        const calculateCatchProbability = (receiver, ballPosition, momentumScore = 50, throwAccuracyMultiplier = 1.0) => {
            const catchingStat = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            // Find closest defender and check for shoulder throw
            let closestDefenderDist = coverageRange;
            let closestDefenderCoverage = 0;
            let hasSideBonus = false;
            let hasNearbyDefender = false;
            let defenderDetails = [];

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;

                    // Get defender's coverage stat
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;

                    // Check if this is the closest defender
                    if (dist < closestDefenderDist) {
                        closestDefenderDist = dist;
                        closestDefenderCoverage = coverageStat;
                    }

                    // Check for shoulder throw (ball on opposite side from defender)
                    const ballDx = ballPosition.x - receiver.position.x;
                    const ballDz = ballPosition.z - receiver.position.z;
                    const dotProduct = dx * ballDx + dz * ballDz;
                    const isShoulder = dotProduct < 0;
                    if (isShoulder) hasSideBonus = true;

                    defenderDetails.push({
                        name: defender.name,
                        dist: dist.toFixed(2),
                        coverageStat: coverageStat,
                        aiType: defender.aiType,
                        sideBonus: isShoulder
                    });
                }
            });

            // BASE CATCH RATE: catching stat determines your potential
            // 70 catch ‚Üí 70%, 80 catch ‚Üí 95%, 90 catch ‚Üí 120%, 100 catch ‚Üí 145%
            // Not capped - high catching can exceed 100% to better absorb DB penalty
            const baseCatchRate = (catchingStat - 50) * 2.5 + 20;

            // WIDE OPEN: no nearby defender (cap at 98% for actual probability)
            if (!hasNearbyDefender) {
                return {
                    probability: Math.min(98, baseCatchRate),
                    baseCatch: catchingStat,
                    wideOpenRate: baseCatchRate,
                    separation: coverageRange,
                    coverageLevel: 'Wide Open',
                    isContested: false,
                    hasSideBonus: false,
                    shoulderBonusSaved: 0,
                    leadQuality: 0,
                    dbPenalty: 0,
                    defenderDetails: []
                };
            }

            // DB PENALTY: coverage stat √ó proximity¬≤
            // proximity: 1.0 at distance 0, 0.0 at max range
            const proximityFactor = Math.max(0, 1 - (closestDefenderDist / coverageRange));
            const tightCoverageBonus = closestDefenderDist <= 0.7 ? 1.2 : 1.0;  // +20% penalty for tight coverage
            const rawDbPenalty = closestDefenderCoverage * 1.5 * proximityFactor * proximityFactor * tightCoverageBonus;

            // LEAD BONUS: reduces DB penalty based on momentum and throw accuracy
            // Base reduction up to 50%, scaled by QB throw accuracy (0.7x to 1.2x)
            let leadReduction = 0;
            let leadBonusSaved = 0;
            if (hasSideBonus) {
                const baseLeadReduction = (momentumScore / 100) * 0.5;  // 0 to 0.5
                leadReduction = baseLeadReduction * throwAccuracyMultiplier;  // Scale by accuracy
                leadBonusSaved = Math.round(rawDbPenalty * leadReduction);
            }
            const effectiveDbPenalty = rawDbPenalty * (1 - leadReduction);

            // FINAL PROBABILITY
            const finalProbability = Math.max(5, Math.min(98, baseCatchRate - effectiveDbPenalty));

            // Determine coverage level for display
            let coverageLevel = 'Wide Open';
            if (closestDefenderDist <= 0.6) coverageLevel = 'Blanketed';
            else if (closestDefenderDist <= 1.5) coverageLevel = 'Tight Coverage';
            else if (closestDefenderDist <= 2.5) coverageLevel = 'Contested';
            else coverageLevel = 'Light Coverage';

            return {
                probability: finalProbability,
                baseCatch: catchingStat,
                wideOpenRate: baseCatchRate,
                separation: closestDefenderDist,
                coverageLevel: coverageLevel,
                isContested: true,
                hasSideBonus: hasSideBonus,
                shoulderBonusSaved: leadBonusSaved,
                leadQuality: Math.round(momentumScore),
                dbPenalty: Math.round(rawDbPenalty),
                effectiveDbPenalty: Math.round(effectiveDbPenalty),
                defenderDetails: defenderDetails
            };
        };

        // Show catch probability display
        const showCatchDisplay = (catchInfo, roll, success, throwRating = null) => {
            // Skip showing in training mode (catch info is in the popup instead)
            if (gameState.trainingMode) return;

            const display = document.getElementById('catchDisplay');
            const header = display.querySelector('.catch-header');
            const barBase = display.querySelector('.catch-bar-base');
            const barPenalty = display.querySelector('.catch-bar-penalty');
            const barRoll = display.querySelector('.catch-bar-roll');
            const defenderInfo = display.querySelector('.defender-info');
            const throwRatingInfo = display.querySelector('.throw-rating-info');

            // Set header
            header.textContent = success ? 'CATCH!' : 'DROPPED';
            header.className = 'catch-header ' + (success ? 'success' : 'fail');

            // Calculate raw catch % (base + focus, before defender penalty)
            const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
            const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

            // Set bar: green shows raw potential, dark overlay shows defender penalty
            barBase.style.width = `${rawCatch}%`;

            // Penalty overlay starts where final probability ends
            if (penaltyWidth > 0) {
                barPenalty.style.display = 'block';
                barPenalty.style.left = `${catchInfo.probability}%`;
                barPenalty.style.width = `${penaltyWidth}%`;
            } else {
                barPenalty.style.display = 'none';
            }

            // Roll marker with football icon
            barRoll.textContent = 'üèà';
            barRoll.className = 'catch-bar-roll ' + (success ? 'success' : 'fail');
            barRoll.style.filter = success ? 'none' : 'grayscale(100%)';
            barRoll.style.left = `${roll}%`;

            // Show defender distances only
            if (catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0) {
                const distances = catchInfo.defenderDetails
                    .filter(d => parseFloat(d.penalty) > 0.5)
                    .map(d => d.dist)
                    .join(', ');
                defenderInfo.textContent = distances ? distances + 'yd' : '';
            } else {
                defenderInfo.textContent = '';
            }

            // Show throw rating info if available
            if (throwRating) {
                throwRatingInfo.textContent = `${throwRating.grade} | Route: ${throwRating.distToRoute}yd off | Lead: ${throwRating.leadText || ''}`;
            } else {
                throwRatingInfo.textContent = '';
            }

            // Show display
            display.classList.add('visible');

            // Hide after 2.5 seconds
            setTimeout(() => {
                display.classList.remove('visible');
            }, 2500);
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;

            // In target practice mode, immediately reset (no bounce animation)
            if (gameState.targetPracticeMode) {
                football.setEnabled(false);
                resetTargetPracticePlay();
                return;
            }

            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Hide player labels when play starts
        const hidePlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 0;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });
            gameState.defenders.forEach(defender => {
                if (defender.nameLabel) {
                    defender.nameLabel.alpha = 0;
                }
            });
        };

        // Show player labels when play is frozen
        const showPlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 1;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 1;
                }
            });
            gameState.defenders.forEach(defender => {
                if (defender.nameLabel) {
                    defender.nameLabel.alpha = 1;
                }
            });
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset pointer/drag state to prevent desync issues
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragCurrent = null;
            gameState.activePointerId = null;
            gameState.canThrow = true;

            // Reset play state flags
            gameState.ballCarrier = null;
            gameState.playEnded = false;
            gameState.qbSacked = false;
            gameState.playFrozen = true;  // Freeze until player holds screen

            // Clear catch info from previous play
            gameState.lastCatchInfo = null;
            gameState.lastCatchRoll = null;
            gameState.lastCatchSuccess = null;

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Reset linemen
            resetOffensiveLine();
            resetDefensiveLine();

            // Reset QB position (relative to line of scrimmage, randomized depth behind it)
            const qbDepthBehindLine = 2 + Math.random() * 2;  // 2-4 yards behind LOS
            // Clamp QB Z position to stay on visible field (min -60 for own 35 start)
            const qbZ = Math.max(-60, gameState.lineOfScrimmage - qbDepthBehindLine);
            gameState.qbStartZ = qbZ;
            scene.qb.position.x = 0;
            scene.qb.position.z = qbZ;
            scene.qb.position.y = 0;
            scene.qb.rotation.x = 0;
            scene.qb.rotation.y = 0;

            // Update field position markers
            if (scene.losLine) {
                scene.losLine.position.z = gameState.lineOfScrimmage;
            }
            if (scene.firstDownLine) {
                scene.firstDownLine.position.z = gameState.firstDownMarker;
            }

            // Move camera to follow the line of scrimmage
            if (scene.activeCamera) {
                const camera = scene.activeCamera;

                // Target centered on the line of scrimmage
                // Allow camera to follow full field from own 35 (-60) to end zone (Z = 14)
                // Apply camera offset to move view forward (reduces space behind QB)
                const baseTargetZ = gameState.lineOfScrimmage + 2;
                const maxForwardOffset = 12;  // Maximum forward offset in world units
                const forwardOffset = (gameState.cameraOffset || 0) * maxForwardOffset;
                const cameraTargetZ = Math.max(-60, Math.min(14, baseTargetZ + forwardOffset));
                camera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);

                // In training mode, use the slider-controlled camera angle
                if (gameState.trainingMode && gameState.cameraAngle !== undefined) {
                    camera.alpha = -Math.PI / 2;
                    camera.beta = 0.1 + gameState.cameraAngle * (Math.PI / 2 - 0.1);
                    // Adjust radius based on camera offset to maintain consistent framing
                    // More forward offset = slightly larger radius to compensate
                    const baseRadius = 32;
                    const radiusAdjust = (gameState.cameraOffset || 0) * 8;
                    camera.radius = baseRadius + radiusAdjust;
                } else {
                    // Reset camera to current view mode settings (alpha, beta, radius)
                    switch(gameState.currentView) {
                        case 'iso':
                            camera.alpha = -Math.PI / 2;
                            camera.beta = Math.PI / 3.5;
                            camera.radius = 32;
                            break;
                        case 'overhead':
                            camera.alpha = -Math.PI / 2;
                            camera.beta = 0.1;
                            camera.radius = 28;
                            break;
                        case 'shoulder':
                            camera.alpha = -Math.PI / 2;
                            camera.beta = Math.PI / 2.5;
                            camera.radius = 18;
                            break;
                        default:
                            camera.alpha = -Math.PI / 2;
                            camera.beta = Math.PI / 3.5;
                            camera.radius = 32;
                    }
                }
            }

            // Update down and distance display
            updateDownDistance();

            // Show player labels while frozen
            showPlayerLabels();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Hold to start play');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            const scoreEl = document.getElementById('score');
            scoreEl.querySelector('.catches').textContent = `${gameState.catches}/${gameState.attempts}`;
            scoreEl.querySelector('.touchdowns').textContent = gameState.touchdowns;
        };

        const updateDownDistance = () => {
            const ddEl = document.getElementById('downDistance');
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const downText = downNames[gameState.down - 1] || '4th';

            // Calculate yards to go (convert Z units to approximate yards - roughly 1 unit = 1 yard)
            const yardsToGo = Math.max(1, Math.round(gameState.yardsToGo));
            const distanceText = yardsToGo >= 10 ? '10+' : yardsToGo.toString();

            // Calculate field position (yards from end zone)
            // lineOfScrimmage goes from about -8 (own goal line) to 11 (opponent end zone)
            // Convert to standard field position (own 1-50, then opponent 49-1)
            const END_ZONE_Z = 11;
            const yardsFromGoal = Math.round(END_ZONE_Z - gameState.lineOfScrimmage);
            let fieldPosText = '';
            if (yardsFromGoal <= 0) {
                fieldPosText = 'GOAL';
            } else if (yardsFromGoal <= 50) {
                // In opponent territory or at midfield
                fieldPosText = yardsFromGoal === 50 ? 'MID' : `OPP ${yardsFromGoal}`;
            } else {
                // In own territory
                const ownYardLine = 100 - yardsFromGoal;
                fieldPosText = `OWN ${ownYardLine}`;
            }

            ddEl.querySelector('.down').textContent = downText;
            ddEl.querySelector('.distance').textContent = distanceText;
            ddEl.querySelector('.field-pos').textContent = fieldPosText;
        };

        const updateMessage = (msg) => {
            // Message display removed
        };

        // Update debug info display
        const updateDebugInfo = () => {
            if (!FEATURE_FLAGS.showDebugInfo) {
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            document.getElementById('debugInfo').style.display = 'block';

            let debugText = '=== RECEIVER STATUS ===\n';
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.receivers.forEach((receiver, i) => {
                // Find closest defender
                let closestDef = null;
                let closestDist = Infinity;
                gameState.defenders.forEach(def => {
                    if (def.knockdownUntil > gameState.gameTime) return;
                    const dx = def.position.x - receiver.position.x;
                    const dz = def.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestDef = def;
                    }
                });

                const timeSinceClash = (gameState.gameTime - receiver.lastClashTime).toFixed(1);
                const speedMod = (receiver.speed / receiver.baseSpeed * 100).toFixed(0);
                const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                const catchProb = receiver.currentCatchProb || receiver.stats.catching;

                // Determine coverage level based on catch probability
                let coverageLevel = 'OPEN';
                let levelColor = 'üü¢';
                if (catchProb < 40) {
                    coverageLevel = 'COVERED';
                    levelColor = 'üî¥';
                } else if (catchProb < 70) {
                    coverageLevel = 'CONTESTED';
                    levelColor = 'üü°';
                }

                debugText += `\n${receiver.displayName}:\n`;
                debugText += `  ${levelColor} Catch: ${catchProb.toFixed(0)}% (${coverageLevel})\n`;
                debugText += `  Speed: ${speedMod}%${hasSpeedPenalty ? ' (SLOWED)' : ''}\n`;

                if (closestDef) {
                    const defSpeedPenalty = closestDef.clashSpeedPenaltyUntil > gameState.gameTime;
                    const defCovStat = closestDef.aiType === 'zone' ?
                        closestDef.stats.zoneCoverage : closestDef.stats.manCoverage;
                    debugText += `  Nearest: ${closestDef.displayName}`;
                    if (defSpeedPenalty) debugText += ' (SLOWED)';
                    debugText += `\n`;
                    debugText += `  Dist: ${closestDist.toFixed(1)}/${coverageRange.toFixed(1)}`;
                    debugText += ` | ${closestDef.aiType === 'zone' ? 'ZoneCov' : 'ManCov'}: ${defCovStat}\n`;
                }
            });

            document.getElementById('debugInfo').textContent = debugText;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only capture left-click (button 0) or single touch for throwing
                // Let right-click (button 2) and multi-touch pass through to camera
                if (evt.button !== 0 && evt.pointerType === 'mouse') return;

                // ALWAYS unfreeze play when holding down (starts the play)
                // This ensures the play starts even if there was stale state
                if (gameState.playFrozen) {
                    hidePlayerLabels();
                }
                gameState.playFrozen = false;
                gameState.playStartTime = performance.now() * 0.001;

                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.activePointerId = evt.pointerId;  // Track which pointer is dragging
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
            };

            const onPointerMove = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only track the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only respond to the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.activePointerId = null;

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                if (gameState.dragStart && gameState.dragCurrent) {
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Handle pointer cancel (touch interrupted by system gesture, notification, etc.)
            const onPointerCancel = (evt) => {
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                // Clean up drag state without throwing
                gameState.isDragging = false;
                gameState.activePointerId = null;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointercancel', onPointerCancel);
            canvas.addEventListener('pointerleave', onPointerUp);
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                // Skip all game logic when in management mode
                if (!gameSceneActive) return;

                // Pause game during possession overlay
                if (gameState.waitingForPossession) return;

                // Freeze play until player holds screen (but not in target practice)
                if (gameState.playFrozen && !gameState.targetPracticeMode) return;

                // Target Practice Mode - move targets and update distance colors
                if (gameState.targetPracticeMode) {
                    moveTargets();
                    updateTargetDistanceColors();
                }

                // Move bonus zones (all modes)
                moveBonusZones();

                const time = performance.now() * 0.001;

                // QB breathing/ready animation (only when not in danger)
                const qb = scene.qb;
                if (!gameState.playEnded && !gameState.qbSacked) {
                    // Only subtle breathing when not moving
                    const isEvading = gameState.defensiveLine.some(d =>
                        d.knockdownUntil <= gameState.gameTime &&
                        BABYLON.Vector3.Distance(d.position, qb.position) < POCKET_CONSTANTS.THREAT_RADIUS
                    );
                    if (!isEvading) {
                        qb.rotation.y = Math.sin(time * 2) * 0.05;
                        qb.position.y = Math.sin(time * 3) * 0.02;
                    } else {
                        qb.position.y = Math.abs(Math.sin(time * 8)) * 0.06;  // Running animation
                    }
                }

                // Track game time for clash system
                gameState.gameTime = time;

                // Skip receiver/defender processing in target practice mode
                if (gameState.targetPracticeMode) {
                    return;
                }

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Reset speed to base when boost/penalty expires
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate effective speed (slowdown during initial clash, unless clash outcome already applied)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash (only if no outcome yet)
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (receiver.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (receiver.clashTiltUntil - gameState.gameTime) / 0.5;
                            receiver.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                        // Show green while speed boosted, red while speed penalized (if enabled)
                        if (gameState.showClashFlash && receiver.clashSpeedBoostUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const green = new BABYLON.Color3(0.2, 1.0, 0.3);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, green, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = green.scale(flashRate * 0.3);
                        } else if (gameState.showClashFlash && receiver.clashSpeedPenaltyUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const red = new BABYLON.Color3(1.0, 0.2, 0.2);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, red, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = red.scale(flashRate * 0.3);
                        } else {
                            receiver.bodyMaterial.diffuseColor = receiver.originalColor;
                            receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
                        }
                    });

                    // Update throw heat map if enabled
                    if (gameState.showThrowHeatMap) {
                        updateThrowHeatMap();
                    }

                    // Route completion no longer triggers reset - play continues normally

                    // Move offensive linemen
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            oLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        oLineman.rotation.x = 0;

                        moveOLineman(oLineman);

                        // Subtle stance animation
                        oLineman.position.y = Math.abs(Math.sin(time * 4 + i * 0.5)) * 0.03;
                    });

                    // Move defensive linemen
                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            dLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        dLineman.rotation.x = 0;

                        moveDLineman(dLineman);

                        // Running animation when moving fast
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        const bobSpeed = isRushing ? 8 : 4;
                        dLineman.position.y = Math.abs(Math.sin(time * bobSpeed + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes
                    processLineClashes();

                    // Move QB (pocket behavior and evasion)
                    moveQB(scene);

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdowns and boosts from clashes)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }
                        if (defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.5;  // 50% slower after losing clash
                        }
                        // DB catch-up boost - kicks in after receiver's boost ends
                        if (defender.catchupBoostStart && defender.catchupBoostUntil &&
                            gameState.gameTime >= defender.catchupBoostStart &&
                            gameState.gameTime < defender.catchupBoostUntil) {
                            effectiveSpeed *= defender.catchupBoostAmount || 1.3;  // 30% faster catch-up
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (bob only, tilt handled by momentum system)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;

                        // Clash tilt effect (add forward lean during clash)
                        if (defender.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (defender.clashTiltUntil - gameState.gameTime) / 0.5;
                            defender.rotation.x += Math.sin(tiltProgress * Math.PI) * 0.3;
                        }

                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();

                    // Name labels are hidden by hidePlayerLabels() when play starts
                    // No additional fade logic needed here
                }
            });
        };

        // Get zone colors based on catch probability (0-100%)
        // High catch % = green, medium = yellow, low = red
        const getZoneColorsByCatchProb = (catchProbability) => {
            if (catchProbability >= 70) {
                // Green - high catch chance
                return {
                    diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),
                    emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                };
            } else if (catchProbability >= 40) {
                // Yellow - moderate catch chance
                return {
                    diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                };
            } else {
                // Red - low catch chance
                return {
                    diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                };
            }
        };

        // Calculate real-time catch probability for a receiver (for visual display)
        const calculateRealtimeCatchProb = (receiver) => {
            const catchingStat = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;
            let totalDefenderInfluence = 0;
            let hasNearbyDefender = false;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / coverageRange);
                    let influence = proximityFactor * proximityFactor * (coverageStat / 100);
                    if (dist <= 0.6) influence *= 1.5;
                    totalDefenderInfluence += influence;
                }
            });

            totalDefenderInfluence = Math.min(1, totalDefenderInfluence);

            // Match the new catch system: wide open uses catching stat with bonus, contested 25-35%
            if (!hasNearbyDefender || totalDefenderInfluence < 0.1) {
                // Wide open: 60 catching = 80%, 80+ catching = 95% (capped)
                const wideOpenBase = 80 + (catchingStat - 60) * 0.75;
                return Math.min(95, wideOpenBase);
            } else {
                // 50 catching = 10%, 100 catching = 45%
                const contestedBase = 10;
                const catchingBonus = (catchingStat - 50) * 0.7;  // Catching now includes focus ability
                const defenderReduction = totalDefenderInfluence * 40;
                return Math.max(5, Math.min(95, contestedBase + catchingBonus - defenderReduction));
            }
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Calculate real-time catch probability
                const catchProb = calculateRealtimeCatchProb(receiver);
                receiver.currentCatchProb = catchProb;  // Store for debug display

                // Size based on catch probability (larger = higher catch %)
                const minScale = 0.3;  // Minimum size at 0% catch
                const maxScale = 1.2;  // Maximum size at 100% catch
                const catchFactor = catchProb / 100;  // 0-1
                const fillScale = minScale + (maxScale - minScale) * catchFactor;
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Keep white color, adjust alpha based on coverage for visibility
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                receiver.fillMaterial.alpha = 0.5;

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);
                    coveringDefender.fillMaterial.alpha = maxCoverage * 0.45;
                    coveringDefender.ringMaterial.alpha = 0.8;
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const tiltDuration = 0.5;   // seconds for grappling tilt
            const currentTime = gameState.gameTime;

            // Calculate tilt direction (towards each other)
            const dx = defender.position.x - receiver.position.x;
            const dz = defender.position.z - receiver.position.z;
            const angle = Math.atan2(dx, dz);

            // Both tilt towards each other during clash
            receiver.clashTiltUntil = currentTime + tiltDuration;
            receiver.clashTiltAngle = angle;  // Tilt towards defender
            defender.clashTiltUntil = currentTime + tiltDuration;
            defender.clashTiltAngle = angle + Math.PI;  // Tilt towards receiver (opposite)

            // Color is now controlled by speed effect timers (clashSpeedBoostUntil / clashSpeedPenaltyUntil)
            // No separate flash timer needed
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        // Uses coreAttributes for speed, agility, strength (merged stats)
        const weightedRoll = (stats, weights, coreAttributes = null) => {
            let weightedTotal = 0;
            const coreStats = ['speed', 'agility', 'strength'];
            for (const stat in weights) {
                let statValue;
                // Use coreAttributes for speed, agility, strength if available
                if (coreStats.includes(stat) && coreAttributes && coreAttributes[stat] !== undefined) {
                    statValue = coreAttributes[stat];
                } else {
                    statValue = stats[stat] || 50;  // Default to 50 if stat missing
                }
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (¬±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                // Track that they were far apart (for initial clash detection)
                if (!receiver.hasHadInitialClash) {
                    receiver.wasOutsideClashRange = true;
                }
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Cooldown - don't clash again too soon after a previous clash
            const CLASH_COOLDOWN = 2.0;  // seconds between clashes
            const timeSinceReceiverClash = currentTime - receiver.lastClashTime;
            const timeSinceDefenderClash = currentTime - defender.lastClashTime;
            if (timeSinceReceiverClash < CLASH_COOLDOWN || timeSinceDefenderClash < CLASH_COOLDOWN) {
                return { trigger: false, reason: 'cooldown' };
            }

            // Initial contact - only trigger if they were previously apart
            // This prevents clashes from happening immediately at play start
            if (!receiver.hasHadInitialClash) {
                if (receiver.wasOutsideClashRange) {
                    return { trigger: true, reason: 'initial_contact' };
                }
                return { trigger: false, reason: 'not_yet_separated' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            // Zone defenders get a small bonus from awareness instead of general coverage
            if (defender.aiType === 'zone') {
                defenderWeights.awareness = (defenderWeights.awareness || 0) + 0.05;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver, receiver.coreAttributes);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights, defender.coreAttributes);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            // Speed effect durations
            const CLASH_SPEED_EFFECT_DURATION = 1.0;  // seconds - reduced for quicker gameplay
            const DB_CATCHUP_DELAY = 2.0;             // seconds - delay before DB catch-up starts
            const DB_CATCHUP_BOOST_DURATION = 1.0;    // seconds - DB gets catch-up boost after delay
            const CLASH_SPEED_PENALTY = 0.75;  // 25% slower (was 50%, cut in half)
            const CLASH_SPEED_BOOST = 1.5;  // 50% faster
            const DB_CATCHUP_BOOST = 1.3;  // 30% faster for catch-up

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                // Receiver wins - gets speed boost for 1 second
                // Scale boost down at higher game speeds to prevent excessive speed
                const scaledBoost = 1 + (CLASH_SPEED_BOOST - 1) / gameState.gameSpeedMultiplier;
                receiver.clashSpeedBoostUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                receiver.speed = receiver.baseSpeed * scaledBoost;
                // DB gets catch-up boost 2 seconds after clash
                defender.catchupBoostStart = currentTime + DB_CATCHUP_DELAY;
                defender.catchupBoostUntil = currentTime + DB_CATCHUP_DELAY + DB_CATCHUP_BOOST_DURATION;
                defender.catchupBoostAmount = DB_CATCHUP_BOOST;
                // Record clash stats
                recordPlayerStat(receiver, 'seasonClashesWon');
                recordPlayerStat(defender, 'seasonClashesLost');
                // Record per-game clash stats
                if (receiver.playerId) {
                    const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                    rStats.clashesWon++;
                    rStats.clashDifficulties.push(margin);
                }
                if (defender.playerId) {
                    const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                    dStats.clashesLost++;
                    dStats.clashDifficulties.push(-margin);
                }
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                // Direction changes (jukes) only benefit receivers - ignore defender wins
                if (reason === 'direction_change') {
                    result.winner = 'none';
                    result.type = 'contested';
                    // Juke failed but no penalty - just maintain current speed
                } else {
                    result.winner = 'defender';
                    result.type = 'coverage';
                    // Receiver loses - gets slowed
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                    receiver.speed = receiver.baseSpeed * CLASH_SPEED_PENALTY;
                    // Record clash stats
                    recordPlayerStat(defender, 'seasonClashesWon');
                    recordPlayerStat(receiver, 'seasonClashesLost');
                    // Record per-game clash stats
                    if (defender.playerId) {
                        const dStats = gameStats.getPlayer(defender.playerId, defender.displayName);
                        dStats.clashesWon++;
                        dStats.clashDifficulties.push(-margin);
                    }
                    if (receiver.playerId) {
                        const rStats = gameStats.getPlayer(receiver.playerId, receiver.displayName);
                        rStats.clashesLost++;
                        rStats.clashDifficulties.push(margin);
                    }
                }
            } else {
                result.winner = 'none';
                result.type = 'contested';
                // Tie - receiver maintains current speed
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Process all clashes in the game
        const processClashes = () => {
            // Skip clashes during ball flight to keep speed/distance calculations accurate
            if (gameState.ballInFlight) return;

            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // Clean up any expired speed boosts/penalties (called when ball lands)
        const cleanupExpiredSpeedEffects = () => {
            const currentTime = gameState.gameTime;
            gameState.receivers.forEach(receiver => {
                if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= currentTime) {
                    receiver.speed = receiver.baseSpeed;
                    receiver.clashSpeedBoostUntil = 0;
                }
                if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= currentTime) {
                    receiver.speed = receiver.baseSpeed;
                    receiver.clashSpeedPenaltyUntil = 0;
                }
            });
        };

        // ========================================
        // MANAGEMENT LAYER - UI SYSTEM
        // ========================================

        // UI state
        let managementUI = null;

        // Create Management UI
        function createManagementUI() {
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManagementUI");

            // Scale UI elements based on screen size for mobile
            const scale = Math.min(window.innerWidth / 400, window.innerHeight / 600, 1.5);
            advancedTexture.rootContainer.scaleX = scale;
            advancedTexture.rootContainer.scaleY = scale;

            const ui = {
                advancedTexture,
                visible: true
            };

            managementUI = ui;
            return ui;
        }

        // ========================================
        // HTML-BASED SCREEN NAVIGATION
        // ========================================

        // Hide all management screens
        function hideAllScreens() {
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
        }

        // Show a specific screen
        function showScreen(screenName) {
            const overlay = document.getElementById('managementOverlay');
            const topBar = document.getElementById('topBar');
            const viewButtons = document.getElementById('viewButtons');

            if (screenName === 'game') {
                // Game mode - hide overlay, show game
                overlay.classList.add('hidden');
                topBar.style.display = 'flex';
                viewButtons.style.display = 'flex';
                gameSceneActive = true;

                // IMPORTANT: Force engine resize after overlay is hidden
                // This fixes a rendering issue where canvas stays black
                // See TRAINING_MODE_FIX.md for details
                engine.resize();
            } else {
                // Management mode - show overlay, hide game
                overlay.classList.remove('hidden');
                topBar.style.display = 'none';
                viewButtons.style.display = 'none';
                document.getElementById('btnSimRest').style.display = 'none';
                gameSceneActive = false;

                hideAllScreens();

                switch (screenName) {
                    case 'main_menu':
                        document.getElementById('mainMenuScreen').style.display = 'block';
                        const continueBtn = document.getElementById('btnContinue');
                        continueBtn.disabled = !managementState.initialized;
                        // Update button text based on whether there's an active draft
                        if (draftState.active) {
                            continueBtn.textContent = 'CONTINUE DRAFT';
                        } else {
                            continueBtn.textContent = 'CONTINUE';
                        }
                        break;
                    case 'hub':
                        document.getElementById('hubScreen').style.display = 'block';
                        refreshHubScreen();
                        break;
                    case 'roster':
                        document.getElementById('rosterScreen').style.display = 'block';
                        refreshRosterScreen();
                        break;
                    case 'free_agency':
                        document.getElementById('freeAgencyScreen').style.display = 'block';
                        refreshFreeAgencyScreen();
                        break;
                    case 'schedule':
                        document.getElementById('scheduleScreen').style.display = 'block';
                        refreshScheduleScreen();
                        break;
                    case 'facilities':
                        document.getElementById('facilitiesScreen').style.display = 'block';
                        refreshFacilitiesScreen();
                        break;
                    case 'match_end':
                        document.getElementById('matchEndScreen').style.display = 'block';
                        break;
                    case 'pre_game':
                        document.getElementById('preGameScreen').style.display = 'block';
                        break;
                    case 'draft':
                        document.getElementById('draftScreen').style.display = 'block';
                        refreshDraftScreen();
                        break;
                    case 'settings':
                        document.getElementById('gameSettingsScreen').style.display = 'block';
                        refreshSettingsScreen();
                        break;
                }
            }

            managementState.currentScreen = screenName;
        }

        // Refresh hub screen data
        function refreshHubScreen() {
            if (!managementState.team) return;
            document.getElementById('hubStatus').textContent =
                `Fame: ${managementState.team.fame.toLocaleString()} | Week ${managementState.season?.week || 1}`;
            document.getElementById('hubRecord').textContent =
                `Record: ${managementState.team.record.wins}-${managementState.team.record.losses}`;

            if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                const game = managementState.season.schedule[managementState.season.week - 1];
                document.getElementById('hubNextGame').textContent = `Next: vs ${game.opponent.name}`;
            } else {
                document.getElementById('hubNextGame').textContent = 'Season Complete!';
            }
        }

        // Refresh settings screen data
        function refreshSettingsScreen() {
            // Update difficulty button states
            document.querySelectorAll('.game-difficulty-btn').forEach(btn => {
                if (btn.dataset.difficulty === gameState.gameDifficulty) {
                    btn.style.background = '#4a4';
                } else {
                    btn.style.background = '#333';
                }
            });
        }

        // Calculate season stat change for a player (based on primary stats/overall)
        function calculateSeasonStatChange(player) {
            if (!player.seasonStartStats) return 0;

            // Calculate based on primary stats for the position (same as overall)
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;
            const coreStatNames = ['strength', 'speed', 'agility', 'intelligence'];

            let currentTotal = 0;
            let startTotal = 0;
            primaryStats.forEach(stat => {
                // Check if this is a core stat (stored in coreAttributes) or technique stat
                const isCoreAttribute = coreStatNames.includes(stat);
                if (isCoreAttribute) {
                    currentTotal += player.coreAttributes?.[stat] || 0;
                    startTotal += player.seasonStartCoreAttributes?.[stat] || player.coreAttributes?.[stat] || 0;
                } else {
                    currentTotal += player.stats[stat] || 0;
                    startTotal += player.seasonStartStats[stat] || 0;
                }
            });

            // Return change in overall (average of primary stats)
            const currentOverall = Math.round(currentTotal / primaryStats.length);
            const startOverall = Math.round(startTotal / primaryStats.length);
            return currentOverall - startOverall;
        }

        // Refresh roster screen
        function refreshRosterScreen() {
            const list = document.getElementById('rosterList');
            list.innerHTML = '';
            if (!managementState.team) return;

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                list.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    const seasonChange = calculateSeasonStatChange(player);
                    const changeClass = seasonChange > 0 ? 'positive' : seasonChange < 0 ? 'negative' : '';
                    const changeText = seasonChange > 0 ? `+${seasonChange}` : seasonChange < 0 ? `${seasonChange}` : '';

                    // Show stars for growing players, minuses for declining
                    let potentialDisplay = '';
                    let potentialColor = '#ffd700';
                    if (player.age >= player.peakAge) {
                        // Declining: show red minuses based on years past peak
                        const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                        potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                        potentialColor = '#f66';
                    } else if (player.potentialGrade > 0) {
                        // Growing: show 0-3 stars
                        potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                    }

                    // Fame bank display
                    const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
                    const fameDisplay = fameBank > 0 ? `<span style="color:#ffd700;font-size:11px;">[${fameBank}]</span>` : '';

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName} ${fameDisplay}</div>
                            <div class="stats">Age ${player.age} | ${formatSalary(player.salaryCost)}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="season-gain ${changeClass}" style="min-width:28px;text-align:right;">${changeText}</span>
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    list.appendChild(item);
                });
            });
        }

        // Show player detail modal
        function showPlayerDetail(playerId) {
            const player = managementState.team.roster.find(p => p.id === playerId);
            if (!player) return;

            managementState.selectedPlayerId = playerId;

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Calculate overall change
            const currentOverall = player.overall;
            let startOverall = currentOverall;
            if (player.seasonStartStats) {
                const positionData = POSITIONS[player.position];
                const primaryStats = positionData.primaryStats;
                const coreStatNames = ['strength', 'speed', 'agility', 'intelligence'];
                const startTotal = primaryStats.reduce((sum, stat) => {
                    const isCoreAttribute = coreStatNames.includes(stat);
                    if (isCoreAttribute) {
                        return sum + (player.seasonStartCoreAttributes?.[stat] || player.coreAttributes?.[stat] || 0);
                    }
                    return sum + (player.seasonStartStats[stat] || 0);
                }, 0);
                startOverall = Math.round(startTotal / primaryStats.length);
            }
            const overallChange = currentOverall - startOverall;
            const overallChangeClass = overallChange > 0 ? 'positive' : overallChange < 0 ? 'negative' : '';
            const overallChangeText = overallChange !== 0 ?
                `<span class="season-change ${overallChangeClass}">${overallChange > 0 ? '+' : ''}${overallChange}</span>` : '';

            // Player info
            const tradeValue = calculateTradeValue(player);
            const tradeText = tradeValue > 0 ? `Trade Value: ${tradeValue}` : 'No Trade Value';

            // Fame/Hype info
            const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
            const hypeMultiplier = getCurrentHypeMultiplier(player);
            const hypeDisplay = hypeMultiplier.toFixed(2) + 'x';

            const infoHtml = `
                <div><span class="ovr-big">${player.overall}</span>${overallChangeText}</div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age}<br>
                    Salary: ${formatSalary(player.salaryCost)} | Potential: ${'‚òÖ'.repeat(player.potentialGrade)}<br>
                    <span style="color:#ffd700;">Fame Bank: ${fameBank}</span> | <span style="color:#4af;">Hype: ${hypeDisplay}</span><br>
                    <span style="color:${tradeValue > 0 ? '#4f4' : '#888'}">${tradeText}</span>
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // Update trade button - use fame bank directly
            const tradeBtn = document.getElementById('btnTradePlayer');
            const cutBtn = document.getElementById('btnCutPlayer');
            cutBtn.style.display = 'block';  // Ensure cut button is visible for roster players
            if (fameBank > 0) {
                tradeBtn.textContent = `HARVEST (+${fameBank} Fame)`;
                tradeBtn.disabled = false;
                tradeBtn.style.opacity = '1';
            } else {
                tradeBtn.textContent = 'NO FAME TO HARVEST';
                tradeBtn.disabled = true;
                tradeBtn.style.opacity = '0.5';
            }

            const getColorClass = (val) => val >= 90 ? 'stat-elite' : val >= 80 ? 'stat-good' : val >= 70 ? 'stat-average' : val >= 60 ? 'stat-below' : 'stat-poor';

            // Build unified stats panel
            const core = player.coreAttributes;
            const abilities = calculateAbilities(player);
            const bestAbility = getBestAbility(player);
            const techniqueStats = POSITIONS[player.position].techniqueStats || [];

            let statsHtml = '<div class="stats-panel">';

            // Core Attributes section (with growth display)
            if (core) {
                const startCore = player.seasonStartCoreAttributes || core;
                const getCoreChange = (stat) => {
                    const current = Math.floor(core[stat]);
                    const start = Math.floor(startCore[stat] || current);
                    const change = current - start;
                    return change !== 0 ? ` <span class="stat-change ${change > 0 ? 'positive' : 'negative'}">${change > 0 ? '+' : ''}${change}</span>` : '';
                };
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Core</div>
                        <div class="stats-grid">
                            <div class="stat-row str-row"><span class="stat-row-name">STR</span><span class="stat-row-value ${getColorClass(core.strength)}">${Math.floor(core.strength)}${getCoreChange('strength')}</span></div>
                            <div class="stat-row spd-row"><span class="stat-row-name">SPD</span><span class="stat-row-value ${getColorClass(core.speed)}">${Math.floor(core.speed)}${getCoreChange('speed')}</span></div>
                            <div class="stat-row agi-row"><span class="stat-row-name">AGI</span><span class="stat-row-value ${getColorClass(core.agility)}">${Math.floor(core.agility)}${getCoreChange('agility')}</span></div>
                            <div class="stat-row int-row"><span class="stat-row-name">INT</span><span class="stat-row-value ${getColorClass(core.intelligence)}">${Math.floor(core.intelligence)}${getCoreChange('intelligence')}</span></div>
                        </div>
                    </div>
                `;
            }

            // Abilities section - show stored ability values with growth indicators
            if (player.abilities) {
                const startAbilities = player.seasonStartAbilities || player.abilities;
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Abilities</div>
                        <div class="stats-grid">
                            ${Object.entries(player.abilities).map(([key, storedValue]) => {
                                const isBest = bestAbility && bestAbility.name === key;
                                const dots = getAbilityDots(key);
                                const name = getAbilityDisplayName(key);
                                const current = Math.floor(storedValue);
                                const start = Math.floor(startAbilities[key] || storedValue);
                                const change = current - start;
                                const changeText = change !== 0 ? ` <span class="stat-change ${change > 0 ? 'positive' : 'negative'}">${change > 0 ? '+' : ''}${change}</span>` : '';
                                return `<div class="stat-row ${isBest ? 'best-ability' : ''}"><span class="stat-row-name">${dots}${name}</span><span class="stat-row-value ${getColorClass(current)}">${current}${changeText}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Technique section with changes
            if (techniqueStats.length > 0) {
                statsHtml += `
                    <div class="stats-section">
                        <div class="stats-section-title">Technique</div>
                        <div class="stats-grid">
                            ${techniqueStats.map(stat => {
                                const currentRaw = player.stats[stat] || 0;
                                const startRaw = player.seasonStartStats ? (player.seasonStartStats[stat] || 0) : currentRaw;
                                const current = Math.floor(currentRaw);
                                const start = Math.floor(startRaw);
                                const change = current - start;
                                const changeText = change !== 0 ? ` <span class="stat-change ${change > 0 ? 'positive' : 'negative'}">${change > 0 ? '+' : ''}${change}</span>` : '';
                                const statName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                                return `<div class="stat-row"><span class="stat-row-name">${statName}</span><span class="stat-row-value ${getColorClass(current)}">${current}${changeText}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            statsHtml += '</div>';

            // Season stats (position-dependent)
            let seasonStatsHtml = '<div class="season-stats-title">Season Stats</div><div class="season-stats-grid">';

            if (player.position === 'WR' || player.position === 'QB') {
                const catchPct = player.seasonTargets > 0
                    ? Math.round((player.seasonCatches || 0) / player.seasonTargets * 100)
                    : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTDs || 0}</div><div class="season-stat-label">TDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonCatches || 0}</div><div class="season-stat-label">Catches</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${catchPct}%</div><div class="season-stat-label">Catch %</div></div>
                `;
            } else if (player.position === 'CB') {
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTackles || 0}</div><div class="season-stat-label">Tackles</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonPassesDefended || 0}</div><div class="season-stat-label">PDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                `;
            } else if (player.position === 'OL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesLost || 0}</div><div class="season-stat-label">Clashes Lost</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            } else if (player.position === 'DL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonSacks || 0}</div><div class="season-stat-label">Sacks</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            }
            seasonStatsHtml += '</div>';

            // Show all stats in main area, season stats in secondary area
            document.getElementById('playerStats').innerHTML = statsHtml;
            document.getElementById('playerSeasonStats').innerHTML = seasonStatsHtml;

            // Career graph
            const history = player.careerHistory || [];
            let graphHtml = '<div class="career-graph-title">Career Progression</div>';

            if (history.length > 0) {
                graphHtml += '<div class="career-graph-container">';
                const maxOvr = Math.max(...history.map(h => h.overall), 99);
                const minOvr = Math.min(...history.map(h => h.overall), 40);
                const range = Math.max(maxOvr - minOvr, 20);

                history.forEach((season, idx) => {
                    const heightPct = ((season.overall - minOvr) / range) * 100;
                    const potentialStars = '‚òÖ'.repeat(season.potential || 0);
                    graphHtml += `
                        <div class="career-bar">
                            <div class="career-bar-ovr">${season.overall}</div>
                            <div class="career-bar-fill" style="height: ${Math.max(heightPct, 10)}%;">
                                <span class="career-bar-potential">${potentialStars}</span>
                            </div>
                            <div class="career-bar-label">Y${idx + 1}</div>
                        </div>
                    `;
                });
                graphHtml += '</div>';
            } else {
                graphHtml += '<div style="color:#666;font-size:12px;">No career history yet</div>';
            }
            document.getElementById('playerCareerGraph').innerHTML = graphHtml;

            // Show modal
            document.getElementById('playerDetailModal').style.display = 'flex';
        }

        // Close player detail modal
        function closePlayerDetail() {
            document.getElementById('playerDetailModal').style.display = 'none';
            managementState.selectedPlayerId = null;
        }

        // Cut player from detail view
        function cutPlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const result = cutPlayer(managementState.selectedPlayerId);
            if (result.success) {
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Harvest player for fame from detail view (returns their accumulated fame bank)
        function tradePlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const player = managementState.team.roster.find(p => p.id === managementState.selectedPlayerId);
            if (!player) return;

            const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;
            if (fameBank <= 0) return;

            if (confirm(`Harvest ${player.firstName} ${player.lastName} for ${fameBank} Fame?`)) {
                managementState.team.fame += fameBank;
                cutPlayer(managementState.selectedPlayerId);
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Refresh free agency screen
        function refreshFreeAgencyScreen() {
            const list = document.getElementById('freeAgentList');
            const status = document.getElementById('faStatus');
            list.innerHTML = '';
            if (!managementState.team) return;

            const salary = calculateTeamSalary(managementState.team);
            const cap = managementState.team.salaryCap + managementState.team.salaryCapModifier;
            status.textContent = `Fame: ${formatSalary(managementState.team.fame)} | Cap: ${formatSalary(cap - salary)}`;

            if (managementState.freeAgents.length === 0) {
                list.innerHTML = '<p style="color:#888;text-align:center;">No free agents available</p>';
                return;
            }

            managementState.freeAgents.forEach(player => {
                const canSign = canSignPlayer(managementState.team, player);

                // Show stars for growing players, minuses for declining
                let potentialDisplay = '';
                let potentialColor = '#ffd700';
                if (player.age >= player.peakAge) {
                    const yearsPastPeak = Math.min(player.age - player.peakAge, 3);
                    potentialDisplay = '‚àí'.repeat(yearsPastPeak);
                    potentialColor = '#f66';
                } else if (player.potentialGrade > 0) {
                    potentialDisplay = '‚òÖ'.repeat(player.potentialGrade);
                }

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div>
                        <div class="name">${player.firstName} ${player.lastName} (${player.position})</div>
                        <div class="stats">Age ${player.age} | Salary: ${formatSalary(player.salaryCost)}</div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="ovr" style="min-width:28px;text-align:right;">${player.overall}</span>
                            <span class="potential-ind" style="min-width:36px;color:${potentialColor};font-size:14px;">${potentialDisplay}</span>
                        </div>
                        <button class="mgmt-btn fa-btn" ${canSign ? '' : 'disabled'}
                            onclick="signAndRefresh('${player.id}')">SIGN</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // Sign player and refresh
        function signAndRefresh(playerId) {
            const result = signFreeAgent(playerId);
            if (result.success) {
                refreshFreeAgencyScreen();
            }
        }

        // Calculate team overall rating
        function calculateTeamOverallRating() {
            if (!managementState.team) return 0;
            const roster = managementState.team.roster;
            if (roster.length === 0) return 0;
            const total = roster.reduce((sum, p) => sum + p.overall, 0);
            return Math.round(total / roster.length);
        }

        // Refresh schedule screen
        function refreshScheduleScreen() {
            const list = document.getElementById('scheduleList');
            list.innerHTML = '';
            if (!managementState.season) return;

            // Update team strength display
            const teamOverall = calculateTeamOverallRating();
            const teamOffense = Math.round(calculateTeamOffenseRating());
            const teamDefense = Math.round(calculateTeamDefenseRating());

            document.getElementById('strengthOverall').textContent = teamOverall;
            document.getElementById('strengthOffense').textContent = teamOffense;
            document.getElementById('strengthDefense').textContent = teamDefense;

            managementState.season.schedule.forEach((game, index) => {
                const weekNum = index + 1;
                const isCurrent = weekNum === managementState.season.week;
                const isPast = weekNum < managementState.season.week;

                const item = document.createElement('div');
                item.className = `schedule-item ${isCurrent ? 'current' : ''} ${isPast ? 'past' : ''}`;

                let resultText = '-';
                let resultClass = '';
                if (game.result) {
                    resultText = `${game.result.win ? 'W' : 'L'} ${game.result.playerScore}-${game.result.opponentScore}`;
                    resultClass = game.result.win ? 'win' : 'loss';
                } else if (isCurrent) {
                    resultText = 'NEXT';
                    resultClass = '';
                }

                // Show opponent strength
                const oppOverall = Math.round((game.opponent.offenseRating + game.opponent.defenseRating) / 2);

                item.innerHTML = `
                    <div>
                        <div>Wk ${weekNum}: ${game.isHome ? 'vs' : '@'} ${game.opponent.name}</div>
                        <div style="font-size:11px;color:#888;">OVR ${oppOverall} | OFF ${game.opponent.offenseRating} | DEF ${game.opponent.defenseRating}</div>
                    </div>
                    <div class="result ${resultClass}">${resultText}</div>
                `;
                list.appendChild(item);
            });
        }

        // Refresh facilities screen
        function refreshFacilitiesScreen() {
            if (!managementState.team) return;

            document.getElementById('facCredits').textContent = `Fame: ${managementState.team.fame.toLocaleString()}`;

            const arena = managementState.team.facilities.stadium;
            const training = managementState.team.facilities.trainingCenter;

            document.getElementById('arenaLevel').textContent = `Level ${arena.level}/${arena.maxLevel}`;
            document.getElementById('trainingLevel').textContent = `Level ${training.level}/${training.maxLevel}`;

            const arenaCost = arena.level < arena.maxLevel ? ECONOMY.STADIUM_UPGRADE_COSTS[arena.level - 1] : 0;
            const trainingCost = training.level < training.maxLevel ? ECONOMY.TRAINING_UPGRADE_COSTS[training.level - 1] : 0;

            document.getElementById('btnUpgradeArena').textContent = arena.level >= arena.maxLevel ? 'MAXED' : `UPGRADE ($${arenaCost.toLocaleString()})`;
            document.getElementById('btnUpgradeArena').disabled = arena.level >= arena.maxLevel || managementState.team.fame < arenaCost;

            document.getElementById('btnUpgradeTraining').textContent = training.level >= training.maxLevel ? 'MAXED' : `UPGRADE ($${trainingCost.toLocaleString()})`;
            document.getElementById('btnUpgradeTraining').disabled = training.level >= training.maxLevel || managementState.team.fame < trainingCost;
        }

        // Show match end result
        function showMatchEnd(matchResult) {
            console.log('[DEBUG] showMatchEnd called', matchResult);
            if (!matchResult) {
                console.error('[DEBUG] showMatchEnd called with null/undefined matchResult');
                return;
            }
            const result = matchResult.result;
            if (!result) {
                console.error('[DEBUG] matchResult.result is null/undefined', matchResult);
                return;
            }

            // Helper to get game stats for a player (needed for both reveal and final display)
            const getPlayerGameStats = (player) => {
                const pStats = gameStats.players[player.id];
                if (!pStats) return [];

                const statItems = [];

                // QB stats
                if (pStats.completions > 0 || pStats.incompletions > 0) {
                    const total = pStats.completions + pStats.incompletions;
                    const pct = total > 0 ? Math.round(pStats.completions / total * 100) : 0;
                    statItems.push({ label: 'COMP', value: `${pStats.completions}/${total}` });
                    statItems.push({ label: '%', value: `${pct}%` });
                    if (pStats.passingYards > 0) {
                        statItems.push({ label: 'YDS', value: pStats.passingYards });
                    }
                }

                // Receiver stats
                if (pStats.catches > 0 || pStats.drops > 0) {
                    statItems.push({ label: 'REC', value: pStats.catches });
                    if (pStats.receivingYards > 0) statItems.push({ label: 'YDS', value: pStats.receivingYards });
                    if (pStats.drops > 0) statItems.push({ label: 'DROP', value: pStats.drops });
                }

                // Clash stats - show win percentage
                if (pStats.clashesWon > 0 || pStats.clashesLost > 0) {
                    const totalClashes = pStats.clashesWon + pStats.clashesLost;
                    const winPct = totalClashes > 0 ? Math.round(pStats.clashesWon / totalClashes * 100) : 0;
                    statItems.push({ label: 'CLSH', value: `${pStats.clashesWon}-${pStats.clashesLost}` });
                    statItems.push({ label: 'WIN%', value: `${winPct}%` });
                }

                // Defense stats
                if (pStats.sacks > 0) statItems.push({ label: 'SACK', value: pStats.sacks });
                if (pStats.tackles > 0) statItems.push({ label: 'TKL', value: pStats.tackles });
                if (pStats.passesDefended > 0) statItems.push({ label: 'PD', value: pStats.passesDefended });

                // TDs
                if (pStats.touchdowns > 0) statItems.push({ label: 'TD', value: pStats.touchdowns });

                return statItems;
            };

            // Function to display the final match end screen
            const displayMatchEndScreen = () => {
                document.getElementById('matchResult').textContent = result.win ? 'VICTORY!' : 'DEFEAT';
                document.getElementById('matchResult').className = result.win ? 'win' : 'loss';
                document.getElementById('matchScore').textContent = `${result.playerScore} - ${result.opponentScore}`;
                document.getElementById('matchRevenue').textContent = `+${matchResult.revenue.toLocaleString()} Fame`;

                // Build player growth map from progression results
                const playerGrowthMap = {};
                if (matchResult.progression && matchResult.progression.improvements) {
                    matchResult.progression.improvements.forEach(({ player, improvements }) => {
                        playerGrowthMap[player.id] = improvements;
                    });
                }

                // Add fame to players ONCE per game (prevent double-counting on re-render)
                if (!managementState.fameAddedThisGame && managementState.team && managementState.team.roster) {
                    managementState.fameAddedThisGame = true;
                    managementState.team.roster.forEach(player => {
                        const pStats = gameStats.players[player.id];
                        if (pStats && player.hypeData) {
                            const fameEarned = calculateGameFame(player, pStats);
                            if (fameEarned > 0) {
                                player.hypeData.accumulatedFameBank += fameEarned;
                                player.hypeData.seasonFameEarnings += fameEarned;
                            }
                        }
                    });
                }

                // Build post-game stats display using roster layout
                const statsContainer = document.getElementById('postGameStats');
                statsContainer.innerHTML = '';

                // Stat name mapping for display
                const statDisplayNames = {
                    speed: 'SPD', strength: 'STR', agility: 'AGI', intelligence: 'INT',
                    catching: 'CTH', routeRunning: 'RTE', awareness: 'AWR', pursuit: 'PUR',
                    passBlock: 'PBK', passRush: 'PSR', tackling: 'TKL', coverage: 'COV',
                    throwPower: 'PWR', throwAccuracy: 'ACC', readDefense: 'RDF'
                };

                // Helper to render a player row (roster-style layout)
                const renderPlayerRow = (player) => {
                    const pStats = gameStats.players[player.id];
                    const statItems = getPlayerGameStats(player);

                    // Calculate fame earned this game
                    const fameEarned = calculateGameFame(player, pStats);

                    // Add fame to stats display if earned
                    if (fameEarned > 0) {
                        statItems.push({ label: 'FAME', value: `+${fameEarned}`, highlight: true });
                    }

                    const statsHtml = statItems.length > 0
                        ? statItems.map(s => `<div class="post-game-stat${s.highlight ? ' fame-stat' : ''}"><span class="post-game-stat-value">${s.value}</span><span class="post-game-stat-label">${s.label}</span></div>`).join('')
                        : '<span class="post-game-no-stats">‚Äî</span>';

                    // Show accumulated fame bank
                    const fameBank = player.hypeData ? player.hypeData.accumulatedFameBank : 0;

                    // Get player growth for this week
                    const playerGrowth = playerGrowthMap[player.id] || [];
                    const growthHtml = playerGrowth.length > 0
                        ? playerGrowth.map(g => `<span class="post-game-growth">+${g.change} ${statDisplayNames[g.stat] || g.stat.toUpperCase()}</span>`).join(' ')
                        : '';

                    // Calculate total growth for display next to OVR
                    const totalGrowth = playerGrowth.reduce((sum, g) => sum + g.change, 0);
                    const growthClass = totalGrowth > 0 ? 'positive' : '';
                    const growthText = totalGrowth > 0 ? `+${totalGrowth}` : '';

                    const div = document.createElement('div');
                    div.className = 'post-game-player';
                    div.innerHTML = `
                        <div class="post-game-player-header">
                            <div class="post-game-player-info">
                                <span class="post-game-player-name">${player.firstName} ${player.lastName}</span>
                                ${fameBank > 0 ? `<span class="post-game-player-fame">[${fameBank}]</span>` : ''}
                            </div>
                            <div class="post-game-player-right">
                                ${growthHtml ? `<span class="post-game-player-growth">${growthHtml}</span>` : ''}
                                <span class="post-game-player-change ${growthClass}">${growthText}</span>
                                <span class="post-game-player-ovr">${player.overall}</span>
                            </div>
                        </div>
                        <div class="post-game-player-stats">${statsHtml}</div>
                    `;
                    div.addEventListener('click', () => showPlayerDetail(player.id));
                    return div;
                };

                if (!managementState.team || !managementState.team.roster) {
                    statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No roster data</p>';
                    showScreen('match_end');
                    return;
                }

                // Use same position order as roster screen
                const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
                positions.forEach(pos => {
                    const players = managementState.team.roster
                        .filter(p => p.position === pos)
                        .sort((a, b) => b.overall - a.overall);

                    if (players.length === 0) return;

                    // Position header (same style as roster)
                    const header = document.createElement('div');
                    header.className = 'position-header';
                    header.textContent = POSITIONS[pos].name;
                    statsContainer.appendChild(header);

                    // Player rows
                    players.forEach(player => {
                        statsContainer.appendChild(renderPlayerRow(player));
                    });
                });

                if (statsContainer.children.length === 0) {
                    statsContainer.innerHTML = '<p style="color:#888;text-align:center;">No player stats recorded</p>';
                }

                // Show simulation log button if there's a log
                const logBtn = document.getElementById('btnShowSimLog');
                const logContainer = document.getElementById('simLogContainer');
                if (managementState.simulationLog && managementState.simulationLog.length > 0) {
                    logBtn.style.display = 'block';
                    document.getElementById('simLogContent').textContent = getSimulationLog();
                } else {
                    logBtn.style.display = 'none';
                }
                logContainer.style.display = 'none';

                showScreen('match_end');
            };

            // Show match end screen directly
            displayMatchEndScreen();
        }
        console.log('[DEBUG] showMatchEnd defined');

        // Show pre-game matchup screen
        function showPreGame(opponent) {
            document.getElementById('preGameOpponent').textContent = `VS ${opponent.name.toUpperCase()}`;

            // Calculate team offense score (QB, WRs, OL average)
            const offensivePlayers = [];
            const qb = getDepthChartPlayer('QB1');
            if (qb) offensivePlayers.push(qb);
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) offensivePlayers.push(p);
            });
            managementState.team.depthChart.OL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) offensivePlayers.push(p);
            });
            const teamOffense = offensivePlayers.length > 0
                ? Math.round(offensivePlayers.reduce((s, p) => s + p.overall, 0) / offensivePlayers.length)
                : 60;

            // Calculate team defense score (CBs, DL average)
            const defensivePlayers = [];
            ['CB1', 'CB2', 'CB3'].forEach(slot => {
                const p = getDepthChartPlayer(slot);
                if (p) defensivePlayers.push(p);
            });
            managementState.team.depthChart.DL.forEach(id => {
                const p = managementState.team.roster.find(r => r.id === id);
                if (p) defensivePlayers.push(p);
            });
            const teamDefense = defensivePlayers.length > 0
                ? Math.round(defensivePlayers.reduce((s, p) => s + p.overall, 0) / defensivePlayers.length)
                : 60;

            // Get opponent roster players by position
            const getOpponentPlayers = (position) => {
                if (!opponent.roster) return [];
                return opponent.roster.filter(p => p.position === position).sort((a, b) => b.overall - a.overall);
            };
            const oppCBs = getOpponentPlayers('CB');
            const oppDL = getOpponentPlayers('DL');

            // Show team scores
            const teamScoresHtml = `
                <div class="team-score-block">
                    <div class="team-score-label">Your Offense</div>
                    <div class="team-score-value yours">${teamOffense}</div>
                </div>
                <div class="team-score-vs">vs</div>
                <div class="team-score-block">
                    <div class="team-score-label">Their Defense</div>
                    <div class="team-score-value theirs">${opponent.defenseRating}</div>
                </div>
            `;
            document.getElementById('preGameTeamScores').innerHTML = teamScoresHtml;

            // Show QB key stats
            let qbScoresHtml = '';
            if (qb) {
                const shortAcc = Math.floor(qb.stats.shortPassAcc || 0);
                const longAcc = Math.floor(qb.stats.longPassAcc || 0);
                const awareness = Math.floor(qb.stats.awareness || 0);
                qbScoresHtml = `
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">QB Overall</div>
                        <div class="qb-stat-value">${qb.overall}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Short</div>
                        <div class="qb-stat-value">${shortAcc}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">Long</div>
                        <div class="qb-stat-value">${longAcc}</div>
                    </div>
                    <div class="qb-stat-block">
                        <div class="qb-stat-label">AWR</div>
                        <div class="qb-stat-value">${awareness}</div>
                    </div>
                `;
            }
            document.getElementById('preGameQBScores').innerHTML = qbScoresHtml;

            const matchupsContainer = document.getElementById('preGameMatchups');
            let html = '';

            // Helper to get advantage class
            const getAdvClass = (yours, theirs) => {
                const diff = yours - theirs;
                if (diff > 3) return 'advantage';
                if (diff < -3) return 'disadvantage';
                return 'even';
            };

            // QB vs opponent defense average
            if (qb) {
                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Quarterback</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${qb.firstName} ${qb.lastName}
                                <span class="matchup-ovr ${getAdvClass(qb.overall, opponent.defenseRating)}">${qb.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${opponent.defenseRating}</span>
                                Defense
                            </div>
                        </div>
                    </div>`;
            }

            // WRs vs opponent CBs
            const wrs = ['WR1', 'WR2', 'WR3'].map(s => getDepthChartPlayer(s)).filter(Boolean);
            if (wrs.length > 0) {
                html += `<div class="matchup-section"><div class="matchup-section-title">Receivers vs Corners</div>`;
                wrs.forEach((wr, i) => {
                    const cb = oppCBs[i];
                    const cbOvr = cb ? cb.overall : opponent.defenseRating;
                    const cbName = cb ? `${cb.firstName} ${cb.lastName.charAt(0)}.` : 'CB';
                    html += `
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                ${wr.firstName} ${wr.lastName.charAt(0)}.
                                <span class="matchup-ovr ${getAdvClass(wr.overall, cbOvr)}">${wr.overall}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${cbOvr}</span>
                                ${cbName}
                            </div>
                        </div>`;
                });
                html += `</div>`;
            }

            // O-Line vs opponent D-Line
            const olPlayers = managementState.team.depthChart.OL.map(id =>
                managementState.team.roster.find(p => p.id === id)
            ).filter(Boolean);

            if (olPlayers.length > 0 || oppDL.length > 0) {
                const olAvg = olPlayers.length > 0
                    ? Math.round(olPlayers.reduce((s, p) => s + p.overall, 0) / olPlayers.length)
                    : 60;
                const dlAvg = oppDL.length > 0
                    ? Math.round(oppDL.reduce((s, p) => s + p.overall, 0) / oppDL.length)
                    : opponent.defenseRating;

                html += `
                    <div class="matchup-section">
                        <div class="matchup-section-title">Line Battle</div>
                        <div class="matchup-row">
                            <div class="matchup-player yours">
                                O-Line (${olPlayers.length})
                                <span class="matchup-ovr ${getAdvClass(olAvg, dlAvg)}">${olAvg}</span>
                            </div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-player theirs">
                                <span class="matchup-ovr">${dlAvg}</span>
                                D-Line (${oppDL.length})
                            </div>
                        </div>
                    </div>`;
            }

            matchupsContainer.innerHTML = html;
            showScreen('pre_game');
        }
        console.log('[DEBUG] showPreGame defined');

        // Start the arcade game portion
        function startArcadeGame() {
            console.log('[ARCADE] Starting arcade game...');

            gameState.trainingMode = false;

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('viewButtons').style.display = 'flex';
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('catchDisplay').style.display = '';
            document.getElementById('btnSimRest').style.display = 'block'; // Show sim rest button
            gameSceneActive = true;

            // Reset game state
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.startingLineOfScrimmage + 10;

            gameStats.reset();

            // Enable offensive and defensive lines and defenders
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(true));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(true));
            gameState.defenders.forEach(defender => defender.setEnabled(true));

            // Update game meshes with roster player data
            updateGamePlayersFromRoster();

            // Reset play to position all players at the line of scrimmage
            if (gameState.scene) {
                resetPlay(gameState.scene);
            }

            updateDownDistance();

            // IMPORTANT: Force engine resize after overlay is hidden
            // See TRAINING_MODE_FIX.md for why this is needed
            setTimeout(() => {
                engine.resize();
            }, 50);
        }

        // Start training mode (no defenders, throw ratings)
        function startTrainingMode() {
            gameState.trainingMode = true;
            gameState.lastThrowRating = null;

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('trainingModeUI').style.display = 'block';
            document.getElementById('catchDisplay').style.display = 'none';
            gameSceneActive = true;

            // Reset game state
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.startingLineOfScrimmage + 10;

            // Hide offensive and defensive lines
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(false));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(false));

            // Reset play
            if (gameState.scene) {
                resetPlay(gameState.scene);
            }

            updateDownDistance();

            // IMPORTANT: Force engine resize after overlay is hidden
            // This fixes a rendering issue where canvas stays black
            // See TRAINING_MODE_FIX.md for details
            engine.resize();
        }

        // Exit training mode and return to hub
        function exitTrainingMode() {
            gameState.trainingMode = false;
            gameSceneActive = false; // Disable game input
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('topBar').style.display = 'none';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('catchDisplay').style.display = ''; // Restore catch display
            document.getElementById('managementOverlay').classList.remove('hidden');

            // Show offensive and defensive lines again
            gameState.offensiveLine.forEach(lineman => lineman.setEnabled(true));
            gameState.defensiveLine.forEach(lineman => lineman.setEnabled(true));

            // Hide other screens and show hub (or main menu if not initialized)
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            if (managementState.initialized) {
                document.getElementById('hubScreen').style.display = 'block';
                refreshHubScreen();
            } else {
                document.getElementById('mainMenuScreen').style.display = 'block';
            }
        }

        // ========================================
        // BONUS ZONES SYSTEM
        // ========================================
        // Green zones that move around the field
        // Provide catch bonuses in training/gameplay, point multipliers in target practice

        const BONUS_ZONE_TYPES = {
            small: {
                radius: 1.5,
                catchBonus: 15,           // +15% catch probability
                pointMultiplier: 2.0,     // 2x points in target practice
                color: new BABYLON.Color3(1, 0.2, 0.2),  // Red - hardest to hit
                emissiveIntensity: 0.7,
                speedMult: 1.5,           // Moves faster
                name: '2x'
            },
            medium: {
                radius: 2.5,
                catchBonus: 10,           // +10% catch probability
                pointMultiplier: 1.5,     // 1.5x points
                color: new BABYLON.Color3(1, 0.85, 0.1),  // Yellow
                emissiveIntensity: 0.5,
                speedMult: 1.0,
                name: '1.5x'
            },
            large: {
                radius: 3.0,              // Reduced from 4.0
                catchBonus: 5,            // +5% catch probability
                pointMultiplier: 1.25,    // 1.25x points
                color: new BABYLON.Color3(0.2, 0.9, 0.3),  // Green - easiest
                emissiveIntensity: 0.4,
                speedMult: 0.8,           // Moves slower
                name: '1.25x'
            }
        };

        // Create a single bonus zone
        function createBonusZone(scene, type, startX, startZ) {
            const config = BONUS_ZONE_TYPES[type];

            // Create the zone disc
            const disc = BABYLON.MeshBuilder.CreateDisc('bonusZone', {
                radius: config.radius,
                tessellation: 32
            }, scene);
            disc.rotation.x = Math.PI / 2;
            disc.position = new BABYLON.Vector3(startX, 0.02, startZ);

            // Create material with transparency and glow
            const mat = new BABYLON.StandardMaterial('zoneMat', scene);
            mat.diffuseColor = config.color;
            mat.emissiveColor = config.color.scale(config.emissiveIntensity);
            mat.alpha = 0.35;
            mat.backFaceCulling = false;
            disc.material = mat;

            // Create outer ring for visibility
            const ring = BABYLON.MeshBuilder.CreateTorus('zoneRing', {
                diameter: config.radius * 2,
                thickness: 0.08,
                tessellation: 32
            }, scene);
            ring.position = new BABYLON.Vector3(startX, 0.03, startZ);

            const ringMat = new BABYLON.StandardMaterial('zoneRingMat', scene);
            ringMat.diffuseColor = config.color;
            ringMat.emissiveColor = config.color.scale(config.emissiveIntensity + 0.2);
            ringMat.alpha = 0.6;
            ring.material = ringMat;

            // Movement target - zone moves toward this point
            const baseSpeed = 0.015 * config.speedMult;

            const zone = {
                disc: disc,
                ring: ring,
                type: type,
                config: config,
                position: disc.position,
                targetX: startX,
                targetZ: startZ,
                speed: baseSpeed,
                moveTimer: 0,
                active: true
            };

            return zone;
        }

        // Create all bonus zones for the field
        function createBonusZones(scene) {
            // Clear existing zones
            if (gameState.bonusZones) {
                gameState.bonusZones.forEach(z => {
                    if (z.disc) z.disc.dispose();
                    if (z.ring) z.ring.dispose();
                });
            }
            gameState.bonusZones = [];

            // Create one of each type spread across the field - keep in front where routes are
            const zoneConfigs = [
                { type: 'large', x: -4, z: gameState.lineOfScrimmage + 6 },
                { type: 'medium', x: 3, z: gameState.lineOfScrimmage + 9 },
                { type: 'small', x: 0, z: gameState.lineOfScrimmage + 12 }
            ];

            zoneConfigs.forEach(cfg => {
                const zone = createBonusZone(scene, cfg.type, cfg.x, cfg.z);
                gameState.bonusZones.push(zone);
            });
        }

        // Move bonus zones around the field
        function moveBonusZones() {
            if (!gameState.bonusZones) return;

            const fieldMinX = -6;
            const fieldMaxX = 6;
            // Keep zones closer to the front where routes are active
            const fieldMinZ = gameState.lineOfScrimmage + 3;
            const fieldMaxZ = gameState.lineOfScrimmage + 15;  // Reduced from 25 to stay in route area

            gameState.bonusZones.forEach(zone => {
                if (!zone.active) return;

                // Move toward target
                const dx = zone.targetX - zone.position.x;
                const dz = zone.targetZ - zone.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 0.5) {
                    // Move toward target
                    zone.position.x += (dx / dist) * zone.speed;
                    zone.position.z += (dz / dist) * zone.speed;
                    zone.ring.position.x = zone.position.x;
                    zone.ring.position.z = zone.position.z;
                } else {
                    // Reached target, pick new random target
                    zone.targetX = fieldMinX + Math.random() * (fieldMaxX - fieldMinX);
                    zone.targetZ = fieldMinZ + Math.random() * (fieldMaxZ - fieldMinZ);
                }

                // Gentle pulsing animation
                const pulse = 1 + Math.sin(performance.now() * 0.003) * 0.05;
                zone.disc.scaling.x = pulse;
                zone.disc.scaling.z = pulse;
            });
        }

        // Check if a position is inside any bonus zone
        function checkBonusZones(position) {
            if (!gameState.bonusZones) return null;

            let bestZone = null;
            let bestBonus = 0;

            gameState.bonusZones.forEach(zone => {
                if (!zone.active) return;

                const dx = zone.position.x - position.x;
                const dz = zone.position.z - position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Check if inside zone
                if (dist < zone.config.radius) {
                    // Prefer higher bonus zones (smaller = better)
                    if (zone.config.catchBonus > bestBonus) {
                        bestBonus = zone.config.catchBonus;
                        bestZone = zone;
                    }
                }
            });

            return bestZone;
        }

        // Distance multiplier zone configurations
        const DISTANCE_ZONE_CONFIGS = [
            {
                name: '2x ZONE',
                minDistance: 18,
                maxDistance: 35,
                multiplier: 2.0,
                color: new BABYLON.Color3(1, 0.2, 0.2),  // Red
                alpha: 0.15
            },
            {
                name: '1.5x ZONE',
                minDistance: 10,
                maxDistance: 18,
                multiplier: 1.5,
                color: new BABYLON.Color3(1, 0.85, 0.1),  // Yellow
                alpha: 0.12
            },
            {
                name: '1.25x ZONE',
                minDistance: 0,
                maxDistance: 10,
                multiplier: 1.25,
                color: new BABYLON.Color3(0.2, 0.9, 0.3),  // Green
                alpha: 0.1
            }
        ];

        // Create distance multiplier zone visualization on the field
        function createDistanceZones(scene, qbZ) {
            // Clear existing distance zones
            if (gameState.distanceZoneMeshes) {
                gameState.distanceZoneMeshes.forEach(m => {
                    if (m.mesh) m.mesh.dispose();
                    if (m.label) m.label.dispose();
                });
            }
            gameState.distanceZoneMeshes = [];

            const fieldWidth = 14;  // Width of the visible field
            const fieldHalfWidth = fieldWidth / 2;

            DISTANCE_ZONE_CONFIGS.forEach((config, index) => {
                // Create a rectangular zone for each distance band
                const zoneDepth = config.maxDistance - config.minDistance;
                const zoneStartZ = qbZ + config.minDistance;

                // Create ground plane for the zone
                const zoneMesh = BABYLON.MeshBuilder.CreateGround('distanceZone' + index, {
                    width: fieldWidth,
                    height: zoneDepth
                }, scene);
                zoneMesh.position.x = 0;
                zoneMesh.position.z = zoneStartZ + zoneDepth / 2;
                zoneMesh.position.y = 0.01;  // Slightly above ground

                const mat = new BABYLON.StandardMaterial('distanceZoneMat' + index, scene);
                mat.diffuseColor = config.color;
                mat.emissiveColor = config.color.scale(0.3);
                mat.alpha = config.alpha;
                mat.backFaceCulling = false;
                zoneMesh.material = mat;

                // Create label for the zone
                const labelPlane = BABYLON.MeshBuilder.CreatePlane('zoneLabel' + index, {
                    width: 3,
                    height: 0.8
                }, scene);
                labelPlane.position.x = -fieldHalfWidth + 2;
                labelPlane.position.z = zoneStartZ + zoneDepth / 2;
                labelPlane.position.y = 0.1;
                labelPlane.rotation.x = Math.PI / 2;

                // Create dynamic texture for label
                const labelTexture = new BABYLON.DynamicTexture('zoneLabelTex' + index, {
                    width: 256,
                    height: 64
                }, scene, false);
                labelTexture.hasAlpha = true;
                const ctx = labelTexture.getContext();
                ctx.clearRect(0, 0, 256, 64);
                ctx.font = 'bold 32px Courier New';
                ctx.fillStyle = `rgb(${Math.floor(config.color.r * 255)}, ${Math.floor(config.color.g * 255)}, ${Math.floor(config.color.b * 255)})`;
                ctx.textAlign = 'center';
                ctx.fillText(config.name, 128, 44);
                labelTexture.update();

                const labelMat = new BABYLON.StandardMaterial('zoneLabelMat' + index, scene);
                labelMat.diffuseTexture = labelTexture;
                labelMat.emissiveColor = config.color.scale(0.5);
                labelMat.useAlphaFromDiffuseTexture = true;
                labelMat.backFaceCulling = false;
                labelPlane.material = labelMat;

                gameState.distanceZoneMeshes.push({
                    mesh: zoneMesh,
                    label: labelPlane,
                    config: config
                });
            });
        }

        // Show/hide distance zones
        function setDistanceZonesVisible(visible) {
            if (!gameState.distanceZoneMeshes) return;
            gameState.distanceZoneMeshes.forEach(z => {
                if (z.mesh) z.mesh.setEnabled(visible);
                if (z.label) z.label.setEnabled(visible);
            });
        }

        // Clean up distance zones
        function clearDistanceZones() {
            if (gameState.distanceZoneMeshes) {
                gameState.distanceZoneMeshes.forEach(m => {
                    if (m.mesh) m.mesh.dispose();
                    if (m.label) m.label.dispose();
                });
            }
            gameState.distanceZoneMeshes = [];
        }

        // Get distance multiplier for a given throw distance
        function getDistanceMultiplier(distance) {
            for (const config of DISTANCE_ZONE_CONFIGS) {
                if (distance >= config.minDistance && distance < config.maxDistance) {
                    return { multiplier: config.multiplier, name: config.name };
                }
            }
            // Default for very long throws
            return { multiplier: 2.0, name: '2x ZONE' };
        }

        // ========================================
        // TARGET PRACTICE MODE
        // ========================================

        // Target configurations - different sizes, speeds, and point values
        // Uses knight meshes like receivers with different scales
        const TARGET_TYPES = {
            small: {
                scale: 0.85,
                speedMult: 1.3,
                points: 150,
                color: new BABYLON.Color3(1, 0.3, 0.3),  // Red
                name: 'Small'
            },
            medium: {
                scale: 1.0,
                speedMult: 1.0,
                points: 100,
                color: new BABYLON.Color3(1, 0.8, 0.2),  // Yellow/Gold
                name: 'Medium'
            },
            large: {
                scale: 1.4,
                speedMult: 0.75,
                points: 50,
                color: new BABYLON.Color3(0.3, 0.8, 0.3),  // Green
                name: 'Large'
            },
            bonus: {
                scale: 0.7,
                speedMult: 1.8,
                points: 300,
                color: new BABYLON.Color3(0.8, 0.2, 1.0),  // Purple/Magenta
                name: 'BONUS',
                isBonus: true,
                glowIntensity: 2.0
            }
        };

        // Field boundaries for targets
        const TARGET_FIELD_BOUNDS = {
            minX: -7,
            maxX: 7,
            minZ: -35,  // Will be adjusted based on line of scrimmage
            maxZ: 12    // End zone
        };

        // Generate a receiver-style route for a target
        function generateTargetRoute(startX, startZ, slotPosition) {
            const route = [];
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = -towardMiddle;

            // Pick a route type based on position (similar to receiver routes)
            const routeTypes = slotPosition === 'outside'
                ? ['go', 'corner', 'out', 'comeback', 'post']
                : ['slant', 'seam', 'dig', 'post', 'curl', 'crossing'];

            const routeType = routeTypes[Math.floor(Math.random() * routeTypes.length)];

            // Clamp function to keep routes in bounds
            const clampX = (x) => Math.max(TARGET_FIELD_BOUNDS.minX, Math.min(TARGET_FIELD_BOUNDS.maxX, x));
            const clampZ = (z) => Math.max(startZ, Math.min(TARGET_FIELD_BOUNDS.maxZ, z));

            switch(routeType) {
                case 'go':
                    // Straight vertical route
                    route.push({ z: clampZ(startZ + 8), x: startX });
                    route.push({ z: clampZ(startZ + 18), x: startX });
                    break;

                case 'slant':
                    // Quick diagonal toward middle
                    route.push({ z: clampZ(startZ + 3), x: startX });
                    route.push({ z: clampZ(startZ + 12), x: clampX(startX + towardMiddle * 6) });
                    break;

                case 'out':
                    // Vertical stem then cut toward sideline
                    route.push({ z: clampZ(startZ + 8), x: startX });
                    route.push({ z: clampZ(startZ + 10), x: clampX(startX + towardSideline * 5) });
                    break;

                case 'corner':
                    // Vertical stem then angle to corner
                    route.push({ z: clampZ(startZ + 8), x: startX });
                    route.push({ z: clampZ(startZ + 16), x: clampX(startX + towardSideline * 6) });
                    break;

                case 'post':
                    // Vertical stem then angle toward middle
                    route.push({ z: clampZ(startZ + 8), x: startX });
                    route.push({ z: clampZ(startZ + 18), x: clampX(startX + towardMiddle * 5) });
                    break;

                case 'curl':
                    // Go forward then stop/curl back slightly
                    route.push({ z: clampZ(startZ + 10), x: startX });
                    route.push({ z: clampZ(startZ + 8), x: clampX(startX + towardMiddle * 1) });
                    break;

                case 'comeback':
                    // Go deep then come back toward sideline
                    route.push({ z: clampZ(startZ + 12), x: startX });
                    route.push({ z: clampZ(startZ + 9), x: clampX(startX + towardSideline * 3) });
                    break;

                case 'dig':
                    // Vertical stem then sharp cut across middle
                    route.push({ z: clampZ(startZ + 10), x: startX });
                    route.push({ z: clampZ(startZ + 11), x: clampX(startX + towardMiddle * 8) });
                    break;

                case 'seam':
                    // Straight up the seam (between zones)
                    route.push({ z: clampZ(startZ + 6), x: startX });
                    route.push({ z: clampZ(startZ + 15), x: clampX(startX + towardMiddle * 2) });
                    break;

                case 'crossing':
                    // Run across the field
                    route.push({ z: clampZ(startZ + 5), x: startX });
                    route.push({ z: clampZ(startZ + 6), x: clampX(startX + towardMiddle * 10) });
                    break;

                default:
                    // Default go route
                    route.push({ z: clampZ(startZ + 10), x: startX });
                    route.push({ z: clampZ(startZ + 20), x: startX });
            }

            return route;
        }

        // Create a target knight mesh with the appropriate size and color
        function createTargetKnight(scene, targetConfig, position) {
            const scale = targetConfig.scale;
            const knight = new BABYLON.TransformNode('targetKnight', scene);
            const isBonus = targetConfig.isBonus;

            // Create material with target color
            const material = new BABYLON.StandardMaterial('targetMat', scene);
            material.diffuseColor = targetConfig.color;
            material.emissiveColor = targetConfig.color.scale(isBonus ? 0.7 : 0.3);

            // Body (scaled)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = knight;

            // Head
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = knight;

            // Helmet plume - special color for bonus targets
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            if (isBonus) {
                // Gold/yellow plume for bonus targets
                plumeMat.diffuseColor = new BABYLON.Color3(1, 0.85, 0);
                plumeMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0);
            } else {
                plumeMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                plumeMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            }
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = knight;

            // Base ring (shows target area)
            const baseRing = BABYLON.MeshBuilder.CreateTorus('baseRing', {
                diameter: 1.2 * scale,
                thickness: isBonus ? 0.12 * scale : 0.08 * scale,
                tessellation: 24
            }, scene);
            const ringMat = new BABYLON.StandardMaterial('ringMat', scene);
            ringMat.diffuseColor = targetConfig.color;
            ringMat.emissiveColor = targetConfig.color.scale(isBonus ? 0.8 : 0.5);
            ringMat.alpha = 0.8;
            baseRing.material = ringMat;
            baseRing.position.y = 0.02;
            baseRing.parent = knight;

            // Add outer glow ring for bonus targets
            if (isBonus) {
                const outerRing = BABYLON.MeshBuilder.CreateTorus('outerRing', {
                    diameter: 1.6 * scale,
                    thickness: 0.06 * scale,
                    tessellation: 32
                }, scene);
                const outerMat = new BABYLON.StandardMaterial('outerRingMat', scene);
                outerMat.diffuseColor = new BABYLON.Color3(1, 0.85, 0);
                outerMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0);
                outerMat.alpha = 0.6;
                outerRing.material = outerMat;
                outerRing.position.y = 0.02;
                outerRing.parent = knight;
            }

            knight.position = position.clone();
            knight.bodyMaterial = material;

            return knight;
        }

        // Create a single target (receiver-like)
        function createTarget(scene, type, startX, startZ, slotPosition) {
            const targetConfig = TARGET_TYPES[type];

            // Create knight mesh for target
            const position = new BABYLON.Vector3(startX, 0, startZ);
            const mesh = createTargetKnight(scene, targetConfig, position);

            // Generate route
            const route = generateTargetRoute(startX, startZ, slotPosition);

            // Create route line visualization
            const routePathPoints = [new BABYLON.Vector3(startX, 0.03, startZ)];
            route.forEach(p => routePathPoints.push(new BABYLON.Vector3(p.x, 0.03, p.z)));

            let routeLine = null;
            if (routePathPoints.length >= 2) {
                routeLine = BABYLON.MeshBuilder.CreateTube('routeLine', {
                    path: routePathPoints,
                    radius: 0.05,
                    tessellation: 8,
                    cap: BABYLON.Mesh.NO_CAP
                }, scene);

                const routeLineMat = new BABYLON.StandardMaterial('routeLineMat', scene);
                routeLineMat.diffuseColor = targetConfig.color.scale(0.5);
                routeLineMat.emissiveColor = targetConfig.color.scale(0.2);
                routeLineMat.alpha = 0.6;
                routeLine.material = routeLineMat;
            }

            // Calculate speed (similar to receiver speed calculation)
            const speedSettings = { slow: 0.6, normal: 1.0, fast: 1.5 };
            const baseSpeedFactor = 0.07;  // Faster base speed for more challenge
            const baseSpeed = baseSpeedFactor * targetConfig.speedMult * (speedSettings[gameState.targetPracticeSpeedSetting] || 1.0);

            // Hit radius should be generous enough to feel fair
            // Scale with playerScale for consistency with receiver catch radius
            // Minimum 1.0 ensures small targets are still hittable
            const baseHitRadius = Math.max(1.0, 0.9 * targetConfig.scale) * (gameState.playerScale || 1.3);

            // Store target data (similar to receiver structure)
            const target = {
                mesh: mesh,
                routeLine: routeLine,
                type: type,
                config: targetConfig,
                route: route,
                routeIndex: 0,
                position: mesh.position,
                rotation: mesh.rotation,
                startPos: position.clone(),
                speed: baseSpeed,
                baseSpeed: baseSpeed,
                velocity: new BABYLON.Vector3(0, 0, 0),
                runMomentum: 0,
                hitRadius: baseHitRadius,
                active: true
            };

            return target;
        }

        // Create all targets for target practice mode
        function createAllTargets(scene) {
            // Clear existing targets (including route lines)
            gameState.targetPracticeTargets.forEach(t => {
                if (t.routeLine) t.routeLine.dispose();
                if (t.mesh) t.mesh.dispose();
            });
            gameState.targetPracticeTargets = [];
            // Note: Don't reset speed bonus here - it increases with rounds

            // Always create exactly 4 targets per round (maximum active at once)
            const targetCount = 4;
            gameState.targetPracticeTargetCount = 4;

            // Starting positions spread across the field (like receiver positions)
            const startingPositions = [
                { x: -5, slot: 'outside' },   // Far left
                { x: -2, slot: 'slot' },      // Left slot
                { x: 2, slot: 'slot' },       // Right slot
                { x: 5, slot: 'outside' },    // Far right
            ];

            const startZ = gameState.lineOfScrimmage + 2;  // Start near line of scrimmage

            // Determine if this round has a bonus target (30% chance after round 2)
            const round = gameState.targetPracticeRound;
            const hasBonusTarget = round >= 2 && Math.random() < 0.3;
            const bonusTargetIndex = hasBonusTarget ? Math.floor(Math.random() * targetCount) : -1;

            // Create targets with varied types, staggered spawns, and positions
            for (let i = 0; i < targetCount; i++) {
                let type;
                const typeIndex = i % 4;

                // Check if this is the bonus target
                if (i === bonusTargetIndex) {
                    type = 'bonus';
                } else if (round >= 10 && (typeIndex === 0 || typeIndex === 3)) {
                    // Small targets only appear at round 10+
                    type = 'small';
                } else if (round >= 5 && typeIndex === 0) {
                    // Some small targets start appearing at round 5
                    type = 'small';
                } else if (typeIndex === 1) {
                    type = 'large';
                } else {
                    type = 'medium';
                }

                // Get position with small random offset
                const posConfig = startingPositions[i];
                const startX = posConfig.x + (Math.random() - 0.5) * 1;

                const target = createTarget(scene, type, startX, startZ, posConfig.slot);

                // Add staggered spawn delay - each target spawns 0.4s after the previous
                target.spawnDelay = i * 0.4;
                target.spawnTime = performance.now() + (target.spawnDelay * 1000);
                target.spawned = i === 0; // First target spawns immediately
                target.isBonus = type === 'bonus';

                // Initially hide non-first targets
                if (!target.spawned) {
                    target.mesh.setEnabled(false);
                    if (target.routeLine) target.routeLine.setEnabled(false);
                }

                gameState.targetPracticeTargets.push(target);
            }
        }

        // Move all targets along their routes (receiver-style movement)
        function moveTargets() {
            const time = performance.now() * 0.001;
            const currentTime = performance.now();

            gameState.targetPracticeTargets.forEach((target, i) => {
                // Skip inactive (hit) targets - they don't respawn
                if (!target.active) return;

                // Check if target should spawn (staggered spawning)
                if (!target.spawned && currentTime >= target.spawnTime) {
                    target.spawned = true;
                    target.mesh.setEnabled(true);
                    if (target.routeLine) target.routeLine.setEnabled(true);
                }

                // Skip targets that haven't spawned yet
                if (!target.spawned) return;

                // Bonus target pulsing glow effect
                if (target.isBonus && target.mesh && target.mesh.bodyMaterial) {
                    const pulse = 0.5 + Math.sin(time * 6) * 0.5;
                    const baseColor = TARGET_TYPES.bonus.color;
                    target.mesh.bodyMaterial.emissiveColor = baseColor.scale(0.3 + pulse * 0.7);
                }

                // Move along route (similar to moveReceiverAlongRoute)
                const runSpeed = target.speed * gameState.targetPracticeSpeedBonus;

                if (!target.route || target.routeIndex >= target.route.length) {
                    // Route complete - teleport back to start and restart
                    target.routeIndex = 0;
                    target.position.x = target.startPos.x;
                    target.position.z = target.startPos.z;
                    target.runMomentum = 0;
                    return;
                }

                const waypoint = target.route[target.routeIndex];
                let dx = waypoint.x - target.position.x;
                let dz = waypoint.z - target.position.z;
                let dist = Math.sqrt(dx * dx + dz * dz);

                // Check if reached waypoint
                if (dist < 0.3) {
                    target.routeIndex++;
                    if (target.routeIndex >= target.route.length) {
                        // Route complete - teleport back to start
                        target.routeIndex = 0;
                        target.position.x = target.startPos.x;
                        target.position.z = target.startPos.z;
                        target.runMomentum = 0;
                        return;
                    }
                    const newWaypoint = target.route[target.routeIndex];
                    dx = newWaypoint.x - target.position.x;
                    dz = newWaypoint.z - target.position.z;
                    dist = Math.sqrt(dx * dx + dz * dz);
                }

                if (dist > 0.1) {
                    // Move toward waypoint
                    const vx = (dx / dist) * runSpeed;
                    const vz = (dz / dist) * runSpeed;
                    target.velocity = new BABYLON.Vector3(vx, 0, vz);

                    target.position.x += vx;
                    target.position.z += vz;
                    target.rotation.y = Math.atan2(dx, dz);

                    // Running momentum for forward lean
                    target.runMomentum = Math.min((target.runMomentum || 0) + 0.15, 1);
                    target.rotation.x = target.runMomentum * 0.2;
                } else {
                    target.velocity = new BABYLON.Vector3(0, 0, 0);
                    target.runMomentum = (target.runMomentum || 0) * 0.95;
                    target.rotation.x = target.runMomentum * 0.1;
                }

                // Running bob animation
                target.position.y = Math.abs(Math.sin(time * 8 + i)) * 0.08;
            });
        }

        // Update target route colors based on distance from QB (green=close, yellow=medium, orange=far)
        function updateTargetDistanceColors() {
            if (!gameState.targetPracticeMode || !gameState.scene || !gameState.scene.qb) return;

            const qbPos = gameState.scene.qb.position;

            gameState.targetPracticeTargets.forEach(target => {
                if (!target.active || !target.routeLine) return;

                // Calculate distance from QB to target
                const dx = target.position.x - qbPos.x;
                const dz = target.position.z - qbPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Determine color based on distance
                // Close (< 10 yards): Green
                // Medium (10-18 yards): Yellow
                // Far (> 18 yards): Orange
                let color;
                if (distance < 10) {
                    color = new BABYLON.Color3(0.3, 0.9, 0.3);  // Green - nearby
                } else if (distance < 18) {
                    color = new BABYLON.Color3(1, 0.85, 0.2);   // Yellow - medium
                } else {
                    color = new BABYLON.Color3(1, 0.5, 0.1);    // Orange - far away
                }

                // Update route line color
                if (target.routeLine.material) {
                    target.routeLine.material.diffuseColor = color.scale(0.6);
                    target.routeLine.material.emissiveColor = color.scale(0.3);
                }

                // Also update the body/ring colors to match
                if (target.mesh && target.mesh.bodyMaterial) {
                    target.mesh.bodyMaterial.diffuseColor = color;
                    target.mesh.bodyMaterial.emissiveColor = color.scale(0.3);
                }
            });
        }

        // Show landing ripple effect where ball lands
        function showLandingRipple(scene, position, isHit) {
            const rippleColor = isHit
                ? new BABYLON.Color3(0.3, 1, 0.3)   // Green for hit
                : new BABYLON.Color3(1, 0.3, 0.3); // Red for miss

            // Create expanding ring
            const ring = BABYLON.MeshBuilder.CreateTorus('landingRipple', {
                diameter: 0.5,
                thickness: 0.08,
                tessellation: 32
            }, scene);
            ring.position = new BABYLON.Vector3(position.x, 0.05, position.z);

            const ringMat = new BABYLON.StandardMaterial('rippleMat', scene);
            ringMat.diffuseColor = rippleColor;
            ringMat.emissiveColor = rippleColor.scale(0.8);
            ringMat.alpha = 1;
            ring.material = ringMat;

            // Create center impact disc
            const disc = BABYLON.MeshBuilder.CreateDisc('impactDisc', {
                radius: 0.3,
                tessellation: 16
            }, scene);
            disc.rotation.x = Math.PI / 2;
            disc.position = new BABYLON.Vector3(position.x, 0.03, position.z);

            const discMat = new BABYLON.StandardMaterial('impactMat', scene);
            discMat.diffuseColor = rippleColor;
            discMat.emissiveColor = rippleColor.scale(0.5);
            discMat.alpha = 0.8;
            disc.material = discMat;

            // Animate the ripple expanding and fading
            let frame = 0;
            const maxFrames = 30;
            const rippleAnimation = scene.onBeforeRenderObservable.add(() => {
                frame++;
                const progress = frame / maxFrames;

                // Expand ring
                const scale = 1 + progress * 4;
                ring.scaling = new BABYLON.Vector3(scale, 1, scale);
                ringMat.alpha = 1 - progress;

                // Shrink and fade disc
                const discScale = 1 - progress * 0.5;
                disc.scaling = new BABYLON.Vector3(discScale, discScale, discScale);
                discMat.alpha = 0.8 * (1 - progress);

                if (frame >= maxFrames) {
                    scene.onBeforeRenderObservable.remove(rippleAnimation);
                    ring.dispose();
                    disc.dispose();
                }
            });
        }

        // Check if a throw hits any targets
        // Hit if ball lands within the visible ring around the target
        function checkTargetHits(ballPosition) {
            const hitTargets = [];

            gameState.targetPracticeTargets.forEach(target => {
                if (!target.active) return;

                // Calculate distance from ball to target center
                const dx = target.position.x - ballPosition.x;
                const dz = target.position.z - ballPosition.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // The base ring visual diameter is 1.2 * scale
                // Hit radius should match or be slightly larger than the visual ring
                const ringRadius = (1.2 * target.config.scale) / 2;  // Convert diameter to radius
                const hitRadius = ringRadius * 1.3 * (gameState.playerScale || 1.3);  // 30% larger than visual for forgiveness

                if (distance < hitRadius) {
                    hitTargets.push(target);
                }
            });

            return hitTargets;
        }

        // Calculate score for hitting targets
        function calculateTargetScore(hitTargets, throwDistance, ballPosition) {
            if (hitTargets.length === 0) return { total: 0, breakdown: [], zoneMultiplier: 1 };

            let basePoints = 0;
            let breakdown = [];
            const now = performance.now();

            // Get distance-based multiplier (based on throw distance from QB)
            const distanceZone = getDistanceMultiplier(throwDistance);
            const zoneMultiplier = distanceZone.multiplier;
            const zoneName = distanceZone.name;

            // Base points for each target hit
            hitTargets.forEach(target => {
                basePoints += target.config.points;
                breakdown.push({
                    label: `${target.config.name} Target`,
                    points: target.config.points
                });
            });

            // Multi-hit bonus (hitting multiple targets at once)
            let multiHitBonus = 0;
            if (hitTargets.length > 1) {
                multiHitBonus = hitTargets.length * 50;
                breakdown.push({
                    label: `Multi-Hit x${hitTargets.length}`,
                    points: multiHitBonus
                });
            }

            // Rapid fire bonus (hit within 3 seconds of last hit)
            let rapidFireBonus = 0;
            if (gameState.targetPracticeLastHitTime > 0 &&
                (now - gameState.targetPracticeLastHitTime) < 3000) {
                rapidFireBonus = 25;
                breakdown.push({
                    label: 'Rapid Fire',
                    points: rapidFireBonus
                });
            }

            // Calculate subtotal before multiplier
            const subtotal = basePoints + multiHitBonus + longThrowBonus + rapidFireBonus;

            // Stack multipliers together (streak √ó zone)
            const streakMultiplier = gameState.targetPracticeMultiplier;
            const combinedMultiplier = streakMultiplier * zoneMultiplier;
            const total = Math.floor(subtotal * combinedMultiplier);

            // Show combined multiplier in breakdown if > 1
            if (combinedMultiplier > 1) {
                let multiplierLabel = '';
                if (streakMultiplier > 1 && zoneMultiplier > 1) {
                    multiplierLabel = `Streak ${streakMultiplier}x √ó ${zoneName} ${zoneMultiplier}x = ${combinedMultiplier}x`;
                } else if (streakMultiplier > 1) {
                    multiplierLabel = `Streak x${streakMultiplier}`;
                } else {
                    multiplierLabel = `${zoneName} Zone x${zoneMultiplier}`;
                }
                breakdown.push({
                    label: multiplierLabel,
                    points: total - subtotal
                });
            }

            return { total, breakdown, subtotal, zoneMultiplier, combinedMultiplier };
        }

        // Handle target hit
        function handleTargetHit(hitTargets, throwDistance, ballPosition) {
            if (hitTargets.length === 0) {
                // Miss - decrement misses remaining
                gameState.targetPracticeMissesRemaining--;

                // Track best streak before resetting
                if (gameState.targetPracticeStreak > (gameState.targetPracticeBestStreak || 0)) {
                    gameState.targetPracticeBestStreak = gameState.targetPracticeStreak;
                }

                // Reset streak
                gameState.targetPracticeStreak = 0;
                gameState.targetPracticeMultiplier = 1;
                updateTargetPracticeUI();

                // Show miss feedback
                showMissPopup();

                // Check for game over
                if (gameState.targetPracticeMissesRemaining <= 0) {
                    showGameOverPopup();
                }
                return;
            }

            // Calculate score (pass ball position for bonus zone check)
            const scoreResult = calculateTargetScore(hitTargets, throwDistance, ballPosition);

            // Update streak
            gameState.targetPracticeStreak++;
            gameState.targetPracticeLastHitTime = performance.now();

            // Update multiplier based on streak (max 5x)
            if (gameState.targetPracticeStreak >= 10) {
                gameState.targetPracticeMultiplier = 5;
            } else if (gameState.targetPracticeStreak >= 7) {
                gameState.targetPracticeMultiplier = 4;
            } else if (gameState.targetPracticeStreak >= 5) {
                gameState.targetPracticeMultiplier = 3;
            } else if (gameState.targetPracticeStreak >= 3) {
                gameState.targetPracticeMultiplier = 2;
            } else {
                gameState.targetPracticeMultiplier = 1;
            }

            // Add score
            gameState.targetPracticeScore += scoreResult.total;

            // Deactivate hit targets (NO respawn - round based)
            hitTargets.forEach(target => {
                target.active = false;
                target.mesh.setEnabled(false);
                if (target.routeLine) {
                    target.routeLine.dispose();
                    target.routeLine = null;
                }
            });

            // Update UI
            updateTargetPracticeUI();
            showTargetHitPopup(hitTargets.length, scoreResult);

            // Check if round complete (all targets hit)
            const remainingTargets = gameState.targetPracticeTargets.filter(t => t.active).length;
            if (remainingTargets === 0) {
                // Round complete!
                completeRound();
            }
        }

        // Complete the current round
        function completeRound() {
            const roundTime = (performance.now() - gameState.targetPracticeRoundStartTime) / 1000;
            const roundThrows = gameState.targetPracticeRoundThrows;
            const targetCount = gameState.targetPracticeTargetCount;

            // Track best streak before any resets
            if (gameState.targetPracticeStreak > (gameState.targetPracticeBestStreak || 0)) {
                gameState.targetPracticeBestStreak = gameState.targetPracticeStreak;
            }

            let timeBonus = 0;
            let accuracyBonus = 0;

            if (gameState.targetPracticeModeType === 'timed') {
                // Timed mode: bonus for remaining time
                const timeRemaining = gameState.targetPracticeTimeRemaining;
                const timeLimit = gameState.targetPracticeRoundTimeLimit;
                if (timeRemaining > 0) {
                    // Bonus based on percentage of time remaining
                    const timeRatio = timeRemaining / timeLimit;
                    timeBonus = Math.floor(timeRatio * 400 * gameState.targetPracticeRound);
                }
                // Accuracy bonus in timed mode
                if (roundThrows <= targetCount) {
                    accuracyBonus = 200 * gameState.targetPracticeRound;
                } else {
                    const accuracy = targetCount / roundThrows;
                    accuracyBonus = Math.floor(accuracy * 100 * gameState.targetPracticeRound);
                }
            } else {
                // Misses mode: bonus for fast completion
                const expectedTime = targetCount * 3;
                if (roundTime < expectedTime) {
                    const timeRatio = 1 - (roundTime / expectedTime);
                    timeBonus = Math.floor(timeRatio * 500 * gameState.targetPracticeRound);
                }
                // Accuracy bonus in misses mode
                if (roundThrows <= targetCount) {
                    accuracyBonus = 300 * gameState.targetPracticeRound;
                } else {
                    const accuracy = targetCount / roundThrows;
                    accuracyBonus = Math.floor(accuracy * 150 * gameState.targetPracticeRound);
                }
                // Give extra miss for completing the round (misses mode only)
                gameState.targetPracticeMissesRemaining++;
                gameState.targetPracticeMaxMisses++;
            }

            // Total round bonus
            const roundBonus = timeBonus + accuracyBonus;
            gameState.targetPracticeScore += roundBonus;

            // Save round history
            gameState.targetPracticeRoundHistory.push({
                round: gameState.targetPracticeRound,
                throws: roundThrows,
                time: roundTime,
                targets: targetCount,
                timeBonus: timeBonus,
                accuracyBonus: accuracyBonus
            });

            // Show round complete popup with bonuses
            showRoundCompletePopup(roundThrows, roundTime, timeBonus, accuracyBonus, roundBonus);
        }

        // Start the next round
        function startNextRound() {
            gameState.targetPracticeRound++;

            // Always 4 targets, but increase speed each round
            gameState.targetPracticeTargetCount = 4;
            gameState.targetPracticeSpeedBonus += 0.12;  // 12% faster each round

            // Reset round stats
            gameState.targetPracticeRoundThrows = 0;
            gameState.targetPracticeRoundStartTime = performance.now();
            gameState.targetPracticeStreak = 0;
            gameState.targetPracticeMultiplier = 1;

            // Reset timer for timed mode (reduce time limit each round for difficulty)
            if (gameState.targetPracticeModeType === 'timed') {
                // Reduce time limit slightly each round (minimum 15 seconds)
                gameState.targetPracticeRoundTimeLimit = Math.max(15, 30 - (gameState.targetPracticeRound - 1) * 2);
                gameState.targetPracticeTimeRemaining = gameState.targetPracticeRoundTimeLimit;
            }

            // Create new targets
            if (gameState.scene) {
                createAllTargets(gameState.scene);
            }

            // Update UI
            updateTargetPracticeUI();
            updateRoundHistoryUI();
        }

        // Show round complete popup
        function showRoundCompletePopup(throws, time, timeBonus, accuracyBonus, totalBonus) {
            const popup = document.getElementById('roundCompletePopup');
            document.getElementById('roundCompleteThrows').textContent = throws;
            document.getElementById('roundCompleteTime').textContent = time.toFixed(1) + 's';
            document.getElementById('nextRoundNum').textContent = gameState.targetPracticeRound + 1;
            document.getElementById('nextRoundTargets').textContent = '4';  // Always 4 targets

            // Show score breakdown
            if (gameState.targetPracticeModeType === 'timed') {
                document.getElementById('roundTimeBonus').textContent = 'Time Left Bonus: +' + timeBonus;
            } else {
                document.getElementById('roundTimeBonus').textContent = 'Speed Bonus: +' + timeBonus;
            }
            document.getElementById('roundAccuracyBonus').textContent = 'Accuracy Bonus: +' + accuracyBonus;
            document.getElementById('roundTotalBonus').textContent = 'Total: +' + totalBonus;

            // Show mode-specific info
            const extraMissEl = document.getElementById('roundExtraMiss');
            if (gameState.targetPracticeModeType === 'timed') {
                // Timed mode: show next round time limit
                const nextTimeLimit = Math.max(15, 30 - gameState.targetPracticeRound * 2);
                extraMissEl.innerHTML = `Next Round: ${nextTimeLimit}s`;
                extraMissEl.style.color = '#4fc3f7';
            } else {
                // Misses mode: show extra miss earned
                let missIcons = '';
                for (let i = 0; i < gameState.targetPracticeMissesRemaining; i++) {
                    missIcons += 'üèà';
                }
                extraMissEl.innerHTML = '+1 üèà Extra! (' + missIcons + ')';
                extraMissEl.style.color = '#ff6b6b';
            }

            popup.style.display = 'block';

            // Wait for tap to continue
            const continueHandler = () => {
                popup.style.display = 'none';
                document.removeEventListener('pointerdown', continueHandler);
                startNextRound();
            };

            // Delay before allowing continue (prevent accidental tap)
            setTimeout(() => {
                document.addEventListener('pointerdown', continueHandler);
            }, 500);
        }

        // Show miss popup
        function showMissPopup() {
            const popup = document.getElementById('targetHitPopup');
            const mainEl = document.getElementById('hitPopupMain');
            const pointsEl = document.getElementById('hitPopupPoints');
            const bonusesEl = document.getElementById('hitPopupBonuses');

            mainEl.textContent = 'MISS!';
            mainEl.style.color = '#f44';
            pointsEl.textContent = 'Streak Reset';
            pointsEl.style.color = '#888';

            if (gameState.targetPracticeModeType === 'timed') {
                // Timed mode: show time remaining
                const timeLeft = Math.max(0, gameState.targetPracticeTimeRemaining).toFixed(1);
                bonusesEl.innerHTML = `${timeLeft}s remaining`;
            } else {
                // Misses mode: show remaining misses as football icons
                let missIcons = '';
                for (let i = 0; i < gameState.targetPracticeMissesRemaining; i++) {
                    missIcons += 'üèà';
                }
                bonusesEl.innerHTML = missIcons + ' left';
            }

            popup.style.display = 'block';
            setTimeout(() => {
                popup.style.display = 'none';
                // Reset color for next hit
                mainEl.style.color = '#4f4';
                pointsEl.style.color = '#ffd700';
            }, 800);  // Shorter for timed mode
        }

        // Show game over popup
        function showGameOverPopup() {
            // Stop the game
            stopTargetPracticeTimer();
            gameState.canThrow = false;

            const popup = document.getElementById('gameOverPopup');
            document.getElementById('gameOverScore').textContent = gameState.targetPracticeScore;
            document.getElementById('gameOverRound').textContent = gameState.targetPracticeRound;
            document.getElementById('gameOverBestStreak').textContent = gameState.targetPracticeBestStreak || 0;

            // Update title based on mode
            const titleEl = popup.querySelector('div[style*="font-size: 28px"]');
            if (titleEl) {
                if (gameState.targetPracticeModeType === 'timed' && gameState.targetPracticeTimeRemaining <= 0) {
                    titleEl.textContent = "TIME'S UP!";
                } else {
                    titleEl.textContent = 'GAME OVER';
                }
            }

            // Check for new best score (separate tracking for each mode)
            const newBestEl = document.getElementById('gameOverNewBest');
            const bestScoreKey = gameState.targetPracticeModeType === 'timed'
                ? 'targetPracticeBestScoreTimed'
                : 'targetPracticeBestScore';
            const currentBest = parseInt(localStorage.getItem(bestScoreKey) || '0', 10);

            if (gameState.targetPracticeScore > currentBest) {
                localStorage.setItem(bestScoreKey, gameState.targetPracticeScore);
                newBestEl.style.display = 'block';
            } else {
                newBestEl.style.display = 'none';
            }

            popup.style.display = 'block';
        }

        // Update target practice UI
        function updateTargetPracticeUI() {
            const remainingTargets = gameState.targetPracticeTargets.filter(t => t.active).length;

            document.getElementById('targetRound').textContent = gameState.targetPracticeRound;
            document.getElementById('targetScoreDisplay').textContent = gameState.targetPracticeScore;
            document.getElementById('targetThrows').textContent = gameState.targetPracticeRoundThrows;
            document.getElementById('targetMultiplier').textContent = gameState.targetPracticeMultiplier + 'x';
            document.getElementById('targetMisses').textContent = gameState.targetPracticeMissesRemaining;
            document.getElementById('targetStreak').textContent = gameState.targetPracticeStreak;

            // Handle mode-specific display
            const missIconsEl = document.getElementById('targetMissIcons');
            if (gameState.targetPracticeModeType === 'timed') {
                // Timed mode: hide misses, show remaining targets
                missIconsEl.innerHTML = `<span style="color: #4fc3f7;">${remainingTargets}</span> left`;
            } else {
                // Misses mode: show football icons for misses remaining
                const missCount = gameState.targetPracticeMissesRemaining;
                let iconsHtml = '';
                for (let i = 0; i < missCount; i++) {
                    // Color based on position: last few get warning colors
                    let color;
                    if (missCount <= 1) {
                        color = '#f44';  // Red - critical
                    } else if (missCount <= 2) {
                        color = '#ff6b6b';  // Orange-red
                    } else {
                        color = '#8B4513';  // Brown football color
                    }
                    iconsHtml += `<span style="color: ${color};">üèà</span>`;
                }
                missIconsEl.innerHTML = iconsHtml;
            }

            // Update time display based on mode
            const elapsed = (performance.now() - gameState.targetPracticeRoundStartTime) / 1000;
            if (gameState.targetPracticeModeType === 'timed') {
                const remaining = Math.max(0, gameState.targetPracticeRoundTimeLimit - elapsed);
                document.getElementById('targetTime').textContent = remaining.toFixed(1) + 's';
                document.getElementById('targetTime').style.color = remaining <= 5 ? '#f44' : '#ffd700';
            } else {
                document.getElementById('targetTime').textContent = elapsed.toFixed(1) + 's';
                document.getElementById('targetTime').style.color = '#ffd700';
            }
        }

        // Update round history UI
        function updateRoundHistoryUI() {
            const historyList = document.getElementById('roundHistoryList');
            if (gameState.targetPracticeRoundHistory.length === 0) {
                historyList.innerHTML = '<div style="color: #555;">No rounds completed</div>';
                return;
            }

            const historyHtml = gameState.targetPracticeRoundHistory.map(r =>
                `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                    <span>R${r.round}</span>
                    <span style="color: #4fc3f7;">${r.throws} throws</span>
                    <span style="color: #ffd700;">${r.time.toFixed(1)}s</span>
                </div>`
            ).join('');
            historyList.innerHTML = historyHtml;
        }

        // Timer update for target practice
        let targetPracticeTimerInterval = null;

        function startTargetPracticeTimer() {
            if (targetPracticeTimerInterval) {
                clearInterval(targetPracticeTimerInterval);
            }
            targetPracticeTimerInterval = setInterval(() => {
                if (gameState.targetPracticeMode && gameState.targetPracticeRoundStartTime > 0) {
                    const elapsed = (performance.now() - gameState.targetPracticeRoundStartTime) / 1000;

                    if (gameState.targetPracticeModeType === 'timed') {
                        // Timed mode: count down
                        const remaining = Math.max(0, gameState.targetPracticeRoundTimeLimit - elapsed);
                        gameState.targetPracticeTimeRemaining = remaining;
                        document.getElementById('targetTime').textContent = remaining.toFixed(1) + 's';
                        document.getElementById('targetTime').style.color = remaining <= 5 ? '#f44' : '#ffd700';

                        // Check for time up
                        if (remaining <= 0) {
                            // Time's up - check if any targets remain
                            const remainingTargets = gameState.targetPracticeTargets.filter(t => t.active).length;
                            if (remainingTargets > 0) {
                                // Didn't complete round in time - game over
                                showGameOverPopup();
                            }
                        }
                    } else {
                        // Misses mode: count up
                        document.getElementById('targetTime').textContent = elapsed.toFixed(1) + 's';
                        document.getElementById('targetTime').style.color = '#ffd700';
                    }
                }
            }, 100);
        }

        function stopTargetPracticeTimer() {
            if (targetPracticeTimerInterval) {
                clearInterval(targetPracticeTimerInterval);
                targetPracticeTimerInterval = null;
            }
        }

        // Show hit popup with score breakdown
        function showTargetHitPopup(hitCount, scoreResult) {
            const popup = document.getElementById('targetHitPopup');
            const mainEl = document.getElementById('hitPopupMain');
            const pointsEl = document.getElementById('hitPopupPoints');
            const bonusesEl = document.getElementById('hitPopupBonuses');

            const remaining = gameState.targetPracticeTargets.filter(t => t.active).length;

            // Check if a bonus target was hit
            const hitBonus = scoreResult.breakdown.some(item => item.label === 'BONUS Target');

            if (hitBonus) {
                mainEl.textContent = 'BONUS HIT!';
                mainEl.style.color = '#e040fb';  // Purple/magenta for bonus
            } else if (hitCount > 1) {
                mainEl.textContent = `MULTI-HIT x${hitCount}!`;
                mainEl.style.color = '#ffd700';
            } else {
                mainEl.textContent = 'HIT!';
                mainEl.style.color = '#4f4';
            }

            // Show total points prominently
            pointsEl.textContent = `+${scoreResult.total} pts`;
            pointsEl.style.color = hitBonus ? '#e040fb' : '#ffd700';

            // Show breakdown of bonuses
            const bonusParts = [];
            scoreResult.breakdown.forEach(item => {
                if (item.points > 0) {
                    const isBonus = item.label === 'BONUS Target';
                    const color = isBonus ? '#e040fb' : '#fff';
                    bonusParts.push(`<span style="color:${color}">${item.label}: +${item.points}</span>`);
                }
            });
            bonusesEl.innerHTML = bonusParts.join('<br>');
            bonusesEl.style.fontSize = '12px';

            popup.style.display = 'block';

            // Hide after delay (longer to read breakdown)
            setTimeout(() => {
                popup.style.display = 'none';
            }, 1200);
        }

        // Start target practice mode
        function startTargetPracticeMode(modeType = 'misses') {
            gameState.targetPracticeMode = true;
            gameState.targetPracticeModeType = modeType; // 'misses' or 'timed'
            gameState.trainingMode = false;

            // Reset all state
            gameState.targetPracticeScore = 0;
            gameState.targetPracticeStreak = 0;
            gameState.targetPracticeMultiplier = 1;
            gameState.targetPracticeLastHitTime = 0;
            gameState.targetPracticeSpeedBonus = 1.15;  // Start faster for more challenge

            // Reset round state
            gameState.targetPracticeRound = 1;
            gameState.targetPracticeRoundThrows = 0;
            gameState.targetPracticeRoundStartTime = performance.now();
            gameState.targetPracticeRoundHistory = [];
            gameState.targetPracticeTotalThrows = 0;
            gameState.targetPracticeTargetCount = 4;  // Always 4 targets

            // Reset mode-specific state
            if (modeType === 'timed') {
                // Timed mode: 30 seconds per round, unlimited misses
                gameState.targetPracticeRoundTimeLimit = 30;
                gameState.targetPracticeTimeRemaining = 30;
                gameState.targetPracticeMissesRemaining = 999; // Unlimited
                gameState.targetPracticeMaxMisses = 999;
            } else {
                // Misses mode: 5 misses, unlimited time
                gameState.targetPracticeMissesRemaining = 5;
                gameState.targetPracticeMaxMisses = 5;
                gameState.targetPracticeRoundTimeLimit = 0; // No limit
                gameState.targetPracticeTimeRemaining = 0;
            }
            gameState.targetPracticeBestStreak = 0;

            // Hide game over popup if showing
            document.getElementById('gameOverPopup').style.display = 'none';

            // Hide management overlay and show game elements
            document.getElementById('managementOverlay').classList.add('hidden');
            document.getElementById('topBar').style.display = 'none';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('trainingModeUI').style.display = 'none';
            document.getElementById('targetPracticeModeUI').style.display = 'block';
            document.getElementById('catchDisplay').style.display = 'none';
            gameSceneActive = true;

            // Hide players - we only want targets
            gameState.receivers.forEach(r => r.setEnabled(false));
            gameState.defenders.forEach(d => d.setEnabled(false));
            gameState.offensiveLine.forEach(l => l.setEnabled(false));
            gameState.defensiveLine.forEach(l => l.setEnabled(false));

            // Hide ALL name labels (QB, receivers, defenders)
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 0;
            }
            gameState.receivers.forEach(r => {
                if (r.nameLabel) r.nameLabel.alpha = 0;
            });
            gameState.defenders.forEach(d => {
                if (d.nameLabel) d.nameLabel.alpha = 0;
            });

            // Position QB
            if (gameState.scene && gameState.scene.qb) {
                gameState.scene.qb.position = new BABYLON.Vector3(0, 0, gameState.lineOfScrimmage - 3);
                gameState.scene.qb.setEnabled(true);
            }

            // Reset game state for throwing
            gameState.ballInFlight = false;
            gameState.canThrow = true;
            gameState.playFrozen = false;  // No freeze in target practice
            gameState.isDragging = false;

            // Create targets
            if (gameState.scene) {
                createAllTargets(gameState.scene);
                // Create distance multiplier zones
                const qbZ = gameState.lineOfScrimmage - 3;
                createDistanceZones(gameState.scene, qbZ);
            }

            // Update UI
            updateTargetPracticeUI();
            updateRoundHistoryUI();

            // Start timer
            startTargetPracticeTimer();

            // Update settings UI
            document.getElementById('tpBallSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
            document.getElementById('tpCameraAngleSlider').value = (gameState.cameraAngle || 0.5) * 100;
            document.getElementById('tpCameraAngleValue').textContent = Math.round((gameState.cameraAngle || 0.5) * 100) + '%';
            document.getElementById('tpCameraOffsetSlider').value = (gameState.cameraOffset || 0.35) * 100;
            document.getElementById('tpCameraOffsetValue').textContent = Math.round((gameState.cameraOffset || 0.35) * 100) + '%';
            // Update mode display
            const modeDisplay = document.getElementById('tpModeDisplay');
            if (modeDisplay) {
                modeDisplay.textContent = modeType === 'timed' ? 'TIMED MODE' : 'MISSES MODE';
                modeDisplay.style.color = modeType === 'timed' ? '#ffd700' : '#4fc3f7';
            }

            // Update camera
            updateTargetPracticeCamera();

            // Force engine resize
            engine.resize();
        }

        // Exit target practice mode
        function exitTargetPracticeMode() {
            gameState.targetPracticeMode = false;
            gameSceneActive = false;

            // Stop timer
            stopTargetPracticeTimer();

            // Hide round complete popup if showing
            document.getElementById('roundCompletePopup').style.display = 'none';
            // Hide game over popup if showing
            document.getElementById('gameOverPopup').style.display = 'none';

            // Clean up targets (including route lines)
            gameState.targetPracticeTargets.forEach(t => {
                if (t.routeLine) t.routeLine.dispose();
                if (t.mesh) t.mesh.dispose();
            });
            gameState.targetPracticeTargets = [];

            // Clean up distance zones
            clearDistanceZones();

            // Hide UI
            document.getElementById('targetPracticeModeUI').style.display = 'none';
            document.getElementById('topBar').style.display = 'none';
            document.getElementById('viewButtons').style.display = 'none';
            document.getElementById('managementOverlay').classList.remove('hidden');

            // Show players again
            gameState.receivers.forEach(r => r.setEnabled(true));
            gameState.offensiveLine.forEach(l => l.setEnabled(true));
            gameState.defensiveLine.forEach(l => l.setEnabled(true));
            // Defenders will be shown based on game mode

            // Return to main menu
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            if (managementState.initialized) {
                document.getElementById('hubScreen').style.display = 'block';
                refreshHubScreen();
            } else {
                document.getElementById('mainMenuScreen').style.display = 'block';
            }
        }

        // Update camera for target practice
        function updateTargetPracticeCamera() {
            if (!gameState.scene || !gameState.scene.activeCamera) return;

            const camera = gameState.scene.activeCamera;
            const baseTargetZ = gameState.lineOfScrimmage + 5;
            const maxForwardOffset = 12;
            const forwardOffset = (gameState.cameraOffset || 0) * maxForwardOffset;

            camera.target = new BABYLON.Vector3(0, 0, baseTargetZ + forwardOffset);
            camera.alpha = -Math.PI / 2;
            camera.beta = 0.1 + (gameState.cameraAngle || 0.5) * (Math.PI / 2 - 0.1);

            const baseRadius = 32;
            const radiusAdjust = (gameState.cameraOffset || 0) * 8;
            camera.radius = baseRadius + radiusAdjust;
        }

        // Reset play for target practice (simpler than regular reset)
        function resetTargetPracticePlay() {
            // Reset throwing state
            gameState.ballInFlight = false;
            gameState.canThrow = true;
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragCurrent = null;

            // Hide football
            if (gameState.scene && gameState.scene.football) {
                gameState.scene.football.setEnabled(false);
                gameState.scene.football.parent = null;
            }

            // Clear trajectory
            if (gameState.scene && gameState.scene.trajectoryDots) {
                gameState.scene.trajectoryDots.forEach(dot => dot.dispose());
                gameState.scene.trajectoryDots = null;
            }
        }

        // Update all player speeds when game speed multiplier changes
        function updateAllPlayerSpeeds() {
            // Update receivers
            gameState.receivers.forEach(receiver => {
                const spd = receiver.coreAttributes?.speed || 70;
                receiver.baseSpeed = spd * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier;
                receiver.speed = receiver.baseSpeed;
            });
            // Update defenders
            gameState.defenders.forEach(defender => {
                const spd = defender.coreAttributes?.speed || 70;
                defender.baseSpeed = spd * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier;
                defender.speed = defender.baseSpeed;
            });
            // Update O-line
            gameState.offensiveLine.forEach(lineman => {
                const spd = lineman.coreAttributes?.speed || 70;
                lineman.baseSpeed = spd * SPEED_CONSTANTS.O_LINE_FACTOR * gameState.gameSpeedMultiplier;
                lineman.speed = lineman.baseSpeed;
            });
            // Update D-line
            gameState.defensiveLine.forEach(lineman => {
                const spd = lineman.coreAttributes?.speed || 70;
                lineman.baseSpeed = spd * SPEED_CONSTANTS.D_LINE_FACTOR * gameState.gameSpeedMultiplier;
                lineman.speed = lineman.baseSpeed;
            });
            // Update display
            const speedDisplay = document.getElementById('gameSpeedDisplay');
            if (speedDisplay) speedDisplay.textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        }

        // Adjust game speed multiplier
        function adjustGameSpeed(delta) {
            gameState.gameSpeedMultiplier = Math.max(0.5, Math.min(2.0, gameState.gameSpeedMultiplier + delta));
            updateAllPlayerSpeeds();
        }

        // Apply receiver speed preset to all receivers
        function applyReceiverSpeedPreset() {
            const preset = gameState.receiverSpeedPreset;
            const speeds = preset === 'mixed' ? [90, 80, 70] : [preset, preset, preset];
            gameState.receivers.forEach((receiver, i) => {
                const speedStat = speeds[i % speeds.length];
                // Update coreAttributes.speed
                if (!receiver.coreAttributes) receiver.coreAttributes = {};
                receiver.coreAttributes.speed = speedStat;
                receiver.baseSpeed = speedStat * SPEED_CONSTANTS.RECEIVER_FACTOR * gameState.gameSpeedMultiplier;
                receiver.speed = receiver.baseSpeed;
                // Recalculate overall using new formula
                receiver.overall = calculateOverall({
                    position: 'WR',
                    coreAttributes: receiver.coreAttributes,
                    stats: receiver.stats
                });
                // Update visual label
                if (receiver.ovrTextBlock) {
                    const stars = receiver.overall >= 90 ? ' ‚òÖ‚òÖ' : receiver.overall >= 85 ? ' ‚òÖ' : '';
                    receiver.ovrTextBlock.text = `${receiver.overall}${stars}`;
                }
            });
        }

        // Apply DB speed preset to all defenders
        function applyDbSpeedPreset() {
            const preset = gameState.dbSpeedPreset;
            const speeds = preset === 'mixed' ? [90, 80, 70] : [preset, preset, preset];
            gameState.defenders.forEach((defender, i) => {
                const speedStat = speeds[i % speeds.length];
                // Update coreAttributes.speed
                if (!defender.coreAttributes) defender.coreAttributes = {};
                defender.coreAttributes.speed = speedStat;
                defender.baseSpeed = speedStat * SPEED_CONSTANTS.DEFENDER_FACTOR * gameState.gameSpeedMultiplier;
                defender.speed = defender.baseSpeed;
                // Recalculate overall using new formula
                defender.overall = calculateOverall({
                    position: 'CB',
                    coreAttributes: defender.coreAttributes,
                    stats: defender.stats
                });
                // Update visual label
                if (defender.ovrTextBlock) {
                    const stars = defender.overall >= 90 ? ' ‚òÖ‚òÖ' : defender.overall >= 85 ? ' ‚òÖ' : '';
                    defender.ovrTextBlock.text = `${defender.overall}${stars}`;
                }
            });
        }

        // Apply receiver awareness preset (affects ball reaction delay)
        function applyReceiverAwarenessPreset() {
            const preset = gameState.receiverAwarenessPreset;
            const awarenesses = preset === 'mixed' ? [90, 70, 50] : [preset, preset, preset];
            gameState.receivers.forEach((receiver, i) => {
                const awarenessStat = awarenesses[i % awarenesses.length];
                // Update coreAttributes.intelligence (which controls reaction time)
                if (!receiver.coreAttributes) receiver.coreAttributes = {};
                receiver.coreAttributes.intelligence = awarenessStat;
                // Recalculate overall using new formula
                receiver.overall = calculateOverall({
                    position: 'WR',
                    coreAttributes: receiver.coreAttributes,
                    stats: receiver.stats
                });
                // Update visual label
                if (receiver.ovrTextBlock) {
                    const stars = receiver.overall >= 90 ? ' ‚òÖ‚òÖ' : receiver.overall >= 85 ? ' ‚òÖ' : '';
                    receiver.ovrTextBlock.text = `${receiver.overall}${stars}`;
                }
            });
        }

        // Apply receiver agility preset (affects turn rate/route correction)
        function applyReceiverAgilityPreset() {
            const preset = gameState.receiverAgilityPreset;
            const agilities = preset === 'mixed' ? [90, 70, 50] : [preset, preset, preset];
            gameState.receivers.forEach((receiver, i) => {
                const agilityStat = agilities[i % agilities.length];
                // Update coreAttributes.agility (which controls turn rate)
                if (!receiver.coreAttributes) receiver.coreAttributes = {};
                receiver.coreAttributes.agility = agilityStat;
                // Recalculate overall using new formula
                receiver.overall = calculateOverall({
                    position: 'WR',
                    coreAttributes: receiver.coreAttributes,
                    stats: receiver.stats
                });
                // Update visual label
                if (receiver.ovrTextBlock) {
                    const stars = receiver.overall >= 90 ? ' ‚òÖ‚òÖ' : receiver.overall >= 85 ? ' ‚òÖ' : '';
                    receiver.ovrTextBlock.text = `${receiver.overall}${stars}`;
                }
            });
        }

        // Calculate throw rating based on lead accuracy, lateral offset, and receiver slowdown
        function calculateThrowRating(receiver, ballLandingPos, catchTime) {
            // Get receiver's position, velocity, and speed at THROW time (not catch time)
            const throwPos = gameState.receiverPositionsAtThrow && gameState.receiverPositionsAtThrow[receiver.name];
            const throwVelocity = gameState.receiverVelocitiesAtThrow && gameState.receiverVelocitiesAtThrow[receiver.name];
            const throwSpeed = gameState.receiverSpeedsAtThrow && gameState.receiverSpeedsAtThrow[receiver.name];

            if (!throwPos || !throwVelocity) {
                return { grade: 'C', score: 50, details: 'No throw data', leadScore: 50 };
            }

            // Calculate ball flight time
            const flightTime = gameState.throwStartTime ?
                (performance.now() - gameState.throwStartTime) / 1000 : 1.5;

            // Get velocity direction at throw time (velocity is per-frame, convert to per-second)
            const velPerSec = { x: throwVelocity.x * 60, z: throwVelocity.z * 60 };
            const velocityMagnitude = Math.sqrt(
                velPerSec.x * velPerSec.x + velPerSec.z * velPerSec.z
            );

            // Use stored speed (includes boosts) for expected distance, fallback to velocity magnitude
            const receiverSpeed = throwSpeed || velocityMagnitude;

            // Vector from receiver (at throw time) to ball landing
            const toBall = new BABYLON.Vector3(
                ballLandingPos.x - throwPos.x,
                0,
                ballLandingPos.z - throwPos.z
            );
            const distToBall = Math.sqrt(toBall.x * toBall.x + toBall.z * toBall.z);

            let leadScore = 50;
            let lateralScore = 100;
            let slowdownScore = 100;
            let leadDistance = 0;
            let lateralOffset = 0;
            let debugInfo = null;

            if (velocityMagnitude > 0.1) {
                // Normalize velocity direction
                const velDir = new BABYLON.Vector3(
                    velPerSec.x / velocityMagnitude,
                    0,
                    velPerSec.z / velocityMagnitude
                );

                // 1. LEAD DISTANCE: Dot product gives distance along velocity direction
                leadDistance = toBall.x * velDir.x + toBall.z * velDir.z;

                // 2. LATERAL OFFSET: Cross product magnitude gives perpendicular distance
                // In 2D (XZ plane): |A √ó B| = Ax*Bz - Az*Bx
                lateralOffset = Math.abs(toBall.x * velDir.z - toBall.z * velDir.x);

                // Ideal lead scales with flight time and receiver speed
                // If receiver runs at speed S for time T, ideal lead = S * T
                const idealLead = velocityMagnitude * flightTime * 0.8; // 80% to give catching room

                // Score lead accuracy (how close to ideal)
                // More lenient: 1.5 yard buffer for full score, gentler dropoff
                const leadError = Math.abs(leadDistance - idealLead);
                if (leadDistance < 0) {
                    // Ball thrown behind - bad but not catastrophic for small amounts
                    // 0 to -1 yard: 80-100, beyond that drops faster
                    leadScore = Math.max(0, 100 + leadDistance * 20);
                } else if (leadDistance > idealLead * 2.5) {
                    // Way too far ahead - receiver can't reach
                    leadScore = Math.max(10, 60 - (leadDistance - idealLead * 2) * 8);
                } else if (leadError <= 1.5) {
                    // Within 1.5 yards of ideal = full score
                    leadScore = 100;
                } else {
                    // Outside buffer but reasonable range - gentle dropoff
                    leadScore = Math.max(40, 100 - (leadError - 1.5) * 12);
                }

                // Lateral offset penalty - each yard off costs points
                // Perfect = on the line, 3+ yards off = significant penalty
                lateralScore = Math.max(0, 100 - lateralOffset * 25);

                // 3. SLOWDOWN MEASUREMENT: Compare momentum at throw vs catch
                // runMomentum is a smoothed 0-1 value (builds 0.15/frame when running, decays 0.9x when stopped)
                // This is more reliable than distance because speed fluctuates with DB closeness
                const throwMomentum = gameState.receiverMomentumAtThrow && gameState.receiverMomentumAtThrow[receiver.name];
                const catchMomentum = receiver.runMomentum || 0;

                // Calculate momentum ratio: how much momentum was maintained
                // If throwMomentum was low (receiver wasn't running), don't penalize
                let momentumRatio;
                if (throwMomentum !== undefined && throwMomentum > 0.2) {
                    // Receiver was running at throw - compare to catch momentum
                    momentumRatio = Math.min(1, catchMomentum / throwMomentum);
                } else {
                    // Receiver was stationary or just starting - no penalty
                    momentumRatio = 1;
                }

                slowdownScore = momentumRatio * 100;

                // Store debug info for display
                debugInfo = {
                    flightTime: flightTime.toFixed(2),
                    throwMomentum: throwMomentum !== undefined ? throwMomentum.toFixed(2) : 'N/A',
                    catchMomentum: catchMomentum.toFixed(2),
                    momentumRatio: momentumRatio.toFixed(2)
                };
            } else {
                // Stationary receiver - just measure distance to ball
                const directDist = distToBall;
                leadScore = Math.max(0, 100 - directDist * 30);
                lateralScore = 100; // No direction, so no lateral concept
            }

            // Combine scores: lead most important, then slowdown, then lateral
            // Lead 40%, Slowdown 35%, Lateral 25%
            const totalScore = Math.round(
                leadScore * 0.40 +
                slowdownScore * 0.35 +
                lateralScore * 0.25
            );

            // Determine grade
            let grade;
            if (totalScore >= 90) grade = 'A+';
            else if (totalScore >= 80) grade = 'A';
            else if (totalScore >= 65) grade = 'B';
            else grade = 'C';

            // Format details
            let leadText;
            if (velocityMagnitude < 0.001) {
                leadText = 'stationary';
            } else if (leadDistance < 0) {
                leadText = `${leadDistance.toFixed(1)}yd behind`;
            } else {
                leadText = `${leadDistance.toFixed(1)}yd ahead`;
            }

            const lateralText = lateralOffset > 0.3 ? `, ${lateralOffset.toFixed(1)}yd wide` : '';

            // Check if receiver has active speed boost or penalty
            const hasSpeedBoost = receiver.clashSpeedBoostUntil > gameState.gameTime;
            const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;

            return {
                grade,
                score: totalScore,
                leadScore: Math.round(leadScore),
                lateralScore: Math.round(lateralScore),
                slowdownScore: Math.round(slowdownScore),
                leadDistance: leadDistance,
                lateralOffset: lateralOffset,
                leadText: leadText + lateralText,
                details: `Lead: ${leadText}${lateralText} | Slowdown: ${Math.round(slowdownScore)}%`,
                debugInfo: debugInfo,
                hasSpeedBoost: hasSpeedBoost,
                hasSpeedPenalty: hasSpeedPenalty
            };
        }

        // Clear heat map meshes
        function clearThrowHeatMap() {
            if (gameState.heatMapMeshes) {
                gameState.heatMapMeshes.forEach(mesh => mesh.dispose());
                gameState.heatMapMeshes = [];
            }
        }

        // Draw throw heat map showing ideal/medium/poor zones for each receiver
        function updateThrowHeatMap() {
            if (!gameState.showThrowHeatMap || !gameState.scene) return;
            clearThrowHeatMap();

            const scene = gameState.scene;
            const qbPos = scene.qb ? scene.qb.position : new BABYLON.Vector3(0, 0, gameState.qbStartZ);

            gameState.receivers.forEach((receiver, idx) => {
                if (!receiver.velocity) return;
                const pos = receiver.position;
                const vel = { x: receiver.velocity.x * 60, z: receiver.velocity.z * 60 };
                const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
                if (speed < 0.1) return;

                const throwSpeed = 25;
                for (let t = 0.3; t <= 2.0; t += 0.2) {
                    const futureX = pos.x + vel.x * t;
                    const futureZ = pos.z + vel.z * t;
                    const distToQB = Math.sqrt(Math.pow(futureX - qbPos.x, 2) + Math.pow(futureZ - qbPos.z, 2));
                    const ballFlightTime = distToQB / throwSpeed;
                    const timeDiff = Math.abs(t - ballFlightTime);

                    let color;
                    if (timeDiff < 0.15) color = new BABYLON.Color3(0, 1, 0);
                    else if (timeDiff < 0.35) color = new BABYLON.Color3(1, 1, 0);
                    else if (timeDiff < 0.6) color = new BABYLON.Color3(1, 0.5, 0);
                    else color = new BABYLON.Color3(1, 0, 0);

                    const zoneMesh = BABYLON.MeshBuilder.CreateDisc(`heatZone_${idx}_${t}`, { radius: 0.3, tessellation: 16 }, scene);
                    zoneMesh.position = new BABYLON.Vector3(futureX, 0.02, futureZ);
                    zoneMesh.rotation.x = Math.PI / 2;
                    const zoneMat = new BABYLON.StandardMaterial(`heatZoneMat_${idx}_${t}`, scene);
                    zoneMat.diffuseColor = color;
                    zoneMat.emissiveColor = color.scale(0.5);
                    zoneMat.alpha = 0.4;
                    zoneMesh.material = zoneMat;
                    gameState.heatMapMeshes.push(zoneMesh);
                }
            });
        }

        // Update game player meshes with roster data
        function updateGamePlayersFromRoster() {
            if (!managementState.initialized || !managementState.team) return;

            const scene = gameState.scene;
            if (!scene) return;

            // Helper for rating indicator text
            const getRatingText = (overall) => {
                if (overall >= 90) return `${overall} ‚òÖ‚òÖ`;
                if (overall >= 85) return `${overall} ‚òÖ`;
                return `${overall}`;
            };

            // Helper to get label background based on rating (for offense - gold tint)
            const getOffenseLabelBg = (overall) => {
                if (overall >= 90) return 'rgba(80, 60, 0, 0.85)';
                if (overall >= 85) return 'rgba(50, 40, 0, 0.8)';
                return null;  // Use default - no special background below 85
            };

            // Update QB
            const rosterQB = getDepthChartPlayer('QB');
            if (rosterQB && scene.qb) {
                try {
                    scene.qb.playerId = rosterQB.id;
                    scene.qb.displayName = `${rosterQB.firstName} ${rosterQB.lastName.charAt(0)}.`;
                    scene.qb.stats = { ...rosterQB.stats };
                    scene.qb.coreAttributes = rosterQB.coreAttributes ? { ...rosterQB.coreAttributes } : null;
                    scene.qb.lastName = rosterQB.lastName;
                    scene.qb.overall = rosterQB.overall;
                    // Update name label TextBlocks
                    if (scene.qb.nameTextBlock) {
                        scene.qb.nameTextBlock.text = rosterQB.lastName.toUpperCase();
                    }
                    if (scene.qb.ovrTextBlock) {
                        scene.qb.ovrTextBlock.text = getRatingText(rosterQB.overall);
                    }
                    if (scene.qb.nameLabel) {
                        scene.qb.nameLabel.background = getOffenseLabelBg(rosterQB.overall) || 'rgba(0, 0, 0, 0.7)';
                    }
                    console.log(`[ROSTER] QB updated: ${scene.qb.displayName} (${scene.qb.overall})`);
                } catch (e) {
                    console.error('[ROSTER] Error updating QB:', e);
                }
            }

            // Update Receivers
            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                const player = getDepthChartPlayer(slot);
                const receiver = gameState.receivers[index];
                if (player && receiver) {
                    try {
                        receiver.playerId = player.id;
                        receiver.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        receiver.stats = { ...player.stats };
                        receiver.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                        receiver.lastName = player.lastName;
                        receiver.overall = player.overall;
                        // Update name label TextBlocks
                        if (receiver.nameTextBlock) {
                            receiver.nameTextBlock.text = player.lastName.toUpperCase();
                        }
                        if (receiver.ovrTextBlock) {
                            receiver.ovrTextBlock.text = getRatingText(player.overall);
                        }
                        if (receiver.nameLabel) {
                            receiver.nameLabel.background = getOffenseLabelBg(player.overall) || 'rgba(0, 0, 0, 0.65)';
                        }
                        console.log(`[ROSTER] Receiver ${slot} updated: ${receiver.displayName} (${receiver.overall})`);
                    } catch (e) {
                        console.error(`[ROSTER] Error updating receiver ${slot}:`, e);
                    }
                }
            });

            // Update Defenders from opponent's CBs
            const game = managementState.season?.schedule?.[managementState.season.week - 1];
            const opponent = game?.opponent;
            if (opponent && opponent.roster) {
                const oppCBs = opponent.roster
                    .filter(p => p.position === 'CB')
                    .sort((a, b) => b.overall - a.overall);

                // Helper for defender label background (red theme)
                const getDefenderLabelBg = (overall) => {
                    if (overall >= 90) return 'rgba(100, 40, 40, 0.9)';
                    if (overall >= 85) return 'rgba(80, 35, 35, 0.85)';
                    return 'rgba(40, 20, 20, 0.75)';
                };

                gameState.defenders.forEach((defender, index) => {
                    const player = oppCBs[index];
                    if (player && defender) {
                        try {
                            defender.playerId = player.id;
                            defender.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                            // Preserve essential defender stats (zoneCoverage, manCoverage) while updating from roster
                            const originalZoneCov = defender.stats?.zoneCoverage || 70;
                            const originalManCov = defender.stats?.manCoverage || 70;
                            defender.stats = {
                                ...player.stats,
                                zoneCoverage: player.stats.zoneCoverage || originalZoneCov,
                                manCoverage: player.stats.manCoverage || originalManCov
                            };
                            defender.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                            defender.overall = player.overall;
                            // Update name label TextBlocks
                            if (defender.nameTextBlock) {
                                defender.nameTextBlock.text = defender.displayName.toUpperCase();
                            }
                            if (defender.ovrTextBlock) {
                                defender.ovrTextBlock.text = getRatingText(player.overall);
                            }
                            if (defender.nameLabel) {
                                defender.nameLabel.background = getDefenderLabelBg(player.overall);
                            }
                            console.log(`[ROSTER] Defender ${index} updated: ${defender.displayName} (${defender.overall})`);
                        } catch (e) {
                            console.error(`[ROSTER] Error updating defender ${index}:`, e);
                        }
                    }
                });
            }

            // Update O-Line
            managementState.team.depthChart.OL.forEach((playerId, index) => {
                const player = managementState.team.roster.find(p => p.id === playerId);
                const oLineman = gameState.offensiveLine[index];
                if (player && oLineman) {
                    try {
                        oLineman.playerId = player.id;
                        oLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                        oLineman.stats = { ...player.stats };
                        oLineman.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                        console.log(`[ROSTER] O-Line ${index} updated: ${oLineman.displayName}`);
                    } catch (e) {
                        console.error(`[ROSTER] Error updating O-Line ${index}:`, e);
                    }
                }
            });

            // Update D-Line from opponent's roster
            if (opponent && opponent.roster) {
                const oppDL = opponent.roster
                    .filter(p => p.position === 'DL')
                    .sort((a, b) => b.overall - a.overall);

                gameState.defensiveLine.forEach((dLineman, index) => {
                    const player = oppDL[index];
                    if (player && dLineman) {
                        try {
                            dLineman.playerId = player.id;
                            dLineman.displayName = `${player.firstName} ${player.lastName.charAt(0)}.`;
                            dLineman.stats = { ...player.stats };
                            dLineman.coreAttributes = player.coreAttributes ? { ...player.coreAttributes } : null;
                            console.log(`[ROSTER] D-Line ${index} updated: ${dLineman.displayName}`);
                        } catch (e) {
                            console.error(`[ROSTER] Error updating D-Line ${index}:`, e);
                        }
                    }
                });
            }
        }
        console.log('[DEBUG] updateGamePlayersFromRoster defined');

        // Called when a drive/possession ends in the arcade game
        function onPossessionComplete(points) {
            if (!managementState.matchInProgress) return;

            const result = recordPossessionResult(points);

            // Handle case where recordPossessionResult returns undefined
            if (!result) {
                console.error('recordPossessionResult returned undefined');
                gameState.waitingForPossession = false;
                resetPlay(gameState.scene);
                return;
            }

            if (!result.ongoing) {
                showMatchEnd(result);
            } else {
                // Show enemy drive result between possessions
                showEnemyDriveResult(result);
            }
        }

        // Helper to create catch probability bar HTML
        // Shows QB roll vs catch window - lower roll is better (exponential distribution)
        function createCatchBarHTML(catchInfo, small = false) {
            if (!catchInfo) return '';

            const barWidth = small ? 80 : 100;
            const barHeight = small ? 10 : 14;
            const fontSize = small ? 10 : 12;

            const success = catchInfo.catchSuccess;
            const catchWindow = catchInfo.catchProb;
            // Scale the roll position: catchProb is the threshold, show roll relative to it
            // Bar shows 0-100 scale where catchWindow% is the "safe zone"
            const rollPosition = Math.min(100, (catchInfo.qbRoll / Math.max(1, catchWindow)) * catchWindow);

            return `
                <div style="display: inline-flex; align-items: center; gap: 6px; font-family: 'Courier New', monospace; font-size: ${fontSize}px;">
                    <span style="color: ${success ? '#4f4' : '#f66'}; font-weight: bold;">${success ? 'CATCH!' : 'INCOMPLETE'}</span>
                    <div style="position: relative; width: ${barWidth}px; height: ${barHeight}px; background: #222; border-radius: 2px; overflow: visible;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${catchWindow}%; background: linear-gradient(90deg, #3a3, #4b4); border-radius: 2px;"></div>
                        <div style="position: absolute; top: -1px; left: ${Math.min(98, rollPosition)}%; transform: translateX(-50%); font-size: ${fontSize}px; font-weight: bold; text-shadow: 0 0 2px #000; color: ${success ? '#4f4' : '#f44'}; line-height: ${barHeight}px;">${success ? '‚úì' : '‚úó'}</div>
                    </div>
                    <span style="color: #888; font-size: ${fontSize - 1}px;">${catchInfo.effectiveCatchPct}%</span>
                </div>
            `;
        }

        // Helper to create pressure bar HTML
        function createPressureBarHTML(pressureInfo) {
            if (!pressureInfo) return '';

            const pressure = pressureInfo.totalPressure;
            const level = pressureInfo.pressureLevel;
            const colors = {
                'light': '#4a4',
                'moderate': '#aa4',
                'heavy': '#f84',
                'extreme': '#f44'
            };
            const color = colors[level] || '#888';

            return `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                    <span style="color: #888; font-size: 11px; width: 60px;">PRESSURE</span>
                    <div style="position: relative; width: 80px; height: 8px; background: #222; border-radius: 2px;">
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${pressure}%; background: ${color}; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                    <span style="color: ${color}; font-size: 10px; text-transform: uppercase;">${level}</span>
                </div>
            `;
        }

        // Show enemy drive result overlay with detailed simulation info
        function showEnemyDriveResult(result) {
            const game = managementState.season.schedule[managementState.season.week - 1];
            const plays = result.enemyResult.plays || []; // Array of detailed play objects
            const delayPerPlay = plays.length > 0 ? 1200 : 500; // Time between plays

            console.log('showEnemyDriveResult - plays count:', plays.length);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'enemyDriveOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                font-family: 'Courier New', monospace;
            `;

            const pointsColor = result.enemyResult.points > 0 ? '#f44' : '#4f4';
            const pointsText = result.enemyResult.points > 0
                ? `+${result.enemyResult.points} points`
                : 'Defensive Stop!';

            overlay.innerHTML = `
                <div style="background: #1a1a2e; border: 2px solid #333; border-radius: 12px; padding: 20px; max-width: 700px; width: 95%; text-align: center; max-height: 90vh; display: flex; flex-direction: column;">
                    <h2 style="color: #888; margin: 0 0 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; flex-shrink: 0;">
                        ${game.opponent.name} Possession
                    </h2>
                    <div id="playsScrollContainer" style="flex: 1; overflow-y: auto; min-height: 200px; max-height: 400px; padding: 8px; background: #151528; border-radius: 8px; margin-bottom: 12px;">
                        <div id="playsContainer" style="text-align: left;">
                        </div>
                    </div>
                    <div id="driveResult" style="display: none; flex-shrink: 0;">
                        <div style="color: ${pointsColor}; font-size: 24px; font-weight: bold; margin-bottom: 12px;">
                            ${pointsText}
                        </div>
                        <div style="color: #aaa; margin-bottom: 12px;">
                            <span style="color: #4af;">You: ${result.score.player}</span>
                            &nbsp;-&nbsp;
                            <span style="color: #f44;">${game.opponent.name}: ${result.score.opponent}</span>
                        </div>
                        <div style="color: #666; margin-bottom: 12px; font-size: 12px;">
                            ${getGamePhaseDisplay(result)}
                        </div>
                        ${result.message ? `<div style="color: #fa4; margin-bottom: 12px; font-size: 14px; font-weight: bold;">${result.message}</div>` : ''}
                        <button id="btnContinueDrive" style="
                            background: #4a4; color: white; border: none;
                            padding: 12px 30px; border-radius: 6px; cursor: pointer;
                            font-size: 16px; transition: background 0.2s;
                        ">Continue</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            const playsContainer = document.getElementById('playsContainer');
            const scrollContainer = document.getElementById('playsScrollContainer');
            let playIndex = 0;

            // Format a detailed play display
            const formatPlayDetails = (play, playNum) => {
                if (!play) return '<div style="color: #ccc;">Loading...</div>';

                const opponent = result.enemyResult.opponent || game.opponent;
                const teamShort = (opponent?.name || 'Enemy').split(' ')[0];
                const qbName = play.qb ? getPlayerFullName(play.qb) : `${teamShort} QB`;

                // Determine border color based on play result
                const borderColor = play.type === 'sack' ? '#4f4' :
                                   play.type === 'interception' ? '#4f4' :
                                   play.type === 'incomplete' ? '#4af' :
                                   play.type === 'touchdown' ? '#f44' :
                                   play.type === 'complete' ? '#fa4' : '#555';

                let html = `<div style="background: #202038; border-radius: 6px; padding: 10px; margin-bottom: 8px; border-left: 4px solid ${borderColor};">`;

                // Play number and down/distance header - improved contrast
                const downStr = getDownString(play.down);
                const fieldPos = 100 - play.yardsFromGoal;
                const fieldPosStr = fieldPos > 50 ? `OPP ${100 - fieldPos}` : `OWN ${fieldPos}`;
                html += `<div style="color: #ddd; font-size: 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <span><span style="color: #888;">Play ${playNum}:</span> <span style="color: #fff; font-weight: bold;">${downStr} & ${play.yardsToGo}</span></span>
                    <span style="color: #aaa; background: #333; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${fieldPosStr}</span>
                </div>`;

                // Round events timeline (compact format)
                if (play.roundEvents && play.roundEvents.length > 0) {
                    html += `<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; font-size: 10px;">`;
                    play.roundEvents.forEach(re => {
                        re.events.forEach(ev => {
                            let badge = '';
                            if (ev.type === 'pressure') {
                                const pColor = ev.result === 'beaten badly' ? '#f44' : ev.result === 'beaten' ? '#f84' : '#fa4';
                                badge = `<span style="background: ${pColor}22; color: ${pColor}; padding: 2px 5px; border-radius: 3px; border: 1px solid ${pColor}44;">R${re.round} ‚ö°${ev.player} ${ev.result}</span>`;
                            } else if (ev.type === 'route_break') {
                                badge = `<span style="background: #4af22; color: #4af; padding: 2px 5px; border-radius: 3px; border: 1px solid #4af44;">R${re.round} WR${ev.wr} +${ev.momentum} sep</span>`;
                            } else if (ev.type === 'sack') {
                                badge = `<span style="background: #4f422; color: #4f4; padding: 2px 5px; border-radius: 3px; border: 1px solid #4f444; font-weight: bold;">R${re.round} SACK!</span>`;
                            } else if (ev.type === 'throw') {
                                const throwColor = ev.catchProb > 70 ? '#4f4' : ev.catchProb > 40 ? '#fa4' : '#f44';
                                badge = `<span style="background: ${throwColor}22; color: ${throwColor}; padding: 2px 5px; border-radius: 3px; border: 1px solid ${throwColor}44;">R${re.round} ‚Üí WR${ev.target} (${ev.catchProb}%)</span>`;
                            }
                            html += badge;
                        });
                    });
                    html += `</div>`;
                }

                if (play.type === 'sack') {
                    // Sack play
                    const dlName = play.sackingPlayer ? getPlayerFullName(play.sackingPlayer) : 'Your DL';
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #203a2a; border-radius: 4px;">`;
                    html += `<div style="color: #44ff44; font-size: 14px; font-weight: bold;">üî• SACK! ${dlName} breaks through!</div>`;
                    html += `<div style="color: #aaa; font-size: 11px; margin-top: 4px;">${qbName} taken down for <span style="color: #44ff44; font-weight: bold;">${Math.abs(play.yardsGained)} yard loss</span></div>`;

                    // DL matchup details - collapsible
                    if (play.pressureInfo?.matchups) {
                        html += `<details style="margin-top: 6px;">`;
                        html += `<summary style="color: #888; cursor: pointer; font-size: 10px;">View line matchups</summary>`;
                        html += `<div style="margin-top: 4px; padding: 6px; background: #1e1e35; border-radius: 4px; font-size: 10px;">`;
                        play.pressureInfo.matchups.slice(0, 3).forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#ff4444' : m.result === 'beaten' ? '#ff8844' : m.result === 'pressured' ? '#ffaa44' : '#44aa44';
                            html += `<div style="display: flex; justify-content: space-between; color: #ccc; margin: 2px 0; padding: 2px 4px; background: #252545; border-radius: 2px;">
                                <span style="color: #44aaff;">${getPlayerFullName(m.dl)}</span>
                                <span><span style="color: #44aaff;">${m.dlRoll}</span> vs <span style="color: #ff9944;">${m.olRoll}</span> ‚Üí <span style="color: ${resultColor}; font-weight: bold;">${m.result}</span></span>
                            </div>`;
                        });
                        html += `</div></details>`;
                    }
                    html += `</div>`;
                } else if (play.fieldGoalAttempt) {
                    // Field goal attempt
                    const distance = play.yardsFromGoal + 17;
                    const successColor = play.fieldGoalSuccess ? '#44ff44' : '#ff4444';
                    const emoji = play.fieldGoalSuccess ? '‚úì' : '‚úó';
                    html += `<div style="margin-top: 8px; padding: 8px; background: ${play.fieldGoalSuccess ? '#3a2a20' : '#203a2a'}; border-radius: 4px;">`;
                    html += `<div style="color: ${successColor}; font-size: 14px; font-weight: bold;">${emoji} Field Goal ${play.fieldGoalSuccess ? 'GOOD' : 'MISSED'} from ${distance} yards!</div>`;
                    html += `</div>`;
                } else if (play.type === 'scramble') {
                    // QB scramble
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #3a3a20; border-radius: 4px;">`;
                    html += `<div style="color: #ffaa44; font-size: 13px; font-weight: bold;">üèÉ QB Scramble!</div>`;
                    html += `<div style="color: #ccc; font-size: 11px; margin-top: 4px;">${qbName} takes off for <span style="color: #ffaa44; font-weight: bold;">${play.yardsGained} yards</span></div>`;
                    html += `</div>`;
                } else if (play.type === 'throwaway') {
                    // Throwaway
                    html += createPressureBarHTML(play.pressureInfo);
                    html += `<div style="margin-top: 8px; padding: 8px; background: #252540; border-radius: 4px;">`;
                    html += `<div style="color: #aaa; font-size: 13px;">üì§ Throwaway</div>`;
                    html += `<div style="color: #888; font-size: 11px; margin-top: 4px;">${qbName} throws it away under pressure</div>`;
                    html += `</div>`;
                } else if (play.type === 'interception') {
                    // Interception
                    html += createPressureBarHTML(play.pressureInfo);
                    const interceptedBy = play.interceptedBy ? getPlayerFullName(play.interceptedBy) : 'Your DB';
                    html += `<div style="margin-top: 8px; padding: 8px; background: #203a2a; border-radius: 4px;">`;
                    html += `<div style="color: #44ff44; font-size: 14px; font-weight: bold;">üéØ INTERCEPTION!</div>`;
                    html += `<div style="color: #aaa; font-size: 11px; margin-top: 4px;">Picked off by <span style="color: #44aaff; font-weight: bold;">${interceptedBy}</span>!</div>`;
                    html += `</div>`;
                } else {
                    // Pass play (complete/incomplete)
                    const catchInfo = play.catchInfo;
                    const wrName = catchInfo?.receiver ? getPlayerFullName(catchInfo.receiver) : `${teamShort} WR`;
                    const cbName = catchInfo?.cb ? getPlayerFullName(catchInfo.cb) : 'Your CB';

                    // Pressure bar
                    html += createPressureBarHTML(play.pressureInfo);

                    // Target info - improved contrast
                    html += `<div style="margin: 8px 0; font-size: 12px; padding: 6px; background: #282848; border-radius: 4px;">`;
                    html += `<span style="color: #bbb;">Target:</span> <span style="color: #ff9944; font-weight: bold;">${wrName}</span>`;
                    if (play.targetSlot) html += ` <span style="color: #888;">(${play.targetSlot})</span>`;
                    html += ` <span style="color: #bbb;">vs</span> <span style="color: #44aaff; font-weight: bold;">${cbName}</span>`;
                    html += `</div>`;

                    // Show line matchups in compact format
                    if (play.pressureInfo?.matchups && play.pressureInfo.matchups.length > 0) {
                        html += `<details style="margin-top: 6px; background: #1e1e35; border-radius: 4px; padding: 6px;">`;
                        html += `<summary style="color: #aaa; cursor: pointer; font-size: 11px; user-select: none;">üìä Line Clashes (Pressure: <span style="color: #fff;">${play.pressureInfo.totalPressure}</span>)</summary>`;
                        html += `<div style="margin-top: 6px; font-size: 10px;">`;
                        play.pressureInfo.matchups.forEach(m => {
                            const resultColor = m.result === 'beaten badly' ? '#f44' : m.result === 'beaten' ? '#f84' : m.result === 'pressured' ? '#fa4' : m.result === 'held' ? '#aa4' : '#4a4';
                            html += `<div style="display: flex; justify-content: space-between; color: #ccc; margin: 2px 0; padding: 2px 4px; background: #252545; border-radius: 2px;">
                                <span style="color: #44aaff;">${getPlayerFullName(m.dl)}</span>
                                <span><span style="color: #44aaff;">${m.dlRoll}</span> vs <span style="color: #ff9944;">${m.olRoll}</span> ‚Üí <span style="color: ${resultColor}; font-weight: bold;">${m.result}</span></span>
                            </div>`;
                        });
                        html += `</div></details>`;
                    }

                    if (catchInfo) {
                        // Matchup details box - improved contrast
                        html += `<div style="background: #1e1e35; border-radius: 4px; padding: 8px; margin: 8px 0; font-size: 11px;">`;
                        html += `<div style="color: #aaa; font-size: 10px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">Coverage Matchup</div>`;

                        // WR vs CB separation roll - clearer layout
                        const sepColor = catchInfo.separationMargin > 5 ? '#44ff44' : catchInfo.separationMargin < -5 ? '#ff4444' : '#ffaa44';
                        const sepLabel = catchInfo.coverageCloseness < 0.2 ? 'OPEN' :
                                        catchInfo.coverageCloseness < 0.4 ? 'SPACE' :
                                        catchInfo.coverageCloseness < 0.6 ? 'CONTESTED' :
                                        catchInfo.coverageCloseness < 0.8 ? 'TIGHT' : 'SMOTHERED';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">Separation</span>
                            <span>WR <span style="color: #ff9944; font-weight: bold;">${catchInfo.wrRoll}</span> vs CB <span style="color: #44aaff; font-weight: bold;">${catchInfo.cbRoll}</span> ‚Üí <span style="color: ${sepColor}; font-weight: bold;">${sepLabel}</span></span>
                        </div>`;

                        // Momentum advantage display (if route had direction change)
                        if (catchInfo.momentumAdvantage && catchInfo.momentumAdvantage > 0) {
                            const momColor = catchInfo.momentumAdvantage >= 15 ? '#44ff44' :
                                           catchInfo.momentumAdvantage >= 8 ? '#88ff44' : '#ffaa44';
                            const reactionLabel = catchInfo.dbReactionDelay >= 2 ? 'SLOW' :
                                                 catchInfo.dbReactionDelay >= 1 ? 'delayed' : 'quick';
                            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                                <span style="color: #ccc;">Route Break (AWR ${catchInfo.dbAwareness})</span>
                                <span style="color: ${momColor}; font-weight: bold;">+${catchInfo.momentumAdvantage} <span style="color: #888; font-weight: normal;">(${reactionLabel})</span></span>
                            </div>`;
                        }

                        // Coverage penalty
                        const penaltyColor = catchInfo.defenderPenalty > 20 ? '#ff4444' : catchInfo.defenderPenalty > 10 ? '#ffaa44' : '#44ff44';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">CB Penalty</span>
                            <span style="color: ${penaltyColor}; font-weight: bold;">-${catchInfo.defenderPenalty}</span>
                        </div>`;

                        // Catch window
                        const focusStr = catchInfo.focusMod > 0 ? `+${catchInfo.focusMod}` : '';
                        const catchColor = catchInfo.catchProb > 70 ? '#44ff44' : catchInfo.catchProb > 40 ? '#ffaa44' : '#ff4444';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #303060; border-radius: 3px;">
                            <span style="color: #ddd;">Catch Window</span>
                            <span style="color: ${catchColor}; font-weight: bold; font-size: 13px;">${catchInfo.catchProb}%</span>
                        </div>`;

                        // QB throw quality - simplified display
                        const qbColor = catchInfo.catchSuccess ? '#44ff44' : '#ff4444';
                        html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #252545; border-radius: 3px;">
                            <span style="color: #ccc;">QB Roll (ACC ${catchInfo.qbAccuracy})</span>
                            <span style="color: ${qbColor}; font-weight: bold;">${catchInfo.qbRoll} ${catchInfo.catchSuccess ? '< ' + catchInfo.catchProb + ' ‚úì' : '‚â• ' + catchInfo.catchProb + ' ‚úó'}</span>
                        </div>`;

                        html += `</div>`;
                    }

                    // Result with catch bar - improved styling
                    html += `<div style="margin-top: 8px; padding: 8px; background: ${play.type === 'complete' || play.type === 'touchdown' ? '#3a2a20' : '#203a2a'}; border-radius: 4px;">`;
                    if (play.type === 'complete' || play.type === 'touchdown') {
                        if (play.type === 'touchdown' || play.isTouchdown) {
                            html += `<div style="color: #ff4444; font-size: 14px; font-weight: bold;">üèà TOUCHDOWN! ${play.yardsGained} yards!</div>`;
                        } else {
                            html += `<div style="color: #ffcc88; font-size: 12px;">${wrName} catches for <span style="color: #ff9944; font-weight: bold;">${play.yardsGained} yards</span></div>`;
                        }
                        html += `<div style="margin-top: 6px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    } else {
                        html += `<div style="color: #44ff44; font-size: 12px; font-weight: bold;">üõ°Ô∏è Pass broken up by ${cbName}!</div>`;
                        html += `<div style="margin-top: 6px;">${createCatchBarHTML(catchInfo, true)}</div>`;
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            };

            // Show plays progressively in scrolling container
            const showNextPlay = () => {
                if (playIndex < plays.length) {
                    const play = plays[playIndex];

                    // Add play to container
                    const playDiv = document.createElement('div');
                    playDiv.innerHTML = formatPlayDetails(play, playIndex + 1);
                    playDiv.style.opacity = '0';
                    playDiv.style.transition = 'opacity 0.3s';
                    playsContainer.appendChild(playDiv);

                    // Fade in and scroll to show new play
                    setTimeout(() => {
                        playDiv.style.opacity = '1';
                        scrollContainer.scrollTop = scrollContainer.scrollHeight;
                    }, 50);

                    playIndex++;
                    setTimeout(showNextPlay, delayPerPlay);
                } else {
                    // All plays shown - add final result banner
                    const resultBanner = document.createElement('div');
                    resultBanner.style.cssText = `text-align: center; padding: 15px; color: ${pointsColor}; font-size: 16px; font-weight: bold; background: #252540; border-radius: 6px; border-left: 3px solid ${pointsColor};`;
                    const driveType = result.enemyResult.type;
                    resultBanner.textContent = (driveType === 'TD' || driveType === 'touchdown') ? 'TOUCHDOWN!' :
                        (driveType === 'FG' || driveType === 'field_goal') ? 'FIELD GOAL!' :
                        (driveType === 'PUNT' || driveType === 'punt') ? 'Forced to Punt!' :
                        (driveType === 'MISSED_FG' || driveType === 'missed_fg') ? 'Field Goal Missed!' :
                        driveType === 'turnover' ? 'TURNOVER!' : 'Drive Stopped!';
                    playsContainer.appendChild(resultBanner);
                    scrollContainer.scrollTop = scrollContainer.scrollHeight;

                    setTimeout(() => {
                        document.getElementById('driveResult').style.display = 'block';
                        document.getElementById('btnContinueDrive').addEventListener('click', () => {
                            overlay.remove();
                            gameState.waitingForPossession = false;
                            resetPlay(gameState.scene);
                        });
                    }, 300);
                }
            };

            // Start showing plays after a brief pause
            setTimeout(showNextPlay, 400);
        }
        console.log('[DEBUG] All functions defined, starting Main initialization');

        // Main
        let scene;
        try {
            scene = createScene();
            console.log('[DEBUG] createScene completed');
        } catch (e) {
            console.error('[DEBUG] ERROR in createScene:', e);
            console.error('[DEBUG] Error stack:', e.stack);
        }
        setupInput(scene);
        setupIdleAnimations(scene);

        // Create bonus zones
        createBonusZones(scene);

        // Handle visibility changes (app switching) - clear stale pointer state
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // App is being hidden - clear any in-progress drag
                gameState.isDragging = false;
                gameState.activePointerId = null;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            } else {
                // App is becoming visible again - ensure clean state
                // Clear any stale pointer state that might have persisted
                gameState.isDragging = false;
                gameState.activePointerId = null;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
                // Force engine resize in case canvas dimensions changed
                engine.resize();
            }
        });

        // Initialize management system
        initializeManagement();

        // Setup HTML button handlers
        document.getElementById('btnNewGame').addEventListener('click', () => {
            startNewGame();
            // Draft screen is shown by startNewGame() via startDraft()
        });
        document.getElementById('btnContinue').addEventListener('click', () => {
            if (managementState.initialized) {
                // Go to draft if there's an active draft, otherwise go to hub
                if (draftState.active) {
                    showScreen('draft');
                } else {
                    showScreen('hub');
                }
            }
        });
        document.getElementById('btnTrainingMode').addEventListener('click', () => {
            // Show training selection screen
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            document.getElementById('trainingSelectionScreen').style.display = 'block';
        });
        document.getElementById('btnExitTraining').addEventListener('click', () => {
            exitTrainingMode();
        });

        // Training Selection Screen handlers
        document.getElementById('btnTrainingSelectionBack').addEventListener('click', () => {
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            if (managementState.initialized) {
                document.getElementById('hubScreen').style.display = 'block';
            } else {
                document.getElementById('mainMenuScreen').style.display = 'block';
            }
        });
        document.getElementById('btnSelectScrimmage').addEventListener('click', () => {
            startTrainingMode();
        });
        document.getElementById('btnSelectTPMisses').addEventListener('click', () => {
            startTargetPracticeMode('misses');
        });
        document.getElementById('btnSelectTPTimed').addEventListener('click', () => {
            startTargetPracticeMode('timed');
        });
        document.getElementById('btnExitTargetPractice').addEventListener('click', () => {
            exitTargetPracticeMode();
        });

        // Game Over popup button handlers
        document.getElementById('btnPlayAgain').addEventListener('click', () => {
            document.getElementById('gameOverPopup').style.display = 'none';
            // Preserve the current mode type when replaying
            startTargetPracticeMode(gameState.targetPracticeModeType || 'misses');
        });
        document.getElementById('btnExitGameOver').addEventListener('click', () => {
            document.getElementById('gameOverPopup').style.display = 'none';
            exitTargetPracticeMode();
        });

        // Target Practice Settings handlers
        document.getElementById('btnTargetPracticeSettings').addEventListener('click', () => {
            const panel = document.getElementById('targetPracticeSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        // Target count buttons
        document.querySelectorAll('.target-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.target-count-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                gameState.targetPracticeTargetCount = parseInt(btn.dataset.count, 10);
                if (gameState.targetPracticeMode && gameState.scene) {
                    createAllTargets(gameState.scene);
                }
            });
        });

        // Target speed buttons
        document.querySelectorAll('.target-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.target-speed-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                gameState.targetPracticeSpeedSetting = btn.dataset.speed;
                // Update existing target speeds
                const speedSettings = { slow: 0.6, normal: 1.0, fast: 1.5 };
                gameState.targetPracticeTargets.forEach(target => {
                    const baseSpeed = 0.04 * target.config.speedMult * speedSettings[gameState.targetPracticeSpeedSetting];
                    target.speed = baseSpeed;
                });
            });
        });

        // Ball speed controls for target practice
        document.getElementById('btnTPBallSpeedDown').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.max(0.5, gameState.ballSpeedMultiplier - 0.1);
            document.getElementById('tpBallSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });
        document.getElementById('btnTPBallSpeedUp').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.min(2.0, gameState.ballSpeedMultiplier + 0.1);
            document.getElementById('tpBallSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });

        // Camera sliders for target practice
        document.getElementById('tpCameraAngleSlider').addEventListener('input', (e) => {
            gameState.cameraAngle = e.target.value / 100;
            document.getElementById('tpCameraAngleValue').textContent = e.target.value + '%';
            updateTargetPracticeCamera();
        });
        document.getElementById('tpCameraOffsetSlider').addEventListener('input', (e) => {
            gameState.cameraOffset = e.target.value / 100;
            document.getElementById('tpCameraOffsetValue').textContent = e.target.value + '%';
            updateTargetPracticeCamera();
        });

        // ========================================
        // GAME MANUAL SYSTEM
        // ========================================
        const MANUAL_PAGES = [
            // Page 0: Welcome / Overview
            {
                title: "Welcome to Smashball",
                section: "basics",
                content: `
                    <h3><span class="emoji-icon">üèà</span> Welcome to Smashball</h3>
                    <p>Smashball is a <strong>medieval football management game</strong> where you build a dynasty through smart drafting, player development, and hands-on gameplay.</p>

                    <div class="highlight">
                        <strong>Your Goal:</strong> Build fame, win games, and develop your roster into a championship team.
                    </div>

                    <h4>üéÆ Two Ways to Play</h4>
                    <ul>
                        <li><strong>Offense:</strong> You control the QB ‚Äî aim and throw passes to your receivers</li>
                        <li><strong>Defense:</strong> Simulated ‚Äî watch your defense try to stop the opponent</li>
                    </ul>

                    <h4>üìñ What's in This Manual</h4>
                    <table>
                        <tr><th>Section</th><th>Topics</th></tr>
                        <tr><td>üéØ Basics</td><td>Controls, gameplay, positions</td></tr>
                        <tr><td>üìä Stats</td><td>Core attributes, abilities, technique</td></tr>
                        <tr><td>üèüÔ∏è Management</td><td>Draft, roster, season flow</td></tr>
                        <tr><td>‚öîÔ∏è Advanced</td><td>Clash mechanics, formulas</td></tr>
                    </table>
                `
            },
            // Page 1: Basic Controls
            {
                title: "Basic Controls",
                section: "basics",
                content: `
                    <h3><span class="emoji-icon">üéÆ</span> Basic Controls</h3>

                    <h4>Throwing the Ball</h4>
                    <div class="diagram">
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  1. HOLD to start the play     ‚îÇ
  ‚îÇ     (players begin moving)      ‚îÇ
  ‚îÇ                                 ‚îÇ
  ‚îÇ  2. DRAG to aim                 ‚îÇ
  ‚îÇ     ‚Üê short drag = bullet pass  ‚îÇ
  ‚îÇ     ‚Üê long drag = lob pass      ‚îÇ
  ‚îÇ                                 ‚îÇ
  ‚îÇ  3. RELEASE to throw            ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    </div>

                    <h4>Reading the Field</h4>
                    <ul>
                        <li>üü¢ <strong>Green glow</strong> = Receiver is OPEN</li>
                        <li>üü° <strong>Yellow glow</strong> = Contested coverage</li>
                        <li>üî¥ <strong>Red glow</strong> = Tightly COVERED</li>
                    </ul>

                    <div class="warning">
                        <strong>‚è±Ô∏è Don't wait too long!</strong> Your offensive line will eventually lose their blocks, and the QB will get sacked.
                    </div>

                    <h4>Throw Types</h4>
                    <table>
                        <tr><th>Drag Distance</th><th>Result</th></tr>
                        <tr><td>Short</td><td>Fast bullet pass (harder to catch)</td></tr>
                        <tr><td>Medium</td><td>Balanced throw</td></tr>
                        <tr><td>Long</td><td>High lob (more air time)</td></tr>
                    </table>
                `
            },
            // Page 2: Positions Overview
            {
                title: "Team Positions",
                section: "basics",
                content: `
                    <h3><span class="emoji-icon">üë•</span> Team Positions</h3>

                    <h4>Offense (You Control)</h4>
                    <table>
                        <tr><th>Pos</th><th>Role</th><th>Key Stats</th></tr>
                        <tr><td>üéØ QB</td><td>Throws the ball</td><td>Pass Accuracy, Intelligence</td></tr>
                        <tr><td>üèÉ WR</td><td>Catches passes</td><td>Speed, Catching, Route Running</td></tr>
                        <tr><td>üõ°Ô∏è OL</td><td>Blocks defenders</td><td>Strength, Pass Block</td></tr>
                    </table>

                    <h4>Defense (Simulated)</h4>
                    <table>
                        <tr><th>Pos</th><th>Role</th><th>Key Stats</th></tr>
                        <tr><td>üî¥ CB</td><td>Covers receivers</td><td>Speed, Agility, Awareness</td></tr>
                        <tr><td>üí™ DL</td><td>Rushes the QB</td><td>Strength, Speed, Pass Rush</td></tr>
                    </table>

                    <div class="diagram">
         THE FIELD
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
       WR        WR   WR   ‚Üê Run routes
          OL OL OL OL OL   ‚Üê Block
              QB           ‚Üê You throw
    ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
       CB        CB   CB   ‚Üê Cover WRs
          DL DL DL DL      ‚Üê Rush QB
    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                    </div>
                `
            },
            // Page 3: Player Stats Overview
            {
                title: "Understanding Stats",
                section: "stats",
                content: `
                    <h3><span class="emoji-icon">üìä</span> Understanding Player Stats</h3>

                    <p>Every player has three types of stats:</p>

                    <h4>1. Core Attributes (Rarely Change)</h4>
                    <p>Natural physical and mental traits:</p>
                    <table>
                        <tr><td style="color:#ff6b6b">üí™ STR</td><td>Strength ‚Äî Power in blocks/tackles</td></tr>
                        <tr><td style="color:#4dabf7">‚ö° SPD</td><td>Speed ‚Äî How fast they move</td></tr>
                        <tr><td style="color:#69db7c">üîÑ AGI</td><td>Agility ‚Äî Quickness, direction changes</td></tr>
                        <tr><td style="color:#ffd43b">üß† INT</td><td>Intelligence ‚Äî Reads, decisions</td></tr>
                    </table>

                    <h4>2. Abilities (Can Grow)</h4>
                    <p>Learned skills that use core attributes:</p>
                    <ul>
                        <li>DL: Bull Rush, Swim Move, Spin Move, Block Shed</li>
                        <li>OL: Anchor, Hand Fighting, Footwork, Drive Block</li>
                        <li>WR: Release Move, Route Sharpness, Contested Catch</li>
                        <li>CB: Press Coverage, Man Coverage, Zone Coverage</li>
                    </ul>

                    <h4>3. Technique Stats (Grow Most)</h4>
                    <p>Position-specific skills like Catching, Pass Rush, Route Running.</p>

                    <div class="highlight">
                        <strong>üí° Key Insight:</strong> Abilities combine your stored skill with core attributes. A player with high Bull Rush ability maximizes their STR+SPD contribution.
                    </div>
                `
            },
            // Page 4: How Abilities Work
            {
                title: "How Abilities Work",
                section: "stats",
                content: `
                    <h3><span class="emoji-icon">‚öîÔ∏è</span> How Abilities Work</h3>

                    <p>Abilities are <strong>stored skills</strong> that determine how effectively a player uses their core attributes.</p>

                    <h4>The Formula (Simplified)</h4>
                    <div class="diagram">
  Effective Ability = Stored Skill √ó (Core Stats √∑ 100)

  Example: Bull Rush uses STR + SPD
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Player A: 90 Bull Rush, 70 STR, 70 SPD ‚îÇ
  ‚îÇ ‚Üí 90 √ó 0.70 = 63 effective             ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ Player B: 60 Bull Rush, 70 STR, 70 SPD ‚îÇ
  ‚îÇ ‚Üí 60 √ó 0.70 = 42 effective             ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    </div>

                    <h4>What This Means</h4>
                    <ul>
                        <li>High ability = maximize your core stat potential</li>
                        <li>Low ability = waste your physical gifts</li>
                        <li>Both matter ‚Äî you need skill AND athleticism</li>
                    </ul>

                    <h4>DL Ability ‚Üí Core Stat Mapping</h4>
                    <table>
                        <tr><th>Ability</th><th>Core Stats Used</th></tr>
                        <tr><td>üêÇ Bull Rush</td><td>STR + SPD</td></tr>
                        <tr><td>üåä Swim Move</td><td>STR + INT</td></tr>
                        <tr><td>üîÑ Spin Move</td><td>AGI + STR</td></tr>
                        <tr><td>üí• Block Shed</td><td>STR + AGI</td></tr>
                    </table>
                `
            },
            // Page 5: The Line Battle
            {
                title: "The Line Battle",
                section: "gameplay",
                content: `
                    <h3><span class="emoji-icon">üí•</span> The Line Battle</h3>

                    <p>Every play features a battle between your OL and enemy DL. This determines how much time your QB has to throw.</p>

                    <div class="diagram">
       DL ‚Üê‚îÄ‚îÄclash‚îÄ‚îÄ‚Üí OL
       DL ‚Üê‚îÄ‚îÄclash‚îÄ‚îÄ‚Üí OL
       DL ‚Üê‚îÄ‚îÄclash‚îÄ‚îÄ‚Üí OL
       DL ‚Üê‚îÄ‚îÄclash‚îÄ‚îÄ‚Üí OL
             ‚Üì
         Pressure on QB
                    </div>

                    <h4>How Clashes Work</h4>
                    <ol>
                        <li><strong>DL picks an ability</strong> (Bull Rush, Swim Move, etc.)</li>
                        <li><strong>OL reacts</strong> with a counter ability</li>
                        <li><strong>Both roll</strong> based on stats + some randomness</li>
                        <li><strong>Winner</strong> gains advantage</li>
                    </ol>

                    <h4>Clash Outcomes</h4>
                    <table>
                        <tr><th>Result</th><th>Effect</th></tr>
                        <tr><td style="color:#4f4">OL Wins Big</td><td>DL knocked down</td></tr>
                        <tr><td style="color:#aa4">Neutral</td><td>DL slowed to crawl</td></tr>
                        <tr><td style="color:#f44">DL Wins Big</td><td>OL knocked aside, DL bursts through</td></tr>
                    </table>

                    <div class="warning">
                        <strong>Clashes repeat every 0.5 seconds</strong> while linemen are engaged. Even a great OL will eventually lose!
                    </div>
                `
            },
            // Page 6: Coverage & Catching
            {
                title: "Coverage & Catching",
                section: "gameplay",
                content: `
                    <h3><span class="emoji-icon">üéØ</span> Coverage & Catching</h3>

                    <h4>Reading Coverage</h4>
                    <p>Watch the colored glow around receivers:</p>
                    <div class="diagram">
  üü¢ OPEN (70%+ catch)
     CB is beaten, throw with confidence!

  üü° CONTESTED (40-70% catch)
     Could go either way ‚Äî risky throw

  üî¥ COVERED (<40% catch)
     CB has position ‚Äî high INT risk!
                    </div>

                    <h4>What Affects Catch Probability</h4>
                    <ul>
                        <li><strong>Separation</strong> ‚Äî WR speed vs CB coverage</li>
                        <li><strong>WR Catching stat</strong> ‚Äî Hands and focus</li>
                        <li><strong>Throw accuracy</strong> ‚Äî Based on your aim</li>
                        <li><strong>Pressure</strong> ‚Äî Rushed throws are less accurate</li>
                    </ul>

                    <h4>WR vs CB Abilities</h4>
                    <table>
                        <tr><th>WR Uses</th><th>Good Against</th><th>Weak Against</th></tr>
                        <tr><td>Release Move</td><td>Man Coverage</td><td>Press Coverage</td></tr>
                        <tr><td>Route Sharpness</td><td>Zone Coverage</td><td>Man Coverage</td></tr>
                    </table>

                    <div class="highlight">
                        <strong>üí° Tip:</strong> If a WR starts covered but has good Route Sharpness, they may get open on their break. Be patient!
                    </div>
                `
            },
            // Page 7: Season & Management
            {
                title: "Season Flow",
                section: "management",
                content: `
                    <h3><span class="emoji-icon">üìÖ</span> Season Flow</h3>

                    <h4>Season Structure</h4>
                    <div class="diagram">
  WEEK 1-16: Regular Season
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Each week:               ‚îÇ
  ‚îÇ ‚Ä¢ Play your game         ‚îÇ
  ‚îÇ ‚Ä¢ Players develop        ‚îÇ
  ‚îÇ ‚Ä¢ Manage roster          ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚Üì
  OFFSEASON
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ ‚Ä¢ Players age (+1 year)  ‚îÇ
  ‚îÇ ‚Ä¢ Draft new players      ‚îÇ
  ‚îÇ ‚Ä¢ Sign free agents       ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    </div>

                    <h4>Weekly Player Development</h4>
                    <p>After each game, players may improve:</p>
                    <ul>
                        <li><strong>Young players</strong> (pre-peak) ‚Äî Can grow all stats</li>
                        <li><strong>Peak players</strong> ‚Äî Stats stabilize</li>
                        <li><strong>Aging players</strong> ‚Äî Stats decline, especially physical</li>
                    </ul>

                    <h4>The Potential System</h4>
                    <table>
                        <tr><th>Grade</th><th>Growth Rate</th></tr>
                        <tr><td>‚≠ê‚≠ê‚≠ê</td><td>High ‚Äî Frequent, large improvements</td></tr>
                        <tr><td>‚≠ê‚≠ê</td><td>Medium ‚Äî Steady growth</td></tr>
                        <tr><td>‚≠ê</td><td>Low ‚Äî Rare, small improvements</td></tr>
                    </table>
                `
            },
            // Page 8: The Draft
            {
                title: "The Draft",
                section: "management",
                content: `
                    <h3><span class="emoji-icon">üìã</span> The Draft</h3>

                    <p>The draft is your main source of talent. You compete with AI teams for the best rookies.</p>

                    <h4>Draft Order</h4>
                    <div class="diagram">
  Pick order based on previous season:

  Worst record  ‚Üí Pick 1st  (best players)
  Best record   ‚Üí Pick last (leftovers)

  3 Rounds √ó 8 teams = 24 picks per round
                    </div>

                    <h4>Draft Point System</h4>
                    <p>Each pick costs Fame (draft points). You can:</p>
                    <ul>
                        <li><strong>Use your pick</strong> ‚Äî Select a player</li>
                        <li><strong>Trade down</strong> ‚Äî Skip pick, gain bonus points</li>
                        <li><strong>Trade up</strong> ‚Äî Spend points to pick earlier</li>
                    </ul>

                    <h4>Scouting Tips</h4>
                    <div class="highlight">
                        <strong>Look for:</strong>
                        <ul>
                            <li>High potential (‚≠ê‚≠ê‚≠ê) on young players</li>
                            <li>Core stats that match position needs</li>
                            <li>Age 21-23 for maximum development time</li>
                        </ul>
                    </div>
                `
            },
            // Page 9: Fame System
            {
                title: "Fame & Economy",
                section: "management",
                content: `
                    <h3><span class="emoji-icon">‚≠ê</span> Fame & Economy</h3>

                    <p><strong>Fame</strong> is your currency for everything ‚Äî drafting, signing free agents, and building facilities.</p>

                    <h4>Earning Fame</h4>
                    <table>
                        <tr><th>Action</th><th>Fame Earned</th></tr>
                        <tr><td>Win a game</td><td>Base + bonus for margin</td></tr>
                        <tr><td>Score touchdowns</td><td>Per TD scored</td></tr>
                        <tr><td>Big plays</td><td>Long catches, sacks, INTs</td></tr>
                        <tr><td>Season wins</td><td>End of season bonus</td></tr>
                    </table>

                    <h4>Spending Fame</h4>
                    <ul>
                        <li><strong>Draft picks</strong> ‚Äî Earlier picks cost more</li>
                        <li><strong>Free agents</strong> ‚Äî Better players cost more</li>
                        <li><strong>Facilities</strong> ‚Äî Training bonuses (coming soon)</li>
                    </ul>

                    <div class="warning">
                        <strong>Budget carefully!</strong> If you spend all your fame on one star player, you won't have depth to field a full team.
                    </div>
                `
            },
            // Page 10: Advanced - Clash Calculations
            {
                title: "Clash Calculations",
                section: "advanced",
                content: `
                    <h3><span class="emoji-icon">üî¢</span> Clash Calculations</h3>

                    <p>For those who want to understand the math behind clashes:</p>

                    <h4>Roll Components</h4>
                    <div class="diagram">
  Total Roll = (Technique √ó 0.4) + (Core√óAbility √ó 0.6)
             √ó Variance (0.8 to 1.2)
             √ó Matchup Multiplier
                    </div>

                    <h4>Technique Roll (40%)</h4>
                    <p>Weighted average of position technique stats:</p>
                    <ul>
                        <li>OL: Pass Block, Balance, Awareness</li>
                        <li>DL: Pass Rush, Tackling, Pursuit</li>
                    </ul>

                    <h4>Core√óAbility Roll (60%)</h4>
                    <div class="diagram">
  (CoreStatAvg √∑ 100) √ó (EffectiveAbility √∑ 100) √ó 60

  Example: 80 core avg, 70 effective ability
  ‚Üí (0.80) √ó (0.70) √ó 60 = 33.6 points
                    </div>

                    <h4>Matchup Multipliers</h4>
                    <table>
                        <tr><th>DL Move</th><th>vs Anchor</th><th>vs Footwork</th></tr>
                        <tr><td>Bull Rush</td><td>0.85 ‚ùå</td><td>1.15 ‚úì</td></tr>
                        <tr><td>Spin Move</td><td>1.20 ‚úì</td><td>0.85 ‚ùå</td></tr>
                        <tr><td>Swim Move</td><td>1.15 ‚úì</td><td>0.95</td></tr>
                    </table>
                `
            },
            // Page 11: Advanced - Ability Selection
            {
                title: "Ability Selection AI",
                section: "advanced",
                content: `
                    <h3><span class="emoji-icon">üß†</span> Ability Selection AI</h3>

                    <h4>The 60/30/10 Rule</h4>
                    <p>When a player picks an ability:</p>
                    <div class="diagram">
  Sort abilities by effective value:

  60% chance ‚Üí Use BEST ability
  30% chance ‚Üí Use 2nd best ability
  10% chance ‚Üí Use 3rd best ability
                    </div>

                    <h4>Counter Selection</h4>
                    <p>The reacting player (OL defending vs DL) can counter:</p>
                    <ul>
                        <li><strong>Counter chance</strong> = (Intelligence - 20)%</li>
                        <li>If counter triggers, picks optimal counter ability</li>
                        <li>If not, uses 60/30/10 rule instead</li>
                    </ul>

                    <div class="highlight">
                        <strong>Example:</strong> OL with 70 INT has 50% chance to read the DL's move and pick the perfect counter. Otherwise, they guess.
                    </div>

                    <h4>Why This Matters</h4>
                    <p>High INT players:</p>
                    <ul>
                        <li>More consistently counter opponent moves</li>
                        <li>Less likely to get caught by bad matchups</li>
                        <li>Make better use of their ability toolkit</li>
                    </ul>
                `
            },
            // Page 12: Tips & Strategy
            {
                title: "Tips & Strategy",
                section: "advanced",
                content: `
                    <h3><span class="emoji-icon">üí°</span> Tips & Strategy</h3>

                    <h4>Offensive Tips</h4>
                    <ul>
                        <li>üéØ <strong>Don't force throws</strong> ‚Äî Take the open man</li>
                        <li>‚è±Ô∏è <strong>Quick reads</strong> ‚Äî Your line won't hold forever</li>
                        <li>üèÉ <strong>Speed kills</strong> ‚Äî Fast WRs create separation</li>
                        <li>üìê <strong>Lead your receiver</strong> ‚Äî Aim where they're going</li>
                    </ul>

                    <h4>Draft Strategy</h4>
                    <ul>
                        <li>‚≠ê <strong>Potential > Overall</strong> for young players</li>
                        <li>üí™ <strong>Core stats matter</strong> ‚Äî They rarely improve</li>
                        <li>üîÑ <strong>Balance your roster</strong> ‚Äî Stars need support</li>
                        <li>üìâ <strong>Trade down</strong> if top prospects are gone</li>
                    </ul>

                    <h4>Roster Building</h4>
                    <div class="highlight">
                        <strong>Priority order:</strong>
                        <ol>
                            <li>Elite WR or CB (game-changers)</li>
                            <li>Solid OL (protects your QB)</li>
                            <li>Fast DL (disrupts opponent)</li>
                            <li>Depth at every position</li>
                        </ol>
                    </div>

                    <h4>Long-term Thinking</h4>
                    <p>Build for sustained success:</p>
                    <ul>
                        <li>Mix veterans (win now) with prospects (future)</li>
                        <li>Watch player ages ‚Äî 30+ year olds decline fast</li>
                        <li>Don't overspend on aging stars</li>
                    </ul>
                `
            }
        ];

        // Manual state
        let manualCurrentPage = 0;
        let manualShowingIndex = false;

        function showManual() {
            document.getElementById('manualOverlay').style.display = 'flex';
            manualCurrentPage = 0;
            manualShowingIndex = false;
            renderManualPage();
        }

        function hideManual() {
            document.getElementById('manualOverlay').style.display = 'none';
        }

        function renderManualPage() {
            const page = MANUAL_PAGES[manualCurrentPage];
            document.getElementById('manualTitle').textContent = page.title;
            document.getElementById('manualContent').innerHTML = page.content;
            document.getElementById('manualPageNum').textContent = `${manualCurrentPage + 1} / ${MANUAL_PAGES.length}`;

            // Update nav buttons
            document.getElementById('btnManualPrev').disabled = manualCurrentPage === 0;
            document.getElementById('btnManualNext').disabled = manualCurrentPage === MANUAL_PAGES.length - 1;

            // Show content, hide index
            document.getElementById('manualContent').style.display = 'block';
            document.getElementById('manualIndex').style.display = 'none';
            manualShowingIndex = false;
            document.getElementById('btnManualIndex').textContent = 'üìñ Index';
        }

        function renderManualIndex() {
            const sections = {
                basics: { title: 'üéØ Basics', pages: [] },
                stats: { title: 'üìä Stats & Abilities', pages: [] },
                gameplay: { title: 'üèà Gameplay', pages: [] },
                management: { title: 'üèüÔ∏è Management', pages: [] },
                advanced: { title: '‚öîÔ∏è Advanced', pages: [] }
            };

            MANUAL_PAGES.forEach((page, idx) => {
                if (sections[page.section]) {
                    sections[page.section].pages.push({ title: page.title, idx });
                }
            });

            let html = '<h3>üìñ Manual Index</h3>';
            for (const [key, section] of Object.entries(sections)) {
                if (section.pages.length > 0) {
                    html += `<div class="manual-index-section">`;
                    html += `<h4>${section.title}</h4>`;
                    section.pages.forEach(p => {
                        html += `<button class="manual-index-item" data-page="${p.idx}">${p.title} <span>Page ${p.idx + 1}</span></button>`;
                    });
                    html += `</div>`;
                }
            }

            document.getElementById('manualIndex').innerHTML = html;

            // Add click handlers
            document.querySelectorAll('.manual-index-item').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    manualCurrentPage = parseInt(e.currentTarget.dataset.page);
                    renderManualPage();
                });
            });
        }

        function toggleManualIndex() {
            manualShowingIndex = !manualShowingIndex;
            if (manualShowingIndex) {
                renderManualIndex();
                document.getElementById('manualContent').style.display = 'none';
                document.getElementById('manualIndex').style.display = 'block';
                document.getElementById('btnManualIndex').textContent = '‚Üê Back';
            } else {
                document.getElementById('manualContent').style.display = 'block';
                document.getElementById('manualIndex').style.display = 'none';
                document.getElementById('btnManualIndex').textContent = 'üìñ Index';
            }
        }

        // Manual event listeners
        document.getElementById('btnHowToPlay').addEventListener('click', showManual);
        document.getElementById('btnHubManual').addEventListener('click', showManual);
        document.getElementById('btnManualClose').addEventListener('click', hideManual);
        document.getElementById('btnManualPrev').addEventListener('click', () => {
            if (manualCurrentPage > 0) {
                manualCurrentPage--;
                renderManualPage();
            }
        });
        document.getElementById('btnManualNext').addEventListener('click', () => {
            if (manualCurrentPage < MANUAL_PAGES.length - 1) {
                manualCurrentPage++;
                renderManualPage();
            }
        });
        document.getElementById('btnManualIndex').addEventListener('click', toggleManualIndex);
        // Training settings panel toggle
        document.getElementById('btnTrainingSettings').addEventListener('click', () => {
            const panel = document.getElementById('trainingSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        // Game speed controls
        document.getElementById('btnGameSpeedDown').addEventListener('click', () => {
            adjustGameSpeed(-0.1);
            document.getElementById('gameSpeedDisplay').textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        });
        document.getElementById('btnGameSpeedUp').addEventListener('click', () => {
            adjustGameSpeed(0.1);
            document.getElementById('gameSpeedDisplay').textContent = gameState.gameSpeedMultiplier.toFixed(1) + 'x';
        });
        // Ball speed controls
        document.getElementById('btnBallSpeedDown').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.max(0.5, gameState.ballSpeedMultiplier - 0.1);
            document.getElementById('ballSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });
        document.getElementById('btnBallSpeedUp').addEventListener('click', () => {
            gameState.ballSpeedMultiplier = Math.min(2.0, gameState.ballSpeedMultiplier + 0.1);
            document.getElementById('ballSpeedDisplay').textContent = gameState.ballSpeedMultiplier.toFixed(1) + 'x';
        });
        // Grade popup toggle
        document.getElementById('btnToggleGradePopup').addEventListener('click', () => {
            gameState.showGradePopup = !gameState.showGradePopup;
            const btn = document.getElementById('btnToggleGradePopup');
            btn.textContent = gameState.showGradePopup ? 'ON' : 'OFF';
            btn.style.background = gameState.showGradePopup ? '#4a4' : '#444';
        });
        document.getElementById('btnToggleClashFlash').addEventListener('click', () => {
            gameState.showClashFlash = !gameState.showClashFlash;
            const btn = document.getElementById('btnToggleClashFlash');
            btn.textContent = gameState.showClashFlash ? 'ON' : 'OFF';
            btn.style.background = gameState.showClashFlash ? '#4a4' : '#444';
        });
        // Camera angle slider
        document.getElementById('cameraAngleSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            gameState.cameraAngle = value / 100;
            document.getElementById('cameraAngleValue').textContent = value + '%';
            // Update camera beta: 0% = top-down (0.1), 100% = horizontal (PI/2)
            if (scene && scene.activeCamera) {
                scene.activeCamera.beta = 0.1 + (value / 100) * (Math.PI / 2 - 0.1);
            }
        });
        // Camera offset slider (moves camera forward, reduces space behind QB)
        document.getElementById('cameraOffsetSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            gameState.cameraOffset = value / 100;
            document.getElementById('cameraOffsetValue').textContent = value + '%';
            // Update camera target and radius immediately
            if (scene && scene.activeCamera) {
                const baseTargetZ = gameState.lineOfScrimmage + 2;
                const maxForwardOffset = 12;
                const forwardOffset = (value / 100) * maxForwardOffset;
                const cameraTargetZ = Math.max(-60, Math.min(14, baseTargetZ + forwardOffset));
                scene.activeCamera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);
                // Adjust radius to maintain consistent framing
                const baseRadius = 32;
                const radiusAdjust = (value / 100) * 8;
                scene.activeCamera.radius = baseRadius + radiusAdjust;
            }
        });
        // Player size slider
        document.getElementById('playerSizeSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const scale = value / 100;
            gameState.playerScale = scale;
            document.getElementById('playerSizeValue').textContent = scale.toFixed(1) + 'x';
            // Scale all players (receivers, defenders, linemen, QB)
            if (gameState.receivers) {
                gameState.receivers.forEach(r => r.scaling = new BABYLON.Vector3(scale, scale, scale));
            }
            if (gameState.defenders) {
                gameState.defenders.forEach(d => d.scaling = new BABYLON.Vector3(scale, scale, scale));
            }
            if (gameState.offensiveLine) {
                gameState.offensiveLine.forEach(o => o.scaling = new BABYLON.Vector3(scale, scale, scale));
            }
            if (gameState.defensiveLine) {
                gameState.defensiveLine.forEach(d => d.scaling = new BABYLON.Vector3(scale, scale, scale));
            }
            if (scene && scene.qb) {
                scene.qb.scaling = new BABYLON.Vector3(scale, scale, scale);
            }
        });
        // Ball size slider
        document.getElementById('ballSizeSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const scale = value / 100;
            gameState.ballScale = scale;
            document.getElementById('ballSizeValue').textContent = scale.toFixed(1) + 'x';
            // Scale football
            if (scene && scene.football) {
                scene.football.scaling = new BABYLON.Vector3(scale, scale, scale);
            }
        });
        // Difficulty buttons (training panel - separate from main game difficulty)
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                gameState.trainingDifficulty = btn.dataset.difficulty;
                document.querySelectorAll('.difficulty-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
            });
        });
        // Receiver speed preset buttons
        document.querySelectorAll('.rcvr-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = btn.dataset.speed;
                gameState.receiverSpeedPreset = speed === 'mixed' ? 'mixed' : parseInt(speed);
                document.querySelectorAll('.rcvr-speed-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyReceiverSpeedPreset();
            });
        });
        // DB speed preset buttons
        document.querySelectorAll('.db-speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = btn.dataset.speed;
                gameState.dbSpeedPreset = speed === 'mixed' ? 'mixed' : parseInt(speed);
                document.querySelectorAll('.db-speed-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyDbSpeedPreset();
            });
        });
        // WR awareness preset buttons (controls ball reaction time)
        document.querySelectorAll('.wr-awr-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const awareness = btn.dataset.awareness;
                gameState.receiverAwarenessPreset = awareness === 'mixed' ? 'mixed' : parseInt(awareness);
                document.querySelectorAll('.wr-awr-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyReceiverAwarenessPreset();
            });
        });
        // WR agility preset buttons (controls turn rate/route correction)
        document.querySelectorAll('.wr-agi-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const agility = btn.dataset.agility;
                gameState.receiverAgilityPreset = agility === 'mixed' ? 'mixed' : parseInt(agility);
                document.querySelectorAll('.wr-agi-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
                applyReceiverAgilityPreset();
            });
        });
        document.getElementById('btnPlayGame').addEventListener('click', () => {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) return;
            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) return;
            showPreGame(game.opponent);
        });
        document.getElementById('btnStartGame').addEventListener('click', () => {
            const result = startMatch();
            if (result.success) startArcadeGame();
        });
        document.getElementById('btnSimulateGame').addEventListener('click', () => {
            console.log('[SIMULATE] Button clicked');
            const simResult = simulateFullGame();
            console.log('[SIMULATE] Result:', simResult);
            if (simResult.success) {
                // End match to record result and get matchResult object
                const matchResult = endMatch();
                console.log('[SIMULATE] Match result:', matchResult);
                if (matchResult) {
                    showMatchEnd(matchResult);
                }
            } else {
                console.error('[SIMULATE] Failed:', simResult.error);
            }
        });
        document.getElementById('btnPreGameBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnRoster').addEventListener('click', () => showScreen('roster'));
        document.getElementById('btnFreeAgency').addEventListener('click', () => showScreen('free_agency'));
        document.getElementById('btnSchedule').addEventListener('click', () => showScreen('schedule'));
        document.getElementById('btnFacilities').addEventListener('click', () => showScreen('facilities'));
        document.getElementById('btnHubTraining').addEventListener('click', () => {
            // Show training selection screen
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
            document.getElementById('trainingSelectionScreen').style.display = 'block';
        });
        document.getElementById('btnHubNewGame').addEventListener('click', () => {
            if (confirm("Start a new game? All progress will be lost!")) {
                SaveSystem.clear();
                managementState.initialized = false;
                managementState.team = null;
                managementState.season = null;
                managementState.freeAgents = [];
                startNewGame();
                // Draft screen is shown by startNewGame() via startDraft()
            }
        });
        document.getElementById('btnRosterBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFABack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnScheduleBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFacilitiesBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnHubSettings').addEventListener('click', () => showScreen('settings'));
        document.getElementById('btnSettingsBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnHubBack').addEventListener('click', () => showScreen('main_menu'));
        // Game difficulty buttons (settings screen - separate from training difficulty)
        document.querySelectorAll('.game-difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                gameState.gameDifficulty = btn.dataset.difficulty;
                document.querySelectorAll('.game-difficulty-btn').forEach(b => b.style.background = '#333');
                btn.style.background = '#4a4';
            });
        });
        document.getElementById('btnMatchContinue').addEventListener('click', () => {
            if (managementState.seasonJustEnded) {
                managementState.seasonJustEnded = false;
                startDraft(false);  // Start offseason draft
            } else {
                showScreen('hub');
            }
        });
        document.getElementById('btnShowSimLog').addEventListener('click', () => {
            const container = document.getElementById('simLogContainer');
            const btn = document.getElementById('btnShowSimLog');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                btn.textContent = 'HIDE LOG';
            } else {
                container.style.display = 'none';
                btn.textContent = 'VIEW LOG';
            }
        });

        document.getElementById('btnCopySimLog').addEventListener('click', () => {
            const logText = getSimulationLog();
            navigator.clipboard.writeText(logText).then(() => {
                const btn = document.getElementById('btnCopySimLog');
                btn.textContent = 'COPIED!';
                setTimeout(() => { btn.textContent = 'COPY TO CLIPBOARD'; }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        });
        document.getElementById('btnUpgradeArena').addEventListener('click', () => {
            upgradeFacility('stadium');
            refreshFacilitiesScreen();
        });
        document.getElementById('btnUpgradeTraining').addEventListener('click', () => {
            upgradeFacility('trainingCenter');
            refreshFacilitiesScreen();
        });

        // Draft screen handlers
        document.getElementById('btnSkipRound').addEventListener('click', () => {
            skipDraftPick();
        });
        document.getElementById('btnFinishDraft').addEventListener('click', () => {
            finishDraft();
        });
        document.getElementById('btnDraftPoolView').addEventListener('click', () => {
            toggleDraftView(false);
        });
        document.getElementById('btnDraftRosterView').addEventListener('click', () => {
            toggleDraftView(true);
        });

        // Draft navigation handlers
        document.getElementById('btnNextPick').addEventListener('click', () => {
            simulateNextComputerPick();
        });

        document.getElementById('btnSkipToYourPick').addEventListener('click', () => {
            skipToPlayerTurn();
        });

        // Pick trading handlers
        document.getElementById('btnTradeInPick').addEventListener('click', () => {
            if (tradeInPick()) {
                // Show feedback
                const btn = document.getElementById('btnTradeInPick');
                const originalText = btn.textContent;
                btn.textContent = 'PICK TRADED!';
                btn.disabled = true;
                setTimeout(() => {
                    btn.textContent = originalText;
                    refreshDraftScreen();
                }, 1000);
            }
        });

        document.getElementById('btnAcquirePick').addEventListener('click', () => {
            if (acquireCurrentPick()) {
                // Show feedback
                const btn = document.getElementById('btnAcquirePick');
                btn.textContent = 'PICK ACQUIRED!';
                btn.disabled = true;
                setTimeout(() => {
                    refreshDraftScreen();
                }, 1000);
            }
        });

        // Draft back button - return to main menu
        document.getElementById('btnDraftBack').addEventListener('click', () => {
            document.getElementById('draftMenuDropdown').style.display = 'none';
            // Save the game state (draft will be preserved)
            if (managementState.settings.autoSave) SaveSystem.save();
            showScreen('main_menu');
        });

        // Draft menu dropdown handler
        document.getElementById('btnDraftMenu').addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('draftMenuDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener('click', () => {
            document.getElementById('draftMenuDropdown').style.display = 'none';
        });

        // Draft options modal handlers
        document.getElementById('btnDraftOptions').addEventListener('click', () => {
            document.getElementById('draftMenuDropdown').style.display = 'none';
            // Load current settings into inputs
            document.getElementById('pickTradeInPenalty').value = managementState.settings.pickTradeInPenalty || 50;
            document.getElementById('pickAcquirePremium').value = managementState.settings.pickAcquirePremium || 10;
            // Default to true if not set
            const showReasoning = managementState.settings.showPickReasoning !== false;
            document.getElementById('showPickReasoning').checked = showReasoning;
            document.getElementById('draftOptionsModal').style.display = 'flex';
        });

        document.getElementById('btnSaveDraftOptions').addEventListener('click', () => {
            // Save settings
            managementState.settings.pickTradeInPenalty = parseInt(document.getElementById('pickTradeInPenalty').value) || 50;
            managementState.settings.pickAcquirePremium = parseInt(document.getElementById('pickAcquirePremium').value) || 10;
            managementState.settings.showPickReasoning = document.getElementById('showPickReasoning').checked;
            document.getElementById('draftOptionsModal').style.display = 'none';
            // Refresh draft screen to show updated values
            if (draftState.active) {
                refreshDraftScreen();
            }
            // Save if auto-save is on
            if (managementState.settings.autoSave) SaveSystem.save();
        });

        document.getElementById('btnCloseDraftOptions').addEventListener('click', () => {
            document.getElementById('draftOptionsModal').style.display = 'none';
        });

        // Player detail modal handlers
        document.getElementById('btnCloseDetail').addEventListener('click', () => {
            // Reset draft player state when closing
            if (draftState.selectedDraftPlayer) {
                draftState.selectedDraftPlayer = null;
                // Restore cut button visibility
                document.getElementById('btnCutPlayer').style.display = 'block';
            }
            closePlayerDetail();
        });
        document.getElementById('btnCutPlayer').addEventListener('click', cutPlayerFromDetail);
        console.log('Setting up btnTradePlayer click handler...');
        const tradeBtnEl = document.getElementById('btnTradePlayer');
        console.log('Found btnTradePlayer element:', tradeBtnEl);
        if (!tradeBtnEl) {
            console.error('ERROR: btnTradePlayer not found in DOM!');
            alert('ERROR: Draft button not found!');
        }
        tradeBtnEl.addEventListener('click', (e) => {
            console.log('Trade/Draft button clicked', e);
            // Handle draft player differently
            if (draftState.selectedDraftPlayer) {
                console.log('Selected draft player:', draftState.selectedDraftPlayer);
                const playerId = draftState.selectedDraftPlayer.id;
                const playerName = draftState.selectedDraftPlayer.name;
                console.log('Attempting to draft player ID:', playerId);
                const result = draftPlayer(playerId);
                console.log('draftPlayer result:', result);
                if (result) {
                    console.log('Draft succeeded! Showing confirmation...');
                    draftState.selectedDraftPlayer = null;
                    // Show confirmation on the button briefly
                    const btn = document.getElementById('btnTradePlayer');
                    btn.textContent = 'DRAFTED!';
                    btn.style.backgroundColor = '#4CAF50';
                    console.log('Button updated to DRAFTED!, closing modal in 600ms...');
                    setTimeout(() => {
                        console.log('Timeout fired, closing modal...');
                        btn.textContent = 'DRAFT';
                        btn.style.backgroundColor = '';
                        closePlayerDetail();
                    }, 600);
                } else {
                    // Draft failed - show error briefly
                    console.log('Draft failed - showing error on button');
                    const btn = document.getElementById('btnTradePlayer');
                    const originalText = btn.textContent;
                    btn.textContent = 'FAILED!';
                    btn.style.backgroundColor = '#f44';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 1000);
                }
            } else {
                tradePlayerFromDetail();
            }
        });

        // Show initial screen
        showScreen(managementState.currentScreen);

        // Heat map toggle button
        const heatMapBtn = document.getElementById('btnHeatMap');
        const updateHeatMapButton = () => {
            heatMapBtn.textContent = gameState.showThrowHeatMap ? 'Heat Map: ON' : 'Heat Map: OFF';
            heatMapBtn.classList.toggle('active', gameState.showThrowHeatMap);
        };
        heatMapBtn.addEventListener('click', () => {
            gameState.showThrowHeatMap = !gameState.showThrowHeatMap;
            if (!gameState.showThrowHeatMap) clearThrowHeatMap();
            updateHeatMapButton();
        });
        updateHeatMapButton();

        // Render loop - try/catch prevents silent failures from stopping rendering
        // See TRAINING_MODE_FIX.md for why this is important
        engine.runRenderLoop(() => {
            try {
                scene.render();
            } catch (e) {
                console.error('Render error:', e);
                console.error('Stack:', e.stack);
            }
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });

        // Simulate rest of game from current state
        function simulateRestOfGame() {
            if (!managementState.matchInProgress) return;

            console.log('[SIM] Simulating rest of game...');
            console.log('[SIM] Current possession:', managementState.currentPossession, '/', SEASON.POSSESSIONS_PER_GAME);
            console.log('[SIM] Current score:', managementState.matchScore.player, '-', managementState.matchScore.opponent);

            // Hide button
            document.getElementById('btnSimRest').style.display = 'none';

            // Get game info
            const game = managementState.season.schedule[managementState.season.week - 1];
            const opponent = game.opponent;
            const playerTeam = managementState.team;

            // Simulate remaining possessions in regulation
            while (managementState.currentPossession < SEASON.POSSESSIONS_PER_GAME) {
                // Simulate player drive
                const playerDrive = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                const playerPoints = playerDrive.type === 'touchdown' ? 7 :
                                    playerDrive.type === 'field_goal' ? 3 : 0;
                managementState.matchScore.player += playerPoints;

                // Record stats from player drive
                if (playerDrive.statUpdates) {
                    playerDrive.statUpdates.forEach(update => {
                        const pStats = gameStats.getPlayer(update.playerId, update.playerName);
                        Object.keys(update).forEach(key => {
                            if (key !== 'playerId' && key !== 'playerName') {
                                pStats[key] = (pStats[key] || 0) + update[key];
                            }
                        });
                    });
                }

                // Simulate enemy drive
                const enemyResult = simulateEnemyPossession(opponent);
                managementState.matchScore.opponent += enemyResult.points;

                managementState.currentPossession++;
                console.log('[SIM] After possession', managementState.currentPossession, ':',
                    managementState.matchScore.player, '-', managementState.matchScore.opponent);
            }

            // Handle overtime if tied
            const playerScore = managementState.matchScore.player;
            const oppScore = managementState.matchScore.opponent;

            if (playerScore === oppScore) {
                console.log('[SIM] Tied game, simulating overtime...');
                managementState.gamePhase = 'overtime';

                while (managementState.matchScore.player === managementState.matchScore.opponent) {
                    // Player OT possession
                    const playerOT = simulatePlayerDriveHighFidelity(playerTeam, opponent);
                    const playerOTPoints = playerOT.type === 'touchdown' ? 7 :
                                           playerOT.type === 'field_goal' ? 3 : 0;
                    managementState.matchScore.player += playerOTPoints;

                    // Enemy OT possession
                    const enemyOT = simulateEnemyPossession(opponent);
                    managementState.matchScore.opponent += enemyOT.points;

                    console.log('[SIM] OT score:', managementState.matchScore.player, '-', managementState.matchScore.opponent);
                }
            }

            console.log('[SIM] Final score:', managementState.matchScore.player, '-', managementState.matchScore.opponent);

            // End the match
            const matchResult = endMatch();
            if (matchResult) {
                showMatchEnd(matchResult);
            } else {
                console.error('[SIM] endMatch returned null');
            }
        }

        // Sim rest button click handler
        document.getElementById('btnSimRest').addEventListener('click', simulateRestOfGame);

        // Keyboard shortcut: Press 'S' during a game to simulate rest
        window.addEventListener('keydown', (e) => {
            if (e.key === 's' || e.key === 'S') {
                if (managementState.matchInProgress && managementState.currentScreen === 'game') {
                    simulateRestOfGame();
                }
            }
        });
        console.log('[DEBUG] Press S or tap SIM REST button to simulate rest of game');
    </script>
</body>
</html>
