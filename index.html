<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        #score {
            font-size: 32px;
            margin-bottom: 5px;
        }

        #message {
            font-size: 18px;
            color: #aaa;
            min-height: 25px;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="ui">
        <div id="score">CATCHES: 0</div>
        <div id="message">Drag from knight to throw</div>
    </div>
    <div id="instructions">⬇ DRAG BACK TO AIM ⬆</div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        // Game State
        const gameState = {
            catches: 0,
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0  // Seconds between time-based clashes
        };

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 2.5,           // Distance for clash detection
            SEPARATION_THRESHOLD: 8,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 8,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
            TIME_BASED_CLASH_INTERVAL: 2.0    // Seconds between forced clashes
        };

        // Stat weights for clash resolution
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.20, acceleration: 0.15, release: 0.15 },
                defender: { speed: 0.20, agility: 0.20, manCoverage: 0.25, pursuit: 0.20, awareness: 0.15 }
            },
            physical: {
                attacker: { strength: 0.35, aggression: 0.25, hitPower: 0.25, balance: 0.15 },
                defender: { strength: 0.35, aggression: 0.25, tackling: 0.25, balance: 0.15 }
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false  // Show defender zone rings and fills
        };

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 20;
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Don't attach camera controls - we handle input ourselves

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line
            const receiverConfigs = [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 68, acceleration: 72, agility: 85,
                        routeRunning: 88, release: 75, catching: 90,
                        jumping: 70, strength: 60, balance: 72,
                        aggression: 45, stamina: 80, focus: 88
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 95, acceleration: 92, agility: 78,
                        routeRunning: 65, release: 70, catching: 72,
                        jumping: 75, strength: 50, balance: 60,
                        aggression: 40, stamina: 85, focus: 68
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 76, acceleration: 78, agility: 80,
                        routeRunning: 82, release: 78, catching: 85,
                        jumping: 82, strength: 72, balance: 78,
                        aggression: 55, stamina: 82, focus: 80
                    }
                }
            ];

            // Defender configurations
            const defenderConfigs = [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 72, acceleration: 70, agility: 75,
                        manCoverage: 82, zoneCoverage: 60, press: 78,
                        tackling: 80, hitPower: 85, pursuit: 75,
                        awareness: 72, strength: 82, balance: 78,
                        aggression: 75, stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 88, acceleration: 85, agility: 82,
                        manCoverage: 78, zoneCoverage: 65, press: 60,
                        tackling: 70, hitPower: 65, pursuit: 90,
                        awareness: 75, strength: 65, balance: 72,
                        aggression: 55, stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(4, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 5,
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 70, acceleration: 68, agility: 70,
                        manCoverage: 65, zoneCoverage: 88, press: 72,
                        tackling: 85, hitPower: 90, pursuit: 72,
                        awareness: 85, strength: 88, balance: 82,
                        aggression: 70, stamina: 75
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            receiverConfigs.forEach((config, i) => {
                const receiver = createKnight(scene, materials.receiverMaterial, config.start.clone());
                receiver.name = `receiver_${i}`;

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;

                // Derive base speed from stats (normalized to game units)
                receiver.baseSpeed = config.stats.speed * 0.0005;  // Scale stat to movement speed
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // 'open', 'contested', 'covered'
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);
                fillMat.emissiveColor = new BABYLON.Color3(0.2, 0.15, 0.05);
                fillMat.alpha = 0;  // Start invisible
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                const defender = createKnight(scene, materials.defenderMaterial, startPos);
                defender.name = `defender_${i}`;

                // Store config data on defender
                defender.displayName = config.name;
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.startPos = startPos.clone();

                // Derive base speed from stats
                defender.baseSpeed = config.stats.speed * 0.0005;
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Add name labels to receivers
            gameState.receivers.forEach((receiver, i) => {
                const nameLabel = new BABYLON.GUI.TextBlock();
                nameLabel.text = receiver.displayName;
                nameLabel.color = '#88bbff';
                nameLabel.fontSize = 14;
                nameLabel.fontFamily = 'Courier New';
                nameLabel.outlineWidth = 2;
                nameLabel.outlineColor = '#000000';

                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '120px';
                labelRect.height = '24px';
                labelRect.cornerRadius = 4;
                labelRect.thickness = 0;
                labelRect.background = 'rgba(0, 0, 0, 0.5)';
                labelRect.addControl(nameLabel);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -50;

                receiver.nameLabel = labelRect;
            });

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark red/maroon knights
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.15, 0.15);
            defenderMaterial.specularColor = new BABYLON.Color3(0.7, 0.3, 0.3);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Main field
            const field = BABYLON.MeshBuilder.CreateGround('field', {
                width: FIELD_WIDTH + 2,
                height: FIELD_LENGTH + 4
            }, scene);
            field.material = materials.fieldMaterial;
            field.position.z = 2;

            // Yard lines
            for (let i = -8; i <= 12; i += 4) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.1
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.01, i);
            }

            // End zone
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 3
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 12.5);

            // Border walls (castle-like)
            const wallHeight = 0.8;
            const wallPositions = [
                { x: -FIELD_WIDTH/2 - 0.5, z: 2, width: 1, depth: FIELD_LENGTH + 4 },
                { x: FIELD_WIDTH/2 + 0.5, z: 2, width: 1, depth: FIELD_LENGTH + 4 }
            ];

            wallPositions.forEach((wp, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall_${i}`, {
                    width: wp.width,
                    height: wallHeight,
                    depth: wp.depth
                }, scene);
                const wallMat = new BABYLON.StandardMaterial(`wallMat_${i}`, scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.35, 0.3, 0.25);
                wall.material = wallMat;
                wall.position.set(wp.x, wallHeight/2, wp.z);

                // Battlements
                for (let j = 0; j < 10; j++) {
                    const merlon = BABYLON.MeshBuilder.CreateBox(`merlon_${i}_${j}`, {
                        width: 0.4,
                        height: 0.3,
                        depth: 0.4
                    }, scene);
                    merlon.material = wallMat;
                    merlon.position.set(wp.x, wallHeight + 0.15, -7 + j * 2.2);
                }
            });
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.3,
                segments: 8
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.6, 0.6, 1);
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.05,
                height: 0.02,
                depth: 0.15
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            laces.material = laceMat;
            laces.position.y = 0.08;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Distance dragged determines throw power
            const dragDistance = Math.sqrt(dx * dx + dy * dy) * DRAG_SENSITIVITY;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), MAX_THROW_DISTANCE);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            const angle = Math.atan2(dx, -dy);

            return {
                distance: throwDistance,
                angle: angle,
                power: throwDistance / MAX_THROW_DISTANCE
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw power
            const maxHeight = 2 + power * 4;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                return false; // Route complete
            }

            const target = receiver.route[receiver.routeIndex];
            const dx = target.x - receiver.position.x;
            const dz = target.z - receiver.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                return receiver.routeIndex < receiver.route.length;
            }

            // Move toward target
            receiver.position.x += (dx / dist) * runSpeed;
            receiver.position.z += (dz / dist) * runSpeed;
            receiver.rotation.y = Math.atan2(dx, dz);
            return true;
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Zone coverage AI - patrol assigned area, react to nearby receivers
        const moveDefenderZoneCoverage = (defender, speed) => {
            // Find nearest receiver in zone
            let nearestReceiver = null;
            let nearestDist = defender.zoneRadius;

            gameState.receivers.forEach(receiver => {
                const dx = receiver.position.x - defender.zoneCenter.x;
                const dz = receiver.position.z - defender.zoneCenter.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver in zone
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;  // Stay slightly behind
            } else {
                // Patrol zone center
                targetX = defender.zoneCenter.x;
                targetZ = defender.zoneCenter.z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            gameState.defenders.forEach(defender => {
                defender.position.x = defender.startPos.x;
                defender.position.z = defender.startPos.z;
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.lastClashTime = 0;
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            gameState.receivers.forEach(receiver => {
                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiver.startPos.z;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.coverageAmount = 0;
                receiver.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                receiver.fillMaterial.alpha = 0;
                updateReceiverZoneColor(receiver);
            });
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            const catchRadius = 1.2;

            let frameIndex = 0;
            const animationSpeed = 1;  // Slowed down by half
            let accumulator = 0;
            const time = { value: 0 };

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Spin animation
                    football.rotation.z += 0.2;

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // If ball is coming to them (within catch range), move toward it
                        // Moving off-route to catch slows the receiver down (allows defenders to close)
                        if (distToLanding < catchRadius * 2.5 && frameIndex > 5) {
                            if (distToLanding > 0.2) {
                                // Reduced speed when adjusting to catch (70% of normal)
                                const catchAdjustSpeed = receiver.speed * 0.7;
                                receiver.position.x += (dx / distToLanding) * catchAdjustSpeed;
                                receiver.position.z += (dz / distToLanding) * catchAdjustSpeed;
                                receiver.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            // Follow their route at full speed
                            moveReceiverAlongRoute(receiver, receiver.speed);
                        }

                        // Running animation
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                        receiver.rotation.z = Math.sin(time.value * 8 + i) * 0.05;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Defenders move at full speed during ball flight
                        moveDefender(defender, 0.016);

                        // Running animation
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time.value * 8 + i + 0.5) * 0.05;
                    });

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            const catchRadius = 1.2;
            let potentialCatcher = null;
            let closestDistance = catchRadius;

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                }
            }

            if (potentialCatcher) {
                // Calculate catch probability
                const catchProbability = calculateCatchProbability(potentialCatcher, ballPosition);
                const catchRoll = Math.random() * 100;

                if (catchRoll < catchProbability) {
                    // Successful catch!
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}!`);

                    // Attach ball to receiver and celebrate
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    celebrateReceiver(potentialCatcher, scene);

                    // Reset after delay
                    setTimeout(() => {
                        resetPlay(scene);
                    }, 2000);
                } else {
                    // Dropped or defended
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');
                    bounceBall(scene, ballPosition);
                }
            } else {
                updateMessage('Incomplete...');
                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Calculate catch probability based on receiver stats and coverage
        const calculateCatchProbability = (receiver, ballPosition) => {
            // Base catch rate from receiver's catching stat
            let baseCatch = receiver.stats.catching;

            // Separation state modifier
            let separationMod = 0;
            switch (receiver.separationState) {
                case 'open':
                    separationMod = 15;  // Easier catch when open
                    break;
                case 'covered':
                    separationMod = -25;  // Harder when covered
                    break;
                case 'contested':
                default:
                    separationMod = 0;
                    break;
            }

            // Focus stat helps in contested situations
            const focusMod = receiver.separationState === 'contested' ?
                (receiver.stats.focus - 70) * 0.3 : 0;

            // Find closest defender and apply proximity penalty
            let defenderProximityPenalty = 0;
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < CLASH_CONSTANTS.CLASH_RANGE) {
                    // Defender is close - apply coverage penalty
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / CLASH_CONSTANTS.CLASH_RANGE);
                    defenderProximityPenalty += proximityFactor * coverageStat * 0.2;
                }
            });

            // Calculate final probability (clamped between 5% and 95%)
            const finalProbability = Math.max(5, Math.min(95,
                baseCatch + separationMod + focusMod - defenderProximityPenalty
            ));

            return finalProbability;
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;
            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Drag from knight to throw');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            document.getElementById('score').textContent = `CATCHES: ${gameState.catches}`;
        };

        const updateMessage = (msg) => {
            document.getElementById('message').textContent = msg;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
                console.log('Drag started at:', pos);
            };

            const onPointerMove = (evt) => {
                if (!gameState.isDragging) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                if (!gameState.isDragging) return;

                evt.preventDefault();

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                console.log('Drag ended. Start:', gameState.dragStart, 'End:', gameState.dragCurrent);

                if (gameState.dragStart && gameState.dragCurrent) {
                    const dx = gameState.dragStart.x - gameState.dragCurrent.x;
                    const dy = gameState.dragStart.y - gameState.dragCurrent.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    console.log('Drag distance:', dist, 'Throw distance:', dist * DRAG_SENSITIVITY);
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);

            console.log('Input handlers attached to canvas');
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                const time = performance.now() * 0.001;

                // QB breathing/ready animation
                const qb = scene.qb;
                qb.rotation.y = Math.sin(time * 2) * 0.05;
                qb.position.y = Math.sin(time * 3) * 0.02;

                // Track game time for clash system
                gameState.gameTime = time;

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdown during initial clash)
                        let effectiveSpeed = receiver.speed;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Arm swing approximation via slight rotation
                        receiver.rotation.z = Math.sin(time * bobSpeed + i) * 0.05;
                    });

                    // Reset all players when any route completes
                    if (anyRouteComplete) {
                        resetReceivers();
                        resetDefenders();
                    }

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdown during initial clash)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (slower during slowdown)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time * bobSpeed + i + 0.5) * 0.05;
                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();
                }
            });
        };

        // Get zone color based on separation state
        const getZoneColors = (separationState) => {
            switch (separationState) {
                case 'open':
                    return {
                        diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),  // Green
                        emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                    };
                case 'covered':
                    return {
                        diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),  // Red
                        emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                    };
                case 'contested':
                default:
                    return {
                        diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),  // Yellow
                        emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                    };
            }
        };

        // Update receiver zone color based on separation state
        const updateReceiverZoneColor = (receiver) => {
            if (!receiver.ringMaterial) return;

            const colors = getZoneColors(receiver.separationState);
            receiver.ringMaterial.diffuseColor = colors.diffuse;
            receiver.ringMaterial.emissiveColor = colors.emissive;
            receiver.fillMaterial.diffuseColor = colors.diffuse;
            receiver.fillMaterial.emissiveColor = colors.emissive.scale(0.5);
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Handle clash flash animation
                const currentTime = gameState.gameTime;
                let flashMultiplier = 1;
                let isFlashing = false;
                if (receiver.clashFlashUntil > currentTime) {
                    isFlashing = true;
                    const flashProgress = (receiver.clashFlashUntil - currentTime) / 0.3;  // 0.3s flash
                    // Pulsing flash effect
                    flashMultiplier = 1 + flashProgress * Math.sin(flashProgress * Math.PI * 4) * 0.5;
                }

                // Update receiver fill based on coverage (more visible)
                const fillScale = Math.max(0.1, maxCoverage) * 0.95;  // Always show some fill when in range
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Higher base alpha for better visibility
                const baseAlpha = maxCoverage * 0.5;
                receiver.fillMaterial.alpha = Math.min(0.7, baseAlpha * flashMultiplier);

                // Brighter emissive during flash
                if (isFlashing) {
                    const colors = getZoneColors(receiver.separationState);
                    receiver.fillMaterial.emissiveColor = colors.emissive.scale(flashMultiplier);
                    receiver.ringMaterial.emissiveColor = colors.emissive.scale(flashMultiplier * 1.5);
                }

                // Update ring brightness based on flash
                receiver.ringMaterial.alpha = Math.min(1.0, 0.8 * flashMultiplier);

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);

                    // Defender flash
                    let defFlashMult = 1;
                    let defIsFlashing = false;
                    if (coveringDefender.clashFlashUntil > currentTime) {
                        defIsFlashing = true;
                        const flashProgress = (coveringDefender.clashFlashUntil - currentTime) / 0.3;
                        defFlashMult = 1 + flashProgress * Math.sin(flashProgress * Math.PI * 4) * 0.5;
                    }

                    const defBaseAlpha = maxCoverage * 0.45;
                    coveringDefender.fillMaterial.alpha = Math.min(0.6, defBaseAlpha * defFlashMult);
                    coveringDefender.ringMaterial.alpha = Math.min(1.0, 0.8 * defFlashMult);

                    // Brighter emissive during flash
                    if (defIsFlashing) {
                        coveringDefender.fillMaterial.emissiveColor = coveringDefender.baseZoneColor.scale(0.4 * defFlashMult);
                        coveringDefender.ringMaterial.emissiveColor = coveringDefender.baseZoneColor.scale(0.6 * defFlashMult);
                    }
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const currentTime = gameState.gameTime;

            if (winner === 'receiver') {
                receiver.clashFlashUntil = currentTime + flashDuration;
            } else if (winner === 'defender') {
                defender.clashFlashUntil = currentTime + flashDuration;
            } else {
                // Contested - both flash briefly
                receiver.clashFlashUntil = currentTime + flashDuration * 0.5;
                defender.clashFlashUntil = currentTime + flashDuration * 0.5;
            }
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        const weightedRoll = (stats, weights) => {
            let weightedTotal = 0;
            for (const stat in weights) {
                const statValue = stats[stat] || 50;  // Default to 50 if stat missing
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Initial contact - first time zones overlap
            if (!receiver.hasHadInitialClash) {
                return { trigger: true, reason: 'initial_contact' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            // Time-based - hasn't clashed in a while
            const timeSinceLastClash = currentTime - Math.max(receiver.lastClashTime, defender.lastClashTime);
            if (timeSinceLastClash >= CLASH_CONSTANTS.TIME_BASED_CLASH_INTERVAL) {
                return { trigger: true, reason: 'time_based' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            if (defender.aiType === 'zone') {
                defenderWeights.zoneCoverage = defenderWeights.manCoverage;
                delete defenderWeights.manCoverage;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                receiver.separationState = 'open';
                receiver.speed = receiver.baseSpeed * CLASH_CONSTANTS.SEPARATION_SPEED_BOOST;
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                result.winner = 'defender';
                result.type = 'coverage';
                receiver.separationState = 'covered';
                receiver.speed = receiver.baseSpeed * CLASH_CONSTANTS.COVERAGE_SPEED_PENALTY;
            } else {
                result.winner = 'none';
                result.type = 'contested';
                receiver.separationState = 'contested';
                receiver.speed = receiver.baseSpeed;
            }

            // Update zone color
            updateReceiverZoneColor(receiver);

            // Physical battle check (based on aggression)
            const physicalChance = (receiver.stats.aggression + defender.stats.aggression) / 200;
            if (Math.random() < physicalChance) {
                resolvePhysicalClash(receiver, defender, result);
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Resolve physical aspect of clash (knockdowns)
        const resolvePhysicalClash = (receiver, defender, separationResult) => {
            const currentTime = gameState.gameTime;

            // Roll physical battle
            const receiverPhysical = weightedRoll(receiver.stats, CLASH_WEIGHTS.physical.attacker);
            const defenderPhysical = weightedRoll(defender.stats, CLASH_WEIGHTS.physical.defender);

            const margin = receiverPhysical - defenderPhysical;
            const loser = margin > 0 ? defender : receiver;
            const winner = margin > 0 ? receiver : defender;

            // Check for knockdown
            const knockdownChance = CLASH_CONSTANTS.KNOCKDOWN_BASE_CHANCE +
                (Math.abs(margin) / 100) * 0.1 -
                loser.knockdownResistance;

            if (Math.random() < Math.max(0, knockdownChance)) {
                // Knockdown!
                loser.knockdownUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                loser.knockdownResistance += CLASH_CONSTANTS.KNOCKDOWN_RESISTANCE_GAIN;

                // If receiver knocked down, they're definitely covered
                if (loser === receiver) {
                    receiver.separationState = 'covered';
                    updateReceiverZoneColor(receiver);
                }
            }
        };

        // Process all clashes in the game
        const processClashes = () => {
            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // Main
        const scene = createScene();
        setupInput(scene);
        setupIdleAnimations(scene);

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
