<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smashball - Medieval Football</title>
    <!-- v4 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            touch-action: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 36px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            border-bottom: 1px solid #333;
        }

        #score {
            color: #ffd700;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }

        #score .catches { color: #8cf; }
        #score .touchdowns { color: #4f4; }
        #score .label { color: #888; }

        #downDistance {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            background: rgba(40, 40, 40, 0.9);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #555;
        }
        #downDistance .down { color: #ffa; }
        #downDistance .distance { color: #aef; }

        #viewButtons {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        #viewButtons button {
            background: rgba(60, 60, 60, 0.9);
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 14px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        #viewButtons button:hover {
            background: rgba(80, 80, 80, 0.9);
            color: #fff;
        }
        #viewButtons button.active {
            background: rgba(70, 90, 120, 0.9);
            border-color: #68a;
            color: #fff;
        }

        #debugInfo {
            position: absolute;
            top: 80px;
            right: 10px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: left;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
            white-space: pre-wrap;
        }
        #catchDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #catchDisplay.visible {
            opacity: 1;
        }
        #catchDisplay .catch-header {
            font-size: 11px;
            font-weight: bold;
        }
        #catchDisplay .catch-header.success { color: #4f4; }
        #catchDisplay .catch-header.fail { color: #f66; }
        #catchDisplay .catch-bar {
            position: relative;
            width: 100px;
            height: 14px;
            background: #222;
            border-radius: 2px;
            overflow: visible;
        }
        #catchDisplay .catch-bar-base {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #3a3, #4b4);
            border-radius: 2px;
        }
        #catchDisplay .catch-bar-penalty {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
            border-left: 1px solid #f55;
        }
        #catchDisplay .catch-bar-roll {
            position: absolute;
            top: -1px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
            transform: translateX(-50%);
            line-height: 14px;
        }
        #catchDisplay .catch-bar-roll.success { color: #4f4; }
        #catchDisplay .catch-bar-roll.fail { color: #f44; }
        #catchDisplay .defender-info {
            font-size: 10px;
            color: #f99;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="topBar">
        <div id="downDistance">
            <span class="down">1st</span> & <span class="distance">10</span>
        </div>
        <div id="score">
            <span><span class="label">Catches</span> <span class="catches">0/0</span></span>
            <span><span class="label">TD</span> <span class="touchdowns">0</span></span>
        </div>
        <div id="catchDisplay">
            <div class="catch-header">CATCH</div>
            <div class="catch-bar">
                <div class="catch-bar-base"></div>
                <div class="catch-bar-penalty"></div>
                <div class="catch-bar-roll">✓</div>
            </div>
            <div class="defender-info"></div>
        </div>
    </div>
    <div id="viewButtons">
        <button id="viewIso" class="active">Iso</button>
        <button id="viewOverhead">Top</button>
        <button id="viewShoulder">Behind</button>
    </div>
    <div id="debugInfo"></div>

    <!-- Management UI Overlay -->
    <div id="managementOverlay">
        <!-- Main Menu -->
        <div id="mainMenuScreen" class="mgmt-screen">
            <h1>SMASHBALL</h1>
            <p class="subtitle">Medieval Football Management</p>
            <button id="btnNewGame" class="mgmt-btn">NEW GAME</button>
            <button id="btnContinue" class="mgmt-btn">CONTINUE</button>
        </div>

        <!-- Hub Screen -->
        <div id="hubScreen" class="mgmt-screen" style="display:none;">
            <div class="hub-status" id="hubStatus">$10,000 | Week 1</div>
            <h2>TEAM HUB</h2>
            <div class="hub-buttons">
                <button id="btnPlayGame" class="mgmt-btn primary">PLAY GAME</button>
                <button id="btnRoster" class="mgmt-btn">ROSTER</button>
                <button id="btnFreeAgency" class="mgmt-btn">FREE AGENCY</button>
                <button id="btnSchedule" class="mgmt-btn">SCHEDULE</button>
                <button id="btnFacilities" class="mgmt-btn">FACILITIES</button>
            </div>
            <p id="hubRecord" class="hub-record">Record: 0-0</p>
            <p id="hubNextGame" class="hub-next"></p>
        </div>

        <!-- Roster Screen -->
        <div id="rosterScreen" class="mgmt-screen" style="display:none;">
            <button id="btnRosterBack" class="mgmt-btn back-btn">← BACK</button>
            <h2>ROSTER</h2>
            <div id="rosterList" class="roster-list"></div>
        </div>

        <!-- Free Agency Screen -->
        <div id="freeAgencyScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFABack" class="mgmt-btn back-btn">← BACK</button>
            <h2>FREE AGENCY</h2>
            <p id="faStatus" class="fa-status"></p>
            <div id="freeAgentList" class="roster-list"></div>
        </div>

        <!-- Schedule Screen -->
        <div id="scheduleScreen" class="mgmt-screen" style="display:none;">
            <button id="btnScheduleBack" class="mgmt-btn back-btn">← BACK</button>
            <h2>SCHEDULE</h2>
            <div id="teamStrength" class="team-strength">
                <h3>YOUR TEAM</h3>
                <div class="strength-ratings">
                    <div class="strength-item">
                        <div class="label">OVERALL</div>
                        <div class="value" id="strengthOverall">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">OFFENSE</div>
                        <div class="value" id="strengthOffense">--</div>
                    </div>
                    <div class="strength-item">
                        <div class="label">DEFENSE</div>
                        <div class="value" id="strengthDefense">--</div>
                    </div>
                </div>
            </div>
            <div id="scheduleList" class="schedule-list"></div>
        </div>

        <!-- Facilities Screen -->
        <div id="facilitiesScreen" class="mgmt-screen" style="display:none;">
            <button id="btnFacilitiesBack" class="mgmt-btn back-btn">← BACK</button>
            <h2>FACILITIES</h2>
            <p id="facCredits" class="fac-credits"></p>
            <div class="facility-item">
                <h3>ARENA</h3>
                <p id="arenaLevel">Level 1/5</p>
                <p class="fac-desc">Increases home game revenue</p>
                <button id="btnUpgradeArena" class="mgmt-btn">UPGRADE</button>
            </div>
            <div class="facility-item">
                <h3>TRAINING GROUNDS</h3>
                <p id="trainingLevel">Level 1/5</p>
                <p class="fac-desc">Boosts player development</p>
                <button id="btnUpgradeTraining" class="mgmt-btn">UPGRADE</button>
            </div>
        </div>

        <!-- Match End Screen -->
        <div id="matchEndScreen" class="mgmt-screen" style="display:none;">
            <h1 id="matchResult">VICTORY!</h1>
            <p id="matchScore" class="match-score">21 - 14</p>
            <p id="matchRevenue" class="match-revenue"></p>
            <button id="btnMatchContinue" class="mgmt-btn primary">CONTINUE</button>
        </div>

        <!-- Player Detail Modal -->
        <div id="playerDetailModal" class="mgmt-modal" style="display:none;">
            <div class="modal-content">
                <button id="btnCloseDetail" class="mgmt-btn back-btn">← BACK</button>
                <h2 id="playerName">Player Name</h2>
                <div id="playerInfo" class="player-info"></div>
                <div id="playerStats" class="player-stats"></div>
                <div id="playerSeasonStats" class="player-season-stats"></div>
                <div id="playerCareerGraph" class="player-career-graph"></div>
                <div class="modal-actions">
                    <button id="btnCutPlayer" class="mgmt-btn danger">CUT PLAYER</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        #managementOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #0a0a14;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #managementOverlay.hidden { display: none; }
        .mgmt-screen {
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
            width: 100%;
            max-width: 400px;
        }
        .mgmt-screen h1 {
            color: #ffd700;
            font-size: 48px;
            margin: 0 0 10px 0;
        }
        .mgmt-screen h2 {
            color: #ffd700;
            font-size: 28px;
            margin: 10px 0 20px 0;
        }
        .mgmt-screen .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 40px;
        }
        .mgmt-btn {
            display: block;
            width: 100%;
            max-width: 280px;
            margin: 10px auto;
            padding: 16px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: #2a2a40;
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 8px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .mgmt-btn:active { background: #3a3a50; }
        .mgmt-btn:disabled { opacity: 0.5; }
        .mgmt-btn.primary { background: #3a3a60; }
        .mgmt-btn.back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: auto;
            padding: 10px 16px;
            font-size: 14px;
        }
        .hub-status {
            position: absolute;
            top: 10px;
            left: 0; right: 0;
            text-align: center;
            color: #ffd700;
            font-size: 14px;
        }
        .hub-record { font-size: 20px; margin-top: 30px; }
        .hub-next { color: #aaa; font-size: 14px; }
        .roster-list, .schedule-list {
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .roster-item, .schedule-item {
            background: #1a1a2a;
            padding: 12px;
            margin: 6px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-item .name { font-size: 14px; }
        .roster-item .stats { font-size: 12px; color: #aaa; }
        .roster-item .ovr { color: #4f4; font-size: 16px; }
        .position-header {
            background: #2a2a40;
            color: #ffd700;
            padding: 8px 12px;
            margin-top: 12px;
            font-size: 14px;
        }
        .schedule-item.current { background: #2a3a2a; }
        .schedule-item.past { opacity: 0.6; }
        .schedule-item .result { font-weight: bold; }
        .schedule-item .result.win { color: #4f4; }
        .schedule-item .result.loss { color: #f44; }
        .facility-item {
            background: #1a1a2a;
            padding: 16px;
            margin: 12px 0;
            border-radius: 8px;
            text-align: left;
        }
        .facility-item h3 { color: #ffd700; margin: 0 0 8px 0; font-size: 16px; }
        .fac-desc { color: #888; font-size: 12px; margin: 8px 0; }
        .fac-credits { color: #ffd700; font-size: 18px; }
        .fa-status { color: #aaa; font-size: 14px; }
        .fa-btn { padding: 8px 16px; font-size: 14px; }
        .match-score { font-size: 36px; margin: 20px 0; }
        .match-revenue { color: #4f4; font-size: 18px; }
        #matchResult.win { color: #4f4; }
        #matchResult.loss { color: #f44; }

        /* Player Detail Modal */
        .mgmt-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }
        .modal-content {
            background: #0a0a14;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .modal-content h2 {
            color: #ffd700;
            margin: 40px 0 10px 0;
            text-align: center;
        }
        .player-info {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .player-info .ovr-big {
            font-size: 48px;
            color: #4f4;
            font-weight: bold;
        }
        .player-info .season-change {
            font-size: 18px;
            margin-left: 10px;
        }
        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .stat-row {
            background: #1a1a2a;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }
        .stat-row .stat-name { color: #888; }
        .stat-row .stat-values {
            display: flex;
            align-items: center;
            min-width: 60px;
            justify-content: flex-end;
        }
        .stat-row .stat-value {
            display: inline-block;
            width: 24px;
            text-align: right;
        }
        .stat-row .stat-change {
            display: inline-block;
            width: 28px;
            text-align: right;
            font-size: 11px;
        }
        /* Stat color coding by value */
        .stat-elite { color: #4f4; }      /* 90+ green */
        .stat-good { color: #8f8; }       /* 80-89 light green */
        .stat-average { color: #ff0; }    /* 70-79 yellow */
        .stat-below { color: #f80; }      /* 60-69 orange */
        .stat-poor { color: #f44; }       /* <60 red */
        .stat-change.positive { color: #4f4; }
        .stat-change.negative { color: #f44; }
        /* Season stats section */
        .player-season-stats {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .season-stats-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .season-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        .season-stat-item {
            text-align: center;
        }
        .season-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4f4;
        }
        .season-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        /* Career graph section */
        .player-career-graph {
            margin-top: 16px;
            padding: 12px;
            background: #1a1a2a;
            border-radius: 6px;
        }
        .career-graph-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .career-graph-container {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 4px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .career-bar {
            flex: 1;
            min-width: 20px;
            max-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .career-bar-fill {
            width: 100%;
            background: linear-gradient(to top, #4f4, #8f8);
            border-radius: 2px 2px 0 0;
            position: relative;
        }
        .career-bar-potential {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-size: 8px;
        }
        .career-bar-label {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }
        .career-bar-ovr {
            font-size: 10px;
            color: #fff;
            margin-bottom: 2px;
        }
        .modal-actions {
            margin-top: 20px;
            text-align: center;
        }
        .mgmt-btn.danger {
            background: #4a2020;
            border-color: #f44;
            color: #f44;
        }
        .roster-item { cursor: pointer; }
        .roster-item:active { background: #2a2a3a; }
        .roster-item .season-gain {
            font-size: 12px;
            margin-left: 8px;
        }
        .season-gain.positive { color: #4f4; }
        .season-gain.negative { color: #f44; }

        /* Team Strength Display */
        .team-strength {
            background: #1a1a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .team-strength h3 {
            color: #ffd700;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .strength-ratings {
            display: flex;
            justify-content: space-around;
        }
        .strength-item {
            text-align: center;
        }
        .strength-item .label { color: #888; font-size: 11px; }
        .strength-item .value { color: #4f4; font-size: 20px; font-weight: bold; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script>
        // Game State
        const gameState = {
            catches: 0,
            attempts: 0,            // Total catch attempts
            touchdowns: 0,          // Touchdowns scored
            isDragging: false,
            canThrow: true,
            dragStart: null,
            dragCurrent: null,
            ballInFlight: false,
            receivers: [],
            receiversStartZ: [],
            defenders: [],
            offensiveLine: [],      // O-line players
            defensiveLine: [],      // D-line players
            gameTime: 0,  // Track game time for clash timing
            clashCooldown: 2.0,  // Seconds between time-based clashes
            playStartTime: 0,  // When current play started (for label fading)
            ballCarrier: null,      // Receiver carrying the ball after catch
            playEnded: false,       // Track if play has ended (tackle/sack/TD)
            waitingForPossession: false, // Pause game during possession overlay
            playFrozen: true,       // Play frozen until player holds screen
            qbSacked: false,        // Track if QB was sacked
            qbStartZ: -6,           // QB's randomized starting position (set each play)
            currentView: 'iso',     // Camera view: 'iso', 'overhead', 'shoulder'
            // Down and distance tracking
            down: 1,                // Current down (1-4)
            yardsToGo: 10,          // Yards needed for first down
            lineOfScrimmage: -5,    // Current field position (Z coordinate) - own 30
            firstDownMarker: 5,     // Z position where first down is achieved
            startingLineOfScrimmage: -5  // Where drive started - own 30 yard line
        };

        // Management mode flag - when false, game input is disabled
        let gameSceneActive = false;

        // Clash system constants
        const CLASH_CONSTANTS = {
            CLASH_RANGE: 2.5,           // Distance for clash detection
            SEPARATION_THRESHOLD: 3,     // Margin needed to win separation
            COVERAGE_THRESHOLD: 3,       // Margin needed to win coverage
            KNOCKDOWN_BASE_CHANCE: 0.15, // Base chance for knockdown on physical win
            KNOCKDOWN_DURATION: 1.0,     // Seconds knocked down
            KNOCKDOWN_RESISTANCE_GAIN: 0.15,  // Cumulative resistance per knockdown
            SEPARATION_SPEED_BOOST: 1.15,     // Speed multiplier when open
            COVERAGE_SPEED_PENALTY: 0.90,     // Speed multiplier when covered
        };

        // Line clash system constants
        const LINE_CLASH_CONSTANTS = {
            CLASH_RANGE: 1.5,           // Distance for line clash detection
            CLASH_INTERVAL: 0.5,        // Seconds between clash resolutions while engaged
            NEUTRAL_SPEED: 0.05,        // Near-zero speed on neutral clash
            OFFENSE_WIN_THRESHOLD: 5,   // Margin needed for O-line to win decisively
            DEFENSE_WIN_THRESHOLD: 5,   // Margin needed for D-line to win decisively
            KNOCKDOWN_DURATION: 1.0,    // Seconds knocked down
            SPEED_BURST_MULTIPLIER: 1.5,// Speed boost after D-line wins
            SPEED_BURST_DURATION: 1.5,  // Duration of speed burst
            TACKLE_RANGE: 1.2,          // Distance for QB sack
        };

        // Receiver tackling constants
        const TACKLE_CONSTANTS = {
            TACKLE_RANGE: 1.0,          // Distance for tackle attempt
            TACKLE_INTERVAL: 0.3,       // Seconds between tackle attempts
            STUMBLE_DURATION: 0.5,      // How long defender stumbles after failed tackle
            BREAK_TACKLE_BOOST: 1.3,    // Speed boost after breaking tackle
            BREAK_TACKLE_DURATION: 0.8, // Duration of break tackle speed boost
        };

        // QB pocket constants
        const POCKET_CONSTANTS = {
            POCKET_CENTER_Z: -7,        // Ideal pocket depth (3 yards behind LOS)
            POCKET_MIN_X: -3,           // Pocket left boundary
            POCKET_MAX_X: 3,            // Pocket right boundary
            POCKET_MAX_DEPTH: -10,      // Don't go deeper than this
            LINE_OF_SCRIMMAGE: -4,      // Can't cross this going forward
            THREAT_RADIUS: 4,           // Start evading when defender this close
            EVADE_SPEED: 0.06,          // Speed when evading
            SETTLE_SPEED: 0.03,         // Speed when settling into pocket
        };

        // Stat weights for clash resolution
        const CLASH_WEIGHTS = {
            separation: {
                receiver: { speed: 0.25, agility: 0.25, routeRunning: 0.20, acceleration: 0.15, release: 0.15 },
                defender: { speed: 0.20, agility: 0.20, manCoverage: 0.25, pursuit: 0.20, awareness: 0.15 }
            },
            physical: {
                attacker: { strength: 0.35, aggression: 0.25, hitPower: 0.25, balance: 0.15 },
                defender: { strength: 0.35, aggression: 0.25, tackling: 0.25, balance: 0.15 }
            },
            lineClash: {
                offense: { passBlock: 0.35, strength: 0.30, balance: 0.20, awareness: 0.15 },
                defense: { passRush: 0.35, strength: 0.30, acceleration: 0.20, speed: 0.15 }
            },
            tackle: {
                tackler: { tackling: 0.40, pursuit: 0.30, hitPower: 0.30 },
                ballCarrier: { agility: 0.35, speed: 0.30, balance: 0.35 }
            }
        };

        // Feature flags
        const FEATURE_FLAGS = {
            showDefenderZones: false,  // Show defender zone rings and fills
            showDebugInfo: false       // Show on-screen debug info for coverage/catch factors
        };

        // ========================================
        // MANAGEMENT LAYER - DATA MODELS
        // ========================================

        // Management state - persisted between sessions
        const managementState = {
            team: null,
            season: null,
            freeAgents: [],
            settings: {
                difficulty: 'normal',  // easy, normal, hard
                autoSave: true
            },
            initialized: false,
            currentScreen: 'main_menu',  // main_menu, hub, roster, player_detail, free_agency, facilities, schedule, game
            selectedPlayerId: null,
            matchInProgress: false,
            currentPossession: 0,
            matchScore: { player: 0, opponent: 0 }
        };

        // Position definitions with stat priorities
        const POSITIONS = {
            WR: {
                name: 'Wide Receiver',
                shortName: 'WR',
                primaryStats: ['speed', 'catching', 'routeRunning', 'agility'],
                count: 3
            },
            CB: {
                name: 'Cornerback',
                shortName: 'CB',
                primaryStats: ['speed', 'manCoverage', 'zoneCoverage', 'agility'],
                count: 4
            },
            OL: {
                name: 'Offensive Lineman',
                shortName: 'OL',
                primaryStats: ['passBlock', 'strength', 'balance', 'awareness'],
                count: 5
            },
            DL: {
                name: 'Defensive Lineman',
                shortName: 'DL',
                primaryStats: ['passRush', 'strength', 'acceleration', 'tackling'],
                count: 4
            },
            QB: {
                name: 'Quarterback',
                shortName: 'QB',
                primaryStats: ['throwing', 'awareness', 'agility', 'speed'],
                count: 1
            }
        };

        // Medieval-themed name pools
        const FIRST_NAMES = [
            'Aldric', 'Baldwin', 'Cedric', 'Duncan', 'Edmund', 'Fabian', 'Gareth', 'Harold',
            'Ivan', 'Jasper', 'Kendrick', 'Leopold', 'Magnus', 'Norbert', 'Oswald', 'Percival',
            'Quincy', 'Roderick', 'Sigmund', 'Thaddeus', 'Ulric', 'Victor', 'Wallace', 'Xavier',
            'Yorick', 'Zephyr', 'Arthur', 'Bernard', 'Conrad', 'Dorian', 'Edgar', 'Felix',
            'Geoffrey', 'Hugo', 'Ignatius', 'Julius', 'Klaus', 'Lionel', 'Marcus', 'Neville'
        ];

        const LAST_NAMES = [
            'Blackwood', 'Ironforge', 'Stoneheart', 'Thornfield', 'Winterbane', 'Ashford',
            'Brighthelm', 'Coldwell', 'Darkwater', 'Everhart', 'Foxworth', 'Grimshaw',
            'Hawthorne', 'Ironcrest', 'Jarvis', 'Kingsley', 'Lockwood', 'Montague',
            'Northwind', 'Oakenshield', 'Proudfoot', 'Queensbury', 'Ravenwood', 'Silverton',
            'Thunderstone', 'Underhill', 'Vanguard', 'Westbrook', 'Yarrow', 'Zephyrus',
            'Battleborn', 'Crossbow', 'Dragonbane', 'Eaglecrest', 'Flameheart', 'Goldmane'
        ];

        // Team name components
        const TEAM_CITIES = [
            'Ironhelm', 'Stormwall', 'Dragonfire', 'Shadowmere', 'Frostpeak', 'Sunspire',
            'Bloodstone', 'Thornwood', 'Goldcrest', 'Ravenmoor', 'Wolfhaven', 'Eaglekeep',
            'Lionhart', 'Bearhold', 'Hawkridge', 'Serpentine'
        ];

        const TEAM_NAMES = [
            'Crusaders', 'Sentinels', 'Legion', 'Knights', 'Warriors', 'Guardians',
            'Paladins', 'Champions', 'Defenders', 'Marauders', 'Vanguard', 'Templars',
            'Berserkers', 'Wardens', 'Lancers', 'Reavers'
        ];

        // Economy constants
        const ECONOMY = {
            STARTING_CREDITS: 10000,
            SALARY_CAP: 120000,  // Slightly higher than typical team salary (~115k)
            SALARY_MULTIPLIER: 100,  // salary = sum(stats) * 100

            // Revenue
            HOME_GAME_BASE: 500,
            HOME_GAME_STADIUM_BONUS: 300,  // per level
            AWAY_GAME_REVENUE: 250,
            PLAYER_SALE_RATE: 0.5,  // get 50% of salary value

            // Facility costs by level (1->2, 2->3, etc)
            STADIUM_UPGRADE_COSTS: [2000, 5000, 10000, 20000, 40000],
            TRAINING_UPGRADE_COSTS: [1500, 4000, 8000, 15000, 30000],

            // Other
            BRIBE_COST: 10000,
            BRIBE_CAP_BONUS: 5000
        };

        // Progression constants
        const PROGRESSION = {
            // Growth is based purely on potential grade
            GROWTH_CHANCE_BASE: 0.07,           // 7% base chance per stat per week (~20 total skill for max pot)
            GROWTH_AMOUNT_MIN: 1,               // Minimum +1 when growth happens
            // Potential decay: chance for potential to drop each year
            POTENTIAL_DECAY_EARLY: 0.15,        // 15% chance years 1-3
            POTENTIAL_DECAY_LATE: 0.50,         // 50% chance after year 3
            POTENTIAL_DROP_TWO_CHANCE: 0.25,    // 25% chance to drop 2 levels instead of 1
            // Decline rates
            DECLINE_RATE: 0.3,                  // per year over peak (base)
            // Physical stats: grow rarely, decline in phases
            PHYSICAL_STATS: ['speed', 'acceleration', 'agility', 'strength', 'stamina'],
            PHYSICAL_GROWTH_CHANCE_MULT: 0.22,  // 22% of normal growth chance (~1/year)
            PHYSICAL_DECLINE_EARLY_MULT: 0.5,   // Gentle decline years 1-3 after peak
            PHYSICAL_DECLINE_LATE_MULT: 3.0,    // Steep decline years 4+ after peak
            PHYSICAL_DECLINE_LATE_START: 4,     // When steep decline begins
            // Skill stats: decline very slowly
            SKILL_STATS: ['catching', 'routeRunning', 'blocking', 'runBlock', 'passBlock',
                          'tackling', 'manCoverage', 'zoneCoverage', 'passRush', 'awareness', 'focus'],
            SKILL_DECLINE_MULT: 0.1,            // Only 10% of normal decline
            MIN_STAT: 20,
            MIN_AVERAGE_STAT: 35,  // retire if average drops below
            MAX_AGE: 40
        };

        // Season constants
        const SEASON = {
            WEEKS: 16,
            POSSESSIONS_PER_GAME: 5
        };

        // ========================================
        // MANAGEMENT LAYER - UTILITY FUNCTIONS
        // ========================================

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Random from array
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Random int between min and max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Format salary in millions (e.g., 5000 -> "$5M")
        function formatSalaryM(amount) {
            const millions = Math.round(amount / 1000);
            return `$${millions}M`;
        }

        // Shuffle array (Fisher-Yates)
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // ========================================
        // MANAGEMENT LAYER - SAVE/LOAD SYSTEM
        // ========================================

        const SaveSystem = {
            SAVE_KEY: 'smashball_management_save',

            save() {
                if (!managementState.initialized) return false;

                const saveData = {
                    version: 1,
                    timestamp: Date.now(),
                    team: managementState.team,
                    season: managementState.season,
                    freeAgents: managementState.freeAgents,
                    settings: managementState.settings
                };

                try {
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('Game saved successfully');
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            },

            load() {
                try {
                    const data = localStorage.getItem(this.SAVE_KEY);
                    if (!data) return null;

                    const saveData = JSON.parse(data);
                    console.log('Game loaded successfully, version:', saveData.version);
                    return saveData;
                } catch (e) {
                    console.error('Failed to load game:', e);
                    return null;
                }
            },

            exists() {
                return localStorage.getItem(this.SAVE_KEY) !== null;
            },

            clear() {
                localStorage.removeItem(this.SAVE_KEY);
                console.log('Save data cleared');
            },

            applySaveData(saveData) {
                if (!saveData) return false;

                managementState.team = saveData.team;
                managementState.season = saveData.season;
                managementState.freeAgents = saveData.freeAgents || [];
                managementState.settings = saveData.settings || managementState.settings;
                managementState.initialized = true;

                return true;
            }
        };

        // ========================================
        // MANAGEMENT LAYER - PLAYER GENERATION
        // ========================================

        // Generate base stats for a tier
        function getBaseStatsForTier(tier) {
            const ranges = {
                rookie: { min: 45, max: 65 },
                average: { min: 55, max: 75 },
                veteran: { min: 65, max: 85 },
                elite: { min: 75, max: 95 }
            };
            const range = ranges[tier] || ranges.average;
            return { min: range.min, max: range.max };
        }

        // Roll age based on tier
        function rollAge(tier) {
            switch(tier) {
                case 'rookie': return randomInt(20, 23);
                case 'average': return randomInt(23, 28);
                case 'veteran': return randomInt(28, 33);
                case 'elite': return randomInt(25, 30);
                default: return randomInt(22, 28);
            }
        }

        // Roll potential grade based on age and tier (0-3 scale)
        // Distribution: max (3) 15%, average (2) 35%, low (1) 35%, very low (0) 15%
        function rollPotential(age, tier) {
            // Base weighted distribution
            const roll = Math.random() * 100;
            let potential;
            if (roll < 15) potential = 3;        // 15% max
            else if (roll < 50) potential = 2;   // 35% average
            else if (roll < 85) potential = 1;   // 35% low
            else potential = 0;                   // 15% very low

            // Age modifier: older players lose potential
            if (age > 28) potential = Math.max(0, potential - 1);
            if (age > 32) potential = Math.max(0, potential - 1);

            // Tier bonus for young elite/rookie players
            if ((tier === 'elite' || tier === 'rookie') && age <= 24) {
                potential = Math.min(3, potential + 1);
            }

            return potential;
        }

        // Generate position-specific stats
        function generatePositionStats(position, baseRange) {
            const stats = {};
            const positionData = POSITIONS[position];

            // All possible stats
            const allStats = [
                'speed', 'acceleration', 'agility', 'strength', 'stamina', 'balance',
                'catching', 'throwing', 'routeRunning', 'release', 'jumping', 'focus',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'hitPower', 'pursuit', 'awareness',
                'passBlock', 'passRush', 'aggression'
            ];

            // Generate all stats
            allStats.forEach(stat => {
                // Primary stats get bonus
                const isPrimary = positionData.primaryStats.includes(stat);
                const bonus = isPrimary ? 10 : 0;

                stats[stat] = Math.min(99, Math.max(1,
                    randomInt(baseRange.min, baseRange.max) + bonus
                ));
            });

            return stats;
        }

        // Calculate salary from stats
        function calculateSalary(stats) {
            const total = Object.values(stats).reduce((sum, val) => sum + val, 0);
            const avgStat = total / Object.keys(stats).length;
            // Salary based on average stat, scaled
            return Math.floor(avgStat * ECONOMY.SALARY_MULTIPLIER);
        }

        // Calculate overall rating (average of primary stats for position)
        function calculateOverall(player) {
            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;
            const total = primaryStats.reduce((sum, stat) => sum + (player.stats[stat] || 0), 0);
            return Math.round(total / primaryStats.length);
        }

        // Generate a player
        function generatePlayer(position, tier = 'average') {
            const baseRange = getBaseStatsForTier(tier);
            const age = rollAge(tier);
            const peakAge = randomInt(28, 32);
            const stats = generatePositionStats(position, baseRange);

            // Years in league based on age (rookies start at 0)
            const yearsInLeague = tier === 'rookie' ? 0 : Math.max(0, age - 22);

            const player = {
                id: generateUUID(),
                firstName: randomFrom(FIRST_NAMES),
                lastName: randomFrom(LAST_NAMES),
                age,
                position,
                stats,
                potentialGrade: rollPotential(age, tier),
                yearsInLeague,
                peakAge,
                salaryCost: calculateSalary(stats),
                seasonStartStats: { ...stats },
                // Season stats
                gamesPlayed: 0,
                seasonTDs: 0,
                seasonCatches: 0,
                seasonTargets: 0,
                seasonTackles: 0,
                seasonClashesWon: 0,
                seasonClashesLost: 0,
                seasonSacks: 0,
                seasonPassesDefended: 0,
                // Career history (array of season snapshots)
                careerHistory: [{
                    season: 0,
                    overall: Math.round(Object.values(stats).reduce((a, b) => a + b, 0) / Object.keys(stats).length),
                    potential: rollPotential(age, tier)
                }]
            };

            player.overall = calculateOverall(player);
            return player;
        }

        // Generate initial roster for new game
        function generateInitialRoster() {
            const roster = [];

            // WRs: 1 good, 2 average
            roster.push(generatePlayer('WR', 'veteran'));
            roster.push(generatePlayer('WR', 'average'));
            roster.push(generatePlayer('WR', 'average'));

            // CBs: 1 good, 3 average
            roster.push(generatePlayer('CB', 'veteran'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));
            roster.push(generatePlayer('CB', 'average'));

            // OL: 1 good, 4 average
            roster.push(generatePlayer('OL', 'veteran'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));
            roster.push(generatePlayer('OL', 'average'));

            // DL: 1 good, 3 average
            roster.push(generatePlayer('DL', 'veteran'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));
            roster.push(generatePlayer('DL', 'average'));

            // QB
            roster.push(generatePlayer('QB', 'average'));

            return roster;
        }

        // Auto-assign depth chart based on overall ratings
        function autoAssignDepthChart(team) {
            const roster = team.roster;

            // Group by position and sort by overall
            const byPosition = {};
            roster.forEach(p => {
                if (!byPosition[p.position]) byPosition[p.position] = [];
                byPosition[p.position].push(p);
            });

            Object.keys(byPosition).forEach(pos => {
                byPosition[pos].sort((a, b) => b.overall - a.overall);
            });

            // Assign to depth chart
            const depthChart = {
                WR1: byPosition.WR?.[0]?.id || null,
                WR2: byPosition.WR?.[1]?.id || null,
                WR3: byPosition.WR?.[2]?.id || null,
                CB1: byPosition.CB?.[0]?.id || null,
                CB2: byPosition.CB?.[1]?.id || null,
                CB3: byPosition.CB?.[2]?.id || null,
                CB4: byPosition.CB?.[3]?.id || null,
                OL: (byPosition.OL || []).slice(0, 5).map(p => p.id),
                DL: (byPosition.DL || []).slice(0, 4).map(p => p.id),
                QB: byPosition.QB?.[0]?.id || null
            };

            // Pad OL and DL if needed
            while (depthChart.OL.length < 5) depthChart.OL.push(null);
            while (depthChart.DL.length < 4) depthChart.DL.push(null);

            team.depthChart = depthChart;
        }

        // Create a new team
        function createNewTeam(name = 'Your Team') {
            const team = {
                name,
                credits: ECONOMY.STARTING_CREDITS,
                salaryCap: ECONOMY.SALARY_CAP,
                salaryCapModifier: 0,
                roster: generateInitialRoster(),
                depthChart: {},
                facilities: {
                    stadium: { level: 1, maxLevel: 5 },
                    trainingCenter: { level: 1, maxLevel: 5 }
                },
                record: { wins: 0, losses: 0 }
            };

            autoAssignDepthChart(team);
            return team;
        }

        // ========================================
        // MANAGEMENT LAYER - OPPONENT GENERATION
        // ========================================

        // Pre-defined opponents with varying difficulty
        function generateOpponents() {
            const difficulties = [
                { name: 'easy', offenseRange: [35, 50], defenseRange: [35, 50] },
                { name: 'medium', offenseRange: [50, 65], defenseRange: [50, 65] },
                { name: 'hard', offenseRange: [65, 80], defenseRange: [65, 80] },
                { name: 'elite', offenseRange: [75, 90], defenseRange: [75, 90] }
            ];

            const opponents = [];
            const usedNames = new Set();

            // Generate 16 unique opponents
            while (opponents.length < 16) {
                const city = randomFrom(TEAM_CITIES);
                const teamName = randomFrom(TEAM_NAMES);
                const fullName = `${city} ${teamName}`;

                if (usedNames.has(fullName)) continue;
                usedNames.add(fullName);

                // Distribute difficulty: 4 easy, 6 medium, 4 hard, 2 elite
                let diffIndex;
                if (opponents.length < 4) diffIndex = 0;
                else if (opponents.length < 10) diffIndex = 1;
                else if (opponents.length < 14) diffIndex = 2;
                else diffIndex = 3;

                const diff = difficulties[diffIndex];

                opponents.push({
                    id: generateUUID(),
                    name: fullName,
                    difficulty: diff.name,
                    offenseRating: randomInt(diff.offenseRange[0], diff.offenseRange[1]),
                    defenseRating: randomInt(diff.defenseRange[0], diff.defenseRange[1]),
                    record: { wins: 0, losses: 0 }
                });
            }

            return shuffleArray(opponents);
        }

        // Generate season schedule
        function generateSchedule(opponents) {
            const schedule = [];
            const shuffledOpponents = shuffleArray([...opponents]);

            for (let week = 1; week <= SEASON.WEEKS; week++) {
                const opponent = shuffledOpponents[(week - 1) % shuffledOpponents.length];
                schedule.push({
                    week,
                    opponent,
                    isHome: Math.random() > 0.5,
                    result: null  // { playerScore, opponentScore, win }
                });
            }

            return schedule;
        }

        // Create a new season
        function createNewSeason() {
            const opponents = generateOpponents();
            return {
                week: 1,
                opponents,
                schedule: generateSchedule(opponents)
            };
        }

        // ========================================
        // MANAGEMENT LAYER - ECONOMY SYSTEM
        // ========================================

        // Calculate current team salary
        function calculateTeamSalary(team) {
            return team.roster.reduce((sum, p) => sum + p.salaryCost, 0);
        }

        // Check if can sign player (under cap)
        function canSignPlayer(team, player) {
            const currentSalary = calculateTeamSalary(team);
            const cap = team.salaryCap + team.salaryCapModifier;
            return currentSalary + player.salaryCost <= cap;
        }

        // Sign a free agent
        function signFreeAgent(playerId) {
            const player = managementState.freeAgents.find(p => p.id === playerId);
            if (!player) return { success: false, error: 'Player not found' };

            if (!canSignPlayer(managementState.team, player)) {
                return { success: false, error: 'Over salary cap' };
            }

            managementState.team.roster.push(player);
            managementState.freeAgents = managementState.freeAgents.filter(p => p.id !== playerId);

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true };
        }

        // Cut/release a player
        function cutPlayer(playerId) {
            const playerIndex = managementState.team.roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return { success: false, error: 'Player not found' };

            const player = managementState.team.roster[playerIndex];
            const payout = Math.floor(player.salaryCost * ECONOMY.PLAYER_SALE_RATE);

            managementState.team.credits += payout;
            managementState.team.roster.splice(playerIndex, 1);

            // Remove from depth chart
            const dc = managementState.team.depthChart;
            Object.keys(dc).forEach(slot => {
                if (Array.isArray(dc[slot])) {
                    const idx = dc[slot].indexOf(playerId);
                    if (idx !== -1) dc[slot][idx] = null;
                } else if (dc[slot] === playerId) {
                    dc[slot] = null;
                }
            });

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, payout };
        }

        // Award game revenue
        function awardGameRevenue(isHome) {
            let revenue;
            if (isHome) {
                revenue = ECONOMY.HOME_GAME_BASE +
                    (managementState.team.facilities.stadium.level * ECONOMY.HOME_GAME_STADIUM_BONUS);
            } else {
                revenue = ECONOMY.AWAY_GAME_REVENUE;
            }

            managementState.team.credits += revenue;
            return revenue;
        }

        // Upgrade facility
        function upgradeFacility(facilityType) {
            const facility = managementState.team.facilities[facilityType];
            if (!facility) return { success: false, error: 'Invalid facility' };

            if (facility.level >= facility.maxLevel) {
                return { success: false, error: 'Already at max level' };
            }

            const costs = facilityType === 'stadium'
                ? ECONOMY.STADIUM_UPGRADE_COSTS
                : ECONOMY.TRAINING_UPGRADE_COSTS;
            const cost = costs[facility.level - 1];

            if (managementState.team.credits < cost) {
                return { success: false, error: 'Insufficient credits' };
            }

            managementState.team.credits -= cost;
            facility.level++;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newLevel: facility.level, cost };
        }

        // Bribe officials for more cap space
        function bribeOfficials() {
            if (managementState.team.credits < ECONOMY.BRIBE_COST) {
                return { success: false, error: 'Insufficient credits' };
            }

            managementState.team.credits -= ECONOMY.BRIBE_COST;
            managementState.team.salaryCapModifier += ECONOMY.BRIBE_CAP_BONUS;

            if (managementState.settings.autoSave) SaveSystem.save();

            return { success: true, newCap: managementState.team.salaryCap + managementState.team.salaryCapModifier };
        }

        // ========================================
        // MANAGEMENT LAYER - PROGRESSION SYSTEM
        // ========================================

        // Process growth for a player (weekly)
        // Growth is based purely on current potential grade
        function processPlayerGrowth(player) {
            if (player.age >= player.peakAge) return [];
            if (player.potentialGrade <= 0) return []; // No growth potential left

            // Potential grade affects growth chance (0-3 scale)
            const potentialMultiplier = 0.5 + (player.potentialGrade * 0.5); // 0.5x to 2.0x
            const baseGrowthChance = PROGRESSION.GROWTH_CHANCE_BASE * potentialMultiplier;

            const positionData = POSITIONS[player.position];
            const primaryStats = positionData.primaryStats;

            const improvements = [];
            primaryStats.forEach(stat => {
                if (player.stats[stat] === undefined) return;

                // Physical stats grow very rarely
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const growthChance = isPhysical
                    ? baseGrowthChance * PROGRESSION.PHYSICAL_GROWTH_CHANCE_MULT
                    : baseGrowthChance;

                if (Math.random() < growthChance) {
                    const oldVal = player.stats[stat];
                    // Growth is always at least +1, with potential for more based on potential
                    const bonusGrowth = Math.floor(Math.random() * player.potentialGrade);
                    const growth = PROGRESSION.GROWTH_AMOUNT_MIN + bonusGrowth;
                    player.stats[stat] = Math.min(99, player.stats[stat] + growth);
                    if (player.stats[stat] > oldVal) {
                        improvements.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats);
            player.overall = calculateOverall(player);

            return improvements;
        }

        // Process decline for a player (weekly)
        function processPlayerDecline(player) {
            if (player.age < player.peakAge) return [];

            const yearsOver = player.age - player.peakAge;
            const baseDeclineRate = yearsOver * PROGRESSION.DECLINE_RATE;

            const declines = [];

            // Process all stats the player has
            Object.keys(player.stats).forEach(stat => {
                const isPhysical = PROGRESSION.PHYSICAL_STATS.includes(stat);
                const isSkill = PROGRESSION.SKILL_STATS.includes(stat);

                let declineRate;
                let minStat = PROGRESSION.MIN_STAT;

                if (isPhysical) {
                    // Physical stats: gentle decline years 1-3, steep decline years 4+
                    const isLateDecline = yearsOver >= PROGRESSION.PHYSICAL_DECLINE_LATE_START;
                    const physicalMult = isLateDecline
                        ? PROGRESSION.PHYSICAL_DECLINE_LATE_MULT
                        : PROGRESSION.PHYSICAL_DECLINE_EARLY_MULT;
                    declineRate = baseDeclineRate * physicalMult;
                } else if (isSkill) {
                    // Skill stats barely decline (10% of normal)
                    declineRate = baseDeclineRate * PROGRESSION.SKILL_DECLINE_MULT;
                    minStat = PROGRESSION.MIN_STAT + 15; // Skills floor higher
                } else {
                    // Other stats decline normally
                    declineRate = baseDeclineRate;
                }

                // Apply decline with some randomness
                if (Math.random() < 0.5 + (yearsOver * 0.1)) { // More likely to decline as years pass
                    const oldVal = player.stats[stat];
                    const actualDecline = declineRate * (0.5 + Math.random()); // 50-150% of rate
                    player.stats[stat] = Math.max(minStat, player.stats[stat] - actualDecline);
                    if (player.stats[stat] < oldVal) {
                        declines.push({ stat, change: player.stats[stat] - oldVal });
                    }
                }
            });

            // Recalculate derived values
            player.salaryCost = calculateSalary(player.stats);
            player.overall = calculateOverall(player);

            return declines;
        }

        // Check if player should retire
        function checkRetirement(player) {
            if (player.age > PROGRESSION.MAX_AGE) return true;

            const statValues = Object.values(player.stats);
            const avgStat = statValues.reduce((a, b) => a + b, 0) / statValues.length;

            return avgStat < PROGRESSION.MIN_AVERAGE_STAT;
        }

        // Process weekly progression for all players
        function processWeeklyProgression() {
            const results = {
                improvements: [],
                declines: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                // Growth or decline
                const improvements = processPlayerGrowth(player);
                const declines = processPlayerDecline(player);

                if (improvements.length > 0) {
                    results.improvements.push({ player, improvements });
                }
                if (declines.length > 0) {
                    results.declines.push({ player, declines });
                }

                // Check retirement
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            return results;
        }

        // Process end of season (age all players)
        function processEndOfSeason() {
            const results = {
                ageUps: [],
                retirements: []
            };

            const toRemove = [];

            managementState.team.roster.forEach(player => {
                player.age++;
                player.yearsInLeague = (player.yearsInLeague || 0) + 1;
                results.ageUps.push(player);

                // Potential decay: chance for potential to drop each year
                // Much higher chance after year 3
                if (player.potentialGrade > 0 && player.age < player.peakAge) {
                    const decayChance = player.yearsInLeague <= 3
                        ? PROGRESSION.POTENTIAL_DECAY_EARLY
                        : PROGRESSION.POTENTIAL_DECAY_LATE;

                    if (Math.random() < decayChance) {
                        // Chance to drop 2 levels instead of 1
                        const dropAmount = Math.random() < PROGRESSION.POTENTIAL_DROP_TWO_CHANCE ? 2 : 1;
                        player.potentialGrade = Math.max(0, player.potentialGrade - dropAmount);
                    }
                }

                // Record career history before resetting
                if (!player.careerHistory) player.careerHistory = [];
                player.careerHistory.push({
                    season: player.careerHistory.length,
                    overall: player.overall,
                    potential: player.potentialGrade,
                    gamesPlayed: player.gamesPlayed || 0,
                    tds: player.seasonTDs || 0,
                    catches: player.seasonCatches || 0,
                    targets: player.seasonTargets || 0,
                    tackles: player.seasonTackles || 0,
                    clashesWon: player.seasonClashesWon || 0,
                    clashesLost: player.seasonClashesLost || 0,
                    sacks: player.seasonSacks || 0,
                    passesDefended: player.seasonPassesDefended || 0
                });

                // Reset season stats
                player.seasonStartStats = { ...player.stats };
                player.gamesPlayed = 0;
                player.seasonTDs = 0;
                player.seasonCatches = 0;
                player.seasonTargets = 0;
                player.seasonTackles = 0;
                player.seasonClashesWon = 0;
                player.seasonClashesLost = 0;
                player.seasonSacks = 0;
                player.seasonPassesDefended = 0;

                // Check retirement after aging
                if (checkRetirement(player)) {
                    results.retirements.push(player);
                    toRemove.push(player.id);
                }
            });

            // Remove retired players
            toRemove.forEach(id => {
                cutPlayer(id);
            });

            // Create new season
            managementState.season = createNewSeason();

            // Refresh free agents
            refreshFreeAgents();

            if (managementState.settings.autoSave) SaveSystem.save();

            return results;
        }

        // ========================================
        // MANAGEMENT LAYER - FREE AGENCY
        // ========================================

        // Roll tier for free agent (weighted towards average)
        function rollFreeAgentTier() {
            const roll = Math.random();
            if (roll < 0.1) return 'elite';      // 10%
            if (roll < 0.25) return 'veteran';   // 15%
            if (roll < 0.75) return 'average';   // 50%
            return 'rookie';                      // 25%
        }

        // Refresh free agent pool
        function refreshFreeAgents() {
            managementState.freeAgents = [];

            const count = randomInt(5, 8);
            const positions = ['WR', 'CB', 'OL', 'DL'];

            for (let i = 0; i < count; i++) {
                const position = randomFrom(positions);
                const tier = rollFreeAgentTier();
                managementState.freeAgents.push(generatePlayer(position, tier));
            }
        }

        // ========================================
        // MANAGEMENT LAYER - MATCH SIMULATION
        // ========================================

        // Calculate team defense rating
        function calculateTeamDefenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // CBs
            ['CB1', 'CB2', 'CB3', 'CB4'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.manCoverage + player.stats.zoneCoverage + player.stats.tackling) / 3;
                        count++;
                    }
                }
            });

            // DL
            dc.DL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passRush + player.stats.tackling) / 2;
                        count++;
                    }
                }
            });

            return count > 0 ? total / count : 50;
        }

        // Calculate team offense rating
        function calculateTeamOffenseRating() {
            const dc = managementState.team.depthChart;
            const roster = managementState.team.roster;

            let total = 0;
            let count = 0;

            // WRs
            ['WR1', 'WR2', 'WR3'].forEach(slot => {
                const playerId = dc[slot];
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.speed + player.stats.catching + player.stats.routeRunning) / 3;
                        count++;
                    }
                }
            });

            // OL
            dc.OL.forEach(playerId => {
                if (playerId) {
                    const player = roster.find(p => p.id === playerId);
                    if (player) {
                        total += (player.stats.passBlock + player.stats.strength) / 2;
                        count++;
                    }
                }
            });

            // QB
            if (dc.QB) {
                const qb = roster.find(p => p.id === dc.QB);
                if (qb) {
                    total += (qb.stats.throwing + qb.stats.awareness) / 2;
                    count++;
                }
            }

            return count > 0 ? total / count : 50;
        }

        // Simulate enemy possession (when player loses possession)
        function simulateEnemyPossession(opponent) {
            const defenseRating = calculateTeamDefenseRating();
            const offenseRating = opponent.offenseRating;

            // Differential affects probabilities
            const differential = offenseRating - defenseRating;

            // Base probabilities adjusted by differential
            const tdChance = Math.max(5, Math.min(40, 20 + (differential * 0.3)));
            const fgChance = Math.max(10, Math.min(35, 25 + (differential * 0.2)));

            const roll = Math.random() * 100;

            // Generate narrative with key plays
            const narrative = generateDriveNarrative(opponent, roll, tdChance, fgChance);

            if (roll < tdChance) return { points: 7, type: 'TD', narrative };
            if (roll < tdChance + fgChance) return { points: 3, type: 'FG', narrative };
            return { points: 0, type: 'STOP', narrative };
        }

        // Generate narrative plays for enemy drive (returns array for progressive display)
        function generateDriveNarrative(opponent, roll, tdChance, fgChance) {
            // Get random player names from your roster for defensive mentions
            const defenders = (managementState.team?.roster || []).filter(p =>
                ['CB', 'S', 'LB', 'DL'].includes(p.position)
            );
            const getDefenderName = () => {
                if (defenders.length === 0) return 'the defense';
                const d = defenders[Math.floor(Math.random() * defenders.length)];
                return `${d.firstName} ${d.lastName.charAt(0)}.`;
            };

            // Opponent player names (fictional based on team)
            const teamShort = opponent.name.split(' ')[0];
            const oppQB = `${teamShort} QB`;
            const oppWR = `${teamShort} receiver`;
            const oppRB = `${teamShort} runner`;

            if (roll < tdChance) {
                // TD drive - 4-5 plays
                const plays = [
                    `1st & 10: ${oppQB} hits ${oppWR} for 12 yards.`,
                    `1st & 10: ${oppRB} bursts through for 8 yards.`,
                    `2nd & 2: Play action! ${oppWR} gets behind ${getDefenderName()} for 25 yards!`,
                    `1st & Goal: ${oppQB} rolls out...`,
                    `TOUCHDOWN ${opponent.name}! ${oppQB} finds ${oppWR} in the corner of the end zone.`
                ];
                return plays;
            } else if (roll < tdChance + fgChance) {
                // FG drive - 4-5 plays
                const plays = [
                    `1st & 10: ${oppQB} throws short to ${oppWR} for 7 yards.`,
                    `2nd & 3: ${oppRB} runs for 4 yards. First down.`,
                    `1st & 10: ${getDefenderName()} with tight coverage! Incomplete.`,
                    `2nd & 10: ${oppQB} scrambles for 5 yards.`,
                    `3rd & 5: Pass broken up by ${getDefenderName()}! Field goal unit comes on.`,
                    `Field goal is GOOD from 38 yards.`
                ];
                return plays;
            } else {
                // Defensive stop - 3-4 plays
                const stopType = Math.floor(Math.random() * 4);
                if (stopType === 0) {
                    return [
                        `1st & 10: ${oppQB} drops back...`,
                        `${getDefenderName()} jumps the route!`,
                        `INTERCEPTION! ${getDefenderName()} returns it 15 yards!`
                    ];
                } else if (stopType === 1) {
                    return [
                        `1st & 10: ${oppRB} stuffed at the line by ${getDefenderName()}.`,
                        `2nd & 11: ${oppQB} sacked! ${getDefenderName()} with the pressure!`,
                        `3rd & 18: Incomplete. ${opponent.name} forced to punt.`
                    ];
                } else if (stopType === 2) {
                    return [
                        `1st & 10: Short pass to ${oppWR} for 3 yards.`,
                        `2nd & 7: ${oppRB} runs for 2 yards.`,
                        `3rd & 5: ${getDefenderName()} with the pass breakup!`,
                        `4th & 5: ${opponent.name} goes for it... Incomplete! Turnover on downs!`
                    ];
                } else {
                    return [
                        `1st & 10: ${oppQB} under pressure, throws it away.`,
                        `2nd & 10: ${getDefenderName()} forces a fumble!`,
                        `TURNOVER! Your ball!`
                    ];
                }
            }
        }

        // Start a match
        function startMatch() {
            if (!managementState.season || managementState.season.week > SEASON.WEEKS) {
                return { success: false, error: 'Season is over' };
            }

            const game = managementState.season.schedule[managementState.season.week - 1];
            if (game.result) {
                return { success: false, error: 'Game already played' };
            }

            managementState.matchInProgress = true;
            managementState.currentPossession = 0;
            managementState.matchScore = { player: 0, opponent: 0 };
            managementState.currentScreen = 'game';

            return { success: true, opponent: game.opponent, isHome: game.isHome };
        }

        // Record possession result (called after each arcade possession)
        function recordPossessionResult(points) {
            if (!managementState.matchInProgress) return;

            managementState.matchScore.player += points;

            // Enemy gets counter-possession
            const game = managementState.season.schedule[managementState.season.week - 1];
            const enemyResult = simulateEnemyPossession(game.opponent);
            managementState.matchScore.opponent += enemyResult.points;

            managementState.currentPossession++;

            // Check if match is over
            if (managementState.currentPossession >= SEASON.POSSESSIONS_PER_GAME) {
                return endMatch();
            }

            return {
                ongoing: true,
                possession: managementState.currentPossession,
                score: managementState.matchScore,
                enemyResult
            };
        }

        // End match
        function endMatch() {
            if (!managementState.matchInProgress) return null;

            const game = managementState.season.schedule[managementState.season.week - 1];
            const win = managementState.matchScore.player > managementState.matchScore.opponent;

            // Record result
            game.result = {
                playerScore: managementState.matchScore.player,
                opponentScore: managementState.matchScore.opponent,
                win
            };

            // Update records
            if (win) {
                managementState.team.record.wins++;
            } else {
                managementState.team.record.losses++;
            }

            // Award revenue
            const revenue = awardGameRevenue(game.isHome);

            // Process weekly progression
            const progressionResults = processWeeklyProgression();

            // Advance week
            managementState.season.week++;

            // Check end of season
            let seasonEnded = false;
            if (managementState.season.week > SEASON.WEEKS) {
                processEndOfSeason();
                seasonEnded = true;
            }

            managementState.matchInProgress = false;
            managementState.currentScreen = 'hub';

            if (managementState.settings.autoSave) SaveSystem.save();

            return {
                ongoing: false,
                result: game.result,
                revenue,
                progression: progressionResults,
                seasonEnded
            };
        }

        // ========================================
        // MANAGEMENT LAYER - GAME INTEGRATION
        // ========================================

        // Get player from depth chart slot
        function getDepthChartPlayer(slot) {
            const dc = managementState.team.depthChart;
            let playerId;

            if (Array.isArray(dc[slot])) {
                // For OL/DL arrays, slot should be like 'OL' with index
                return null;  // Handle differently
            } else {
                playerId = dc[slot];
            }

            if (!playerId) return null;
            return managementState.team.roster.find(p => p.id === playerId);
        }

        // Generate walk-on player (very low stats) for empty slots
        function generateWalkOn(position) {
            const player = generatePlayer(position, 'rookie');
            // Reduce all stats significantly
            Object.keys(player.stats).forEach(stat => {
                player.stats[stat] = Math.max(20, player.stats[stat] - 30);
            });
            player.firstName = 'Recruit';
            player.lastName = position;
            player.salaryCost = 0;
            player.overall = calculateOverall(player);
            return player;
        }

        // Convert roster player to game receiver config
        function playerToReceiverConfig(player, index, startZ) {
            const xPositions = [-5, 0, 5];
            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                lastName: player.lastName,
                overall: player.overall || calculateOverall(player),
                playerId: player.id,
                start: new BABYLON.Vector3(xPositions[index], 0, startZ),
                route: [],  // Will be generated
                stats: { ...player.stats }
            };
        }

        // Convert roster player to game defender config
        function playerToDefenderConfig(player, index, startZ, receiverIndex) {
            const aiTypes = ['man', 'man', 'man', 'zone'];
            const cushions = [2, 4, 3, 4];
            const zoneColors = [
                new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(0.6, 0.2, 0.8),
                new BABYLON.Color3(1.0, 0.5, 0.1)   // Orange for zone
            ];

            return {
                name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                playerId: player.id,
                aiType: aiTypes[index],
                assignedReceiver: receiverIndex !== undefined ? receiverIndex : index,
                cushion: cushions[index],
                zoneCenter: index === 3 ? new BABYLON.Vector3(0, 0, startZ + 8) : null,
                zoneRadius: index === 3 ? 6 : 0,
                zoneColor: zoneColors[index],
                stats: { ...player.stats }
            };
        }

        // Get receiver configs from roster
        function getReceiverConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            ['WR1', 'WR2', 'WR3'].forEach((slot, index) => {
                let player = getDepthChartPlayer(slot);
                if (!player) {
                    player = generateWalkOn('WR');
                }
                configs.push(playerToReceiverConfig(player, index, RECEIVER_START_Z));
            });

            return configs;
        }

        // Get defender configs from roster
        function getDefenderConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;  // Use defaults
            }

            const RECEIVER_START_Z = QB_START_Z + 2;
            const configs = [];

            ['CB1', 'CB2', 'CB3', 'CB4'].forEach((slot, index) => {
                let player = getDepthChartPlayer(slot);
                if (!player) {
                    player = generateWalkOn('CB');
                }
                configs.push(playerToDefenderConfig(player, index, RECEIVER_START_Z, index < 3 ? index : undefined));
            });

            return configs;
        }

        // Get OL configs from roster
        function getOLineConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;
            }

            const configs = [];
            const posLabels = ['C', 'LG', 'RG', 'LT', 'RT'];

            managementState.team.depthChart.OL.forEach((playerId, index) => {
                let player = playerId ? managementState.team.roster.find(p => p.id === playerId) : null;
                if (!player) {
                    player = generateWalkOn('OL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[index],
                    stats: { ...player.stats }
                });
            });

            return configs;
        }

        // Get DL configs from roster
        function getDLineConfigsFromRoster() {
            if (!managementState.initialized || !managementState.team) {
                return null;
            }

            const configs = [];
            const posLabels = ['LDE', 'LDT', 'RDT', 'RDE'];

            managementState.team.depthChart.DL.forEach((playerId, index) => {
                let player = playerId ? managementState.team.roster.find(p => p.id === playerId) : null;
                if (!player) {
                    player = generateWalkOn('DL');
                }
                configs.push({
                    name: `${player.firstName} ${player.lastName.charAt(0)}.`,
                    playerId: player.id,
                    position_label: posLabels[index],
                    stats: { ...player.stats }
                });
            });

            return configs;
        }

        // Record a stat for a roster player by their in-game mesh
        function recordPlayerStat(gameMesh, statName, increment = 1) {
            if (!gameMesh || !gameMesh.playerId) return;
            if (!managementState.team || !managementState.team.roster) return;

            const player = managementState.team.roster.find(p => p.id === gameMesh.playerId);
            if (!player) return;

            // Initialize stat if it doesn't exist
            if (player[statName] === undefined) player[statName] = 0;
            player[statName] += increment;
        }

        // Initialize management system
        function initializeManagement() {
            // Try to load existing save
            if (SaveSystem.exists()) {
                const saveData = SaveSystem.load();
                if (saveData && SaveSystem.applySaveData(saveData)) {
                    console.log('Loaded existing save');
                    managementState.currentScreen = 'hub';
                    return;
                }
            }

            // No save - show main menu
            managementState.currentScreen = 'main_menu';
        }

        // Start new game
        function startNewGame(teamName = 'Your Knights') {
            managementState.team = createNewTeam(teamName);
            managementState.season = createNewSeason();
            refreshFreeAgents();
            managementState.initialized = true;
            managementState.currentScreen = 'hub';

            SaveSystem.save();
        }

        // Constants
        const FIELD_WIDTH = 16;  // Doubled width
        const FIELD_LENGTH = 20;
        const QB_START_Z = -6;  // Moved back (closer to bottom of screen)
        const MAX_THROW_DISTANCE = 18;  // Can overthrow into endzone
        const MIN_THROW_DISTANCE = 2;
        const DRAG_SENSITIVITY = 0.12;  // More responsive - bottom of screen = max throw

        // Initialize Babylon.js
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true
        });
        // Set hardware scaling for sharp rendering on high-DPI screens
        engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

        // Create Scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.18, 1);

            // Isometric Camera - adjusted for wider field, target lower
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                -Math.PI / 2,  // Alpha - looking down the field
                Math.PI / 3.5, // Beta - slightly steeper angle
                32,            // Radius - further out for wider field
                new BABYLON.Vector3(0, 0, 2),  // Target moved down to show QB better
                scene
            );
            // Camera is view-only, no user controls
            scene.activeCamera = camera;

            // Lighting
            const light = new BABYLON.HemisphericLight(
                'light',
                new BABYLON.Vector3(0.5, 1, 0.3),
                scene
            );
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
            light.groundColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Secondary directional light for shadows
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-0.5, -1, 0.5),
                scene
            );
            dirLight.intensity = 0.4;

            // Create Materials
            const materials = createMaterials(scene);

            // Create Field
            createField(scene, materials);

            // Create Quarterback
            const qb = createKnight(scene, materials.qbMaterial, new BABYLON.Vector3(0, 0, QB_START_Z));
            qb.name = 'quarterback';

            // Create Receivers with routes - all start at same yardline, close to QB
            const RECEIVER_START_Z = QB_START_Z + 2;  // Close to QB, same line

            // Try to get roster configs, fall back to defaults
            const rosterReceiverConfigs = getReceiverConfigsFromRoster();
            const receiverConfigs = rosterReceiverConfigs || [
                {
                    name: "Sir Aldric",
                    start: new BABYLON.Vector3(-5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 6, x: -5 },    // Run straight
                        { z: RECEIVER_START_Z + 12, x: -2 }    // Jink inward
                    ],
                    stats: {
                        speed: 80, acceleration: 72, agility: 85,
                        routeRunning: 88, release: 75, catching: 80,
                        jumping: 70, strength: 60, balance: 72,
                        aggression: 45, stamina: 80, focus: 88
                    }
                },
                {
                    name: "Swift Roderick",
                    start: new BABYLON.Vector3(0, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 14, x: 0 }     // Straight up (burner)
                    ],
                    stats: {
                        speed: 80, acceleration: 92, agility: 78,
                        routeRunning: 65, release: 70, catching: 80,
                        jumping: 75, strength: 50, balance: 60,
                        aggression: 40, stamina: 85, focus: 68
                    }
                },
                {
                    name: "Baron Wyatt",
                    start: new BABYLON.Vector3(5, 0, RECEIVER_START_Z),
                    route: [
                        { z: RECEIVER_START_Z + 5, x: 5 },     // Run straight
                        { z: RECEIVER_START_Z + 11, x: 7 }     // Jink outward
                    ],
                    stats: {
                        speed: 80, acceleration: 78, agility: 80,
                        routeRunning: 82, release: 78, catching: 80,
                        jumping: 82, strength: 72, balance: 78,
                        aggression: 55, stamina: 82, focus: 80
                    }
                }
            ];

            // Defender configurations - try roster first
            const rosterDefenderConfigs = getDefenderConfigsFromRoster();
            const defenderConfigs = rosterDefenderConfigs || [
                {
                    name: "The Black Knight",
                    aiType: 'man',
                    assignedReceiver: 0,  // Covers Sir Aldric
                    cushion: 2,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 70, agility: 75,
                        manCoverage: 80, zoneCoverage: 80, press: 78,
                        tackling: 80, hitPower: 85, pursuit: 75,
                        awareness: 72, strength: 82, balance: 78,
                        aggression: 75, stamina: 78
                    }
                },
                {
                    name: "Shadow Sentinel",
                    aiType: 'man',
                    assignedReceiver: 1,  // Covers Swift Roderick
                    cushion: 4,           // Plays off the speedy receiver
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 85, agility: 82,
                        manCoverage: 80, zoneCoverage: 80, press: 60,
                        tackling: 70, hitPower: 65, pursuit: 90,
                        awareness: 75, strength: 65, balance: 72,
                        aggression: 55, stamina: 88
                    }
                },
                {
                    name: "Iron Warden",
                    aiType: 'man',
                    assignedReceiver: 2,  // Covers Baron Wyatt
                    cushion: 3,
                    zoneColor: new BABYLON.Color3(0.6, 0.2, 0.8),  // Purple for man
                    stats: {
                        speed: 80, acceleration: 68, agility: 70,
                        manCoverage: 80, zoneCoverage: 80, press: 72,
                        tackling: 85, hitPower: 90, pursuit: 72,
                        awareness: 85, strength: 88, balance: 82,
                        aggression: 70, stamina: 75
                    }
                },
                {
                    name: "The Sentinel",
                    aiType: 'zone',
                    zoneCenter: new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 8),
                    zoneRadius: 6,
                    cushion: 4,
                    zoneColor: new BABYLON.Color3(1.0, 0.5, 0.1),  // Orange for zone
                    stats: {
                        speed: 80, acceleration: 72, agility: 78,
                        manCoverage: 80, zoneCoverage: 80, press: 65,
                        tackling: 78, hitPower: 75, pursuit: 80,
                        awareness: 88, strength: 75, balance: 80,
                        aggression: 60, stamina: 82
                    }
                }
            ];

            // Route line material
            const routeMat = new BABYLON.StandardMaterial('routeMat', scene);
            routeMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1);
            routeMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            routeMat.alpha = 0.6;

            // Store references for route regeneration
            gameState.scene = scene;
            gameState.routeMaterial = routeMat;

            receiverConfigs.forEach((config, i) => {
                // Clone material so each receiver can flash independently
                const receiverMat = materials.receiverMaterial.clone(`receiverMat_${i}`);
                const receiver = createKnight(scene, receiverMat, config.start.clone());
                receiver.name = `receiver_${i}`;
                receiver.bodyMaterial = receiverMat;
                receiver.originalColor = receiverMat.diffuseColor.clone();

                // Store config data on receiver
                receiver.displayName = config.name;
                receiver.lastName = config.lastName || config.name.split(' ').pop();  // Extract last name from display name if not provided
                receiver.overall = config.overall || Math.round(Object.values(config.stats).reduce((a, b) => a + b, 0) / Object.keys(config.stats).length);
                receiver.playerId = config.playerId || null;  // Link to roster player
                receiver.route = config.route;
                receiver.routeIndex = 0;
                receiver.startPos = config.start.clone();
                receiver.stats = config.stats;

                // Derive base speed from stats (normalized to game units)
                receiver.baseSpeed = config.stats.speed * 0.0005;  // Scale stat to movement speed
                receiver.speed = receiver.baseSpeed;

                // Clash system runtime state
                receiver.separationState = 'contested';  // Legacy - kept for compatibility
                receiver.clashSpeedPenaltyUntil = 0;  // Clash loser speed penalty timer
                receiver.lastClashTime = 0;
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.hasHadInitialClash = false;
                receiver.lastRouteIndex = 0;  // Track route changes for jink clashes
                receiver.initialClashSlowdownUntil = 0;  // Slowdown during first contact

                // Add catch zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const zoneRing = BABYLON.MeshBuilder.CreateTorus('zoneRing_' + i, {
                    diameter: 2.4,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const ringMat = new BABYLON.StandardMaterial('ringMat_' + i, scene);
                ringMat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);  // Yellow for contested
                ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
                ringMat.alpha = 0.8;
                zoneRing.material = ringMat;
                zoneRing.position.y = 0.03;
                zoneRing.parent = receiver;

                // Fill disc (shows coverage proximity)
                const zoneFill = BABYLON.MeshBuilder.CreateDisc('zoneFill_' + i, {
                    radius: 1.2,
                    tessellation: 32
                }, scene);
                zoneFill.rotation.x = Math.PI / 2;  // Lay flat
                const fillMat = new BABYLON.StandardMaterial('fillMat_' + i, scene);
                fillMat.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);  // White
                fillMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                fillMat.alpha = 0.5;  // Base visibility
                zoneFill.material = fillMat;
                zoneFill.position.y = 0.02;
                zoneFill.parent = receiver;
                zoneFill.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);  // Start with base visible circle

                receiver.zoneRing = zoneRing;
                receiver.zoneFill = zoneFill;
                receiver.ringMaterial = ringMat;
                receiver.fillMaterial = fillMat;
                receiver.coverageAmount = 0;  // 0-1 how much defender is covering
                receiver.clashFlashUntil = 0;  // For clash animation
                receiver.clashTiltUntil = 0;  // For grappling tilt
                receiver.clashTiltAngle = 0;
                receiver.loserFlashUntil = 0;   // Red flash when losing clash
                receiver.winnerFlashUntil = 0;  // Green flash when winning clash
                receiver.clashSpeedBoostUntil = 0;  // Speed boost timer

                // Hide the outer ring - only show proximity-based fill
                zoneRing.setEnabled(false);

                // Draw route line on field
                const routePoints = [config.start.clone()];
                routePoints[0].y = 0.05;
                config.route.forEach(point => {
                    routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
                });

                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + i, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, scene);
                routeLine.material = routeMat;
                receiver.routeLine = routeLine;

                gameState.receivers.push(receiver);
                gameState.receiversStartZ.push(config.start.z);
            });

            // Create Defenders
            // Line of scrimmage is at RECEIVER_START_Z - defenders spawn above it
            defenderConfigs.forEach((config, i) => {
                // Calculate starting position - defenders start ABOVE line of scrimmage
                let startPos;
                if (config.aiType === 'man' && config.assignedReceiver !== undefined) {
                    const targetReceiver = receiverConfigs[config.assignedReceiver];
                    startPos = new BABYLON.Vector3(
                        targetReceiver.start.x,
                        0,
                        targetReceiver.start.z + config.cushion  // Above receiver (+ cushion)
                    );
                } else if (config.aiType === 'zone') {
                    startPos = config.zoneCenter.clone();
                    // Zone defenders already positioned by zoneCenter, cushion is depth into field
                } else {
                    // Blitzer starts at line of scrimmage
                    startPos = new BABYLON.Vector3(0, 0, RECEIVER_START_Z + 1);
                }

                // Clone material so each defender can flash independently
                const defenderMat = materials.defenderMaterial.clone(`defenderMat_${i}`);
                const defender = createKnight(scene, defenderMat, startPos);
                defender.name = `defender_${i}`;
                defender.bodyMaterial = defenderMat;
                defender.originalColor = defenderMat.diffuseColor.clone();

                // Store config data on defender
                defender.displayName = config.name;
                defender.playerId = config.playerId || null;  // Link to roster player
                defender.aiType = config.aiType;
                defender.assignedReceiver = config.assignedReceiver;
                defender.cushion = config.cushion;
                defender.zoneCenter = config.zoneCenter;
                defender.zoneRadius = config.zoneRadius || 5;
                defender.stats = config.stats;
                defender.startPos = startPos.clone();

                // Derive base speed from stats
                defender.baseSpeed = config.stats.speed * 0.0005;
                defender.speed = defender.baseSpeed;

                // Clash system runtime state
                defender.lastClashTime = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.initialClashSlowdownUntil = 0;  // Slowdown during first contact
                defender.clashSpeedPenaltyUntil = 0;  // Speed penalty from losing clash

                // Add defender zone indicator - ring outline + fill disc
                // Ring (outer indicator)
                const defRing = BABYLON.MeshBuilder.CreateTorus('defRing_' + i, {
                    diameter: 2.8,
                    thickness: 0.1,
                    tessellation: 32
                }, scene);
                const defRingMat = new BABYLON.StandardMaterial('defRingMat_' + i, scene);
                defRingMat.diffuseColor = config.zoneColor;
                defRingMat.emissiveColor = config.zoneColor.scale(0.4);
                defRingMat.alpha = 0.8;
                defRing.material = defRingMat;
                defRing.position.y = 0.03;
                defRing.parent = defender;

                // Fill disc (shows coverage engagement)
                const defFill = BABYLON.MeshBuilder.CreateDisc('defFill_' + i, {
                    radius: 1.4,
                    tessellation: 32
                }, scene);
                defFill.rotation.x = Math.PI / 2;  // Lay flat
                const defFillMat = new BABYLON.StandardMaterial('defFillMat_' + i, scene);
                defFillMat.diffuseColor = config.zoneColor;
                defFillMat.emissiveColor = config.zoneColor.scale(0.2);
                defFillMat.alpha = 0;  // Start invisible
                defFill.material = defFillMat;
                defFill.position.y = 0.01;
                defFill.parent = defender;
                defFill.scaling = new BABYLON.Vector3(0, 0, 0);  // Start with no fill

                defender.zoneRing = defRing;
                defender.zoneFill = defFill;
                defender.ringMaterial = defRingMat;
                defender.fillMaterial = defFillMat;
                defender.baseZoneColor = config.zoneColor.clone();
                defender.clashFlashUntil = 0;  // For clash animation
                defender.clashTiltUntil = 0;  // For grappling tilt
                defender.clashTiltAngle = 0;
                defender.loserFlashUntil = 0;   // Red flash when losing clash
                defender.winnerFlashUntil = 0;  // Green flash when winning clash

                // Apply feature flag for defender zone visibility
                defRing.setEnabled(FEATURE_FLAGS.showDefenderZones);
                defFill.setEnabled(FEATURE_FLAGS.showDefenderZones);

                gameState.defenders.push(defender);
            });

            // Offensive Line configurations (5 players) - try roster first
            const LINE_OF_SCRIMMAGE_Z = RECEIVER_START_Z;  // Same as receivers start
            const rosterOLineConfigs = getOLineConfigsFromRoster();
            const defaultOLineConfigs = [
                {
                    name: "Sir Bulwark",
                    position: 'C',
                    startX: 0,
                    stats: { passBlock: 82, strength: 80, balance: 85, awareness: 80, speed: 60, acceleration: 65 }
                },
                {
                    name: "Ironside",
                    position: 'LG',
                    startX: -1.5,
                    stats: { passBlock: 80, strength: 85, balance: 78, awareness: 75, speed: 58, acceleration: 62 }
                },
                {
                    name: "Stonewall",
                    position: 'RG',
                    startX: 1.5,
                    stats: { passBlock: 78, strength: 88, balance: 80, awareness: 72, speed: 55, acceleration: 60 }
                },
                {
                    name: "Rampart",
                    position: 'LT',
                    startX: -3.5,
                    stats: { passBlock: 85, strength: 78, balance: 82, awareness: 78, speed: 62, acceleration: 68 }
                },
                {
                    name: "Bastion",
                    position: 'RT',
                    startX: 3.5,
                    stats: { passBlock: 83, strength: 80, balance: 80, awareness: 76, speed: 60, acceleration: 65 }
                }
            ];
            // Merge roster configs with default positions/startX
            const oLineConfigs = rosterOLineConfigs ? rosterOLineConfigs.map((rc, i) => ({
                ...defaultOLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultOLineConfigs;

            // Create Offensive Line
            oLineConfigs.forEach((config, i) => {
                const oLineMat = materials.oLineMaterial.clone(`oLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z - 0.5);
                const oLineman = createLineman(scene, oLineMat, startPos, true);
                oLineman.name = `oline_${i}`;
                oLineman.displayName = config.name;
                oLineman.playerId = config.playerId || null;  // Link to roster player
                oLineman.position_label = config.position;
                oLineman.stats = config.stats;
                oLineman.startPos = startPos.clone();
                oLineman.baseSpeed = config.stats.speed * 0.0004;
                oLineman.speed = oLineman.baseSpeed;

                // Blocking state
                oLineman.engagedWith = null;         // D-lineman currently blocking
                oLineman.lastClashTime = 0;
                oLineman.knockdownUntil = 0;
                oLineman.bodyMaterial = oLineMat;
                oLineman.originalColor = oLineMat.diffuseColor.clone();

                gameState.offensiveLine.push(oLineman);
            });

            // Defensive Line configurations (4 players) - try roster first
            const rosterDLineConfigs = getDLineConfigsFromRoster();
            const defaultDLineConfigs = [
                {
                    name: "Siege Breaker",
                    position: 'LDE',
                    startX: -3,
                    stats: { passRush: 82, strength: 80, acceleration: 78, speed: 72, awareness: 75, tackling: 80 }
                },
                {
                    name: "Crusher",
                    position: 'LDT',
                    startX: -1,
                    stats: { passRush: 78, strength: 90, acceleration: 70, speed: 65, awareness: 72, tackling: 82 }
                },
                {
                    name: "Devastator",
                    position: 'RDT',
                    startX: 1,
                    stats: { passRush: 80, strength: 88, acceleration: 72, speed: 68, awareness: 74, tackling: 80 }
                },
                {
                    name: "Ramraid",
                    position: 'RDE',
                    startX: 3,
                    stats: { passRush: 85, strength: 78, acceleration: 82, speed: 75, awareness: 78, tackling: 78 }
                }
            ];
            // Merge roster configs with default positions/startX
            const dLineConfigs = rosterDLineConfigs ? rosterDLineConfigs.map((rc, i) => ({
                ...defaultDLineConfigs[i],
                name: rc.name,
                playerId: rc.playerId,
                stats: rc.stats
            })) : defaultDLineConfigs;

            // Create Defensive Line
            dLineConfigs.forEach((config, i) => {
                const dLineMat = materials.dLineMaterial.clone(`dLineMat_${i}`);
                const startPos = new BABYLON.Vector3(config.startX, 0, LINE_OF_SCRIMMAGE_Z + 0.5);
                const dLineman = createLineman(scene, dLineMat, startPos, false);
                dLineman.name = `dline_${i}`;
                dLineman.displayName = config.name;
                dLineman.playerId = config.playerId || null;  // Link to roster player
                dLineman.position_label = config.position;
                dLineman.stats = config.stats;
                dLineman.startPos = startPos.clone();
                dLineman.baseSpeed = config.stats.speed * 0.0005;
                dLineman.speed = dLineman.baseSpeed;

                // Pass rush state
                dLineman.engagedWith = null;         // O-lineman currently engaged with
                dLineman.lastClashTime = 0;
                dLineman.knockdownUntil = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial = dLineMat;
                dLineman.originalColor = dLineMat.diffuseColor.clone();

                gameState.defensiveLine.push(dLineman);
            });

            // Create GUI for player name labels
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI', true, scene);

            // Get QB data from roster
            let qbPlayer = null;
            if (managementState.initialized && managementState.team && managementState.team.depthChart.QB) {
                qbPlayer = managementState.team.roster.find(p => p.id === managementState.team.depthChart.QB);
            }
            if (!qbPlayer) {
                qbPlayer = { firstName: 'Knight', lastName: 'Commander', overall: 80 };
            }
            qb.lastName = qbPlayer.lastName;
            qb.overall = qbPlayer.overall;
            qb.displayName = `${qbPlayer.firstName} ${qbPlayer.lastName.charAt(0)}.`;

            // Add name label to QB
            const qbNameLabel = new BABYLON.GUI.TextBlock();
            qbNameLabel.text = `${qb.lastName} ${qb.overall}`;
            qbNameLabel.color = '#ffcc44';
            qbNameLabel.fontSize = 16;
            qbNameLabel.fontFamily = 'Courier New';
            qbNameLabel.fontWeight = 'bold';
            qbNameLabel.outlineWidth = 3;
            qbNameLabel.outlineColor = '#000000';

            const qbLabelRect = new BABYLON.GUI.Rectangle();
            qbLabelRect.width = '120px';
            qbLabelRect.height = '28px';
            qbLabelRect.cornerRadius = 4;
            qbLabelRect.thickness = 0;
            qbLabelRect.background = 'rgba(0, 0, 0, 0.6)';
            qbLabelRect.addControl(qbNameLabel);

            advancedTexture.addControl(qbLabelRect);
            qbLabelRect.linkWithMesh(qb);
            qbLabelRect.linkOffsetY = -55;
            qbLabelRect.alpha = 1;  // Show when frozen

            qb.nameLabel = qbLabelRect;

            // Add name labels to receivers
            gameState.receivers.forEach((receiver, i) => {
                const nameLabel = new BABYLON.GUI.TextBlock();
                nameLabel.text = `${receiver.lastName} ${receiver.overall}`;
                nameLabel.color = '#88bbff';
                nameLabel.fontSize = 14;
                nameLabel.fontFamily = 'Courier New';
                nameLabel.fontWeight = 'bold';
                nameLabel.outlineWidth = 2;
                nameLabel.outlineColor = '#000000';

                const labelRect = new BABYLON.GUI.Rectangle();
                labelRect.width = '120px';
                labelRect.height = '24px';
                labelRect.cornerRadius = 4;
                labelRect.thickness = 0;
                labelRect.background = 'rgba(0, 0, 0, 0.5)';
                labelRect.addControl(nameLabel);

                advancedTexture.addControl(labelRect);
                labelRect.linkWithMesh(receiver);
                labelRect.linkOffsetY = -50;
                labelRect.alpha = 1;  // Show when frozen

                receiver.nameLabel = labelRect;
            });

            // Store GUI reference
            scene.gui = advancedTexture;

            // Create Football (initially hidden)
            const football = createFootball(scene, materials);
            football.setEnabled(false);

            // Store references (use gameMaterials to avoid conflict with Babylon's scene.materials)
            scene.qb = qb;
            scene.football = football;
            scene.trajectoryDots = null;  // Created dynamically during drag
            scene.gameMaterials = materials;

            return scene;
        };

        // Create Materials
        const createMaterials = (scene) => {
            // Field material - dark green medieval grass
            const fieldMaterial = new BABYLON.StandardMaterial('fieldMat', scene);
            fieldMaterial.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);
            fieldMaterial.specularColor = new BABYLON.Color3(0.05, 0.1, 0.05);

            // QB material - gold/yellow knight
            const qbMaterial = new BABYLON.StandardMaterial('qbMat', scene);
            qbMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
            qbMaterial.specularColor = new BABYLON.Color3(1, 0.9, 0.5);
            qbMaterial.specularPower = 32;

            // Receiver material - blue knights
            const receiverMaterial = new BABYLON.StandardMaterial('receiverMat', scene);
            receiverMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            receiverMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            receiverMaterial.specularPower = 32;

            // Defender material - dark gray enemies
            const defenderMaterial = new BABYLON.StandardMaterial('defenderMat', scene);
            defenderMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            defenderMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            defenderMaterial.specularPower = 32;

            // Football material - brown leather
            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.2);
            ballMaterial.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);

            // Line material - yard lines
            const lineMaterial = new BABYLON.StandardMaterial('lineMat', scene);
            lineMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.7);
            lineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.15);

            // Trajectory material
            const trajectoryMaterial = new BABYLON.StandardMaterial('trajMat', scene);
            trajectoryMaterial.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            trajectoryMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            trajectoryMaterial.alpha = 0.7;

            // Offensive line material - similar to receivers (blue)
            const oLineMaterial = new BABYLON.StandardMaterial('oLineMat', scene);
            oLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
            oLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.6, 1);
            oLineMaterial.specularPower = 32;

            // Defensive line material - similar to defenders (dark gray)
            const dLineMaterial = new BABYLON.StandardMaterial('dLineMat', scene);
            dLineMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.28);
            dLineMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.45);
            dLineMaterial.specularPower = 32;

            return { fieldMaterial, qbMaterial, receiverMaterial, defenderMaterial, ballMaterial, lineMaterial, trajectoryMaterial, oLineMaterial, dLineMaterial };
        };

        // Create Field
        const createField = (scene, materials) => {
            // Main field (extended for deeper end zone)
            const field = BABYLON.MeshBuilder.CreateGround('field', {
                width: FIELD_WIDTH + 2,
                height: FIELD_LENGTH + 6
            }, scene);
            field.material = materials.fieldMaterial;
            field.position.z = 2.5;

            // Yard lines - only 10-yard markers (every 5 units)
            for (let i = 0; i <= 10; i += 5) {
                const line = BABYLON.MeshBuilder.CreateBox('yardLine', {
                    width: FIELD_WIDTH,
                    height: 0.02,
                    depth: 0.1
                }, scene);
                line.material = materials.lineMaterial;
                line.position.set(0, 0.01, i);
            }

            // End zone (30% deeper)
            const endZone = BABYLON.MeshBuilder.CreateGround('endzone', {
                width: FIELD_WIDTH + 2,
                height: 4
            }, scene);
            const endZoneMat = new BABYLON.StandardMaterial('endzoneMat', scene);
            endZoneMat.diffuseColor = new BABYLON.Color3(0.4, 0.15, 0.15);
            endZone.material = endZoneMat;
            endZone.position.set(0, 0.001, 13);

            // Border walls (castle-like)
            const wallHeight = 0.8;
            const wallPositions = [
                { x: -FIELD_WIDTH/2 - 0.5, z: 2.5, width: 1, depth: FIELD_LENGTH + 6 },
                { x: FIELD_WIDTH/2 + 0.5, z: 2.5, width: 1, depth: FIELD_LENGTH + 6 }
            ];

            wallPositions.forEach((wp, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall_${i}`, {
                    width: wp.width,
                    height: wallHeight,
                    depth: wp.depth
                }, scene);
                const wallMat = new BABYLON.StandardMaterial(`wallMat_${i}`, scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.35, 0.3, 0.25);
                wall.material = wallMat;
                wall.position.set(wp.x, wallHeight/2, wp.z);

                // Battlements
                for (let j = 0; j < 10; j++) {
                    const merlon = BABYLON.MeshBuilder.CreateBox(`merlon_${i}_${j}`, {
                        width: 0.4,
                        height: 0.3,
                        depth: 0.4
                    }, scene);
                    merlon.material = wallMat;
                    merlon.position.set(wp.x, wallHeight + 0.15, -7 + j * 2.2);
                }
            });

            // Line of scrimmage marker (blue)
            const losLine = BABYLON.MeshBuilder.CreateBox('losLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const losMat = new BABYLON.StandardMaterial('losMat', scene);
            losMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.9);
            losMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
            losMat.alpha = 0.8;
            losLine.material = losMat;
            losLine.position.set(0, 0.02, gameState.lineOfScrimmage);
            scene.losLine = losLine;

            // First down marker (yellow)
            const firstDownLine = BABYLON.MeshBuilder.CreateBox('firstDownLine', {
                width: FIELD_WIDTH,
                height: 0.03,
                depth: 0.15
            }, scene);
            const fdMat = new BABYLON.StandardMaterial('fdMat', scene);
            fdMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.2);
            fdMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.1);
            fdMat.alpha = 0.8;
            firstDownLine.material = fdMat;
            firstDownLine.position.set(0, 0.02, gameState.firstDownMarker);
            scene.firstDownLine = firstDownLine;
        };

        // Create Knight Figure
        const createKnight = (scene, material, position) => {
            const knight = new BABYLON.TransformNode('knight', scene);

            // Body (shield shape)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8,
                diameterTop: 0.4,
                diameterBottom: 0.6,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4;
            body.parent = knight;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95;
            head.parent = knight;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25,
                diameterTop: 0.05,
                diameterBottom: 0.12,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2;
            plume.parent = knight;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35,
                height: 0.45,
                depth: 0.08
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3, 0.5, 0.1);
            shield.parent = knight;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = knight;

            knight.position = position;
            knight.idleTime = Math.random() * Math.PI * 2;

            return knight;
        };

        // Create Lineman Figure (larger than receivers)
        const createLineman = (scene, material, position, isOffense) => {
            const lineman = new BABYLON.TransformNode('lineman', scene);
            const scale = 1.25;  // Linemen are 25% bigger than receivers

            // Body (larger than knight)
            const body = BABYLON.MeshBuilder.CreateCylinder('body', {
                height: 0.8 * scale,
                diameterTop: 0.4 * scale,
                diameterBottom: 0.6 * scale,
                tessellation: 6
            }, scene);
            body.material = material;
            body.position.y = 0.4 * scale;
            body.parent = lineman;

            // Head (helmet)
            const head = BABYLON.MeshBuilder.CreateSphere('head', {
                diameter: 0.35 * scale,
                segments: 8
            }, scene);
            head.material = material;
            head.position.y = 0.95 * scale;
            head.parent = lineman;

            // Helmet plume
            const plume = BABYLON.MeshBuilder.CreateCylinder('plume', {
                height: 0.25 * scale,
                diameterTop: 0.05 * scale,
                diameterBottom: 0.12 * scale,
                tessellation: 6
            }, scene);
            const plumeMat = new BABYLON.StandardMaterial('plumeMat', scene);
            plumeMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            plume.material = plumeMat;
            plume.position.y = 1.2 * scale;
            plume.parent = lineman;

            // Shield
            const shield = BABYLON.MeshBuilder.CreateBox('shield', {
                width: 0.35 * scale,
                height: 0.45 * scale,
                depth: 0.08 * scale
            }, scene);
            const shieldMat = new BABYLON.StandardMaterial('shieldMat', scene);
            shieldMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            shield.material = shieldMat;
            shield.position.set(-0.3 * scale, 0.5 * scale, 0.1 * scale);
            shield.parent = lineman;

            // Base shadow
            const shadow = BABYLON.MeshBuilder.CreateDisc('shadow', {
                radius: 0.4 * scale,
                tessellation: 12
            }, scene);
            const shadowMat = new BABYLON.StandardMaterial('shadowMat', scene);
            shadowMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            shadowMat.alpha = 0.3;
            shadow.material = shadowMat;
            shadow.rotation.x = Math.PI / 2;
            shadow.position.y = 0.01;
            shadow.parent = lineman;

            lineman.position = position;
            lineman.idleTime = Math.random() * Math.PI * 2;

            return lineman;
        };

        // Create Football
        const createFootball = (scene, materials) => {
            const football = new BABYLON.TransformNode('football', scene);

            // Elongated sphere for football
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 0.3,
                segments: 8
            }, scene);
            ball.scaling = new BABYLON.Vector3(0.6, 0.6, 1);
            ball.material = materials.ballMaterial;
            ball.parent = football;

            // Laces
            const laces = BABYLON.MeshBuilder.CreateBox('laces', {
                width: 0.05,
                height: 0.02,
                depth: 0.15
            }, scene);
            const laceMat = new BABYLON.StandardMaterial('laceMat', scene);
            laceMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            laces.material = laceMat;
            laces.position.y = 0.08;
            laces.parent = football;

            return football;
        };

        // Calculate Throw Parameters with smoothing to prevent jerky aiming
        let lastValidAngle = 0;  // Store last valid angle for smoothing
        const calculateThrow = (dragStart, dragCurrent) => {
            const dx = dragStart.x - dragCurrent.x;
            const dy = dragStart.y - dragCurrent.y;

            // Distance dragged determines throw power
            const rawDragDistance = Math.sqrt(dx * dx + dy * dy);
            const dragDistance = rawDragDistance * DRAG_SENSITIVITY;
            const throwDistance = Math.min(Math.max(dragDistance, MIN_THROW_DISTANCE), MAX_THROW_DISTANCE);

            // Direction is opposite of drag
            // Negate dy because screen Y is inverted (down = positive) vs world Z (up = positive)
            // Only update angle if drag distance is significant enough to be stable
            let angle;
            if (rawDragDistance > 5) {  // At least 5 pixels of drag for stable angle
                angle = Math.atan2(dx, -dy);
                lastValidAngle = angle;
            } else {
                angle = lastValidAngle;  // Use last valid angle for very small drags
            }

            return {
                distance: throwDistance,
                angle: angle,
                power: throwDistance / MAX_THROW_DISTANCE
            };
        };

        // Generate Parabolic Path
        const generatePath = (startPos, throwParams, numPoints = 30) => {
            const points = [];
            const { distance, angle, power } = throwParams;

            // Maximum height based on throw distance
            // Short throws (power ~0.2) = low arc (1.5), long throws (power ~1.0) = high arc (6)
            const maxHeight = 1 + power * power * 5;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;

                // Horizontal position along throw direction
                const horizontalDist = distance * t;
                const x = startPos.x + Math.sin(angle) * horizontalDist;
                const z = startPos.z + Math.cos(angle) * horizontalDist;

                // Parabolic height: h = 4 * maxH * t * (1 - t)
                const y = startPos.y + 4 * maxHeight * t * (1 - t);

                points.push(new BABYLON.Vector3(x, y, z));
            }

            return points;
        };

        // Update Trajectory Visualization - dotted line using spheres
        const updateTrajectory = (scene) => {
            // Dispose old trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }

            if (!gameState.isDragging || !gameState.dragStart || !gameState.dragCurrent) {
                return;
            }

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            // Only show if drag is significant
            if (throwParams.distance < MIN_THROW_DISTANCE) {
                return;
            }

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 30);

            // Create dotted line with small white spheres
            scene.trajectoryDots = [];
            const whiteMat = new BABYLON.StandardMaterial('whiteDot', scene);
            whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            whiteMat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            for (let i = 0; i < path.length; i++) {
                const dot = BABYLON.MeshBuilder.CreateSphere('dot' + i, {
                    diameter: 0.12,
                    segments: 4
                }, scene);
                dot.position = path[i];
                dot.material = whiteMat;
                scene.trajectoryDots.push(dot);
            }
        };

        // Move receiver along their route
        const moveReceiverAlongRoute = (receiver, runSpeed) => {
            if (!receiver.route || receiver.routeIndex >= receiver.route.length) {
                return false; // Route complete
            }

            let target = receiver.route[receiver.routeIndex];
            let dx = target.x - receiver.position.x;
            let dz = target.z - receiver.position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);

            // Check if reached current waypoint
            if (dist < 0.3) {
                // Reached waypoint, move to next
                receiver.routeIndex++;
                if (receiver.routeIndex >= receiver.route.length) {
                    return false; // Route complete
                }
                // Continue toward new waypoint this frame (don't skip a frame)
                target = receiver.route[receiver.routeIndex];
                dx = target.x - receiver.position.x;
                dz = target.z - receiver.position.z;
                dist = Math.sqrt(dx * dx + dz * dz);
            }

            if (dist > 0.1) {
                // Move toward target
                receiver.position.x += (dx / dist) * runSpeed;
                receiver.position.z += (dz / dist) * runSpeed;
                receiver.rotation.y = Math.atan2(dx, dz);
            }
            return true;
        };

        // Move defender based on AI type
        const moveDefender = (defender, deltaTime, overrideSpeed = null) => {
            // Don't move if knocked down
            if (defender.knockdownUntil > gameState.gameTime) {
                return;
            }

            const speed = overrideSpeed !== null ? overrideSpeed : defender.speed;

            if (defender.aiType === 'man') {
                moveDefenderManCoverage(defender, speed);
            } else if (defender.aiType === 'zone') {
                moveDefenderZoneCoverage(defender, speed);
            } else if (defender.aiType === 'blitzer') {
                moveDefenderBlitz(defender, speed);
            }
        };

        // Man coverage AI - follow assigned receiver
        const moveDefenderManCoverage = (defender, speed) => {
            const targetReceiver = gameState.receivers[defender.assignedReceiver];
            if (!targetReceiver) return;

            // Stay between receiver and where ball would come from (QB position)
            const receiverPos = targetReceiver.position;
            const qbPos = new BABYLON.Vector3(0, 0, QB_START_Z);

            // Calculate ideal position - slightly behind and between receiver and QB
            const cushionOffset = 0.5;  // Stay slightly behind
            const targetX = receiverPos.x;
            const targetZ = receiverPos.z - cushionOffset;

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                // Move toward target position
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Zone coverage AI - patrol assigned area, react to nearby receivers
        const moveDefenderZoneCoverage = (defender, speed) => {
            // Find nearest receiver in zone
            let nearestReceiver = null;
            let nearestDist = defender.zoneRadius;

            gameState.receivers.forEach(receiver => {
                const dx = receiver.position.x - defender.zoneCenter.x;
                const dz = receiver.position.z - defender.zoneCenter.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestReceiver = receiver;
                }
            });

            let targetX, targetZ;

            if (nearestReceiver) {
                // Move toward receiver in zone
                targetX = nearestReceiver.position.x;
                targetZ = nearestReceiver.position.z - 0.5;  // Stay slightly behind
            } else {
                // Patrol zone center
                targetX = defender.zoneCenter.x;
                targetZ = defender.zoneCenter.z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Blitzer AI - rush toward QB or ball
        const moveDefenderBlitz = (defender, speed) => {
            let targetX, targetZ;

            if (gameState.ballInFlight) {
                // Chase the ball
                const football = scene.football;
                targetX = football.position.x;
                targetZ = football.position.z;
            } else {
                // Rush the QB
                targetX = 0;
                targetZ = QB_START_Z;
            }

            const dx = targetX - defender.position.x;
            const dz = targetZ - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.5) {
                defender.position.x += (dx / dist) * speed * 1.2;  // Blitzers are aggressive
                defender.position.z += (dz / dist) * speed * 1.2;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // ============================================
        // LINE MOVEMENT AND CLASH SYSTEM
        // ============================================

        // Move D-lineman - rush toward QB
        const moveDLineman = (dLineman) => {
            // Skip if knocked down
            if (dLineman.knockdownUntil > gameState.gameTime) {
                dLineman.position.y = 0;
                return;
            }

            // Get QB position (use current QB position for evasion tracking)
            const qbPos = gameState.scene.qb.position;

            // Calculate speed with any boosts
            let speed = dLineman.baseSpeed;
            if (dLineman.speedBoostUntil > gameState.gameTime) {
                speed *= LINE_CLASH_CONSTANTS.SPEED_BURST_MULTIPLIER;
            }

            // Apply engagement slowdown
            if (dLineman.engagedWith && !dLineman.engagedWith.knockdownUntil) {
                speed *= dLineman.currentSpeedMultiplier;
            }

            // Rush toward QB
            const dx = qbPos.x - dLineman.position.x;
            const dz = qbPos.z - dLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                dLineman.position.x += (dx / dist) * speed;
                dLineman.position.z += (dz / dist) * speed;
                dLineman.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Move O-lineman - stay between assigned D-lineman and QB
        const moveOLineman = (oLineman) => {
            // Skip if knocked down
            if (oLineman.knockdownUntil > gameState.gameTime) {
                oLineman.position.y = 0;
                return;
            }

            const qbPos = gameState.scene.qb.position;

            // Find best D-lineman to block
            const targetDLineman = findBlockingTarget(oLineman);

            if (!targetDLineman) {
                // No target - hold position
                return;
            }

            // Update engagement
            oLineman.engagedWith = targetDLineman;

            // Calculate ideal blocking position - between D-lineman and QB
            const dLinePos = targetDLineman.position;

            // Vector from D-lineman to QB
            const toQbX = qbPos.x - dLinePos.x;
            const toQbZ = qbPos.z - dLinePos.z;
            const toQbDist = Math.sqrt(toQbX * toQbX + toQbZ * toQbZ);

            if (toQbDist < 0.5) return;  // Too close, don't move

            // Position 0.8 units in front of D-lineman (toward QB)
            const blockDist = 0.8;
            const targetX = dLinePos.x + (toQbX / toQbDist) * blockDist;
            const targetZ = dLinePos.z + (toQbZ / toQbDist) * blockDist;

            const dx = targetX - oLineman.position.x;
            const dz = targetZ - oLineman.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.2) {
                const speed = oLineman.baseSpeed;
                oLineman.position.x += (dx / dist) * speed;
                oLineman.position.z += (dz / dist) * speed;
                // Face the D-lineman
                oLineman.rotation.y = Math.atan2(dLinePos.x - oLineman.position.x, dLinePos.z - oLineman.position.z);
            }
        };

        // Find the best D-lineman for an O-lineman to block
        const findBlockingTarget = (oLineman) => {
            const qbPos = gameState.scene.qb.position;
            let bestTarget = null;
            let bestScore = -Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip knocked down D-linemen
                if (dLineman.knockdownUntil > gameState.gameTime) return;

                // Calculate threat level (closer to QB = more threatening)
                const distToQb = BABYLON.Vector3.Distance(dLineman.position, qbPos);
                const distToOLine = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);

                // Check if another O-lineman is already blocking this D-lineman
                let alreadyBlocked = false;
                let blockingOLineman = null;
                gameState.offensiveLine.forEach(other => {
                    if (other !== oLineman && other.engagedWith === dLineman &&
                        other.knockdownUntil <= gameState.gameTime) {
                        alreadyBlocked = true;
                        blockingOLineman = other;
                    }
                });

                // Scoring: prioritize unblocked D-linemen, close to self, close to QB
                let score = 0;

                // Heavily prioritize unblocked rushers
                if (!alreadyBlocked) {
                    score += 100;
                }

                // Prefer D-linemen close to this O-lineman (easier to reach)
                score -= distToOLine * 5;

                // Prefer D-linemen closer to QB (more threatening)
                score -= distToQb * 2;

                // If this O-lineman was already blocking this D-lineman, prefer to stay
                if (oLineman.engagedWith === dLineman) {
                    score += 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = dLineman;
                }
            });

            return bestTarget;
        };

        // Process line clashes between O-line and D-line
        const processLineClashes = () => {
            const currentTime = gameState.gameTime;

            gameState.defensiveLine.forEach(dLineman => {
                // Skip if knocked down
                if (dLineman.knockdownUntil > currentTime) {
                    dLineman.currentSpeedMultiplier = 0;
                    return;
                }

                // Reset speed boost if expired
                if (dLineman.speedBoostUntil <= currentTime) {
                    dLineman.speedBoostUntil = 0;
                }

                // Find closest O-lineman
                let closestOLineman = null;
                let closestDist = LINE_CLASH_CONSTANTS.CLASH_RANGE;

                gameState.offensiveLine.forEach(oLineman => {
                    if (oLineman.knockdownUntil > currentTime) return;

                    const dist = BABYLON.Vector3.Distance(dLineman.position, oLineman.position);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestOLineman = oLineman;
                    }
                });

                if (closestOLineman) {
                    // Engaged with O-lineman
                    dLineman.engagedWith = closestOLineman;
                    closestOLineman.engagedWith = dLineman;

                    // Check if it's time for a clash resolution
                    const timeSinceLastClash = currentTime - dLineman.lastClashTime;
                    if (timeSinceLastClash >= LINE_CLASH_CONSTANTS.CLASH_INTERVAL) {
                        resolveLineClash(closestOLineman, dLineman);
                    }
                } else {
                    // Not engaged - full speed
                    dLineman.engagedWith = null;
                    dLineman.currentSpeedMultiplier = 1.0;
                }
            });
        };

        // Resolve a clash between O-lineman and D-lineman
        const resolveLineClash = (oLineman, dLineman) => {
            const currentTime = gameState.gameTime;

            // Update clash timing
            oLineman.lastClashTime = currentTime;
            dLineman.lastClashTime = currentTime;

            // Roll for clash
            const oLineRoll = weightedRoll(oLineman.stats, CLASH_WEIGHTS.lineClash.offense);
            const dLineRoll = weightedRoll(dLineman.stats, CLASH_WEIGHTS.lineClash.defense);

            const margin = oLineRoll - dLineRoll;

            if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD) {
                // O-line wins decisively - knock down D-lineman
                dLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                dLineman.currentSpeedMultiplier = 0;
                dLineman.engagedWith = null;

                // O-lineman is free to help another
                oLineman.engagedWith = null;

                // Record clash stats
                recordPlayerStat(oLineman, 'seasonClashesWon');
                recordPlayerStat(dLineman, 'seasonClashesLost');

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD) {
                // D-line wins decisively - knock O-lineman aside, speed burst
                oLineman.knockdownUntil = currentTime + LINE_CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                oLineman.engagedWith = null;

                // D-lineman gets speed burst
                dLineman.speedBoostUntil = currentTime + LINE_CLASH_CONSTANTS.SPEED_BURST_DURATION;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.engagedWith = null;

                // Knock O-lineman to the side
                const sideDir = Math.random() > 0.5 ? 1 : -1;
                oLineman.position.x += sideDir * 1.5;

                // Record clash stats
                recordPlayerStat(dLineman, 'seasonClashesWon');
                recordPlayerStat(oLineman, 'seasonClashesLost');

            } else if (margin > LINE_CLASH_CONSTANTS.OFFENSE_WIN_THRESHOLD / 2) {
                // O-line winning but not decisive - D-lineman very slow
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;

            } else if (margin < -LINE_CLASH_CONSTANTS.DEFENSE_WIN_THRESHOLD / 2) {
                // D-line winning but not decisive - breaking through slowly
                dLineman.currentSpeedMultiplier = 0.5;

            } else {
                // Neutral - D-lineman nearly stopped
                dLineman.currentSpeedMultiplier = LINE_CLASH_CONSTANTS.NEUTRAL_SPEED;
            }
        };

        // Reset offensive line to starting positions
        const resetOffensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.offensiveLine.forEach((oLineman, i) => {
                oLineman.position.x = oLineman.startPos.x;
                oLineman.position.z = lineZ - 0.5;
                oLineman.position.y = 0;
                oLineman.rotation.y = 0;
                oLineman.rotation.x = 0;
                oLineman.knockdownUntil = 0;
                oLineman.engagedWith = null;
                oLineman.lastClashTime = 0;
                oLineman.bodyMaterial.diffuseColor = oLineman.originalColor;
                oLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // Reset defensive line to starting positions
        const resetDefensiveLine = () => {
            const lineZ = gameState.lineOfScrimmage;

            gameState.defensiveLine.forEach((dLineman, i) => {
                dLineman.position.x = dLineman.startPos.x;
                dLineman.position.z = lineZ + 0.5;
                dLineman.position.y = 0;
                dLineman.rotation.y = Math.PI;  // Face the offense
                dLineman.rotation.x = 0;
                dLineman.knockdownUntil = 0;
                dLineman.engagedWith = null;
                dLineman.lastClashTime = 0;
                dLineman.speedBoostUntil = 0;
                dLineman.currentSpeedMultiplier = 1.0;
                dLineman.bodyMaterial.diffuseColor = dLineman.originalColor;
                dLineman.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            });
        };

        // ============================================
        // QB MOVEMENT AND SACK SYSTEM
        // ============================================

        // Move QB based on pocket behavior and threats
        const moveQB = (scene) => {
            const qb = scene.qb;
            const currentTime = gameState.gameTime;

            // Don't move if play has ended or ball is being thrown
            if (gameState.playEnded || gameState.ballInFlight) return;

            // Find closest threat (D-lineman)
            let closestThreat = null;
            let closestThreatDist = Infinity;

            gameState.defensiveLine.forEach(dLineman => {
                if (dLineman.knockdownUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(dLineman.position, qb.position);
                if (dist < closestThreatDist) {
                    closestThreatDist = dist;
                    closestThreat = dLineman;
                }
            });

            // Check for sack
            if (closestThreatDist < LINE_CLASH_CONSTANTS.TACKLE_RANGE) {
                handleSack(scene, closestThreat);
                return;
            }

            // Calculate pocket position relative to line of scrimmage
            const losZ = gameState.lineOfScrimmage;
            const pocketCenterZ = losZ - 3;  // 3 yards behind LOS
            const maxDepthZ = losZ - 6;       // 6 yards behind LOS max

            let targetX = qb.position.x;
            let targetZ = pocketCenterZ;
            let speed = POCKET_CONSTANTS.SETTLE_SPEED;

            // If threat is close, evade
            if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                speed = POCKET_CONSTANTS.EVADE_SPEED;

                // Calculate evasion direction (away from threat)
                const threatDx = qb.position.x - closestThreat.position.x;
                const threatDz = qb.position.z - closestThreat.position.z;
                const threatDist = Math.sqrt(threatDx * threatDx + threatDz * threatDz);

                if (threatDist > 0.1) {
                    // Move away from threat
                    targetX = qb.position.x + (threatDx / threatDist) * 2;
                    targetZ = qb.position.z + (threatDz / threatDist) * 2;
                }
            }

            // Apply constraints
            // Don't cross line of scrimmage
            targetZ = Math.min(targetZ, losZ);

            // Don't go too deep
            targetZ = Math.max(targetZ, maxDepthZ);

            // Stay within pocket width (with some flexibility when evading)
            const maxX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MAX_X + 2 : POCKET_CONSTANTS.POCKET_MAX_X;
            const minX = closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS ?
                POCKET_CONSTANTS.POCKET_MIN_X - 2 : POCKET_CONSTANTS.POCKET_MIN_X;
            targetX = Math.max(minX, Math.min(maxX, targetX));

            // Move toward target
            const dx = targetX - qb.position.x;
            const dz = targetZ - qb.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                qb.position.x += (dx / dist) * speed;
                qb.position.z += (dz / dist) * speed;

                // Face the threat or downfield
                if (closestThreat && closestThreatDist < POCKET_CONSTANTS.THREAT_RADIUS) {
                    const faceDx = closestThreat.position.x - qb.position.x;
                    const faceDz = closestThreat.position.z - qb.position.z;
                    qb.rotation.y = Math.atan2(faceDx, faceDz);
                }
            }
        };

        // Handle QB sack
        const handleSack = (scene, tackler) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.qbSacked = true;
            gameState.canThrow = false;

            // Record sack for roster player
            recordPlayerStat(tackler, 'seasonSacks');

            // Move line of scrimmage back to sack location
            handleSackFieldPosition(scene.qb.position.z);

            updateMessage(`SACK by ${tackler.displayName}!`);

            // QB falls down animation
            const qb = scene.qb;
            qb.rotation.x = Math.PI / 3;  // Fall forward

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // ============================================
        // RECEIVER TACKLING SYSTEM
        // ============================================

        // Move ball carrier (receiver with the ball) toward end zone
        const moveBallCarrier = (receiver) => {
            if (!receiver || receiver.knockdownUntil > gameState.gameTime) return;

            // Calculate effective speed with any boosts
            let speed = receiver.baseSpeed;
            if (receiver.breakTackleBoostUntil > gameState.gameTime) {
                speed *= TACKLE_CONSTANTS.BREAK_TACKLE_BOOST;
            }

            // Run toward back of end zone (positive Z direction)
            const targetZ = 15;  // Back of end zone
            const targetX = receiver.position.x;  // Maintain lane for now

            const dz = targetZ - receiver.position.z;
            const dx = targetX - receiver.position.x;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.1) {
                receiver.position.z += (dz / dist) * speed;
                receiver.position.x += (dx / dist) * speed * 0.3;  // Slight drift
                receiver.rotation.y = Math.atan2(dx, dz);
            }

            // Check for touchdown
            if (receiver.position.z >= 12) {
                handleTouchdown(receiver);
                return;
            }

            // Check for out of bounds
            if (Math.abs(receiver.position.x) > 8) {
                handleOutOfBounds(receiver);
                return;
            }
        };

        // Process tackle attempts by defenders on ball carrier
        const processTackles = () => {
            const receiver = gameState.ballCarrier;
            if (!receiver || gameState.playEnded) return;

            const currentTime = gameState.gameTime;

            // Check all defenders for tackle attempts
            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > currentTime) return;
                if (defender.tackleStumbleUntil > currentTime) return;

                const dist = BABYLON.Vector3.Distance(defender.position, receiver.position);

                if (dist < TACKLE_CONSTANTS.TACKLE_RANGE) {
                    // Check tackle cooldown
                    const timeSinceLastTackle = currentTime - (defender.lastTackleTime || 0);
                    if (timeSinceLastTackle < TACKLE_CONSTANTS.TACKLE_INTERVAL) return;

                    // Attempt tackle
                    resolveTackle(receiver, defender);
                }
            });
        };

        // Resolve a tackle attempt
        const resolveTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;
            defender.lastTackleTime = currentTime;

            // Roll for tackle
            const tackleRoll = weightedRoll(defender.stats, CLASH_WEIGHTS.tackle.tackler);
            const evasionRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.tackle.ballCarrier);

            const margin = tackleRoll - evasionRoll;

            // Tackling is meant to be fairly easy on equal stats
            // So a small positive margin should result in a tackle
            if (margin > -5) {
                // Tackle successful!
                handleTackle(receiver, defender);
            } else {
                // Broken tackle!
                handleBrokenTackle(receiver, defender);
            }
        };

        // Handle successful tackle
        const handleTackle = (receiver, defender) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Record tackle for roster player
            recordPlayerStat(defender, 'seasonTackles');

            // Advance ball to tackle location
            advanceBall(receiver.position.z);

            updateMessage(`TACKLED by ${defender.displayName}!`);

            // Receiver falls down
            receiver.rotation.x = Math.PI / 3;
            receiver.position.y = 0;

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Flash effects
            defender.bodyMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.5, 0.1);
            setTimeout(() => {
                defender.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 500);

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 2000);
        };

        // Handle broken tackle
        const handleBrokenTackle = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            updateMessage(`BROKEN TACKLE!`);

            // Defender stumbles
            defender.tackleStumbleUntil = currentTime + TACKLE_CONSTANTS.STUMBLE_DURATION;
            defender.rotation.x = Math.PI / 6;  // Lean forward stumbling

            // Receiver gets speed boost
            receiver.breakTackleBoostUntil = currentTime + TACKLE_CONSTANTS.BREAK_TACKLE_DURATION;

            // Flash receiver green
            receiver.bodyMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.1);
            setTimeout(() => {
                receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
            }, 300);

            // Reset defender stumble rotation
            setTimeout(() => {
                defender.rotation.x = 0;
            }, TACKLE_CONSTANTS.STUMBLE_DURATION * 1000);
        };

        // Reset the drive to starting position (after TD or turnover on downs)
        const resetDrive = () => {
            gameState.down = 1;
            gameState.lineOfScrimmage = gameState.startingLineOfScrimmage;
            gameState.firstDownMarker = gameState.lineOfScrimmage + 10;
            gameState.yardsToGo = 10;
        };

        // Advance the ball to a new position and handle down logic
        const advanceBall = (newPositionZ) => {
            const END_ZONE_Z = 11;  // Touchdown threshold (matches visual end zone start)
            const oldLOS = gameState.lineOfScrimmage;
            const yardsGained = newPositionZ - oldLOS;

            // Update line of scrimmage
            gameState.lineOfScrimmage = newPositionZ;

            // Check for first down
            if (newPositionZ >= gameState.firstDownMarker) {
                // First down achieved!
                gameState.down = 1;
                gameState.firstDownMarker = newPositionZ + 10;
                gameState.yardsToGo = 10;

                // Cap first down marker at end zone
                if (gameState.firstDownMarker > END_ZONE_Z) {
                    gameState.yardsToGo = END_ZONE_Z - newPositionZ;
                    gameState.firstDownMarker = END_ZONE_Z;
                }

                updateMessage('FIRST DOWN!');
            } else {
                // No first down, advance to next down
                gameState.down++;
                gameState.yardsToGo = gameState.firstDownMarker - newPositionZ;

                if (gameState.down > 4) {
                    // Turnover on downs!
                    updateMessage('TURNOVER ON DOWNS!');
                    resetDrive();
                    // Management: record possession complete with 0 points (turnover)
                    if (managementState.matchInProgress) {
                        gameState.waitingForPossession = true;
                        setTimeout(() => {
                            onPossessionComplete(0);
                        }, 1500);
                    }
                }
            }
        };

        // Handle incomplete pass (same line of scrimmage, next down)
        const handleIncomplete = () => {
            gameState.down++;
            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle sack (move line back)
        const handleSackFieldPosition = (sackPositionZ) => {
            // Sack moves the line of scrimmage back
            const newLOS = Math.max(-8, sackPositionZ);  // Don't go too far back
            gameState.lineOfScrimmage = newLOS;
            gameState.yardsToGo = gameState.firstDownMarker - newLOS;
            gameState.down++;

            if (gameState.down > 4) {
                updateMessage('TURNOVER ON DOWNS!');
                resetDrive();
                // Management: record possession complete with 0 points (turnover)
                if (managementState.matchInProgress) {
                    gameState.waitingForPossession = true;
                    setTimeout(() => {
                        onPossessionComplete(0);
                    }, 1500);
                }
            }
        };

        // Handle touchdown
        const handleTouchdown = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;
            gameState.touchdowns++;
            updateScore();

            // Record TD for roster player
            recordPlayerStat(receiver, 'seasonTDs');

            updateMessage(`TOUCHDOWN by ${receiver.displayName}!`);

            // Celebration
            celebrateReceiver(receiver, gameState.scene);

            // Reset drive tracking (downs/yardage)
            resetDrive();

            // Management: record possession complete with 7 points
            if (managementState.matchInProgress) {
                // Pause game during possession overlay
                gameState.waitingForPossession = true;
                setTimeout(() => {
                    onPossessionComplete(7);
                }, 2500);
                return; // Don't reset play yet - wait for overlay to be dismissed
            }

            // Only reset play immediately if not in management match
            setTimeout(() => {
                resetPlay(gameState.scene);
            }, 3000);
        };

        // Handle out of bounds
        const handleOutOfBounds = (receiver) => {
            if (gameState.playEnded) return;

            gameState.playEnded = true;

            // Advance ball to where receiver went out
            advanceBall(receiver.position.z);

            updateMessage(`OUT OF BOUNDS`);

            // Detach ball
            const scene = gameState.scene;
            scene.football.parent = null;
            scene.football.position = receiver.position.clone();
            scene.football.position.y = 0.2;

            // Reset after delay
            setTimeout(() => {
                resetPlay(scene);
            }, 1500);
        };

        // Move defenders to pursue ball carrier
        const moveDefenderPursuit = (defender, pursuitBoost = 1.0) => {
            const receiver = gameState.ballCarrier;
            if (!receiver || defender.knockdownUntil > gameState.gameTime) return;

            // Stumbling defenders can't move well
            if (defender.tackleStumbleUntil > gameState.gameTime) {
                return;
            }

            // Base pursuit speed with time-based boost
            const speed = defender.baseSpeed * 1.1 * pursuitBoost;

            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > 0.3) {
                defender.position.x += (dx / dist) * speed;
                defender.position.z += (dz / dist) * speed;
                defender.rotation.y = Math.atan2(dx, dz);
            }
        };

        // Reset defenders to starting positions
        const resetDefenders = () => {
            const lineZ = gameState.lineOfScrimmage;
            let manDefenderIndex = 0;

            gameState.defenders.forEach((defender, i) => {
                if (defender.aiType === 'man') {
                    // Man defenders cover receivers 1-to-1
                    const receiverIndex = manDefenderIndex % gameState.receivers.length;
                    defender.assignedReceiver = receiverIndex;
                    const targetReceiver = gameState.receivers[receiverIndex];

                    // Position directly above receiver with varying depth
                    defender.cushion = 2 + Math.random() * 4;  // 2-6 yards cushion
                    defender.startPos.x = targetReceiver.startPos.x;
                    defender.startPos.z = targetReceiver.startPos.z + defender.cushion;
                    manDefenderIndex++;
                } else if (defender.aiType === 'zone') {
                    // Zone defender in middle of field with random depth
                    const zoneDepth = 6 + Math.random() * 4;  // 6-10 yards deep
                    defender.zoneCenter = new BABYLON.Vector3(0, 0, lineZ + zoneDepth);
                    defender.zoneRadius = 5 + Math.random() * 2;  // 5-7 yard radius
                    defender.startPos.x = 0;
                    defender.startPos.z = lineZ + zoneDepth - 2;
                }

                defender.position.x = defender.startPos.x;
                defender.position.z = defender.startPos.z;
                defender.position.y = 0;
                defender.knockdownUntil = 0;
                defender.knockdownResistance = 0;
                defender.clashFlashUntil = 0;
                defender.clashTiltUntil = 0;
                defender.loserFlashUntil = 0;
                defender.winnerFlashUntil = 0;
                defender.initialClashSlowdownUntil = 0;
                defender.clashSpeedPenaltyUntil = 0;
                defender.lastClashTime = 0;
                defender.rotation.x = 0;  // Reset tilt
                defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                defender.fillMaterial.alpha = 0;
                // Tackling state
                defender.tackleStumbleUntil = 0;
                defender.lastTackleTime = 0;
            });
        };

        // Reset receivers to starting positions
        const resetReceivers = () => {
            // Receivers line up at the line of scrimmage
            const receiverLineZ = gameState.lineOfScrimmage;

            // Assign spread positions: wide left, wide right, slot - use full field width
            const positions = [
                -(6 + Math.random() * 1.5),   // Wide left: -6 to -7.5 (near sideline)
                (6 + Math.random() * 1.5),    // Wide right: 6 to 7.5 (near sideline)
                (Math.random() - 0.5) * 3     // Slot: -1.5 to 1.5 (middle)
            ];
            // Shuffle positions for variety
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Rarely pick 0-1 receivers to run crossing routes (less overlap)
            const numCrossing = Math.random() < 0.3 ? 1 : 0;  // 30% chance of 1 crossing route
            const crossingIndices = [];
            while (crossingIndices.length < numCrossing && crossingIndices.length < gameState.receivers.length) {
                const idx = Math.floor(Math.random() * gameState.receivers.length);
                if (!crossingIndices.includes(idx)) {
                    crossingIndices.push(idx);
                }
            }

            gameState.receivers.forEach((receiver, i) => {
                // Assign spread position
                receiver.startPos.x = positions[i] || (Math.random() - 0.5) * 6;
                receiver.startPos.z = receiverLineZ;

                receiver.position.x = receiver.startPos.x;
                receiver.position.z = receiverLineZ;
                receiver.position.y = 0;
                receiver.rotation.y = 0;
                receiver.routeIndex = 0;
                receiver.lastRouteIndex = 0;
                receiver.hasHadInitialClash = false;
                receiver.separationState = 'contested';
                receiver.knockdownUntil = 0;
                receiver.knockdownResistance = 0;
                receiver.clashFlashUntil = 0;
                receiver.clashTiltUntil = 0;
                receiver.loserFlashUntil = 0;
                receiver.winnerFlashUntil = 0;
                receiver.lastClashTime = 0;
                receiver.speed = receiver.baseSpeed;
                receiver.initialClashSlowdownUntil = 0;
                receiver.clashSpeedPenaltyUntil = 0;
                receiver.clashSpeedBoostUntil = 0;
                receiver.rotation.x = 0;  // Reset tilt
                receiver.coverageAmount = 0;
                receiver.currentCatchProb = receiver.stats.catching;
                // Size based on base catching stat (80% = 0.3 + 0.9*0.8 = 1.02 scale)
                const baseScale = 0.3 + 0.9 * (receiver.stats.catching / 100);
                receiver.zoneFill.scaling = new BABYLON.Vector3(baseScale, baseScale, baseScale);
                receiver.fillMaterial.alpha = 0.5;
                // Always white
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);

                // Tackling state
                receiver.breakTackleBoostUntil = 0;

                // Generate new random route (force crossing for selected receivers)
                const isCrossing = crossingIndices.includes(i);
                generateRandomRoute(receiver, isCrossing);

                // Keep name labels hidden
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });

            // Reset play start time for label fading
            gameState.playStartTime = performance.now() * 0.001;
        };

        // Generate a random route for a receiver
        const generateRandomRoute = (receiver, forceCrossing = false) => {
            const startX = receiver.startPos.x;
            const startZ = receiver.startPos.z;
            const END_ZONE_Z = 11;  // End zone starts here
            const END_ZONE_BACK = 15;  // Back of end zone
            const SIDELINE = 8;  // Field boundary

            // Calculate available depth to end zone
            const depthToEndZone = END_ZONE_Z - startZ;
            const isNearGoalLine = depthToEndZone < 6;  // Within 6 yards of end zone
            const isOnSideline = Math.abs(startX) > 5;  // Near sideline
            const isInRedZone = depthToEndZone < 10;  // Inside the 10

            // Determine lateral directions
            const towardMiddle = startX > 0 ? -1 : 1;
            const towardSideline = startX > 0 ? 1 : -1;

            const route = [];
            let routeType;

            // Select route type based on field position
            if (isNearGoalLine) {
                // Goal line routes - short, quick, mostly crossing or corner fades
                if (isOnSideline || forceCrossing) {
                    // Near sideline + goal line = must cross toward middle
                    const types = ['quick_slant', 'corner_fade', 'flat_cross'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Middle of field near goal line
                    const types = ['quick_slant', 'fade', 'back_shoulder', 'out_and_up'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            } else if (isInRedZone) {
                // Red zone routes - medium depth, need to get into end zone
                if (isOnSideline) {
                    const types = ['corner', 'fade', 'comeback_corner', 'slant'];
                    routeType = forceCrossing ? 'slant' : types[Math.floor(Math.random() * types.length)];
                } else {
                    const types = ['post', 'dig', 'seam', 'out'];
                    routeType = forceCrossing ? 'dig' : types[Math.floor(Math.random() * types.length)];
                }
            } else {
                // Normal field position - full route tree
                if (forceCrossing) {
                    routeType = Math.random() > 0.5 ? 'crossing' : 'dig';
                } else if (isOnSideline) {
                    // Sideline receivers: go, corner, out, comeback
                    const types = ['go', 'corner', 'out', 'comeback', 'post'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                } else {
                    // Slot/middle receivers: slant, seam, dig, post
                    const types = ['slant', 'seam', 'dig', 'post', 'curl'];
                    routeType = types[Math.floor(Math.random() * types.length)];
                }
            }

            // Generate route points based on type
            switch(routeType) {
                // === GOAL LINE ROUTES ===
                case 'quick_slant':
                    // Quick slant toward middle - 2-3 yards then cut
                    const qsDepth = Math.min(startZ + 2, END_ZONE_Z);
                    const qsEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (4 + Math.random() * 2)));
                    route.push({ z: qsDepth, x: startX });
                    route.push({ z: Math.min(qsDepth + 3, END_ZONE_BACK), x: qsEndX });
                    break;

                case 'flat_cross':
                    // Run flat across the formation then angle to end zone
                    const fcX = startX + towardMiddle * (6 + Math.random() * 3);
                    route.push({ z: startZ + 1, x: Math.max(-6, Math.min(6, fcX)) });
                    route.push({ z: Math.min(startZ + 4, END_ZONE_BACK), x: Math.max(-6, Math.min(6, fcX + towardMiddle * 2)) });
                    break;

                case 'back_shoulder':
                    // Straight then slight fade back - for back shoulder throw
                    route.push({ z: Math.min(startZ + 3, END_ZONE_Z + 1), x: startX });
                    route.push({ z: Math.min(startZ + 2, END_ZONE_Z), x: startX + towardSideline * 1.5 });
                    break;

                case 'corner_fade':
                    // Quick move to corner of end zone
                    const cfX = Math.max(-7, Math.min(7, startX + towardSideline * 3));
                    route.push({ z: Math.min(startZ + 2, END_ZONE_Z), x: cfX });
                    route.push({ z: Math.min(startZ + 5, END_ZONE_BACK), x: Math.max(-7, Math.min(7, cfX + towardSideline * 2)) });
                    break;

                case 'out_and_up':
                    // Fake out, then go vertical
                    const oauOutX = startX + towardSideline * 2;
                    route.push({ z: startZ + 2, x: oauOutX });
                    route.push({ z: Math.min(startZ + 6, END_ZONE_BACK), x: oauOutX });
                    break;

                // === RED ZONE ROUTES ===
                case 'corner':
                    // Break toward corner of end zone
                    const cornerBreak = startZ + 5 + Math.random() * 2;
                    const cornerX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: Math.min(cornerBreak, END_ZONE_Z - 1), x: startX });
                    route.push({ z: Math.min(cornerBreak + 4, END_ZONE_BACK), x: cornerX });
                    break;

                case 'comeback_corner':
                    // Go, comeback, then break to corner
                    const ccBreak = startZ + 6;
                    route.push({ z: Math.min(ccBreak, END_ZONE_Z), x: startX });
                    route.push({ z: Math.min(ccBreak - 1, END_ZONE_Z - 1), x: startX });
                    route.push({ z: Math.min(ccBreak + 3, END_ZONE_BACK), x: Math.max(-7, Math.min(7, startX + towardSideline * 4)) });
                    break;

                // === STANDARD ROUTES ===
                case 'go':
                case 'fade':
                    // Straight up the field with slight fade
                    const goMid = startZ + 8 + Math.random() * 3;
                    const fadeAmount = towardSideline * (1 + Math.random() * 2);
                    route.push({ z: Math.min(goMid, END_ZONE_Z), x: startX + fadeAmount * 0.3 });
                    route.push({ z: Math.min(goMid + 5, END_ZONE_BACK), x: Math.max(-7, Math.min(7, startX + fadeAmount)) });
                    break;

                case 'slant':
                    // Quick slant across the middle
                    const slantBreak = startZ + 3 + Math.random() * 2;
                    const slantX = startX + towardMiddle * (5 + Math.random() * 3);
                    route.push({ z: slantBreak, x: startX });
                    route.push({ z: Math.min(slantBreak + 6, END_ZONE_Z), x: Math.max(-5, Math.min(5, slantX)) });
                    route.push({ z: Math.min(slantBreak + 10, END_ZONE_BACK), x: Math.max(-5, Math.min(5, slantX)) });
                    break;

                case 'out':
                    // Break to sideline
                    const outBreak = startZ + 5 + Math.random() * 3;
                    const outX = Math.max(-7, Math.min(7, startX + towardSideline * (4 + Math.random() * 2)));
                    route.push({ z: outBreak, x: startX });
                    route.push({ z: outBreak + 1, x: outX });
                    route.push({ z: Math.min(outBreak + 6, END_ZONE_BACK), x: outX });
                    break;

                case 'post':
                    // Break toward the goalpost (middle deep)
                    const postBreak = startZ + 6 + Math.random() * 3;
                    route.push({ z: postBreak, x: startX });
                    route.push({ z: Math.min(postBreak + 6, END_ZONE_BACK), x: towardMiddle * (2 + Math.random() * 2) });
                    break;

                case 'dig':
                case 'crossing':
                    // Deep cross - run vertical then cut across
                    const digBreak = startZ + 7 + Math.random() * 3;
                    const digEndX = Math.max(-6, Math.min(6, startX + towardMiddle * (8 + Math.random() * 4)));
                    route.push({ z: Math.min(digBreak, END_ZONE_Z), x: startX });
                    route.push({ z: Math.min(digBreak + 2, END_ZONE_Z + 2), x: digEndX });
                    route.push({ z: Math.min(digBreak + 5, END_ZONE_BACK), x: digEndX });
                    break;

                case 'seam':
                    // Straight up the seam (between zones)
                    const seamTarget = startX > 0 ? 3 : -3;  // Stay in seam
                    route.push({ z: startZ + 5, x: (startX + seamTarget) / 2 });
                    route.push({ z: Math.min(startZ + 12, END_ZONE_Z), x: seamTarget });
                    route.push({ z: Math.min(startZ + 16, END_ZONE_BACK), x: seamTarget });
                    break;

                case 'curl':
                case 'comeback':
                    // Run up, curl back toward QB
                    const curlDepth = startZ + 8 + Math.random() * 3;
                    route.push({ z: curlDepth, x: startX });
                    route.push({ z: curlDepth - 2, x: startX + towardMiddle * 1 });
                    break;

                default:
                    // Fallback: simple go route
                    route.push({ z: Math.min(startZ + 8, END_ZONE_Z), x: startX });
                    route.push({ z: Math.min(startZ + 14, END_ZONE_BACK), x: startX });
            }

            // Ensure all route points move forward (no backwards routes)
            let lastZ = startZ;
            route.forEach(point => {
                if (point.z < lastZ) {
                    point.z = lastZ + 0.5;  // Force forward movement
                }
                lastZ = point.z;
                // Clamp to field boundaries
                point.z = Math.min(point.z, END_ZONE_BACK);
                point.x = Math.max(-SIDELINE, Math.min(SIDELINE, point.x));
            });

            receiver.route = route;

            // Update route line visual
            if (receiver.routeLine) {
                receiver.routeLine.dispose();
            }

            const routePoints = [receiver.startPos.clone()];
            routePoints[0].y = 0.05;
            route.forEach(point => {
                routePoints.push(new BABYLON.Vector3(point.x, 0.05, point.z));
            });

            // Need to access scene - store reference on gameState
            if (gameState.scene && gameState.routeMaterial) {
                const routeLine = BABYLON.MeshBuilder.CreateTube('route_' + receiver.name, {
                    path: routePoints,
                    radius: 0.08,
                    tessellation: 8
                }, gameState.scene);
                routeLine.material = gameState.routeMaterial;
                receiver.routeLine = routeLine;
            }
        };

        // Throw Football Animation
        const throwFootball = (scene) => {
            if (!gameState.canThrow || gameState.ballInFlight) return;
            if (!gameState.dragStart || !gameState.dragCurrent) return;

            const throwParams = calculateThrow(gameState.dragStart, gameState.dragCurrent);

            if (throwParams.distance < MIN_THROW_DISTANCE) return;

            gameState.ballInFlight = true;
            gameState.canThrow = false;
            updateMessage('');

            const startPos = scene.qb.position.clone();
            startPos.y = 1;
            const path = generatePath(startPos, throwParams, 60);

            const football = scene.football;
            football.setEnabled(true);
            football.position = path[0].clone();

            const landingPos = path[path.length - 1];
            const catchRadius = 1.2;

            let frameIndex = 0;
            // Shorter throws are faster: speed ranges from 2.0 (short) to 0.8 (long)
            const animationSpeed = 2.0 - (throwParams.power * 1.2);
            let accumulator = 0;
            const time = { value: 0 };

            const ballAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                time.value += dt;
                accumulator += dt * 60 * animationSpeed;

                while (accumulator >= 1 && frameIndex < path.length - 1) {
                    frameIndex++;
                    accumulator--;
                }

                if (frameIndex < path.length) {
                    football.position = path[frameIndex].clone();

                    // Rotate ball along flight path
                    if (frameIndex < path.length - 1) {
                        const direction = path[frameIndex + 1].subtract(path[frameIndex]);
                        const angle = Math.atan2(direction.x, direction.z);
                        football.rotation.y = angle;

                        // Pitch based on vertical velocity
                        const pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
                        football.rotation.x = -pitch;
                    }

                    // Spin animation
                    football.rotation.z += 0.2;

                    // Track game time for clash system (use consistent time source)
                    gameState.gameTime = performance.now() * 0.001;

                    // Keep ALL receivers moving along their routes
                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;
                            return;
                        }

                        // Reset speed to base when boost/penalty expires (also during ball flight)
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate distance to ball landing spot
                        const dx = landingPos.x - receiver.position.x;
                        const dz = landingPos.z - receiver.position.z;
                        const distToLanding = Math.sqrt(dx * dx + dz * dz);

                        // Calculate effective speed (apply initial clash slowdown if no outcome yet)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;
                        }

                        // Check if route is complete
                        const routeComplete = !receiver.route || receiver.routeIndex >= receiver.route.length;

                        // If ball is coming to them (within catch range) OR route is done, move toward ball
                        // Moving off-route to catch slows the receiver down (allows defenders to close)
                        if ((distToLanding < catchRadius * 2.5 && frameIndex > 5) || routeComplete) {
                            if (distToLanding > 0.2) {
                                // Reduced speed when adjusting to catch (70% of normal)
                                const catchAdjustSpeed = effectiveSpeed * 0.7;
                                receiver.position.x += (dx / distToLanding) * catchAdjustSpeed;
                                receiver.position.z += (dz / distToLanding) * catchAdjustSpeed;
                                receiver.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            // Follow their route
                            moveReceiverAlongRoute(receiver, effectiveSpeed);
                        }

                        // Running animation
                        receiver.position.y = Math.abs(Math.sin(time.value * 8 + i)) * 0.08;
                        receiver.rotation.z = Math.sin(time.value * 8 + i) * 0.05;
                    });

                    // Move defenders during ball flight - they pursue!
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;
                            return;
                        }

                        // Defenders move at full speed during ball flight
                        moveDefender(defender, 0.016);

                        // Running animation
                        defender.position.y = Math.abs(Math.sin(time.value * 8 + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time.value * 8 + i + 0.5) * 0.05;
                    });

                    // Move linemen during ball flight (battle continues!)
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            return;
                        }
                        moveOLineman(oLineman);
                        oLineman.position.y = Math.abs(Math.sin(time.value * 4 + i * 0.5)) * 0.03;
                    });

                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            return;
                        }
                        moveDLineman(dLineman);
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        dLineman.position.y = Math.abs(Math.sin(time.value * (isRushing ? 8 : 4) + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes during ball flight
                    processLineClashes();

                    // Process clashes during ball flight
                    processClashes();

                    // Update zone visuals based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();
                }

                // Check if ball has landed
                if (frameIndex >= path.length - 1) {
                    scene.onBeforeRenderObservable.remove(ballAnimation);
                    checkCatch(scene, football.position, null);
                }
            });
        };

        // Check for Catch
        const checkCatch = (scene, ballPosition, targetReceiver) => {
            const catchRadius = 1.2;
            let potentialCatcher = null;
            let closestDistance = catchRadius;

            for (const receiver of gameState.receivers) {
                // Can't catch if knocked down
                if (receiver.knockdownUntil > gameState.gameTime) {
                    continue;
                }

                const distance = BABYLON.Vector3.Distance(
                    new BABYLON.Vector3(receiver.position.x, 0, receiver.position.z),
                    new BABYLON.Vector3(ballPosition.x, 0, ballPosition.z)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    potentialCatcher = receiver;
                }
            }

            if (potentialCatcher) {
                // Calculate catch probability (returns detailed info)
                const catchInfo = calculateCatchProbability(potentialCatcher, ballPosition);
                const catchRoll = Math.random() * 100;
                const success = catchRoll < catchInfo.probability;

                // Track attempt
                gameState.attempts++;

                // Record target for roster player
                recordPlayerStat(potentialCatcher, 'seasonTargets');

                // Show the catch probability display
                showCatchDisplay(catchInfo, catchRoll, success);

                if (success) {
                    // Successful catch! Set up ball carrier
                    gameState.catches++;
                    updateScore();
                    updateMessage(`CATCH by ${potentialCatcher.displayName}! RUN!`);

                    // Record catch for roster player
                    recordPlayerStat(potentialCatcher, 'seasonCatches');

                    // Attach ball to receiver
                    scene.football.position.y = 0.8;
                    scene.football.parent = potentialCatcher;
                    scene.football.position = new BABYLON.Vector3(0.3, 0.5, 0);
                    scene.football.rotation = new BABYLON.Vector3(0, 0, Math.PI / 4);

                    // Set up ball carrier state - play continues!
                    gameState.ballCarrier = potentialCatcher;
                    potentialCatcher.breakTackleBoostUntil = 0;

                    // Start the run-after-catch phase
                    startRunAfterCatch(scene);
                } else {
                    // Dropped or defended - incomplete pass
                    handleIncomplete();
                    updateScore();
                    const wasDefended = potentialCatcher.separationState === 'covered';
                    updateMessage(wasDefended ? 'DEFENDED!' : 'Dropped...');

                    // Record pass defended for nearest defender if it was defended
                    if (wasDefended) {
                        let closestDefender = null;
                        let closestDist = Infinity;
                        for (const def of gameState.defenders) {
                            const dist = BABYLON.Vector3.Distance(def.position, potentialCatcher.position);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestDefender = def;
                            }
                        }
                        if (closestDefender) {
                            recordPlayerStat(closestDefender, 'seasonPassesDefended');
                        }
                    }

                    bounceBall(scene, ballPosition);
                }
            } else {
                // No receiver nearby - incomplete pass
                handleIncomplete();
                updateMessage('Incomplete...');
                // Ball bounces and rolls
                bounceBall(scene, ballPosition);
            }
        };

        // Start the run-after-catch phase with animation loop
        const startRunAfterCatch = (scene) => {
            const timeSinceCatch = { value: 0 };

            const runAnimation = scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                timeSinceCatch.value += dt;
                gameState.gameTime = performance.now() * 0.001;

                // Check if play has ended
                if (gameState.playEnded) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                const ballCarrier = gameState.ballCarrier;
                if (!ballCarrier) {
                    scene.onBeforeRenderObservable.remove(runAnimation);
                    return;
                }

                // Move ball carrier
                moveBallCarrier(ballCarrier);

                // Running animation for ball carrier
                ballCarrier.position.y = Math.abs(Math.sin(timeSinceCatch.value * 10)) * 0.1;
                ballCarrier.rotation.z = Math.sin(timeSinceCatch.value * 10) * 0.06;

                // Calculate pursuit boost based on time since catch
                // After 1 second: 10% boost, after 2 seconds: 20% boost
                let pursuitBoost = 1.0;
                if (timeSinceCatch.value >= 2.0) {
                    pursuitBoost = 1.2;  // 20% boost after 2 seconds
                } else if (timeSinceCatch.value >= 1.0) {
                    // Interpolate from 10% to 20% between 1 and 2 seconds
                    const t = timeSinceCatch.value - 1.0;  // 0 to 1
                    pursuitBoost = 1.1 + (t * 0.1);  // 1.1 to 1.2
                }

                // Move all defenders in pursuit with speed boost
                gameState.defenders.forEach((defender, i) => {
                    if (defender.knockdownUntil <= gameState.gameTime) {
                        moveDefenderPursuit(defender, pursuitBoost);

                        // Running animation (faster when boosted)
                        const animSpeed = 10 + (pursuitBoost - 1.0) * 20;
                        defender.position.y = Math.abs(Math.sin(timeSinceCatch.value * animSpeed + i)) * 0.08;
                        defender.rotation.z = Math.sin(timeSinceCatch.value * animSpeed + i) * 0.05;
                    }
                });

                // Process tackle attempts
                processTackles();
            });
        };

        // Calculate catch probability based on receiver stats and proximity to defenders
        const calculateCatchProbability = (receiver, ballPosition) => {
            // Base catch rate from receiver's catching stat
            let baseCatch = receiver.stats.catching;

            // Find defenders and apply proximity penalty
            let defenderProximityPenalty = 0;
            let defenderDetails = [];
            let hasNearbyDefender = false;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            // For zone defenders, count how many receivers are in their zone to split coverage
            const zoneReceiverCounts = new Map();
            gameState.defenders.forEach(defender => {
                if (defender.aiType === 'zone' && defender.knockdownUntil <= gameState.gameTime) {
                    let count = 0;
                    gameState.receivers.forEach(rec => {
                        const dist = BABYLON.Vector3.Distance(defender.position, rec.position);
                        if (dist < coverageRange) count++;
                    });
                    zoneReceiverCounts.set(defender, Math.max(1, count));
                }
            });

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;

                    // Get defender's coverage stat based on their type
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;

                    // Proximity factor: 1.0 at distance 0, 0.0 at max range
                    const proximityFactor = 1 - (dist / coverageRange);

                    // At distance 0, if coverage equals catching, apply 80% penalty
                    // penalty = proximityFactor^3 * coverageStat * 0.8
                    // Cubed for steeper dropoff - separation is rewarded more
                    let penalty = proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;

                    // Very close defenders (0.6 or closer) have 50% more influence
                    const CLOSE_DEFENDER_THRESHOLD = 0.6;
                    if (dist <= CLOSE_DEFENDER_THRESHOLD) {
                        penalty *= 1.5;
                    }

                    // Check if ball is on opposite side from defender
                    // Only applies if defender isn't right on top of receiver (dist > 0.8)
                    const MIN_DIST_FOR_SIDE_BONUS = 0.8;
                    if (dist > MIN_DIST_FOR_SIDE_BONUS) {
                        const defenderSide = Math.sign(defender.position.x - receiver.position.x);
                        const ballSide = Math.sign(ballPosition.x - receiver.position.x);

                        // If ball and defender are on opposite sides, halve the penalty
                        if (defenderSide !== 0 && ballSide !== 0 && defenderSide !== ballSide) {
                            penalty *= 0.5;
                        }
                    }

                    // If defender lost a clash (has speed penalty), reduce their coverage effect by 50%
                    if (defender.clashSpeedPenaltyUntil && defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                        penalty *= 0.5;
                    }

                    // For zone defenders covering multiple receivers, split their coverage
                    if (defender.aiType === 'zone') {
                        const receiversInZone = zoneReceiverCounts.get(defender) || 1;
                        if (receiversInZone > 1) {
                            penalty /= receiversInZone;
                        }
                    }

                    defenderProximityPenalty += penalty;
                    defenderDetails.push({
                        name: defender.name,
                        dist: dist.toFixed(2),
                        penalty: penalty.toFixed(1),
                        coverageStat: coverageStat,
                        aiType: defender.aiType
                    });
                }
            });

            // Focus stat helps when defenders are nearby (higher focus = better under pressure)
            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;

            // Calculate final probability (clamped between 5% and 95%)
            const finalProbability = Math.max(5, Math.min(95,
                baseCatch + focusMod - defenderProximityPenalty
            ));

            // Store for visual display
            receiver.lastCatchProbability = finalProbability;

            // Return detailed info for UI display
            return {
                probability: finalProbability,
                baseCatch: baseCatch,
                focusMod: focusMod,
                defenderPenalty: defenderProximityPenalty,
                defenderDetails: defenderDetails
            };
        };

        // Show catch probability display
        const showCatchDisplay = (catchInfo, roll, success) => {
            const display = document.getElementById('catchDisplay');
            const header = display.querySelector('.catch-header');
            const barBase = display.querySelector('.catch-bar-base');
            const barPenalty = display.querySelector('.catch-bar-penalty');
            const barRoll = display.querySelector('.catch-bar-roll');
            const defenderInfo = display.querySelector('.defender-info');

            // Set header
            header.textContent = success ? 'CATCH!' : 'DROPPED';
            header.className = 'catch-header ' + (success ? 'success' : 'fail');

            // Calculate raw catch % (base + focus, before defender penalty)
            const rawCatch = Math.min(95, catchInfo.baseCatch + catchInfo.focusMod);
            const penaltyWidth = Math.min(catchInfo.defenderPenalty, rawCatch);

            // Set bar: green shows raw potential, dark overlay shows defender penalty
            barBase.style.width = `${rawCatch}%`;

            // Penalty overlay starts where final probability ends
            if (penaltyWidth > 0) {
                barPenalty.style.display = 'block';
                barPenalty.style.left = `${catchInfo.probability}%`;
                barPenalty.style.width = `${penaltyWidth}%`;
            } else {
                barPenalty.style.display = 'none';
            }

            // Roll marker with tick/cross
            barRoll.textContent = success ? '✓' : '✗';
            barRoll.className = 'catch-bar-roll ' + (success ? 'success' : 'fail');
            barRoll.style.left = `${roll}%`;

            // Show defender distances only
            if (catchInfo.defenderDetails && catchInfo.defenderDetails.length > 0) {
                const distances = catchInfo.defenderDetails
                    .filter(d => parseFloat(d.penalty) > 0.5)
                    .map(d => d.dist)
                    .join(', ');
                defenderInfo.textContent = distances ? distances + 'yd' : '';
            } else {
                defenderInfo.textContent = '';
            }

            // Show display
            display.classList.add('visible');

            // Hide after 2.5 seconds
            setTimeout(() => {
                display.classList.remove('visible');
            }, 2500);
        };

        // Ball bounce and roll animation for incomplete passes
        const bounceBall = (scene, startPos) => {
            const football = scene.football;
            let velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: 0.15,  // Initial bounce up
                z: (Math.random() - 0.5) * 0.1
            };
            let bounceCount = 0;
            const maxBounces = 3;
            const gravity = 0.008;
            const friction = 0.95;
            const bounceDamping = 0.5;

            const bounceAnimation = scene.onBeforeRenderObservable.add(() => {
                // Apply gravity
                velocity.y -= gravity;

                // Update position
                football.position.x += velocity.x;
                football.position.y += velocity.y;
                football.position.z += velocity.z;

                // Tumble rotation
                football.rotation.x += velocity.z * 2;
                football.rotation.z += velocity.x * 2;

                // Ground collision
                if (football.position.y <= 0.1) {
                    football.position.y = 0.1;
                    bounceCount++;

                    if (bounceCount < maxBounces) {
                        // Bounce up with damping
                        velocity.y = Math.abs(velocity.y) * bounceDamping;
                        velocity.x *= friction;
                        velocity.z *= friction;
                    } else {
                        // Rolling on ground
                        velocity.y = 0;
                        velocity.x *= 0.92;
                        velocity.z *= 0.92;

                        // Stop when slow enough
                        if (Math.abs(velocity.x) < 0.001 && Math.abs(velocity.z) < 0.001) {
                            scene.onBeforeRenderObservable.remove(bounceAnimation);
                            setTimeout(() => {
                                resetPlay(scene);
                            }, 800);
                        }
                    }
                }
            });
        };

        // Celebrate Catch - receiver holds ball and celebrates
        const celebrateReceiver = (receiver, scene) => {
            let jumpFrame = 0;
            const jumpAnimation = setInterval(() => {
                jumpFrame++;
                receiver.position.y = Math.abs(Math.sin(jumpFrame * 0.3)) * 0.5;
                receiver.rotation.y += 0.15;

                if (jumpFrame > 25) {
                    clearInterval(jumpAnimation);
                    receiver.position.y = 0;
                }
            }, 30);
        };

        // Hide player labels when play starts
        const hidePlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 0;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 0;
                }
            });
        };

        // Show player labels when play is frozen
        const showPlayerLabels = () => {
            if (gameState.scene && gameState.scene.qb && gameState.scene.qb.nameLabel) {
                gameState.scene.qb.nameLabel.alpha = 1;
            }
            gameState.receivers.forEach(receiver => {
                if (receiver.nameLabel) {
                    receiver.nameLabel.alpha = 1;
                }
            });
        };

        // Reset Play
        const resetPlay = (scene) => {
            // Detach football from any parent
            scene.football.parent = null;
            scene.football.setEnabled(false);

            // Clear trajectory dots
            if (scene.trajectoryDots) {
                scene.trajectoryDots.forEach(dot => dot.dispose());
                scene.trajectoryDots = null;
            }
            gameState.ballInFlight = false;

            // Reset play state flags
            gameState.ballCarrier = null;
            gameState.playEnded = false;
            gameState.qbSacked = false;
            gameState.playFrozen = true;  // Freeze until player holds screen

            // Reset receiver and defender positions
            resetReceivers();
            resetDefenders();

            // Reset linemen
            resetOffensiveLine();
            resetDefensiveLine();

            // Reset QB position (relative to line of scrimmage, randomized depth behind it)
            const qbDepthBehindLine = 2 + Math.random() * 2;  // 2-4 yards behind LOS
            const qbZ = gameState.lineOfScrimmage - qbDepthBehindLine;
            gameState.qbStartZ = qbZ;
            scene.qb.position.x = 0;
            scene.qb.position.z = qbZ;
            scene.qb.position.y = 0;
            scene.qb.rotation.x = 0;
            scene.qb.rotation.y = 0;

            // Update field position markers
            if (scene.losLine) {
                scene.losLine.position.z = gameState.lineOfScrimmage;
            }
            if (scene.firstDownLine) {
                scene.firstDownLine.position.z = gameState.firstDownMarker;
            }

            // Move camera to follow the line of scrimmage
            if (scene.activeCamera) {
                const camera = scene.activeCamera;

                // Target centered on the line of scrimmage
                // Allow camera to follow all the way into end zone (Z = 14)
                const cameraTargetZ = Math.max(-4, Math.min(14, gameState.lineOfScrimmage + 2));
                camera.target = new BABYLON.Vector3(0, 0, cameraTargetZ);

                // Reset camera to current view mode settings (alpha, beta, radius)
                switch(gameState.currentView) {
                    case 'iso':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                        break;
                    case 'overhead':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = 0.1;
                        camera.radius = 28;
                        break;
                    case 'shoulder':
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 2.5;
                        camera.radius = 18;
                        break;
                    default:
                        camera.alpha = -Math.PI / 2;
                        camera.beta = Math.PI / 3.5;
                        camera.radius = 32;
                }
            }

            // Update down and distance display
            updateDownDistance();

            // Show player labels while frozen
            showPlayerLabels();

            // Slight delay before allowing next throw
            setTimeout(() => {
                gameState.canThrow = true;
                updateMessage('Hold to start play');
            }, 500);
        };

        // Update UI
        const updateScore = () => {
            const scoreEl = document.getElementById('score');
            scoreEl.querySelector('.catches').textContent = `${gameState.catches}/${gameState.attempts}`;
            scoreEl.querySelector('.touchdowns').textContent = gameState.touchdowns;
        };

        const updateDownDistance = () => {
            const ddEl = document.getElementById('downDistance');
            const downNames = ['1st', '2nd', '3rd', '4th'];
            const downText = downNames[gameState.down - 1] || '4th';

            // Calculate yards to go (convert Z units to approximate yards - roughly 1 unit = 1 yard)
            const yardsToGo = Math.max(1, Math.round(gameState.yardsToGo));
            const distanceText = yardsToGo >= 10 ? '10+' : yardsToGo.toString();

            ddEl.querySelector('.down').textContent = downText;
            ddEl.querySelector('.distance').textContent = distanceText;
        };

        const updateMessage = (msg) => {
            // Message display removed
        };

        // Update debug info display
        const updateDebugInfo = () => {
            if (!FEATURE_FLAGS.showDebugInfo) {
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            document.getElementById('debugInfo').style.display = 'block';

            let debugText = '=== RECEIVER STATUS ===\n';
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;

            gameState.receivers.forEach((receiver, i) => {
                // Find closest defender
                let closestDef = null;
                let closestDist = Infinity;
                gameState.defenders.forEach(def => {
                    if (def.knockdownUntil > gameState.gameTime) return;
                    const dx = def.position.x - receiver.position.x;
                    const dz = def.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestDef = def;
                    }
                });

                const timeSinceClash = (gameState.gameTime - receiver.lastClashTime).toFixed(1);
                const speedMod = (receiver.speed / receiver.baseSpeed * 100).toFixed(0);
                const hasSpeedPenalty = receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                const catchProb = receiver.currentCatchProb || receiver.stats.catching;

                // Determine coverage level based on catch probability
                let coverageLevel = 'OPEN';
                let levelColor = '🟢';
                if (catchProb < 40) {
                    coverageLevel = 'COVERED';
                    levelColor = '🔴';
                } else if (catchProb < 70) {
                    coverageLevel = 'CONTESTED';
                    levelColor = '🟡';
                }

                debugText += `\n${receiver.displayName}:\n`;
                debugText += `  ${levelColor} Catch: ${catchProb.toFixed(0)}% (${coverageLevel})\n`;
                debugText += `  Speed: ${speedMod}%${hasSpeedPenalty ? ' (SLOWED)' : ''}\n`;

                if (closestDef) {
                    const defSpeedPenalty = closestDef.clashSpeedPenaltyUntil > gameState.gameTime;
                    const defCovStat = closestDef.aiType === 'zone' ?
                        closestDef.stats.zoneCoverage : closestDef.stats.manCoverage;
                    debugText += `  Nearest: ${closestDef.displayName}`;
                    if (defSpeedPenalty) debugText += ' (SLOWED)';
                    debugText += `\n`;
                    debugText += `  Dist: ${closestDist.toFixed(1)}/${coverageRange.toFixed(1)}`;
                    debugText += ` | ${closestDef.aiType === 'zone' ? 'ZoneCov' : 'ManCov'}: ${defCovStat}\n`;
                }
            });

            document.getElementById('debugInfo').textContent = debugText;
        };

        // Input Handling
        const setupInput = (scene) => {
            const getPointerPosition = (evt) => {
                const rect = canvas.getBoundingClientRect();
                // Pointer events have clientX/clientY directly
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            };

            const onPointerDown = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only capture left-click (button 0) or single touch for throwing
                // Let right-click (button 2) and multi-touch pass through to camera
                if (evt.button !== 0 && evt.pointerType === 'mouse') return;

                // Unfreeze play when holding down (starts the play)
                if (gameState.playFrozen) {
                    gameState.playFrozen = false;
                    gameState.playStartTime = performance.now() * 0.001;
                    hidePlayerLabels();
                }

                if (!gameState.canThrow || gameState.ballInFlight) return;

                evt.preventDefault();
                const pos = getPointerPosition(evt);
                gameState.isDragging = true;
                gameState.activePointerId = evt.pointerId;  // Track which pointer is dragging
                gameState.dragStart = pos;
                gameState.dragCurrent = pos;
            };

            const onPointerMove = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only track the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.dragCurrent = getPointerPosition(evt);
                updateTrajectory(scene);
            };

            const onPointerUp = (evt) => {
                // Skip game input when in management mode
                if (!gameSceneActive) return;
                // Only respond to the pointer that started the drag
                if (!gameState.isDragging || evt.pointerId !== gameState.activePointerId) return;

                evt.preventDefault();
                gameState.activePointerId = null;

                // Update final position from the end event
                const endPos = getPointerPosition(evt);
                if (endPos.x && endPos.y) {
                    gameState.dragCurrent = endPos;
                }

                if (gameState.dragStart && gameState.dragCurrent) {
                    throwFootball(scene);
                }

                gameState.isDragging = false;
                gameState.dragStart = null;
                gameState.dragCurrent = null;
                if (scene.trajectoryDots) {
                    scene.trajectoryDots.forEach(dot => dot.dispose());
                    scene.trajectoryDots = null;
                }
            };

            // Use pointer events for unified mouse/touch handling
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
        };

        // Idle Animations
        const setupIdleAnimations = (scene) => {
            // QB idle sway
            scene.onBeforeRenderObservable.add(() => {
                // Skip all game logic when in management mode
                if (!gameSceneActive) return;

                // Pause game during possession overlay
                if (gameState.waitingForPossession) return;

                // Freeze play until player holds screen
                if (gameState.playFrozen) return;

                const time = performance.now() * 0.001;

                // QB breathing/ready animation (only when not in danger)
                const qb = scene.qb;
                if (!gameState.playEnded && !gameState.qbSacked) {
                    // Only subtle breathing when not moving
                    const isEvading = gameState.defensiveLine.some(d =>
                        d.knockdownUntil <= gameState.gameTime &&
                        BABYLON.Vector3.Distance(d.position, qb.position) < POCKET_CONSTANTS.THREAT_RADIUS
                    );
                    if (!isEvading) {
                        qb.rotation.y = Math.sin(time * 2) * 0.05;
                        qb.position.y = Math.sin(time * 3) * 0.02;
                    } else {
                        qb.position.y = Math.abs(Math.sin(time * 8)) * 0.06;  // Running animation
                    }
                }

                // Track game time for clash system
                gameState.gameTime = time;

                // Receivers running their routes
                if (!gameState.ballInFlight && gameState.canThrow) {
                    let anyRouteComplete = false;

                    gameState.receivers.forEach((receiver, i) => {
                        // Skip if knocked down
                        if (receiver.knockdownUntil > gameState.gameTime) {
                            receiver.position.y = 0;  // On ground
                            return;
                        }

                        // Reset speed to base when boost/penalty expires
                        if (receiver.clashSpeedBoostUntil > 0 && receiver.clashSpeedBoostUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedBoostUntil = 0;
                        }
                        if (receiver.clashSpeedPenaltyUntil > 0 && receiver.clashSpeedPenaltyUntil <= gameState.gameTime) {
                            receiver.speed = receiver.baseSpeed;
                            receiver.clashSpeedPenaltyUntil = 0;
                        }

                        // Calculate effective speed (slowdown during initial clash, unless clash outcome already applied)
                        let effectiveSpeed = receiver.speed;
                        if (!effectiveSpeed || effectiveSpeed <= 0) {
                            console.error(`[SPEED ERROR] ${receiver.displayName} speed=${receiver.speed}, baseSpeed=${receiver.baseSpeed}, boostUntil=${receiver.clashSpeedBoostUntil}, penaltyUntil=${receiver.clashSpeedPenaltyUntil}`);
                            effectiveSpeed = receiver.baseSpeed;
                        }
                        const hasClashOutcome = receiver.clashSpeedBoostUntil > gameState.gameTime ||
                                               receiver.clashSpeedPenaltyUntil > gameState.gameTime;
                        if (receiver.initialClashSlowdownUntil > gameState.gameTime && !hasClashOutcome) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash (only if no outcome yet)
                        }

                        // Follow route, reset if complete
                        const stillRunning = moveReceiverAlongRoute(receiver, effectiveSpeed);
                        if (!stillRunning) {
                            anyRouteComplete = true;
                        }

                        // Running bob animation (slower bob during slowdown)
                        const bobSpeed = receiver.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        receiver.position.y = Math.abs(Math.sin(time * bobSpeed + i)) * 0.08;

                        // Arm swing approximation via slight rotation
                        receiver.rotation.z = Math.sin(time * bobSpeed + i) * 0.05;

                        // Clash tilt effect (lean towards opponent)
                        if (receiver.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (receiver.clashTiltUntil - gameState.gameTime) / 0.5;
                            receiver.rotation.x = Math.sin(tiltProgress * Math.PI) * 0.3;  // Lean forward
                        } else {
                            receiver.rotation.x = 0;
                        }

                        // Show green while speed boosted, red while speed penalized
                        if (receiver.clashSpeedBoostUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const green = new BABYLON.Color3(0.2, 1.0, 0.3);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, green, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = green.scale(flashRate * 0.3);
                        } else if (receiver.clashSpeedPenaltyUntil > gameState.gameTime) {
                            const flashRate = Math.sin(time * 10) * 0.3 + 0.7;  // Gentle pulse 0.4-1.0
                            const red = new BABYLON.Color3(1.0, 0.2, 0.2);
                            receiver.bodyMaterial.diffuseColor = BABYLON.Color3.Lerp(receiver.originalColor, red, flashRate * 0.7);
                            receiver.bodyMaterial.emissiveColor = red.scale(flashRate * 0.3);
                        } else {
                            receiver.bodyMaterial.diffuseColor = receiver.originalColor;
                            receiver.bodyMaterial.emissiveColor = BABYLON.Color3.Black();
                        }
                    });

                    // Route completion no longer triggers reset - play continues normally

                    // Move offensive linemen
                    gameState.offensiveLine.forEach((oLineman, i) => {
                        if (oLineman.knockdownUntil > gameState.gameTime) {
                            oLineman.position.y = 0;
                            oLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        oLineman.rotation.x = 0;

                        moveOLineman(oLineman);

                        // Subtle stance animation
                        oLineman.position.y = Math.abs(Math.sin(time * 4 + i * 0.5)) * 0.03;
                    });

                    // Move defensive linemen
                    gameState.defensiveLine.forEach((dLineman, i) => {
                        if (dLineman.knockdownUntil > gameState.gameTime) {
                            dLineman.position.y = 0;
                            dLineman.rotation.x = Math.PI / 4;  // Lean when down
                            return;
                        }
                        dLineman.rotation.x = 0;

                        moveDLineman(dLineman);

                        // Running animation when moving fast
                        const isRushing = dLineman.currentSpeedMultiplier > 0.3;
                        const bobSpeed = isRushing ? 8 : 4;
                        dLineman.position.y = Math.abs(Math.sin(time * bobSpeed + i * 0.5)) * (isRushing ? 0.08 : 0.03);
                    });

                    // Process line clashes
                    processLineClashes();

                    // Move QB (pocket behavior and evasion)
                    moveQB(scene);

                    // Move defenders
                    gameState.defenders.forEach((defender, i) => {
                        // Skip if knocked down
                        if (defender.knockdownUntil > gameState.gameTime) {
                            defender.position.y = 0;  // On ground
                            return;
                        }

                        // Calculate effective speed (slowdowns from clashes)
                        let effectiveSpeed = defender.speed;
                        if (defender.initialClashSlowdownUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.2;  // 20% speed during initial clash
                        }
                        if (defender.clashSpeedPenaltyUntil > gameState.gameTime) {
                            effectiveSpeed *= 0.5;  // 50% slower after losing clash
                        }

                        moveDefender(defender, 0.016, effectiveSpeed);

                        // Running bob animation (slower during slowdown)
                        const bobSpeed = defender.initialClashSlowdownUntil > gameState.gameTime ? 4 : 8;
                        defender.position.y = Math.abs(Math.sin(time * bobSpeed + i + 0.5)) * 0.08;
                        defender.rotation.z = Math.sin(time * bobSpeed + i + 0.5) * 0.05;

                        // Clash tilt effect (lean towards opponent)
                        if (defender.clashTiltUntil > gameState.gameTime) {
                            const tiltProgress = (defender.clashTiltUntil - gameState.gameTime) / 0.5;
                            defender.rotation.x = Math.sin(tiltProgress * Math.PI) * 0.3;  // Lean forward
                        } else {
                            defender.rotation.x = 0;
                        }

                    });

                    // Process clashes between receivers and defenders
                    processClashes();

                    // Update zone visual fills based on proximity
                    updateZoneProximity();

                    // Update debug display
                    updateDebugInfo();

                    // Fade out name labels after 1 second
                    const timeSinceStart = time - gameState.playStartTime;
                    if (timeSinceStart > 1.0 && timeSinceStart < 2.0) {
                        // Fade over 1 second (from t=1 to t=2)
                        const fadeProgress = timeSinceStart - 1.0;
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 1 - fadeProgress;
                            }
                        });
                    } else if (timeSinceStart >= 2.0) {
                        // Fully hidden
                        gameState.receivers.forEach(receiver => {
                            if (receiver.nameLabel) {
                                receiver.nameLabel.alpha = 0;
                            }
                        });
                    }
                }
            });
        };

        // Get zone colors based on catch probability (0-100%)
        // High catch % = green, medium = yellow, low = red
        const getZoneColorsByCatchProb = (catchProbability) => {
            if (catchProbability >= 70) {
                // Green - high catch chance
                return {
                    diffuse: new BABYLON.Color3(0.2, 0.9, 0.3),
                    emissive: new BABYLON.Color3(0.1, 0.4, 0.15)
                };
            } else if (catchProbability >= 40) {
                // Yellow - moderate catch chance
                return {
                    diffuse: new BABYLON.Color3(1.0, 0.8, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.3, 0.1)
                };
            } else {
                // Red - low catch chance
                return {
                    diffuse: new BABYLON.Color3(0.9, 0.2, 0.2),
                    emissive: new BABYLON.Color3(0.4, 0.1, 0.1)
                };
            }
        };

        // Calculate real-time catch probability for a receiver (for visual display)
        const calculateRealtimeCatchProb = (receiver) => {
            const baseCatch = receiver.stats.catching;
            const coverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;
            let defenderPenalty = 0;
            let hasNearbyDefender = false;

            gameState.defenders.forEach(defender => {
                if (defender.knockdownUntil > gameState.gameTime) return;

                const dx = defender.position.x - receiver.position.x;
                const dz = defender.position.z - receiver.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < coverageRange) {
                    hasNearbyDefender = true;
                    const coverageStat = defender.aiType === 'zone' ?
                        defender.stats.zoneCoverage : defender.stats.manCoverage;
                    const proximityFactor = 1 - (dist / coverageRange);
                    // Match the catch calculation: cubed for steeper dropoff
                    defenderPenalty += proximityFactor * proximityFactor * proximityFactor * coverageStat * 0.8;
                }
            });

            const focusMod = hasNearbyDefender ? (receiver.stats.focus - 70) * 0.3 : 0;
            return Math.max(5, Math.min(95, baseCatch + focusMod - defenderPenalty));
        };

        // Update zone fills based on proximity between receivers and defenders
        const updateZoneProximity = () => {
            const maxCoverageRange = CLASH_CONSTANTS.CLASH_RANGE * 1.5;  // Range where fill starts

            gameState.receivers.forEach(receiver => {
                let maxCoverage = 0;
                let coveringDefender = null;

                // Find closest defender and calculate coverage amount
                gameState.defenders.forEach(defender => {
                    if (defender.knockdownUntil > gameState.gameTime) return;

                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < maxCoverageRange) {
                        // Coverage increases as distance decreases
                        const coverage = 1 - (dist / maxCoverageRange);
                        if (coverage > maxCoverage) {
                            maxCoverage = coverage;
                            coveringDefender = defender;
                        }
                    }
                });

                receiver.coverageAmount = maxCoverage;

                // Calculate real-time catch probability
                const catchProb = calculateRealtimeCatchProb(receiver);
                receiver.currentCatchProb = catchProb;  // Store for debug display

                // Size based on catch probability (larger = higher catch %)
                const minScale = 0.3;  // Minimum size at 0% catch
                const maxScale = 1.2;  // Maximum size at 100% catch
                const catchFactor = catchProb / 100;  // 0-1
                const fillScale = minScale + (maxScale - minScale) * catchFactor;
                receiver.zoneFill.scaling = new BABYLON.Vector3(fillScale, fillScale, fillScale);

                // Keep white color, adjust alpha based on coverage for visibility
                receiver.fillMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
                receiver.fillMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                receiver.fillMaterial.alpha = 0.5;

                // Update covering defender's fill too
                if (coveringDefender) {
                    const defFillScale = Math.max(0.1, maxCoverage) * 0.9;
                    coveringDefender.zoneFill.scaling = new BABYLON.Vector3(defFillScale, defFillScale, defFillScale);
                    coveringDefender.fillMaterial.alpha = maxCoverage * 0.45;
                    coveringDefender.ringMaterial.alpha = 0.8;
                }
            });

            // Reset defenders not covering anyone
            gameState.defenders.forEach(defender => {
                let isCovering = false;
                gameState.receivers.forEach(receiver => {
                    const dx = defender.position.x - receiver.position.x;
                    const dz = defender.position.z - receiver.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < CLASH_CONSTANTS.CLASH_RANGE * 1.5) {
                        isCovering = true;
                    }
                });

                if (!isCovering) {
                    defender.zoneFill.scaling = new BABYLON.Vector3(0, 0, 0);
                    defender.fillMaterial.alpha = 0;
                }
            });
        };

        // Trigger clash visual effect
        const triggerClashVisual = (receiver, defender, winner) => {
            const flashDuration = 0.3;  // seconds
            const tiltDuration = 0.5;   // seconds for grappling tilt
            const currentTime = gameState.gameTime;

            // Calculate tilt direction (towards each other)
            const dx = defender.position.x - receiver.position.x;
            const dz = defender.position.z - receiver.position.z;
            const angle = Math.atan2(dx, dz);

            // Both tilt towards each other during clash
            receiver.clashTiltUntil = currentTime + tiltDuration;
            receiver.clashTiltAngle = angle;  // Tilt towards defender
            defender.clashTiltUntil = currentTime + tiltDuration;
            defender.clashTiltAngle = angle + Math.PI;  // Tilt towards receiver (opposite)

            // Color is now controlled by speed effect timers (clashSpeedBoostUntil / clashSpeedPenaltyUntil)
            // No separate flash timer needed
        };

        // ============================================
        // CLASH SYSTEM
        // ============================================

        // Weighted dice roll based on stats
        const weightedRoll = (stats, weights) => {
            let weightedTotal = 0;
            for (const stat in weights) {
                const statValue = stats[stat] || 50;  // Default to 50 if stat missing
                weightedTotal += statValue * weights[stat];
            }

            // Add randomness (±20% variance)
            const variance = 0.2;
            const roll = weightedTotal * (1 + (Math.random() - 0.5) * 2 * variance);

            return roll;
        };

        // Check if clash should trigger
        const shouldTriggerClash = (receiver, defender) => {
            const currentTime = gameState.gameTime;

            // Calculate distance between receiver and defender
            const dx = receiver.position.x - defender.position.x;
            const dz = receiver.position.z - defender.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Not close enough for clash
            if (distance > CLASH_CONSTANTS.CLASH_RANGE) {
                return { trigger: false, reason: 'distance' };
            }

            // Either is knocked down
            if (receiver.knockdownUntil > currentTime || defender.knockdownUntil > currentTime) {
                return { trigger: false, reason: 'knockdown' };
            }

            // Cooldown - don't clash again too soon after a previous clash
            const CLASH_COOLDOWN = 2.0;  // seconds between clashes
            const timeSinceReceiverClash = currentTime - receiver.lastClashTime;
            const timeSinceDefenderClash = currentTime - defender.lastClashTime;
            if (timeSinceReceiverClash < CLASH_COOLDOWN || timeSinceDefenderClash < CLASH_COOLDOWN) {
                return { trigger: false, reason: 'cooldown' };
            }

            // Initial contact - first time zones overlap
            if (!receiver.hasHadInitialClash) {
                return { trigger: true, reason: 'initial_contact' };
            }

            // Direction change (jink) - receiver changed route waypoint
            if (receiver.routeIndex !== receiver.lastRouteIndex) {
                return { trigger: true, reason: 'direction_change' };
            }

            return { trigger: false, reason: 'none' };
        };

        // Resolve a clash between receiver and defender
        const resolveClash = (receiver, defender, reason) => {
            const currentTime = gameState.gameTime;

            // Apply slowdown on initial contact (line of scrimmage clash)
            if (reason === 'initial_contact') {
                const slowdownDuration = 0.8;  // seconds of slowdown
                receiver.initialClashSlowdownUntil = currentTime + slowdownDuration;
                defender.initialClashSlowdownUntil = currentTime + slowdownDuration;
            }

            // Update clash timing
            receiver.lastClashTime = currentTime;
            defender.lastClashTime = currentTime;
            receiver.hasHadInitialClash = true;
            receiver.lastRouteIndex = receiver.routeIndex;

            // Get appropriate defender coverage stat
            const defenderWeights = { ...CLASH_WEIGHTS.separation.defender };
            if (defender.aiType === 'zone') {
                defenderWeights.zoneCoverage = defenderWeights.manCoverage;
                delete defenderWeights.manCoverage;
            }

            // Roll for separation battle
            const receiverRoll = weightedRoll(receiver.stats, CLASH_WEIGHTS.separation.receiver);
            const defenderRoll = weightedRoll(defender.stats, defenderWeights);

            const margin = receiverRoll - defenderRoll;

            // Determine outcome
            let result = {
                winner: 'none',
                type: 'contested',
                margin: Math.abs(margin),
                receiverRoll,
                defenderRoll
            };

            // Speed effect duration for receivers only
            const CLASH_SPEED_EFFECT_DURATION = 2.0;  // seconds
            const CLASH_SPEED_PENALTY = 0.5;  // 50% slower
            const CLASH_SPEED_BOOST = 1.5;  // 50% faster

            if (margin > CLASH_CONSTANTS.SEPARATION_THRESHOLD) {
                result.winner = 'receiver';
                result.type = 'separation';
                // Receiver wins - gets speed boost
                receiver.clashSpeedBoostUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                receiver.speed = receiver.baseSpeed * CLASH_SPEED_BOOST;
                // Record clash stats
                recordPlayerStat(receiver, 'seasonClashesWon');
                recordPlayerStat(defender, 'seasonClashesLost');
            } else if (margin < -CLASH_CONSTANTS.COVERAGE_THRESHOLD) {
                // Direction changes (jukes) only benefit receivers - ignore defender wins
                if (reason === 'direction_change') {
                    result.winner = 'none';
                    result.type = 'contested';
                    // Juke failed but no penalty - just maintain current speed
                } else {
                    result.winner = 'defender';
                    result.type = 'coverage';
                    // Receiver loses - gets slowed
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_SPEED_EFFECT_DURATION;
                    receiver.speed = receiver.baseSpeed * CLASH_SPEED_PENALTY;
                    // Record clash stats
                    recordPlayerStat(defender, 'seasonClashesWon');
                    recordPlayerStat(receiver, 'seasonClashesLost');
                }
            } else {
                result.winner = 'none';
                result.type = 'contested';
                // Tie - receiver maintains current speed
            }

            // Physical battle check (based on aggression)
            const physicalChance = (receiver.stats.aggression + defender.stats.aggression) / 200;
            if (Math.random() < physicalChance) {
                resolvePhysicalClash(receiver, defender, result);
            }

            // Trigger visual effect for clash
            triggerClashVisual(receiver, defender, result.winner);

            return result;
        };

        // Resolve physical aspect of clash (knockdowns)
        const resolvePhysicalClash = (receiver, defender, separationResult) => {
            const currentTime = gameState.gameTime;

            // Roll physical battle
            const receiverPhysical = weightedRoll(receiver.stats, CLASH_WEIGHTS.physical.attacker);
            const defenderPhysical = weightedRoll(defender.stats, CLASH_WEIGHTS.physical.defender);

            const margin = receiverPhysical - defenderPhysical;
            const loser = margin > 0 ? defender : receiver;
            const winner = margin > 0 ? receiver : defender;

            // Check for knockdown
            const knockdownChance = CLASH_CONSTANTS.KNOCKDOWN_BASE_CHANCE +
                (Math.abs(margin) / 100) * 0.1 -
                loser.knockdownResistance;

            if (Math.random() < Math.max(0, knockdownChance)) {
                // Knockdown!
                loser.knockdownUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                loser.knockdownResistance += CLASH_CONSTANTS.KNOCKDOWN_RESISTANCE_GAIN;

                // If receiver knocked down, apply heavy speed penalty
                if (loser === receiver) {
                    receiver.clashSpeedPenaltyUntil = currentTime + CLASH_CONSTANTS.KNOCKDOWN_DURATION;
                }
            }
        };

        // Process all clashes in the game
        const processClashes = () => {
            gameState.receivers.forEach((receiver, rIndex) => {
                gameState.defenders.forEach((defender, dIndex) => {
                    const clashCheck = shouldTriggerClash(receiver, defender);

                    if (clashCheck.trigger) {
                        resolveClash(receiver, defender, clashCheck.reason);
                    }
                });
            });
        };

        // ========================================
        // MANAGEMENT LAYER - UI SYSTEM
        // ========================================

        // UI state
        let managementUI = null;

        // Create Management UI
        function createManagementUI() {
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManagementUI");

            // Scale UI elements based on screen size for mobile
            const scale = Math.min(window.innerWidth / 400, window.innerHeight / 600, 1.5);
            advancedTexture.rootContainer.scaleX = scale;
            advancedTexture.rootContainer.scaleY = scale;

            const ui = {
                advancedTexture,
                containers: {},
                visible: true
            };

            // Create all screen containers
            ui.containers.mainMenu = createMainMenuScreen(advancedTexture);
            ui.containers.hub = createHubScreen(advancedTexture);
            ui.containers.roster = createRosterScreen(advancedTexture);
            ui.containers.playerDetail = createPlayerDetailScreen(advancedTexture);
            ui.containers.freeAgency = createFreeAgencyScreen(advancedTexture);
            ui.containers.facilities = createFacilitiesScreen(advancedTexture);
            ui.containers.schedule = createScheduleScreen(advancedTexture);
            ui.containers.matchHUD = createMatchHUDScreen(advancedTexture);
            ui.containers.matchEnd = createMatchEndScreen(advancedTexture);

            // Hide all initially
            Object.values(ui.containers).forEach(c => c.isVisible = false);

            managementUI = ui;
            return ui;
        }

        // Helper: Create styled button
        function createStyledButton(text, width = "200px", height = "50px") {
            const button = BABYLON.GUI.Button.CreateSimpleButton("btn_" + text, text);
            button.width = width;
            button.height = height;
            button.color = "#ffd700";
            button.background = "#2a2a40";
            button.cornerRadius = 8;
            button.thickness = 2;
            button.fontFamily = "Courier New";
            button.fontSize = 18;

            button.onPointerEnterObservable.add(() => {
                button.background = "rgba(60, 60, 90, 0.95)";
            });
            button.onPointerOutObservable.add(() => {
                button.background = "rgba(40, 40, 60, 0.95)";
            });

            return button;
        }

        // Helper: Create text block
        function createText(text, fontSize = 18, color = "#ffffff") {
            const textBlock = new BABYLON.GUI.TextBlock();
            textBlock.text = text;
            textBlock.color = color;
            textBlock.fontSize = fontSize;
            textBlock.fontFamily = "Courier New";
            textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            textBlock.textWrapping = true;
            return textBlock;
        }

        // Helper: Create panel with title
        function createPanel(title, width = "400px", height = "500px") {
            const container = new BABYLON.GUI.Rectangle();
            container.width = width;
            container.height = height;
            container.background = "rgba(20, 20, 40, 0.95)";
            container.cornerRadius = 12;
            container.thickness = 2;
            container.color = "#444";

            // Title
            const titleText = createText(title, 24, "#ffd700");
            titleText.top = "-40%";
            container.addControl(titleText);

            return container;
        }

        // Helper: Format potential grade as stars
        function formatPotential(grade) {
            return '★'.repeat(grade + 1);
        }

        // ========================================
        // MAIN MENU SCREEN
        // ========================================

        function createMainMenuScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "#0a0a14";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Title
            const title = createText("SMASHBALL", 48, "#ffd700");
            title.top = "-180px";
            title.fontWeight = "bold";
            container.addControl(title);

            const subtitle = createText("Medieval Football", 20, "#888");
            subtitle.top = "-130px";
            container.addControl(subtitle);

            // New Game Button
            const newGameBtn = BABYLON.GUI.Button.CreateSimpleButton("newGameBtn", "NEW GAME");
            newGameBtn.width = "280px";
            newGameBtn.height = "60px";
            newGameBtn.top = "-20px";
            newGameBtn.color = "#ffd700";
            newGameBtn.background = "#2a2a40";
            newGameBtn.cornerRadius = 8;
            newGameBtn.thickness = 2;
            newGameBtn.fontSize = 22;
            newGameBtn.fontFamily = "Courier New";
            newGameBtn.onPointerUpObservable.add(() => {
                startNewGame();
                showScreen('hub');
            });
            container.addControl(newGameBtn);

            // Continue Button
            const continueBtn = BABYLON.GUI.Button.CreateSimpleButton("continueBtn", "CONTINUE");
            continueBtn.width = "280px";
            continueBtn.height = "60px";
            continueBtn.top = "60px";
            continueBtn.color = "#ffd700";
            continueBtn.background = "#2a2a40";
            continueBtn.cornerRadius = 8;
            continueBtn.thickness = 2;
            continueBtn.fontSize = 22;
            continueBtn.fontFamily = "Courier New";
            continueBtn.onPointerUpObservable.add(() => {
                if (managementState.initialized) {
                    showScreen('hub');
                }
            });
            container.addControl(continueBtn);

            // Version text
            const version = createText("v1.0", 14, "#444");
            version.top = "180px";
            container.addControl(version);

            container._updateContinueButton = () => {
                continueBtn.isEnabled = managementState.initialized;
                continueBtn.alpha = managementState.initialized ? 1 : 0.5;
            };

            return container;
        }

        // ========================================
        // HUB SCREEN
        // ========================================

        function createHubScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "#0a0a14";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Top status bar
            const statusBar = new BABYLON.GUI.Rectangle();
            statusBar.width = "100%";
            statusBar.height = "50px";
            statusBar.background = "#000";
            statusBar.thickness = 0;
            statusBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            container.addControl(statusBar);

            const statusText = createText("", 14, "#ffd700");
            statusBar.addControl(statusText);

            // Title
            const title = createText("TEAM HUB", 28, "#ffd700");
            title.top = "-280px";
            container.addControl(title);

            // Button stack - mobile optimized
            const buttonStack = new BABYLON.GUI.StackPanel();
            buttonStack.width = "100%";
            buttonStack.top = "-60px";
            container.addControl(buttonStack);

            // Create menu buttons
            const menuButtons = [
                { text: "PLAY GAME", screen: "play_game" },
                { text: "ROSTER", screen: "roster" },
                { text: "FREE AGENCY", screen: "free_agency" },
                { text: "SCHEDULE", screen: "schedule" },
                { text: "FACILITIES", screen: "facilities" }
            ];

            menuButtons.forEach(mb => {
                const btn = BABYLON.GUI.Button.CreateSimpleButton("hub_" + mb.screen, mb.text);
                btn.width = "280px";
                btn.height = "45px";
                btn.color = "#ffd700";
                btn.background = "#2a2a40";
                btn.cornerRadius = 6;
                btn.thickness = 1;
                btn.fontSize = 16;
                btn.fontFamily = "Courier New";
                btn.paddingBottom = "8px";
                btn.onPointerUpObservable.add(() => {
                    if (mb.screen === "play_game") {
                        const result = startMatch();
                        if (result.success) {
                            startArcadeGame();
                        }
                    } else {
                        showScreen(mb.screen);
                    }
                });
                buttonStack.addControl(btn);
            });

            // Next game info
            const nextGameInfo = createText("", 14, "#aaa");
            nextGameInfo.top = "200px";
            container.addControl(nextGameInfo);

            // Record display
            const recordText = createText("", 18, "#fff");
            recordText.top = "260px";
            container.addControl(recordText);

            container._updateStatus = () => {
                if (!managementState.team) return;

                statusText.text = `$${managementState.team.credits.toLocaleString()}  |  Week ${managementState.season?.week || 1}`;

                recordText.text = `Record: ${managementState.team.record.wins} - ${managementState.team.record.losses}`;

                // Next game info
                if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                    const game = managementState.season.schedule[managementState.season.week - 1];
                    nextGameInfo.text = `vs ${game.opponent.name}`;
                } else {
                    nextGameInfo.text = "Season Complete!";
                }
            };

            return container;
        }

        // ========================================
        // ROSTER SCREEN
        // ========================================

        function createRosterScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(10, 10, 20, 0.95)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Back button
            const backBtn = createStyledButton("< BACK", "120px", "40px");
            backBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            backBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            backBtn.left = "20px";
            backBtn.top = "20px";
            backBtn.fontSize = 14;
            backBtn.onPointerUpObservable.add(() => showScreen('hub'));
            container.addControl(backBtn);

            // Title
            const title = createText("ROSTER", 28, "#ffd700");
            title.top = "-320px";
            container.addControl(title);

            // Scrollable player list
            const scrollViewer = new BABYLON.GUI.ScrollViewer();
            scrollViewer.width = "800px";
            scrollViewer.height = "550px";
            scrollViewer.top = "40px";
            scrollViewer.thickness = 1;
            scrollViewer.color = "#333";
            scrollViewer.background = "rgba(0,0,0,0.3)";
            container.addControl(scrollViewer);

            const playerStack = new BABYLON.GUI.StackPanel();
            playerStack.width = "100%";
            scrollViewer.addControl(playerStack);

            container._playerStack = playerStack;

            container._refreshRoster = () => {
                // Clear existing
                playerStack.clearControls();

                if (!managementState.team) return;

                // Group by position
                const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
                positions.forEach(pos => {
                    const positionPlayers = managementState.team.roster.filter(p => p.position === pos);
                    if (positionPlayers.length === 0) return;

                    // Position header
                    const header = new BABYLON.GUI.Rectangle();
                    header.width = "100%";
                    header.height = "35px";
                    header.background = "rgba(60, 60, 80, 0.8)";
                    header.thickness = 0;

                    const headerText = createText(POSITIONS[pos].name, 16, "#ffd700");
                    header.addControl(headerText);
                    playerStack.addControl(header);

                    // Players
                    positionPlayers.sort((a, b) => b.overall - a.overall);
                    positionPlayers.forEach(player => {
                        const row = createPlayerRow(player);
                        playerStack.addControl(row);
                    });
                });
            };

            return container;
        }

        // Helper: Create player row for roster
        function createPlayerRow(player) {
            const row = new BABYLON.GUI.Rectangle();
            row.width = "100%";
            row.height = "50px";
            row.background = "rgba(30, 30, 50, 0.6)";
            row.thickness = 1;
            row.color = "#333";

            // Make clickable
            row.onPointerUpObservable.add(() => {
                managementState.selectedPlayerId = player.id;
                showScreen('player_detail');
            });

            row.onPointerEnterObservable.add(() => {
                row.background = "rgba(50, 50, 80, 0.8)";
            });
            row.onPointerOutObservable.add(() => {
                row.background = "rgba(30, 30, 50, 0.6)";
            });

            // Name
            const name = createText(`${player.firstName} ${player.lastName}`, 14, "#fff");
            name.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            name.left = "20px";
            row.addControl(name);

            // Overall
            const overall = createText(`OVR: ${player.overall}`, 14, "#4f4");
            overall.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            overall.left = "-100px";
            row.addControl(overall);

            // Age + Potential
            const ageText = createText(`Age: ${player.age}  ${formatPotential(player.potentialGrade)}`, 14, "#aaa");
            ageText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            ageText.left = "50px";
            row.addControl(ageText);

            // Salary
            const salary = createText(`$${player.salaryCost.toLocaleString()}`, 14, "#ffd700");
            salary.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            salary.left = "-20px";
            row.addControl(salary);

            return row;
        }

        // ========================================
        // PLAYER DETAIL SCREEN
        // ========================================

        function createPlayerDetailScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(10, 10, 20, 0.95)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Back button
            const backBtn = createStyledButton("< BACK", "120px", "40px");
            backBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            backBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            backBtn.left = "20px";
            backBtn.top = "20px";
            backBtn.fontSize = 14;
            backBtn.onPointerUpObservable.add(() => showScreen('roster'));
            container.addControl(backBtn);

            // Player name (dynamic)
            const nameText = createText("", 28, "#ffd700");
            nameText.top = "-280px";
            container.addControl(nameText);

            // Info line
            const infoText = createText("", 18, "#aaa");
            infoText.top = "-240px";
            container.addControl(infoText);

            // Stats grid
            const statsPanel = new BABYLON.GUI.Rectangle();
            statsPanel.width = "700px";
            statsPanel.height = "380px";
            statsPanel.top = "20px";
            statsPanel.background = "rgba(0,0,0,0.3)";
            statsPanel.thickness = 1;
            statsPanel.color = "#333";
            statsPanel.cornerRadius = 8;
            container.addControl(statsPanel);

            const statsStack = new BABYLON.GUI.StackPanel();
            statsStack.width = "100%";
            statsStack.paddingTop = "10px";
            statsPanel.addControl(statsStack);

            // Action buttons
            const actionGrid = new BABYLON.GUI.StackPanel();
            actionGrid.isVertical = false;
            actionGrid.width = "500px";
            actionGrid.height = "60px";
            actionGrid.top = "280px";
            container.addControl(actionGrid);

            const setStarterBtn = createStyledButton("SET AS STARTER", "200px", "50px");
            setStarterBtn.fontSize = 12;
            setStarterBtn.onPointerUpObservable.add(() => {
                if (!managementState.selectedPlayerId) return;
                const player = managementState.team.roster.find(p => p.id === managementState.selectedPlayerId);
                if (!player) return;

                // Set as primary in depth chart
                const dc = managementState.team.depthChart;
                if (player.position === 'WR') dc.WR1 = player.id;
                else if (player.position === 'CB') dc.CB1 = player.id;
                else if (player.position === 'QB') dc.QB = player.id;
                else if (player.position === 'OL') dc.OL[0] = player.id;
                else if (player.position === 'DL') dc.DL[0] = player.id;

                SaveSystem.save();
                container._refresh();
            });
            actionGrid.addControl(setStarterBtn);

            const spacer = new BABYLON.GUI.Rectangle();
            spacer.width = "50px";
            spacer.height = "1px";
            spacer.thickness = 0;
            actionGrid.addControl(spacer);

            const cutBtn = createStyledButton("CUT PLAYER", "200px", "50px");
            cutBtn.fontSize = 12;
            cutBtn.color = "#f44";
            cutBtn.onPointerUpObservable.add(() => {
                if (!managementState.selectedPlayerId) return;
                const result = cutPlayer(managementState.selectedPlayerId);
                if (result.success) {
                    showScreen('roster');
                }
            });
            actionGrid.addControl(cutBtn);

            container._statsStack = statsStack;

            container._refresh = () => {
                if (!managementState.selectedPlayerId || !managementState.team) return;

                const player = managementState.team.roster.find(p => p.id === managementState.selectedPlayerId);
                if (!player) {
                    showScreen('roster');
                    return;
                }

                nameText.text = `${player.firstName} ${player.lastName}`;
                infoText.text = `${POSITIONS[player.position].name}  |  Age: ${player.age}  |  ${formatPotential(player.potentialGrade)}  |  OVR: ${player.overall}  |  ${formatSalaryM(player.salaryCost)}`;

                // Refresh stats
                statsStack.clearControls();

                const primaryStats = POSITIONS[player.position].primaryStats;

                primaryStats.forEach(stat => {
                    const row = new BABYLON.GUI.Rectangle();
                    row.width = "100%";
                    row.height = "40px";
                    row.thickness = 0;

                    // Stat name
                    const statName = createText(stat.charAt(0).toUpperCase() + stat.slice(1), 14, "#aaa");
                    statName.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    statName.left = "30px";
                    row.addControl(statName);

                    // Stat value
                    const value = player.stats[stat] || 0;
                    const statValue = createText(Math.round(value).toString(), 16, "#fff");
                    statValue.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    statValue.left = "180px";
                    row.addControl(statValue);

                    // Progress bar
                    const barBg = new BABYLON.GUI.Rectangle();
                    barBg.width = "300px";
                    barBg.height = "20px";
                    barBg.left = "100px";
                    barBg.background = "rgba(0,0,0,0.5)";
                    barBg.thickness = 0;
                    barBg.cornerRadius = 4;
                    row.addControl(barBg);

                    const barFill = new BABYLON.GUI.Rectangle();
                    barFill.width = `${value * 3}px`;
                    barFill.height = "18px";
                    barFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    barFill.background = value >= 80 ? "#4a4" : value >= 60 ? "#aa4" : "#a44";
                    barFill.thickness = 0;
                    barFill.cornerRadius = 3;
                    barBg.addControl(barFill);

                    // Season change
                    const startVal = player.seasonStartStats[stat] || value;
                    const change = value - startVal;
                    if (change !== 0) {
                        const changeText = createText(
                            change > 0 ? `(+${change.toFixed(1)})` : `(${change.toFixed(1)})`,
                            12,
                            change > 0 ? "#4f4" : "#f44"
                        );
                        changeText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                        changeText.left = "-30px";
                        row.addControl(changeText);
                    }

                    statsStack.addControl(row);
                });
            };

            return container;
        }

        // ========================================
        // FREE AGENCY SCREEN
        // ========================================

        function createFreeAgencyScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(10, 10, 20, 0.95)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Back button
            const backBtn = createStyledButton("< BACK", "120px", "40px");
            backBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            backBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            backBtn.left = "20px";
            backBtn.top = "20px";
            backBtn.fontSize = 14;
            backBtn.onPointerUpObservable.add(() => showScreen('hub'));
            container.addControl(backBtn);

            // Title
            const title = createText("FREE AGENCY", 28, "#ffd700");
            title.top = "-320px";
            container.addControl(title);

            // Status
            const statusText = createText("", 14, "#aaa");
            statusText.top = "-280px";
            container.addControl(statusText);

            // Scrollable list
            const scrollViewer = new BABYLON.GUI.ScrollViewer();
            scrollViewer.width = "800px";
            scrollViewer.height = "500px";
            scrollViewer.top = "20px";
            scrollViewer.thickness = 1;
            scrollViewer.color = "#333";
            scrollViewer.background = "rgba(0,0,0,0.3)";
            container.addControl(scrollViewer);

            const playerStack = new BABYLON.GUI.StackPanel();
            playerStack.width = "100%";
            scrollViewer.addControl(playerStack);

            container._playerStack = playerStack;
            container._statusText = statusText;

            container._refresh = () => {
                playerStack.clearControls();

                if (!managementState.team) return;

                const salary = calculateTeamSalary(managementState.team);
                const cap = managementState.team.salaryCap + managementState.team.salaryCapModifier;
                const credits = managementState.team.credits;

                statusText.text = `Credits: ${credits.toLocaleString()}  |  Cap Space: ${(cap - salary).toLocaleString()}`;

                if (managementState.freeAgents.length === 0) {
                    const noAgents = createText("No free agents available. Check back next week!", 16, "#888");
                    noAgents.height = "50px";
                    playerStack.addControl(noAgents);
                    return;
                }

                managementState.freeAgents.forEach(player => {
                    const row = createFreeAgentRow(player, container._refresh);
                    playerStack.addControl(row);
                });
            };

            return container;
        }

        // Helper: Create free agent row
        function createFreeAgentRow(player, refreshCallback) {
            const row = new BABYLON.GUI.Rectangle();
            row.width = "100%";
            row.height = "60px";
            row.background = "rgba(30, 30, 50, 0.6)";
            row.thickness = 1;
            row.color = "#333";

            // Name and position
            const name = createText(`${player.firstName} ${player.lastName}`, 14, "#fff");
            name.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            name.left = "20px";
            name.top = "-10px";
            row.addControl(name);

            const pos = createText(`${player.position}  |  Age: ${player.age}  |  ${formatPotential(player.potentialGrade)}`, 12, "#888");
            pos.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            pos.left = "20px";
            pos.top = "10px";
            row.addControl(pos);

            // Overall
            const overall = createText(`OVR: ${player.overall}`, 16, "#4f4");
            overall.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            row.addControl(overall);

            // Cost (salary only, no signing bonus)
            const cost = createText(`Salary: ${formatSalaryM(player.salaryCost)}`, 11, "#ffd700");
            cost.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            cost.left = "-140px";
            row.addControl(cost);

            // Sign button
            const signBtn = createStyledButton("SIGN", "100px", "40px");
            signBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            signBtn.left = "-20px";
            signBtn.fontSize = 12;

            // Check if can sign (only salary cap matters now)
            const underCap = canSignPlayer(managementState.team, player);
            signBtn.isEnabled = underCap;
            signBtn.alpha = signBtn.isEnabled ? 1 : 0.5;

            signBtn.onPointerUpObservable.add(() => {
                const result = signFreeAgent(player.id);
                if (result.success) {
                    refreshCallback();
                }
            });
            row.addControl(signBtn);

            return row;
        }

        // ========================================
        // FACILITIES SCREEN
        // ========================================

        function createFacilitiesScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(10, 10, 20, 0.95)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Back button
            const backBtn = createStyledButton("< BACK", "120px", "40px");
            backBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            backBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            backBtn.left = "20px";
            backBtn.top = "20px";
            backBtn.fontSize = 14;
            backBtn.onPointerUpObservable.add(() => showScreen('hub'));
            container.addControl(backBtn);

            // Title
            const title = createText("FACILITIES", 28, "#ffd700");
            title.top = "-280px";
            container.addControl(title);

            // Credits display
            const creditsText = createText("", 18, "#ffd700");
            creditsText.top = "-230px";
            container.addControl(creditsText);

            // Facilities grid
            const grid = new BABYLON.GUI.StackPanel();
            grid.width = "600px";
            grid.height = "400px";
            grid.top = "20px";
            container.addControl(grid);

            // Stadium
            const stadiumPanel = createFacilityPanel("ARENA", "stadium", "Increases ticket revenue per home game");
            grid.addControl(stadiumPanel);

            // Training Center
            const trainingPanel = createFacilityPanel("TRAINING GROUNDS", "trainingCenter", "Boosts player stat growth");
            grid.addControl(trainingPanel);

            // Bribe section
            const bribePanel = new BABYLON.GUI.Rectangle();
            bribePanel.width = "100%";
            bribePanel.height = "120px";
            bribePanel.background = "rgba(40, 30, 30, 0.5)";
            bribePanel.thickness = 1;
            bribePanel.color = "#533";
            bribePanel.cornerRadius = 8;
            grid.addControl(bribePanel);

            const bribeTitle = createText("BRIBE OFFICIALS", 16, "#f88");
            bribeTitle.top = "-35px";
            bribePanel.addControl(bribeTitle);

            const bribeDesc = createText(`Cost: $${ECONOMY.BRIBE_COST.toLocaleString()} - Permanently increases salary cap by $${ECONOMY.BRIBE_CAP_BONUS.toLocaleString()}`, 12, "#aaa");
            bribeDesc.top = "-5px";
            bribePanel.addControl(bribeDesc);

            const bribeBtn = createStyledButton("BRIBE", "150px", "40px");
            bribeBtn.top = "30px";
            bribeBtn.color = "#f88";
            bribeBtn.onPointerUpObservable.add(() => {
                const result = bribeOfficials();
                if (result.success) {
                    container._refresh();
                }
            });
            bribePanel.addControl(bribeBtn);

            container._creditsText = creditsText;
            container._stadiumPanel = stadiumPanel;
            container._trainingPanel = trainingPanel;
            container._bribeBtn = bribeBtn;

            container._refresh = () => {
                if (!managementState.team) return;

                creditsText.text = `Credits: ${managementState.team.credits.toLocaleString()}`;

                // Update facility panels
                updateFacilityPanel(stadiumPanel, managementState.team.facilities.stadium, 'stadium');
                updateFacilityPanel(trainingPanel, managementState.team.facilities.trainingCenter, 'trainingCenter');

                // Update bribe button
                bribeBtn.isEnabled = managementState.team.credits >= ECONOMY.BRIBE_COST;
                bribeBtn.alpha = bribeBtn.isEnabled ? 1 : 0.5;
            };

            return container;
        }

        function createFacilityPanel(name, type, description) {
            const panel = new BABYLON.GUI.Rectangle();
            panel.width = "100%";
            panel.height = "120px";
            panel.background = "rgba(30, 40, 50, 0.5)";
            panel.thickness = 1;
            panel.color = "#335";
            panel.cornerRadius = 8;

            const titleText = createText(name, 18, "#ffd700");
            titleText.top = "-35px";
            panel.addControl(titleText);

            const levelText = createText("Level: 1 / 5", 14, "#fff");
            levelText.top = "-8px";
            panel.addControl(levelText);
            panel._levelText = levelText;

            const descText = createText(description, 11, "#888");
            descText.top = "15px";
            panel.addControl(descText);

            const upgradeBtn = createStyledButton("UPGRADE", "150px", "35px");
            upgradeBtn.top = "38px";
            upgradeBtn.fontSize = 12;
            panel.addControl(upgradeBtn);
            panel._upgradeBtn = upgradeBtn;
            panel._type = type;

            return panel;
        }

        function updateFacilityPanel(panel, facility, type) {
            panel._levelText.text = `Level: ${facility.level} / ${facility.maxLevel}`;

            const costs = type === 'stadium' ? ECONOMY.STADIUM_UPGRADE_COSTS : ECONOMY.TRAINING_UPGRADE_COSTS;
            const isMaxed = facility.level >= facility.maxLevel;
            const cost = isMaxed ? 0 : costs[facility.level - 1];

            panel._upgradeBtn.textBlock.text = isMaxed ? "MAXED" : `UPGRADE ($${cost.toLocaleString()})`;
            panel._upgradeBtn.isEnabled = !isMaxed && managementState.team.credits >= cost;
            panel._upgradeBtn.alpha = panel._upgradeBtn.isEnabled ? 1 : 0.5;

            // Remove old observable and add new one
            panel._upgradeBtn.onPointerUpObservable.clear();
            if (!isMaxed) {
                panel._upgradeBtn.onPointerUpObservable.add(() => {
                    const result = upgradeFacility(type);
                    if (result.success) {
                        // Refresh the facilities screen
                        if (managementUI.containers.facilities._refresh) {
                            managementUI.containers.facilities._refresh();
                        }
                    }
                });
            }
        }

        // ========================================
        // SCHEDULE SCREEN
        // ========================================

        function createScheduleScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(10, 10, 20, 0.95)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Back button
            const backBtn = createStyledButton("< BACK", "120px", "40px");
            backBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            backBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            backBtn.left = "20px";
            backBtn.top = "20px";
            backBtn.fontSize = 14;
            backBtn.onPointerUpObservable.add(() => showScreen('hub'));
            container.addControl(backBtn);

            // Title
            const title = createText("SEASON SCHEDULE", 28, "#ffd700");
            title.top = "-300px";
            container.addControl(title);

            // Scrollable schedule
            const scrollViewer = new BABYLON.GUI.ScrollViewer();
            scrollViewer.width = "700px";
            scrollViewer.height = "520px";
            scrollViewer.top = "30px";
            scrollViewer.thickness = 1;
            scrollViewer.color = "#333";
            scrollViewer.background = "rgba(0,0,0,0.3)";
            container.addControl(scrollViewer);

            const scheduleStack = new BABYLON.GUI.StackPanel();
            scheduleStack.width = "100%";
            scrollViewer.addControl(scheduleStack);

            container._scheduleStack = scheduleStack;

            container._refresh = () => {
                scheduleStack.clearControls();

                if (!managementState.season) return;

                managementState.season.schedule.forEach((game, index) => {
                    const row = new BABYLON.GUI.Rectangle();
                    row.width = "100%";
                    row.height = "50px";
                    row.thickness = 1;
                    row.color = "#333";

                    const isCurrent = index + 1 === managementState.season.week;
                    const isPast = index + 1 < managementState.season.week;

                    if (isCurrent) {
                        row.background = "rgba(60, 80, 60, 0.6)";
                    } else if (isPast) {
                        row.background = "rgba(40, 40, 40, 0.4)";
                    } else {
                        row.background = "rgba(30, 30, 50, 0.4)";
                    }

                    // Week number
                    const week = createText(`Week ${game.week}`, 14, isCurrent ? "#fff" : "#888");
                    week.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    week.left = "20px";
                    row.addControl(week);

                    // Opponent
                    const opp = createText(`${game.isHome ? 'vs' : '@'} ${game.opponent.name}`, 14, "#fff");
                    opp.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                    row.addControl(opp);

                    // Result or status
                    let resultText;
                    if (game.result) {
                        const won = game.result.win;
                        resultText = createText(
                            `${won ? 'W' : 'L'} ${game.result.playerScore}-${game.result.opponentScore}`,
                            14,
                            won ? "#4f4" : "#f44"
                        );
                    } else if (isCurrent) {
                        resultText = createText("NEXT", 14, "#ffd700");
                    } else {
                        resultText = createText("-", 14, "#555");
                    }
                    resultText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                    resultText.left = "-20px";
                    row.addControl(resultText);

                    scheduleStack.addControl(row);
                });
            };

            return container;
        }

        // ========================================
        // MATCH HUD SCREEN (overlay during game)
        // ========================================

        function createMatchHUDScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.thickness = 0;
            container.isPointerBlocker = false;
            advancedTexture.addControl(container);

            // Match score bar at top
            const scoreBar = new BABYLON.GUI.Rectangle();
            scoreBar.width = "400px";
            scoreBar.height = "50px";
            scoreBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            scoreBar.top = "50px";
            scoreBar.background = "rgba(0, 0, 0, 0.8)";
            scoreBar.cornerRadius = 8;
            scoreBar.thickness = 1;
            scoreBar.color = "#444";
            container.addControl(scoreBar);

            const scoreText = createText("YOU: 0  -  OPP: 0", 20, "#fff");
            scoreBar.addControl(scoreText);

            // Possession indicator
            const possessionText = createText("Possession 1 of 5", 14, "#aaa");
            possessionText.top = "20px";
            scoreBar.addControl(possessionText);

            // Opponent name
            const opponentText = createText("", 12, "#ffd700");
            opponentText.top = "-18px";
            scoreBar.addControl(opponentText);

            container._scoreText = scoreText;
            container._possessionText = possessionText;
            container._opponentText = opponentText;

            container._refresh = () => {
                const score = managementState.matchScore;
                scoreText.text = `YOU: ${score.player}  -  OPP: ${score.opponent}`;
                possessionText.text = `Possession ${managementState.currentPossession + 1} of ${SEASON.POSSESSIONS_PER_GAME}`;

                if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                    const game = managementState.season.schedule[managementState.season.week - 1];
                    opponentText.text = `vs ${game.opponent.name}`;
                }
            };

            return container;
        }

        // ========================================
        // MATCH END SCREEN
        // ========================================

        function createMatchEndScreen(advancedTexture) {
            const container = new BABYLON.GUI.Rectangle();
            container.width = "100%";
            container.height = "100%";
            container.background = "rgba(0, 0, 0, 0.9)";
            container.thickness = 0;
            advancedTexture.addControl(container);

            // Result title
            const resultTitle = createText("", 48, "#ffd700");
            resultTitle.top = "-180px";
            container.addControl(resultTitle);

            // Score
            const scoreText = createText("", 32, "#fff");
            scoreText.top = "-100px";
            container.addControl(scoreText);

            // Details panel
            const detailsPanel = new BABYLON.GUI.StackPanel();
            detailsPanel.width = "400px";
            detailsPanel.height = "200px";
            detailsPanel.top = "20px";
            container.addControl(detailsPanel);

            const revenueText = createText("", 16, "#4f4");
            revenueText.height = "30px";
            detailsPanel.addControl(revenueText);

            const progressText = createText("", 14, "#aaa");
            progressText.height = "60px";
            detailsPanel.addControl(progressText);

            // Continue button
            const continueBtn = createStyledButton("CONTINUE", "200px", "60px");
            continueBtn.top = "180px";
            continueBtn.onPointerUpObservable.add(() => {
                showScreen('hub');
            });
            container.addControl(continueBtn);

            container._resultTitle = resultTitle;
            container._scoreText = scoreText;
            container._revenueText = revenueText;
            container._progressText = progressText;

            container._showResult = (matchResult) => {
                if (!matchResult || matchResult.ongoing) return;

                const result = matchResult.result;
                resultTitle.text = result.win ? "VICTORY!" : "DEFEAT";
                resultTitle.color = result.win ? "#4f4" : "#f44";
                scoreText.text = `${result.playerScore} - ${result.opponentScore}`;
                revenueText.text = `Revenue Earned: +$${matchResult.revenue.toLocaleString()}`;

                // Show progression summary
                let progressSummary = "";
                if (matchResult.progression.improvements.length > 0) {
                    progressSummary += `${matchResult.progression.improvements.length} player(s) improved\n`;
                }
                if (matchResult.progression.declines.length > 0) {
                    progressSummary += `${matchResult.progression.declines.length} player(s) declined\n`;
                }
                if (matchResult.progression.retirements.length > 0) {
                    progressSummary += `${matchResult.progression.retirements.length} player(s) retired\n`;
                }
                if (matchResult.seasonEnded) {
                    progressSummary += "\nSEASON COMPLETE! New season started.";
                }
                progressText.text = progressSummary || "No significant changes";

                container.isVisible = true;
            };

            return container;
        }

        // ========================================
        // HTML-BASED SCREEN NAVIGATION
        // ========================================

        // Hide all management screens
        function hideAllScreens() {
            document.querySelectorAll('.mgmt-screen').forEach(s => s.style.display = 'none');
        }

        // Show a specific screen
        function showScreen(screenName) {
            const overlay = document.getElementById('managementOverlay');
            const topBar = document.getElementById('topBar');
            const viewButtons = document.getElementById('viewButtons');

            if (screenName === 'game') {
                // Game mode - hide overlay, show game
                overlay.classList.add('hidden');
                topBar.style.display = 'flex';
                viewButtons.style.display = 'flex';
                gameSceneActive = true;
            } else {
                // Management mode - show overlay, hide game
                overlay.classList.remove('hidden');
                topBar.style.display = 'none';
                viewButtons.style.display = 'none';
                gameSceneActive = false;

                hideAllScreens();

                switch (screenName) {
                    case 'main_menu':
                        document.getElementById('mainMenuScreen').style.display = 'block';
                        document.getElementById('btnContinue').disabled = !managementState.initialized;
                        break;
                    case 'hub':
                        document.getElementById('hubScreen').style.display = 'block';
                        refreshHubScreen();
                        break;
                    case 'roster':
                        document.getElementById('rosterScreen').style.display = 'block';
                        refreshRosterScreen();
                        break;
                    case 'free_agency':
                        document.getElementById('freeAgencyScreen').style.display = 'block';
                        refreshFreeAgencyScreen();
                        break;
                    case 'schedule':
                        document.getElementById('scheduleScreen').style.display = 'block';
                        refreshScheduleScreen();
                        break;
                    case 'facilities':
                        document.getElementById('facilitiesScreen').style.display = 'block';
                        refreshFacilitiesScreen();
                        break;
                    case 'match_end':
                        document.getElementById('matchEndScreen').style.display = 'block';
                        break;
                }
            }

            managementState.currentScreen = screenName;
        }

        // Refresh hub screen data
        function refreshHubScreen() {
            if (!managementState.team) return;
            document.getElementById('hubStatus').textContent =
                `$${managementState.team.credits.toLocaleString()} | Week ${managementState.season?.week || 1}`;
            document.getElementById('hubRecord').textContent =
                `Record: ${managementState.team.record.wins}-${managementState.team.record.losses}`;

            if (managementState.season && managementState.season.week <= SEASON.WEEKS) {
                const game = managementState.season.schedule[managementState.season.week - 1];
                document.getElementById('hubNextGame').textContent = `Next: vs ${game.opponent.name}`;
            } else {
                document.getElementById('hubNextGame').textContent = 'Season Complete!';
            }
        }

        // Calculate season stat change for a player
        function calculateSeasonStatChange(player) {
            if (!player.seasonStartStats) return 0;
            const currentStats = Object.values(player.stats);
            const startStats = Object.values(player.seasonStartStats);
            const currentAvg = currentStats.reduce((a, b) => a + b, 0) / currentStats.length;
            const startAvg = startStats.reduce((a, b) => a + b, 0) / startStats.length;
            return Math.round(currentAvg - startAvg);
        }

        // Refresh roster screen
        function refreshRosterScreen() {
            const list = document.getElementById('rosterList');
            list.innerHTML = '';
            if (!managementState.team) return;

            const positions = ['QB', 'WR', 'CB', 'OL', 'DL'];
            positions.forEach(pos => {
                const players = managementState.team.roster.filter(p => p.position === pos);
                if (players.length === 0) return;

                const header = document.createElement('div');
                header.className = 'position-header';
                header.textContent = POSITIONS[pos].name;
                list.appendChild(header);

                players.sort((a, b) => b.overall - a.overall);
                players.forEach(player => {
                    const seasonChange = calculateSeasonStatChange(player);
                    const changeClass = seasonChange > 0 ? 'positive' : seasonChange < 0 ? 'negative' : '';
                    const changeText = seasonChange !== 0 ?
                        `<span class="season-gain ${changeClass}">${seasonChange > 0 ? '+' : ''}${seasonChange}</span>` : '';

                    const item = document.createElement('div');
                    item.className = 'roster-item';
                    item.innerHTML = `
                        <div>
                            <div class="name">${player.firstName} ${player.lastName}</div>
                            <div class="stats">Age ${player.age} | ${formatSalaryM(player.salaryCost)}</div>
                        </div>
                        <div style="text-align:right;">
                            <span class="ovr">${player.overall}</span>${changeText}
                        </div>
                    `;
                    item.addEventListener('click', () => showPlayerDetail(player.id));
                    list.appendChild(item);
                });
            });
        }

        // Show player detail modal
        function showPlayerDetail(playerId) {
            const player = managementState.team.roster.find(p => p.id === playerId);
            if (!player) return;

            managementState.selectedPlayerId = playerId;

            // Set player name
            document.getElementById('playerName').textContent = `${player.firstName} ${player.lastName}`;

            // Calculate overall change
            const currentOverall = player.overall;
            let startOverall = currentOverall;
            if (player.seasonStartStats) {
                const positionData = POSITIONS[player.position];
                const primaryStats = positionData.primaryStats;
                const startTotal = primaryStats.reduce((sum, stat) => sum + (player.seasonStartStats[stat] || 0), 0);
                startOverall = Math.round(startTotal / primaryStats.length);
            }
            const overallChange = currentOverall - startOverall;
            const overallChangeClass = overallChange > 0 ? 'positive' : overallChange < 0 ? 'negative' : '';
            const overallChangeText = overallChange !== 0 ?
                `<span class="season-change ${overallChangeClass}">${overallChange > 0 ? '+' : ''}${overallChange}</span>` : '';

            // Player info
            const infoHtml = `
                <div><span class="ovr-big">${player.overall}</span>${overallChangeText}</div>
                <div style="margin-top:10px;">
                    ${POSITIONS[player.position].name} | Age ${player.age} | Peak ${player.peakAge}<br>
                    Salary: ${formatSalaryM(player.salaryCost)} | Potential: ${'★'.repeat(player.potentialGrade + 1)}
                </div>
            `;
            document.getElementById('playerInfo').innerHTML = infoHtml;

            // All stats with changes
            const allStats = [
                'speed', 'acceleration', 'agility', 'strength', 'stamina', 'balance',
                'catching', 'throwing', 'routeRunning', 'release', 'jumping', 'focus',
                'manCoverage', 'zoneCoverage', 'press', 'tackling', 'hitPower', 'pursuit', 'awareness',
                'passBlock', 'passRush', 'aggression'
            ];

            const statsHtml = allStats.map(stat => {
                const currentRaw = player.stats[stat] || 0;
                const startRaw = player.seasonStartStats ? (player.seasonStartStats[stat] || 0) : currentRaw;
                const current = Math.floor(currentRaw);
                const start = Math.floor(startRaw);
                const change = current - start;
                const changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : '';
                const changeText = change !== 0 ? `${change > 0 ? '+' : ''}${change}` : '';

                // Color code based on stat value
                const statColorClass = current >= 90 ? 'stat-elite' :
                                       current >= 80 ? 'stat-good' :
                                       current >= 70 ? 'stat-average' :
                                       current >= 60 ? 'stat-below' : 'stat-poor';

                // Format stat name
                const statName = stat.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());

                return `<div class="stat-row">
                    <span class="stat-name">${statName}</span>
                    <span class="stat-values">
                        <span class="stat-value ${statColorClass}">${current}</span>
                        <span class="stat-change ${changeClass}">${changeText}</span>
                    </span>
                </div>`;
            }).join('');
            document.getElementById('playerStats').innerHTML = statsHtml;

            // Season stats (position-dependent)
            let seasonStatsHtml = '<div class="season-stats-title">Season Stats</div><div class="season-stats-grid">';

            if (player.position === 'WR' || player.position === 'QB') {
                const catchPct = player.seasonTargets > 0
                    ? Math.round((player.seasonCatches || 0) / player.seasonTargets * 100)
                    : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTDs || 0}</div><div class="season-stat-label">TDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonCatches || 0}</div><div class="season-stat-label">Catches</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${catchPct}%</div><div class="season-stat-label">Catch %</div></div>
                `;
            } else if (player.position === 'CB') {
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonTackles || 0}</div><div class="season-stat-label">Tackles</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonPassesDefended || 0}</div><div class="season-stat-label">PDs</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                `;
            } else if (player.position === 'OL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesLost || 0}</div><div class="season-stat-label">Clashes Lost</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            } else if (player.position === 'DL') {
                const clashTotal = (player.seasonClashesWon || 0) + (player.seasonClashesLost || 0);
                const clashPct = clashTotal > 0 ? Math.round((player.seasonClashesWon || 0) / clashTotal * 100) : 0;
                seasonStatsHtml += `
                    <div class="season-stat-item"><div class="season-stat-value">${player.gamesPlayed || 0}</div><div class="season-stat-label">Games</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonSacks || 0}</div><div class="season-stat-label">Sacks</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${player.seasonClashesWon || 0}</div><div class="season-stat-label">Clashes Won</div></div>
                    <div class="season-stat-item"><div class="season-stat-value">${clashPct}%</div><div class="season-stat-label">Win %</div></div>
                `;
            }
            seasonStatsHtml += '</div>';
            document.getElementById('playerSeasonStats').innerHTML = seasonStatsHtml;

            // Career graph
            const history = player.careerHistory || [];
            let graphHtml = '<div class="career-graph-title">Career Progression</div>';

            if (history.length > 0) {
                graphHtml += '<div class="career-graph-container">';
                const maxOvr = Math.max(...history.map(h => h.overall), 99);
                const minOvr = Math.min(...history.map(h => h.overall), 40);
                const range = Math.max(maxOvr - minOvr, 20);

                history.forEach((season, idx) => {
                    const heightPct = ((season.overall - minOvr) / range) * 100;
                    const potentialStars = '★'.repeat((season.potential || 0) + 1);
                    graphHtml += `
                        <div class="career-bar">
                            <div class="career-bar-ovr">${season.overall}</div>
                            <div class="career-bar-fill" style="height: ${Math.max(heightPct, 10)}%;">
                                <span class="career-bar-potential">${potentialStars}</span>
                            </div>
                            <div class="career-bar-label">Y${idx + 1}</div>
                        </div>
                    `;
                });
                graphHtml += '</div>';
            } else {
                graphHtml += '<div style="color:#666;font-size:12px;">No career history yet</div>';
            }
            document.getElementById('playerCareerGraph').innerHTML = graphHtml;

            // Show modal
            document.getElementById('playerDetailModal').style.display = 'flex';
        }

        // Close player detail modal
        function closePlayerDetail() {
            document.getElementById('playerDetailModal').style.display = 'none';
            managementState.selectedPlayerId = null;
        }

        // Cut player from detail view
        function cutPlayerFromDetail() {
            if (!managementState.selectedPlayerId) return;
            const result = cutPlayer(managementState.selectedPlayerId);
            if (result.success) {
                closePlayerDetail();
                refreshRosterScreen();
            }
        }

        // Refresh free agency screen
        function refreshFreeAgencyScreen() {
            const list = document.getElementById('freeAgentList');
            const status = document.getElementById('faStatus');
            list.innerHTML = '';
            if (!managementState.team) return;

            const salary = calculateTeamSalary(managementState.team);
            const cap = managementState.team.salaryCap + managementState.team.salaryCapModifier;
            status.textContent = `Credits: ${formatSalaryM(managementState.team.credits)} | Cap Space: ${formatSalaryM(cap - salary)}`;

            if (managementState.freeAgents.length === 0) {
                list.innerHTML = '<p style="color:#888;text-align:center;">No free agents available</p>';
                return;
            }

            managementState.freeAgents.forEach(player => {
                const canSign = canSignPlayer(managementState.team, player);

                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <div>
                        <div class="name">${player.firstName} ${player.lastName} (${player.position})</div>
                        <div class="stats">Age ${player.age} | Salary: ${formatSalaryM(player.salaryCost)}</div>
                    </div>
                    <div style="text-align:right;">
                        <div class="ovr">${player.overall}</div>
                        <button class="mgmt-btn fa-btn" ${canSign ? '' : 'disabled'}
                            onclick="signAndRefresh('${player.id}')">SIGN</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // Sign player and refresh
        function signAndRefresh(playerId) {
            const result = signFreeAgent(playerId);
            if (result.success) {
                refreshFreeAgencyScreen();
            }
        }

        // Calculate team overall rating
        function calculateTeamOverallRating() {
            if (!managementState.team) return 0;
            const roster = managementState.team.roster;
            if (roster.length === 0) return 0;
            const total = roster.reduce((sum, p) => sum + p.overall, 0);
            return Math.round(total / roster.length);
        }

        // Refresh schedule screen
        function refreshScheduleScreen() {
            const list = document.getElementById('scheduleList');
            list.innerHTML = '';
            if (!managementState.season) return;

            // Update team strength display
            const teamOverall = calculateTeamOverallRating();
            const teamOffense = Math.round(calculateTeamOffenseRating());
            const teamDefense = Math.round(calculateTeamDefenseRating());

            document.getElementById('strengthOverall').textContent = teamOverall;
            document.getElementById('strengthOffense').textContent = teamOffense;
            document.getElementById('strengthDefense').textContent = teamDefense;

            managementState.season.schedule.forEach((game, index) => {
                const weekNum = index + 1;
                const isCurrent = weekNum === managementState.season.week;
                const isPast = weekNum < managementState.season.week;

                const item = document.createElement('div');
                item.className = `schedule-item ${isCurrent ? 'current' : ''} ${isPast ? 'past' : ''}`;

                let resultText = '-';
                let resultClass = '';
                if (game.result) {
                    resultText = `${game.result.win ? 'W' : 'L'} ${game.result.playerScore}-${game.result.opponentScore}`;
                    resultClass = game.result.win ? 'win' : 'loss';
                } else if (isCurrent) {
                    resultText = 'NEXT';
                    resultClass = '';
                }

                // Show opponent strength
                const oppOverall = Math.round((game.opponent.offenseRating + game.opponent.defenseRating) / 2);

                item.innerHTML = `
                    <div>
                        <div>Wk ${weekNum}: ${game.isHome ? 'vs' : '@'} ${game.opponent.name}</div>
                        <div style="font-size:11px;color:#888;">OVR ${oppOverall} | OFF ${game.opponent.offenseRating} | DEF ${game.opponent.defenseRating}</div>
                    </div>
                    <div class="result ${resultClass}">${resultText}</div>
                `;
                list.appendChild(item);
            });
        }

        // Refresh facilities screen
        function refreshFacilitiesScreen() {
            if (!managementState.team) return;

            document.getElementById('facCredits').textContent = `Credits: $${managementState.team.credits.toLocaleString()}`;

            const arena = managementState.team.facilities.stadium;
            const training = managementState.team.facilities.trainingCenter;

            document.getElementById('arenaLevel').textContent = `Level ${arena.level}/${arena.maxLevel}`;
            document.getElementById('trainingLevel').textContent = `Level ${training.level}/${training.maxLevel}`;

            const arenaCost = arena.level < arena.maxLevel ? ECONOMY.STADIUM_UPGRADE_COSTS[arena.level - 1] : 0;
            const trainingCost = training.level < training.maxLevel ? ECONOMY.TRAINING_UPGRADE_COSTS[training.level - 1] : 0;

            document.getElementById('btnUpgradeArena').textContent = arena.level >= arena.maxLevel ? 'MAXED' : `UPGRADE ($${arenaCost.toLocaleString()})`;
            document.getElementById('btnUpgradeArena').disabled = arena.level >= arena.maxLevel || managementState.team.credits < arenaCost;

            document.getElementById('btnUpgradeTraining').textContent = training.level >= training.maxLevel ? 'MAXED' : `UPGRADE ($${trainingCost.toLocaleString()})`;
            document.getElementById('btnUpgradeTraining').disabled = training.level >= training.maxLevel || managementState.team.credits < trainingCost;
        }

        // Show match end result
        function showMatchEnd(matchResult) {
            const result = matchResult.result;
            document.getElementById('matchResult').textContent = result.win ? 'VICTORY!' : 'DEFEAT';
            document.getElementById('matchResult').className = result.win ? 'win' : 'loss';
            document.getElementById('matchScore').textContent = `${result.playerScore} - ${result.opponentScore}`;
            document.getElementById('matchRevenue').textContent = `+$${matchResult.revenue.toLocaleString()}`;
            showScreen('match_end');
        }

        // Start the arcade game portion
        function startArcadeGame() {
            showScreen('game');
            gameState.down = 1;
            gameState.yardsToGo = 10;
            gameState.catches = 0;
            gameState.attempts = 0;
            gameState.touchdowns = 0;
        }

        // Called when a drive/possession ends in the arcade game
        function onPossessionComplete(points) {
            if (!managementState.matchInProgress) return;

            const result = recordPossessionResult(points);

            if (!result.ongoing) {
                showMatchEnd(result);
            } else {
                // Show enemy drive result between possessions
                showEnemyDriveResult(result);
            }
        }

        // Show enemy drive result overlay between possessions with progressive play-by-play
        function showEnemyDriveResult(result) {
            const game = managementState.season.schedule[managementState.season.week - 1];
            const plays = result.enemyResult.narrative; // Array of play descriptions
            const totalDuration = 3500; // 3.5 seconds total
            const delayPerPlay = Math.floor(totalDuration / plays.length);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'enemyDriveOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
            `;

            const pointsColor = result.enemyResult.points > 0 ? '#f44' : '#4f4';
            const pointsText = result.enemyResult.points > 0
                ? `+${result.enemyResult.points} points`
                : 'No score!';

            overlay.innerHTML = `
                <div style="background: #1a1a2e; border: 2px solid #333; border-radius: 12px; padding: 30px; max-width: 550px; text-align: center; min-height: 280px;">
                    <h2 style="color: #888; margin: 0 0 15px; font-size: 14px; text-transform: uppercase;">
                        ${game.opponent.name} Possession
                    </h2>
                    <div id="playByPlay" style="color: #ccc; margin: 0 0 15px; font-size: 15px; line-height: 1.6; min-height: 120px; text-align: left; padding: 0 10px;">
                    </div>
                    <div id="driveResult" style="display: none;">
                        <div style="color: ${pointsColor}; font-size: 24px; font-weight: bold; margin-bottom: 15px;">
                            ${pointsText}
                        </div>
                        <div style="color: #aaa; margin-bottom: 15px;">
                            <span style="color: #4af;">You: ${result.score.player}</span>
                            &nbsp;-&nbsp;
                            <span style="color: #f44;">${game.opponent.name}: ${result.score.opponent}</span>
                        </div>
                        <div style="color: #666; margin-bottom: 12px;">
                            Possession ${result.possession + 1} of ${SEASON.POSSESSIONS_PER_GAME}
                        </div>
                        <button id="btnContinueDrive" style="
                            background: #4a4; color: white; border: none;
                            padding: 12px 30px; border-radius: 6px; cursor: pointer;
                            font-size: 16px;
                        ">Continue</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            const playByPlayDiv = document.getElementById('playByPlay');
            let playIndex = 0;

            // Show plays progressively
            const showNextPlay = () => {
                if (playIndex < plays.length) {
                    const playText = document.createElement('div');
                    playText.style.cssText = 'margin-bottom: 8px; opacity: 0; transition: opacity 0.2s;';

                    // Highlight final play differently
                    const isFinalPlay = playIndex === plays.length - 1;
                    if (isFinalPlay) {
                        playText.style.color = pointsColor;
                        playText.style.fontWeight = 'bold';
                    }

                    playText.textContent = plays[playIndex];
                    playByPlayDiv.appendChild(playText);

                    // Fade in
                    setTimeout(() => playText.style.opacity = '1', 50);

                    playIndex++;
                    setTimeout(showNextPlay, delayPerPlay);
                } else {
                    // All plays shown, reveal result and button
                    setTimeout(() => {
                        document.getElementById('driveResult').style.display = 'block';
                        document.getElementById('btnContinueDrive').addEventListener('click', () => {
                            overlay.remove();
                            // Clear waiting flag and reset play for next possession
                            gameState.waitingForPossession = false;
                            resetPlay(gameState.scene);
                        });
                    }, 300);
                }
            };

            // Start showing plays after a brief pause
            setTimeout(showNextPlay, 400);
        }

        // Main
        const scene = createScene();
        setupInput(scene);
        setupIdleAnimations(scene);

        // Initialize management system
        initializeManagement();

        // Setup HTML button handlers
        document.getElementById('btnNewGame').addEventListener('click', () => {
            startNewGame();
            showScreen('hub');
        });
        document.getElementById('btnContinue').addEventListener('click', () => {
            if (managementState.initialized) showScreen('hub');
        });
        document.getElementById('btnPlayGame').addEventListener('click', () => {
            const result = startMatch();
            if (result.success) startArcadeGame();
        });
        document.getElementById('btnRoster').addEventListener('click', () => showScreen('roster'));
        document.getElementById('btnFreeAgency').addEventListener('click', () => showScreen('free_agency'));
        document.getElementById('btnSchedule').addEventListener('click', () => showScreen('schedule'));
        document.getElementById('btnFacilities').addEventListener('click', () => showScreen('facilities'));
        document.getElementById('btnRosterBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFABack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnScheduleBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnFacilitiesBack').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnMatchContinue').addEventListener('click', () => showScreen('hub'));
        document.getElementById('btnUpgradeArena').addEventListener('click', () => {
            upgradeFacility('stadium');
            refreshFacilitiesScreen();
        });
        document.getElementById('btnUpgradeTraining').addEventListener('click', () => {
            upgradeFacility('trainingCenter');
            refreshFacilitiesScreen();
        });

        // Player detail modal handlers
        document.getElementById('btnCloseDetail').addEventListener('click', closePlayerDetail);
        document.getElementById('btnCutPlayer').addEventListener('click', cutPlayerFromDetail);

        // Show initial screen
        showScreen(managementState.currentScreen);

        // Camera view switching
        const setCameraView = (viewType) => {
            const camera = scene.activeCamera;
            if (!camera) return;
            gameState.currentView = viewType;
            document.querySelectorAll('#viewButtons button').forEach(btn => btn.classList.remove('active'));
            switch(viewType) {
                case 'iso':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 3.5;
                    camera.radius = 32;
                    document.getElementById('viewIso').classList.add('active');
                    break;
                case 'overhead':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = 0.1;
                    camera.radius = 28;
                    document.getElementById('viewOverhead').classList.add('active');
                    break;
                case 'shoulder':
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 2.5;
                    camera.radius = 18;
                    document.getElementById('viewShoulder').classList.add('active');
                    break;
            }
        };

        document.getElementById('viewIso').addEventListener('click', () => setCameraView('iso'));
        document.getElementById('viewOverhead').addEventListener('click', () => setCameraView('overhead'));
        document.getElementById('viewShoulder').addEventListener('click', () => setCameraView('shoulder'));

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
